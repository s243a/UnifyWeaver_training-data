{"cluster_id": "sql-join-001", "question": "How do JOINs work in the SQL target?", "answer": "INNER JOINs happen implicitly via shared variables:\n\n```prolog\ncustomer_orders(CustomerName, Product) :-\n    customers(CustId, CustomerName, _, _),\n    orders(_, CustId, Product, _, _).\n% Generates: SELECT ... FROM customers INNER JOIN orders ON orders.customer_id = customers.id\n```\n\nFor LEFT/RIGHT/FULL OUTER JOINs, use explicit predicates:\n```prolog\ncustomers_with_orders(Name, Product) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(_, CustId, Product, _, _)).\n```", "source_file": "book-10-sql-target/03_joins.md", "prerequisites": ["sql-001"]}
{"cluster_id": "sql-join-001", "question": "What JOIN types does the SQL target support?", "answer": "Four JOIN types:\n- **INNER JOIN**: Implicit via shared variables\n- **LEFT JOIN**: `sql_left_join(table(...))`\n- **RIGHT JOIN**: `sql_right_join(table(...))`\n- **FULL OUTER JOIN**: `sql_full_outer_join(table(...))`\n\nFind non-matching rows with LEFT JOIN + IS NULL:\n```prolog\ncustomers_without_orders(Name) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(OrderId, CustId, _, _, _)),\n    sql_is_null(OrderId).\n```", "source_file": "book-10-sql-target/03_joins.md", "prerequisites": ["sql-join-001"]}
{"cluster_id": "sql-agg-001", "question": "How do I use aggregations in the SQL target?", "answer": "Use aggregate functions with `sql_group_by/1` and optionally `sql_having/1`:\n\n```prolog\ndept_totals(Dept, Total) :-\n    employees(_, _, Dept, Salary, _),\n    Total = sql_sum(Salary),\n    sql_group_by([Dept]).\n\n% With HAVING\nlarge_depts(Dept, Count) :-\n    employees(_, _, Dept, _, _),\n    Count = sql_count(*),\n    sql_group_by([Dept]),\n    sql_having(Count > 5).\n```\n\nSupported: `sql_count`, `sql_sum`, `sql_avg`, `sql_min`, `sql_max`.", "source_file": "book-10-sql-target/04_aggregations.md", "prerequisites": ["sql-001"]}
