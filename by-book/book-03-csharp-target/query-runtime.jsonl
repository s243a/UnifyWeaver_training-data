{"cluster_id": "query-runtime-overview", "seed_level": 2, "source_files": ["education/book-03-csharp-target/03_query_engine_deep_dive.md"], "topics": ["query-runtime", "ir", "intermediate-representation"], "questions": ["What is the C# Query Runtime?", "What is IR (Intermediate Representation)?", "How does Query Runtime differ from Stream Target?", "Why use IR instead of direct translation?"], "answer": {"text": "## C# Query Runtime\n\nThe Query Runtime uses **Intermediate Representation (IR)**:\n\n```\nProlog → IR (Query Plan) → Runtime Engine executes\n```\n\n### Why IR?\n\n- **Supports recursion** via fixpoint iteration\n- **Shared runtime** can be optimized independently\n- **Flexible** query execution strategies\n\n### Core IR Components\n\n| Component | Purpose | SQL Equivalent |\n|-----------|---------|----------------|\n| `RelationRef` | Fetch tuples | `SELECT * FROM table` |\n| `Selection` | Filter rows | `WHERE condition` |\n| `Projection` | Reshape tuples | `SELECT col1, col2` |\n| `Join` | Combine tuples | `JOIN ON key` |\n| `Union` | Merge results | `UNION` |\n| `Distinct` | Remove duplicates | `DISTINCT` |\n\n### Example IR\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n### Execution\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```", "anchor_question_hash": "03d1e2f3a4b50001"}}
{"cluster_id": "ir-components", "seed_level": 2, "source_files": ["education/book-03-csharp-target/03_query_engine_deep_dive.md"], "topics": ["ir", "relationref", "selection", "join", "projection"], "questions": ["What are the IR components in Query Runtime?", "How does RelationRef work?", "How are joins represented in IR?", "What is Selection in IR?"], "answer": {"text": "## IR Components Explained\n\n### RelationRef - Fetch Tuples\n\n```csharp\nnew RelationRef(\"parent\", 2)\n// → All parent/2 tuples\n```\n\n### Selection - Filter Rows\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Age >= 18\n)\n```\n\n**Prolog equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\n### Projection - Reshape Tuples\n\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Keep fields 1 and 3\n)\n```\n\n### Join - Combine Tuples\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Key: P (child)\n    inner => inner.Item1,          // Key: P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n)\n```\n\n**Prolog equivalent:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n### Union - Merge Results\n\n```csharp\nnew Union(clause1, clause2)\n// Combines results from multiple clauses\n```", "anchor_question_hash": "03d2e3f4a5b60002"}}
{"cluster_id": "fixpoint-iteration", "seed_level": 2, "source_files": ["education/book-03-csharp-target/03_query_engine_deep_dive.md"], "topics": ["fixpoint", "semi-naive", "recursion", "iteration"], "questions": ["What is fixpoint iteration?", "How does semi-naive evaluation work?", "Why is semi-naive faster than naive?", "When does fixpoint iteration terminate?"], "answer": {"text": "## Fixpoint Iteration\n\nFor recursive predicates, the engine iterates until no new tuples are produced.\n\n### Example: ancestor/2\n\n**Prolog:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\n### Iteration Trace\n\n**Iteration 0 (Base):**\n```\nparent: (alice, bob), (bob, charlie), (charlie, dave)\nancestor: {} (empty)\n```\n\n**Iteration 1:**\n```\nancestor = {(alice, bob), (bob, charlie), (charlie, dave)}\n```\n\n**Iteration 2:**\n```\nancestor += {(alice, charlie), (bob, dave)}\n```\n\n**Iteration 3:**\n```\nancestor += {(alice, dave)}\n```\n\n**Iteration 4:**\n```\nNo new tuples → Fixpoint reached!\n```\n\n### Semi-Naive Optimization\n\n**Naive:** Re-join ALL tuples every iteration (slow)\n\n**Semi-naive:** Only join with NEW tuples from last iteration (fast)\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**Much faster for deep recursion!**", "anchor_question_hash": "03d3e4f5a6b70003"}}
{"cluster_id": "mutual-recursion-csharp", "seed_level": 3, "source_files": ["education/book-03-csharp-target/03_query_engine_deep_dive.md"], "topics": ["mutual-recursion", "scc", "mutualfixpointnode", "crossrefnode"], "questions": ["How does C# Query Runtime handle mutual recursion?", "What is MutualFixpointNode?", "What is CrossRefNode?", "How are SCCs evaluated in C#?"], "answer": {"text": "## Mutual Recursion in Query Runtime (v0.1)\n\nThe runtime handles strongly connected predicate groups.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### Key Plan Nodes\n\n- **`MutualFixpointNode`**: Orchestrates the group\n- **`MutualMember`**: Describes each predicate (base + recursive plans)\n- **`CrossRefNode`**: References another predicate in the SCC\n\n### Generated Plan\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Execution Model\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nOnly **new tuples** participate in each iteration (semi-naive).", "anchor_question_hash": "03d4e5f6a7b80004"}}
