{"cluster_id": "prolog-modules", "seed_level": 1, "source_files": ["education/book-01-foundations/02_prolog_fundamentals.md"], "topics": ["modules", "use_module", "library", "namespaces"], "questions": ["What are Prolog modules and why does UnifyWeaver need them?", "How do I use use_module in Prolog?", "What does unifyweaver(core/...) syntax mean?", "How do modules prevent naming conflicts?"], "answer": {"text": "## Prolog Modules\n\nModules organize Prolog code into namespaces, preventing naming conflicts.\n\n### Why Modules?\n\nWithout modules, all predicates share a global namespace. If two files define `compile/3`, they conflict. Modules solve this:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Loading Modules\n\n```prolog\n% Load a module\n?- use_module(library(lists)).\n\n% Load UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The unifyweaver(...) Syntax\n\nThe `unifyweaver(...)` syntax is a library alias:\n\n```prolog\n% Defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% So this:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Becomes:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### Accessing Module Predicates\n\n```prolog\n% Exported predicates are available directly\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified syntax\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Module Declaration\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported predicates\n    predicate2/3\n]).\n\n% Private predicates (not in export list)\n% are only visible inside the module\n```", "anchor_question_hash": "a1b2c3d4e5f60001"}}
{"cluster_id": "prolog-directives", "seed_level": 2, "source_files": ["education/book-01-foundations/02_prolog_fundamentals.md"], "topics": ["directives", "pragmas", ":-", "initialization"], "questions": ["What is a Prolog directive or pragma?", "What does :- mean at the start of a line?", "How does UnifyWeaver process the constraint directive?", "What's the difference between a directive and a query?"], "answer": {"text": "## Prolog Directives\n\nA directive (starting with `:-`) is an instruction to Prolog, not a fact or rule.\n\n### Directive vs Query\n\n```prolog\n% Query (interactive prompt) - asks Prolog to prove something\n?- parent(alice, bob).\n\n% Directive (in file) - executes when file loads\n:- use_module(library(lists)).\n```\n\n### Common Directives\n\n```prolog\n% Load a module\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Declare a module\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicate (can be modified at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization (runs after file loads)\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragma\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n### How Directives Execute\n\nWhen Prolog loads a file:\n1. Facts and rules are added to the knowledge base\n2. Directives are executed immediately\n3. Initialization goals run after everything loads\n\n### UnifyWeaver's constraint Directive\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nUnifyWeaver intercepts this during compilation:\n1. Extracts predicate name and arity\n2. Stores constraint options\n3. Uses them to guide code generation\n\n```prolog\n% Example: preserve order, allow duplicates\n:- constraint(event_log/3, [unique(false), ordered]).\n```", "anchor_question_hash": "b2c3d4e5f6a70002"}}
{"cluster_id": "prolog-file-io", "seed_level": 2, "source_files": ["education/book-01-foundations/02_prolog_fundamentals.md"], "topics": ["file-io", "open", "write", "close", "streams"], "questions": ["How do I write to a file in Prolog?", "What do open, write, and close do in Prolog?", "How does Prolog file I/O work?", "What are Prolog streams?"], "answer": {"text": "## Prolog File I/O\n\nProlog uses streams for file operations.\n\n### Basic Pattern\n\n```prolog\n% Open file, write, close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### open/3 Parameters\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\n| Mode | Purpose |\n|------|--------|\n| `read` | Read from existing file |\n| `write` | Create/overwrite file |\n| `append` | Add to end of file |\n\n### Writing Content\n\n```prolog\n% Write term (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Reading Content\n\n```prolog\n% Read a term\nread(Stream, Term).\n\n% Read a line as string\nread_line_to_string(Stream, Line).\n\n% Read entire file\nread_file_to_string(FileName, Content, []).\n```\n\n### Safe Pattern with setup_call_cleanup\n\n```prolog\n% Ensures file is closed even on error\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Creating Directories\n\n```prolog\n% Create directory (including parents)\n?- make_directory_path('education/output').\n```", "anchor_question_hash": "c3d4e5f6a7b80003"}}
{"cluster_id": "init-pl-explained", "seed_level": 1, "source_files": ["education/book-01-foundations/01_introduction.md", "education/init.pl"], "topics": ["init.pl", "initialization", "setup", "library-paths"], "questions": ["What does education/init.pl do?", "Why do I need to load init.pl first?", "What does init.pl set up?", "How do library search paths work in Prolog?"], "answer": {"text": "## Understanding init.pl\n\nThe `init.pl` file sets up the UnifyWeaver environment.\n\n### What It Does\n\n```prolog\n% education/init.pl typically contains:\n\n% 1. Set library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Print confirmation\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Why It's Necessary\n\nWithout init.pl:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nWith init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Library Search Paths\n\nProlog uses `file_search_path/2` to resolve library aliases:\n\n```prolog\n% Define alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Alternative: Using -f Flag\n\n```bash\n# Load init.pl automatically\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "anchor_question_hash": "d4e5f6a7b8c90004"}}
