{"cluster_id": "accumulator-pattern", "seed_level": 2, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md"], "topics": ["accumulator", "tail-recursion", "intermediate-result", "optimization"], "questions": ["What is an accumulator in recursion?", "How does an accumulator enable tail recursion?", "What's the difference between accumulator and non-accumulator recursion?", "Why are accumulators more efficient?"], "answer": {"text": "## The Accumulator Pattern\n\nAn accumulator is an extra parameter that carries intermediate results through recursive calls.\n\n### Without Accumulator (Stack-based)\n\n```prolog\n% Result builds on return path\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.        % Work AFTER recursive call\n```\n\nCall stack for `factorial(4, F)`:\n```\nfactorial(4, F) -> waiting for factorial(3)\n  factorial(3, F) -> waiting for factorial(2)\n    factorial(2, F) -> waiting for factorial(1)\n      factorial(1, F) -> waiting for factorial(0)\n        factorial(0, 1) -> returns 1\n      F = 1 * 1 = 1\n    F = 2 * 1 = 2\n  F = 3 * 2 = 6\nF = 4 * 6 = 24\n```\n\n### With Accumulator (Tail-recursive)\n\n```prolog\n% Result builds on forward path\nfactorial_acc(0, Acc, Acc).     % Base: return accumulator\nfactorial_acc(N, Acc, F) :-\n    N > 0,\n    Acc1 is Acc * N,\n    N1 is N - 1,\n    factorial_acc(N1, Acc1, F). % Tail call - no work after\n```\n\nExecution for `factorial_acc(4, 1, F)`:\n```\nfactorial_acc(4, 1, F)   -> Acc = 1*4 = 4\nfactorial_acc(3, 4, F)   -> Acc = 4*3 = 12\nfactorial_acc(2, 12, F)  -> Acc = 12*2 = 24\nfactorial_acc(1, 24, F)  -> Acc = 24*1 = 24\nfactorial_acc(0, 24, 24) -> F = 24\n```\n\n### Why Accumulators Are Efficient\n\n| Aspect | Without Acc | With Acc |\n|--------|-------------|----------|\n| Stack depth | O(n) | O(1)* |\n| Can overflow | Yes | No |\n| Compilable to loop | No | Yes |\n\n*With tail-call optimization\n\n### UnifyWeaver's Optimization\n\nUnifyWeaver detects accumulator patterns and generates iterative loops:\n\n```bash\n# Instead of recursive calls:\nwhile [[ \"$current_list\" != \"[]\" ]]; do\n    acc=$((acc + 1))\n    # advance to next element\ndone\n```", "anchor_question_hash": "e1f2a3b4c5d60011"}}
{"cluster_id": "fold-pattern", "seed_level": 2, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md", "education/book-02-bash-target/appendix_b_fold_pattern_deep_dive.md"], "topics": ["fold", "reduce", "functional-programming", "compilation-strategy"], "questions": ["What is a fold and why use it for compilation?", "What's the difference between fold_left and fold_right?", "How does fold-based compilation work?", "Why does UnifyWeaver use fold for linear recursion?"], "answer": {"text": "## The Fold Pattern\n\nA fold (also called reduce) accumulates a result by iterating over a sequence.\n\n### Basic Concept\n\n```\nfold(operation, initial, [a, b, c])\n\nSteps:\n  acc = initial\n  acc = operation(a, acc)\n  acc = operation(b, acc)\n  acc = operation(c, acc)\n  return acc\n```\n\n### Example: Sum with Fold\n\n```bash\n# sum([1, 2, 3]) using fold\nfold_left 0 add 1 2 3\n\n# Steps:\n# acc = 0\n# acc = add(1, 0) = 1\n# acc = add(2, 1) = 3\n# acc = add(3, 3) = 6\n# Result: 6\n```\n\n### Left vs Right Fold\n\n```\nfold_left:  ((initial op a) op b) op c\nfold_right: a op (b op (c op initial))\n```\n\nFor associative operations (like +, *), both give same result.\n\n### Why Use Fold for Compilation?\n\n**1. Separation of Concerns**\n- Structure building: generate the sequence\n- Computation: apply the operation\n\n**2. Reusability**\n```bash\n# Same fold_left for many predicates\nfactorial: fold_left 1 multiply [n..1]\nsum_list:  fold_left 0 add [elements]\nlength:    fold_left 0 increment [elements]\n```\n\n### UnifyWeaver's Fold Implementation\n\n```bash\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Usage for factorial\nbuild_range_down() {\n    seq \"$1\" -1 1\n}\n\nfactorial_op() {\n    echo $(($1 * $2))\n}\n\nfactorial() {\n    local range=$(build_range_down \"$1\")\n    fold_left 1 factorial_op $range\n}\n```\n\n### Benefits\n\n- Clear, readable generated code\n- Easy to debug (inspect sequence, operation)\n- Natural fit for linear recursion patterns", "anchor_question_hash": "f2a3b4c5d6e70012"}}
{"cluster_id": "scc-tarjan", "seed_level": 3, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md", "src/unifyweaver/core/advanced/scc_detection.pl"], "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithm"], "questions": ["What is a Strongly Connected Component (SCC)?", "Why does SCC detection matter for mutual recursion?", "How does Tarjan's algorithm work?", "How does UnifyWeaver detect mutual recursion?"], "answer": {"text": "## Strongly Connected Components (SCC)\n\nAn SCC is a maximal group of nodes where every node can reach every other node.\n\n### Visual Example\n\n```\n    A → B → C\n    ↑       ↓\n    └───────┘\n\nA, B, C form an SCC: A→B→C→A (cycle)\n```\n\n### Why SCCs Matter for Mutual Recursion\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even → is_odd\n   ↑         ↓\n   └─────────┘\n```\n\nThese form an SCC - they're mutually recursive and must be compiled together.\n\n### Tarjan's Algorithm (Simplified)\n\n1. **DFS traversal** - visit each node\n2. **Track discovery time** - when node was first seen\n3. **Track low-link** - lowest reachable node\n4. **Stack-based detection** - nodes in current path\n\n```\nVisit A (disc=1, low=1)\n  Visit B (disc=2, low=2)\n    Visit C (disc=3, low=3)\n      C can reach A (disc=1)\n      Update C.low = 1\n    Update B.low = 1\n  Update A.low = 1\nA.disc == A.low → SCC found: {A, B, C}\n```\n\n### UnifyWeaver's SCC Detection\n\n```prolog\n% Build call graph from clauses\nbuild_call_graph(Predicates, Graph),\n\n% Find SCCs using Tarjan\nfind_sccs(Graph, SCCs),\n\n% Non-trivial SCCs = mutual recursion\ninclude(non_trivial_scc, SCCs, MutualGroups).\n```\n\n### Why Shared Memoization?\n\nWithout shared memo:\n```\nis_even(4) → is_odd(3) → is_even(2) → is_odd(1) → true\n              ^ if is_odd has separate memo, \n                is_even's results aren't cached\n```\n\nWith shared memo:\n```\nis_even_is_odd_memo[\"is_even:4\"] = true\nis_even_is_odd_memo[\"is_odd:3\"] = true\n... all results cached in one table\n```", "anchor_question_hash": "a3b4c5d6e7f80013"}}
{"cluster_id": "recursion-types", "seed_level": 1, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md", "education/book-02-bash-target/A_appendix_recursion_patterns.md"], "topics": ["tail-recursion", "linear-recursion", "tree-recursion", "classification"], "questions": ["How do I know if my code is tail/linear/tree recursive?", "What's the difference between tail and linear recursion?", "What makes recursion 'tree' recursion?", "How does UnifyWeaver classify recursion patterns?"], "answer": {"text": "## Recursion Pattern Classification\n\n### Quick Reference\n\n| Pattern | Recursive Calls | Work After Call? | Example |\n|---------|-----------------|------------------|--------|\n| Tail | 1 | No | count_items |\n| Linear | 1 | Yes | factorial |\n| Tree | 2+ | Yes | tree_sum |\n| Mutual | 1+ (to different pred) | Varies | is_even/is_odd |\n\n### Tail Recursion\n\nThe recursive call is the **last action** - no computation after it returns.\n\n```prolog\n% TAIL: recursive call is last\ncount([], Acc, Acc).\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).    % Nothing after this\n```\n\n### Linear Recursion\n\nExactly **one recursive call**, but work happens **after** it returns.\n\n```prolog\n% LINEAR: work after recursive call\nfactorial(0, 1).\nfactorial(N, F) :-\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.          % Multiplication AFTER return\n```\n\n### Tree Recursion\n\n**Multiple recursive calls** on structural parts.\n\n```prolog\n% TREE: two recursive calls\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),      % Call 1\n    tree_sum(R, RS),      % Call 2\n    Sum is V + LS + RS.\n```\n\n### How to Identify\n\n**Step 1:** Count recursive calls per clause\n- 0 = base case\n- 1 = tail or linear\n- 2+ = tree\n\n**Step 2:** If 1 call, check if it's last\n- Last action → tail\n- Work after → linear\n\n**Step 3:** Check if calls are to same predicate\n- Different predicate → possibly mutual\n\n### UnifyWeaver's Priority\n\n1. **Tail** (most efficient → iterative loop)\n2. **Linear** (fold-based with memoization)\n3. **Tree** (recursive with structure parsing)\n4. **Mutual** (SCC detection, shared memo)\n5. **Basic** (fallback BFS)", "anchor_question_hash": "b4c5d6e7f8a90014"}}
{"cluster_id": "memoization-strategy", "seed_level": 2, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md"], "topics": ["memoization", "caching", "performance", "mutual-recursion"], "questions": ["What is memoization and why use it?", "Why must mutual recursive functions share a memo table?", "How does UnifyWeaver implement memoization?", "What would happen without shared memoization?"], "answer": {"text": "## Memoization Strategy\n\nMemoization caches function results to avoid redundant computation.\n\n### Basic Concept\n\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check cache first\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Compute result\n    local result=$(compute_factorial \"$n\")\n    \n    # Cache it\n    factorial_memo[$n]=\"$result\"\n    echo \"$result\"\n}\n```\n\n### Why Memoization Helps\n\n```\nWithout memo: fib(5) computes fib(3) twice\n  fib(5)\n  ├── fib(4)\n  │   ├── fib(3)  ← computed\n  │   └── fib(2)\n  └── fib(3)      ← computed AGAIN\n\nWith memo: fib(3) computed once, cached\n  fib(5)\n  ├── fib(4)\n  │   ├── fib(3)  ← computed, cached\n  │   └── fib(2)\n  └── fib(3)      ← cache hit!\n```\n\n### Why Mutual Recursion Needs Shared Memo\n\nSeparate tables would miss cross-function caching:\n\n```\nis_even(4) → is_odd(3) → is_even(2) → is_odd(1) → true\n\nSeparate memos:\n  is_even_memo: {4: ?, 2: ?}  ← waiting for is_odd\n  is_odd_memo: {3: ?, 1: true}\n  \nShared memo:\n  shared_memo: {\n    \"is_even:4\": true,\n    \"is_odd:3\": true,\n    \"is_even:2\": true,\n    \"is_odd:1\": true\n  }\n```\n\n### Without Shared Memo: Infinite Loop Risk\n\n```prolog\na(X) :- b(X).\nb(X) :- a(X).  % Circular!\n```\n\nShared memo detects the cycle:\n```bash\na(5):  Check memo[\"a:5\"] - not found, mark as computing\nb(5):  Check memo[\"b:5\"] - not found, mark as computing  \na(5):  Check memo[\"a:5\"] - FOUND (computing) → cycle detected!\n```\n\n### UnifyWeaver's Implementation\n\n```bash\n# Shared memo for SCC group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local key=\"is_even:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n\nis_odd() {\n    local key=\"is_odd:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n```", "anchor_question_hash": "c5d6e7f8a9b00015"}}
