{"cluster_id": "bash-subshells", "seed_level": 1, "source_files": ["education/book-02-bash-target/04_variable_scope_and_process_substitution.md"], "topics": ["subshell", "pipes", "variable-scope", "child-process"], "questions": ["What is a bash subshell and why do pipes create one?", "Why don't variables persist after a pipe?", "What is the pipe subshell problem?", "How do pipes affect variable scope in bash?"], "answer": {"text": "## Bash Subshells\n\nA subshell is a child process running a copy of bash.\n\n### The Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\n### Why This Happens\n\nPipes (`|`) create a subshell for the right side:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (changes here)\n   count still 0                  (discarded when done)\n```\n\nThe subshell gets a **copy** of variables. Changes don't affect the parent.\n\n### Why Bash Does This\n\nPipes enable parallelism:\n- Both sides run simultaneously\n- Data flows through the pipe\n- Requires separate processes\n\n### Detecting Subshells\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs = different processes\n```\n\n### Solutions\n\n1. **Process Substitution** - avoid pipe subshell\n2. **Here-string** - for simple cases\n3. **Temp files** - explicit state passing\n4. **lastpipe option** - bash 4.2+ only\n\nSee: Process substitution training for solution details.", "anchor_question_hash": "e5f6a7b8c9d00005"}}
{"cluster_id": "process-substitution", "seed_level": 2, "source_files": ["education/book-02-bash-target/04_variable_scope_and_process_substitution.md"], "topics": ["process-substitution", "file-descriptor", "redirection"], "questions": ["What is process substitution in bash?", "How does < <(...) work?", "Why use process substitution instead of pipes?", "What's the difference between | and < <(...)?"], "answer": {"text": "## Process Substitution\n\nProcess substitution runs a command and makes its output available as a file.\n\n### Syntax\n\n```bash\n< <(command)   # Input from command output\n> >(command)   # Output to command input\n```\n\n### How It Works\n\n```bash\n# Pipe (creates subshell for while loop)\ncommand | while read line; do ...; done\n\n# Process substitution (loop runs in current shell)\nwhile read line; do ...; done < <(command)\n```\n\n### Why It Solves the Subshell Problem\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\nThe `< <(...)` creates a file descriptor that the current shell reads from. No subshell is created for the loop.\n\n### Under the Hood\n\n```bash\n# Process substitution creates /dev/fd/N\necho <(echo hello)\n# Output: /dev/fd/63 (or similar)\n\n# It's like:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Comparison\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\n### UnifyWeaver Usage\n\n```bash\n# From generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```", "anchor_question_hash": "f6a7b8c9d0e10006"}}
{"cluster_id": "bash-arrays", "seed_level": 1, "source_files": ["education/book-02-bash-target/04_variable_scope_and_process_substitution.md"], "topics": ["associative-arrays", "declare", "hash-table", "indexed-arrays"], "questions": ["How do bash associative arrays work?", "What's the difference between indexed and associative arrays?", "How do I declare an associative array in bash?", "Why does UnifyWeaver use associative arrays?"], "answer": {"text": "## Bash Arrays\n\nBash supports two types of arrays: indexed and associative.\n\n### Indexed Arrays\n\n```bash\n# Declare and initialize\nfruits=(apple banana cherry)\n\n# Access by index\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\n\n# All elements\necho ${fruits[@]}    # apple banana cherry\n```\n\n### Associative Arrays\n\n```bash\n# MUST declare with -A\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n\n# All keys\necho ${!colors[@]}    # sky grass sun\n\n# All values\necho ${colors[@]}     # blue green yellow\n```\n\n### Why UnifyWeaver Uses Associative Arrays\n\n**1. O(1) Lookup**\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Deduplication (visited tracking)**\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Fact Storage**\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\n### Global vs Local Arrays\n\n```bash\n# Global (persists across functions)\ndeclare -gA memo_table\n\n# Local (only in function)\nmy_func() {\n    local -A temp_array\n}\n```\n\n### Common Operations\n\n```bash\n# Check if key exists\n[[ -v array[$key] ]]\n\n# Check if value is non-empty\n[[ -n \"${array[$key]}\" ]]\n\n# Delete key\nunset array[$key]\n\n# Array size\necho ${#array[@]}\n```", "anchor_question_hash": "a7b8c9d0e1f20007"}}
{"cluster_id": "bash-redirections", "seed_level": 2, "source_files": ["education/book-02-bash-target/04_variable_scope_and_process_substitution.md"], "topics": ["file-descriptors", "redirection", "stdin", "stdout", "stderr"], "questions": ["How do bash redirections and file descriptors work?", "What are file descriptors 0, 1, and 2?", "What does < and > mean in bash?", "How does redirection relate to process substitution?"], "answer": {"text": "## Bash Redirections and File Descriptors\n\nFile descriptors are integer references to open files/streams.\n\n### Standard Descriptors\n\n| FD | Name | Default |\n|----|------|--------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Terminal (errors) |\n\n### Basic Redirections\n\n```bash\n# Redirect stdout to file\ncommand > output.txt\n\n# Redirect stdin from file\ncommand < input.txt\n\n# Redirect stderr to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or (bash 4+)\ncommand &> output.txt\n```\n\n### Append vs Overwrite\n\n```bash\n# Overwrite\necho \"new\" > file.txt\n\n# Append\necho \"more\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document (multi-line input)\ncat <<EOF\nLine 1\nLine 2\nEOF\n\n# Here string (single string as input)\nread var <<< \"hello world\"\n```\n\n### Process Substitution and FDs\n\n```bash\n# <(...) creates a file descriptor\necho <(echo hello)\n# Output: /dev/fd/63\n\n# < <(...) redirects stdin from that FD\nwhile read line; do\n    echo \"Got: $line\"\ndone < <(echo -e \"a\\nb\\nc\")\n```\n\n### Why This Matters for UnifyWeaver\n\nGenerated code uses these patterns:\n```bash\n# Read from command output without subshell\nwhile IFS=\":\" read -r from to; do\n    process \"$from\" \"$to\"\ndone < <(edge_stream)\n\n# Suppress errors\nresult=$(command 2>/dev/null)\n```", "anchor_question_hash": "b8c9d0e1f2a30008"}}
{"cluster_id": "bash-trap", "seed_level": 2, "source_files": ["education/book-02-bash-target/04_variable_scope_and_process_substitution.md"], "topics": ["trap", "signals", "cleanup", "EXIT", "PIPE"], "questions": ["What does the trap command do in bash?", "How do I clean up temp files on exit?", "Why use trap with EXIT and PIPE?", "What signals can trap handle?"], "answer": {"text": "## Bash Trap Command\n\nThe `trap` command registers handlers for signals and events.\n\n### Basic Syntax\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\n### Common Signals\n\n| Signal | When Triggered |\n|--------|---------------|\n| EXIT | Script exits (any reason) |\n| INT | Ctrl+C pressed |\n| TERM | Kill signal received |\n| PIPE | Broken pipe (reader closed) |\n| ERR | Command returns non-zero |\n\n### Cleanup Pattern\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Why EXIT and PIPE?\n\n- **EXIT**: Normal termination, errors, Ctrl+C\n- **PIPE**: Reader closes pipe early (e.g., `head -1`)\n\nWithout PIPE trap:\n```bash\nreaches_all \"a\" | head -1\n# Temp files might not be cleaned up!\n```\n\n### Multiple Traps\n\n```bash\n# Add to existing trap (don't replace)\ntrap 'echo \"Cleaning up...\"; rm -f $tmp' EXIT\n\n# Reset trap\ntrap - EXIT\n\n# Ignore signal\ntrap '' INT  # Ctrl+C ignored\n```", "anchor_question_hash": "c9d0e1f2a3b40009"}}
{"cluster_id": "bash-string-ops", "seed_level": 2, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md"], "topics": ["string-manipulation", "parameter-expansion", "substring", "pattern-matching"], "questions": ["What do ${string#pattern} and ${string%pattern} do?", "How does bash string manipulation work?", "How do I remove prefixes and suffixes in bash?", "What string operations does UnifyWeaver's generated code use?"], "answer": {"text": "## Bash String Operations\n\nBash has powerful string manipulation via parameter expansion.\n\n### Remove Prefix/Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from start\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from start\necho ${str##*/}   # (for paths)\n\n# Remove longest match from end\necho ${str%%/*}   # (for paths)\n```\n\n### UnifyWeaver List Parsing\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove [\nlist=\"${list%]}\"   # Remove ]\n# Result: a,b,c\n```\n\n### Substring Extraction\n\n```bash\nstr=\"hello world\"\n\n# From position 0, length 5\necho ${str:0:5}    # hello\n\n# From position 6\necho ${str:6}      # world\n\n# Single character at position\necho ${str:0:1}    # h\n```\n\n### String Length\n\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n### Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first occurrence\necho ${str/world/there}   # hello there world\n\n# Replace all occurrences\necho ${str//world/there}  # hello there there\n```\n\n### Pattern Matching in Conditions\n\n```bash\n# Regex match\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob match\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n### UnifyWeaver Tree Parsing\n\n```bash\n# Character-by-character iteration\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```", "anchor_question_hash": "d0e1f2a3b4c50010"}}
