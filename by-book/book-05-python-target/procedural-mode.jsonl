{"cluster_id": "b5-c2-procedural-mode", "seed_level": 2, "source_files": ["education/book-05-python-target/02_procedural_mode.md"], "topics": ["procedural-mode", "streaming", "generator-functions"], "questions": ["What is procedural mode in the Python target?", "How does procedural mode handle streaming?", "How are Prolog facts translated to Python?"], "answer": {"text": "## Procedural Mode\n\nProcedural mode (default) translates Prolog predicates into Python generator functions with streaming semantics.\n\n### Translation Pattern\n\n- **Facts** → constant yields\n- **Rules** → nested generator loops\n- **Constraints** → `if` conditions\n- **Recursion** → memoization or loop optimization\n\n### Streaming Architecture\n\n```python\ndef process_stream(records):\n    seen = set()\n    for record in records:\n        for result in _clause_0(record):\n            key = json.dumps(result, sort_keys=True)\n            if key not in seen:\n                seen.add(key)\n                yield result\n```\n\n### Automatic Deduplication\n\nGenerated scripts use a `seen` set to ensure each unique result is yielded exactly once, matching Prolog's set semantics.", "anchor_question_hash": "b5c2001a"}}
{"cluster_id": "b5-c2-constraints-arithmetic", "seed_level": 3, "source_files": ["education/book-05-python-target/02_procedural_mode.md"], "topics": ["constraints", "arithmetic", "compilation"], "questions": ["How does Python target handle arithmetic expressions?", "How are Prolog constraints compiled to Python?", "What arithmetic operations are supported?"], "answer": {"text": "## Arithmetic and Constraints\n\n### Arithmetic Compilation\n\nProlog `is/2` expressions translate directly to Python:\n\n```prolog\ndouble(X, Y) :- Y is X * 2.\n```\n\n```python\ndef _clause_0(record):\n    x = record.get('arg0')\n    if x is not None:\n        y = x * 2\n        yield {'arg0': x, 'arg1': y}\n```\n\n### Supported Operations\n\n| Prolog | Python | Description |\n|--------|--------|-------------|\n| `X + Y` | `x + y` | Addition |\n| `X - Y` | `x - y` | Subtraction |\n| `X * Y` | `x * y` | Multiplication |\n| `X / Y` | `x / y` | Division |\n| `X mod Y` | `x % y` | Modulo |\n| `X ** Y` | `x ** y` | Exponentiation |\n\n### Comparison Constraints\n\nConstraints become `if` conditions in Python.", "anchor_question_hash": "b5c2002a"}}
{"cluster_id": "b5-c2-io-formats", "seed_level": 3, "source_files": ["education/book-05-python-target/02_procedural_mode.md"], "topics": ["jsonl", "nul-json", "xml", "io-formats"], "questions": ["What input/output formats does the Python target support?", "How do I process XML files with Python target?", "What is NUL-delimited JSON?"], "answer": {"text": "## Input/Output Formats\n\n### JSONL (Default)\n\nJSON Lines - one JSON object per line:\n\n```bash\necho '{\"x\": 5}\n{\"x\": 10}' | python3 script.py\n```\n\n### NUL-Delimited JSON\n\nBinary-safe streaming for embedded NULs:\n\n```prolog\ncompile_predicate_to_python(pred/2, [record_format(nul_json)], Code).\n```\n\n### Native XML Input\n\nDirect XML processing with lxml:\n\n```prolog\ncompile_predicate_to_python(process_products/1, [\n    input_source(xml('data.xml', ['product']))\n], Code).\n```\n\nUses `lxml.etree.iterparse` for memory-efficient streaming of large XML files.", "anchor_question_hash": "b5c2003a"}}
