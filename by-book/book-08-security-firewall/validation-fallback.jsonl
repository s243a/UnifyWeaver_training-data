{"cluster_id": "validation-001", "question": "What validation points does UnifyWeaver have?", "answer": "UnifyWeaver validates at three points: (1) Pre-generation - checks predicate compatibility, target feature support, and firewall policy compliance before generating code; (2) Post-generation - verifies syntax, checks for dangerous patterns (eval, exec), and analyzes complexity after code is generated; (3) Deployment - validates security requirements (HTTPS for remote), configuration correctness, and health check setup. Each validation returns a list of issues that must be addressed.", "source_file": "book-08-security-firewall/05_validation_fallback.md", "prerequisites": ["security-001"]}
{"cluster_id": "validation-001", "question": "How does pre-generation validation work?", "answer": "Pre-generation validation checks compatibility before code generation:\n\n```prolog\nvalidate_for_target(Predicates, Target, Issues) :-\n    findall(Issue,\n        (member(Pred, Predicates),\n         incompatible_feature(Pred, Target, Issue)),\n        Issues).\n\n% Example incompatibilities\nincompatible_feature(Pred, bash, issue(tabling, Pred)) :-\n    uses_tabling(Pred).\nincompatible_feature(Pred, awk, issue(recursion_depth, Pred)) :-\n    deep_recursion(Pred).\n```\n\nAlso checks firewall policies with `validate_firewall/3`.", "source_file": "book-08-security-firewall/05_validation_fallback.md", "prerequisites": ["validation-001"]}
{"cluster_id": "validation-002", "question": "What fallback mechanisms does UnifyWeaver provide?", "answer": "Four fallback mechanisms: (1) Compilation fallback - native compilation fails, falls back to interpreted; (2) Dialect fallback - tries alternative Prolog dialects if one fails; (3) Target fallback - tries alternative compilation targets; (4) Service fallback - uses default values or backup services when a service fails:\n\n```prolog\n:- declare_fallback(api_service, [\n    default_value(#{status: 'unavailable'}),\n    fallback_service(backup_api),\n    cache_timeout(300)\n]).\n```", "source_file": "book-08-security-firewall/05_validation_fallback.md", "prerequisites": ["validation-001"]}
{"cluster_id": "validation-003", "question": "How do I implement retry policies and circuit breakers?", "answer": "Retry policies handle transient failures:\n\n```prolog\n:- declare_retry_policy(api_service, [\n    max_retries(3),\n    retry_delay(exponential(1000, 2, 10000)),\n    retry_on([connection_error, timeout, server_error])\n]).\n```\n\nCircuit breakers prevent cascading failures:\n\n```prolog\n:- declare_circuit_breaker(api_service, [\n    failure_threshold(5),\n    reset_timeout(60),\n    half_open_requests(3)\n]).\n```\n\nCombine with `protected_call/4` for full protection: circuit breaker -> timeout -> retry -> fallback.", "source_file": "book-08-security-firewall/05_validation_fallback.md", "prerequisites": ["validation-002"]}
