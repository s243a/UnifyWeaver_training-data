{"cluster_id": "hooks-001", "question": "What are lifecycle hooks in UnifyWeaver?", "answer": "Lifecycle hooks are actions that execute automatically at specific events during service deployment and operation. The lifecycle flow is: pre_deploy -> Deploy -> post_deploy -> Running -> pre_shutdown -> Shutdown -> post_shutdown. Declare hooks with:\n\n```prolog\n:- declare_lifecycle_hook(api_service, pre_deploy, health_check).\n:- declare_lifecycle_hook(api_service, post_deploy, warm_cache).\n:- declare_lifecycle_hook(api_service, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(api_service, on_health_failure, custom('alert.sh')).\n```", "source_file": "book-08-security-firewall/03_lifecycle_hooks.md", "prerequisites": ["security-001"]}
{"cluster_id": "hooks-001", "question": "What lifecycle hook events are available?", "answer": "Five hook events: (1) `pre_deploy` - before deployment for validation/backup; (2) `post_deploy` - after deployment for health checks/cache warming; (3) `pre_shutdown` - before stopping for connection draining/state saving; (4) `post_shutdown` - after stopping for cleanup/notification; (5) `on_health_failure` - when health check fails for alerting/recovery. Multiple hooks can be declared for the same event and execute sequentially.", "source_file": "book-08-security-firewall/03_lifecycle_hooks.md", "prerequisites": ["hooks-001"]}
{"cluster_id": "hooks-002", "question": "What built-in hook actions are available?", "answer": "Five built-in actions: (1) `drain_connections` - wait for active connections to complete; (2) `health_check` - verify service is responding via HTTP; (3) `warm_cache` - pre-populate caches; (4) `save_state` - persist service state before shutdown; (5) `custom(Command)` - run arbitrary shell command. Example:\n\n```prolog\n:- declare_lifecycle_hook(svc, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(svc, post_deploy, custom('notify.sh deployed')).\n```", "source_file": "book-08-security-firewall/03_lifecycle_hooks.md", "prerequisites": ["hooks-001"]}
{"cluster_id": "hooks-002", "question": "How does deploy_with_hooks work?", "answer": "The `deploy_with_hooks/2` predicate executes the full deployment flow: (1) Validate security requirements; (2) Execute pre-deploy hooks; (3) Perform actual deployment; (4) Execute post-deploy hooks. If any step fails, deployment aborts with appropriate error. Use `graceful_stop/3` for shutdown with hooks:\n\n```prolog\ndeploy_secure :-\n    validate_security(api_service, Errors),\n    (Errors == []\n    ->  deploy_with_hooks(api_service, Result)\n    ;   format('Security errors: ~w~n', [Errors]), fail\n    ).\n```", "source_file": "book-08-security-firewall/03_lifecycle_hooks.md", "prerequisites": ["hooks-001"]}
