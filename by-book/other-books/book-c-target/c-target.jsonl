{"cluster_id": "c-target-001", "question": "How do I compile Prolog predicates to C?", "answer": "Use the C target module:\n\n```prolog\n?- use_module('src/unifyweaver/targets/c_target').\n\n% Pipeline mode (JSONL processing)\n?- compile_predicate_to_c(filter/2, [pipeline_input(true)], Code).\n\n% Recursive query (transitive closure)\n?- compile_recursive(ancestor/2, [target(c)], Code).\n\n% Export facts\n?- compile_facts_to_c(parent, 2, Code).\n```\n\n**Key features:**\n- cJSON for JSON parsing (MIT license)\n- Tail recursion → while loop optimization\n- General recursion → explicit stack pattern\n- Makefile/CMake generation\n- 41 bindings (stdlib, I/O, strings, cJSON)", "source_file": "other-books/book-c-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "c-target-001", "question": "What does the C pipeline mode code look like?", "answer": "Pipeline mode generates C code that processes JSONL using cJSON:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"cJSON.h\"\n\ncJSON* process(cJSON* record) {\n    /* Process and return, or NULL to filter out */\n    return record;\n}\n\nvoid run_pipeline(void) {\n    char line[65536];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        size_t len = strlen(line);\n        if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';\n        if (strlen(line) == 0) continue;\n        \n        cJSON* record = cJSON_Parse(line);\n        if (!record) {\n            fprintf(stderr, \"JSON parse error: %s\\n\", cJSON_GetErrorPtr());\n            continue;\n        }\n        \n        cJSON* result = process(record);\n        if (result) {\n            char* json_str = cJSON_PrintUnformatted(result);\n            if (json_str) {\n                printf(\"%s\\n\", json_str);\n                free(json_str);\n            }\n            if (result != record) cJSON_Delete(result);\n        }\n        cJSON_Delete(record);\n    }\n}\n\nint main(int argc, char** argv) {\n    (void)argc; (void)argv;\n    run_pipeline();\n    return 0;\n}\n```", "source_file": "other-books/book-c-target/02_pipeline_mode.md", "prerequisites": ["c-target-001"]}
{"cluster_id": "c-target-001", "question": "How does C generator mode work without coroutines?", "answer": "C generator mode uses a **callback pattern** since C doesn't have coroutines:\n\n```c\ntypedef void (*record_callback)(cJSON* record, void* user_data);\n\nint generate(cJSON* record, record_callback callback, void* user_data) {\n    /* Call callback for each result */\n    callback(record, user_data);\n    return 1;  /* Number of results */\n}\n\nvoid run_generator(record_callback callback, void* user_data) {\n    char line[65536];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        cJSON* record = cJSON_Parse(line);\n        if (record) {\n            generate(record, callback, user_data);\n            cJSON_Delete(record);\n        }\n    }\n}\n\nvoid print_result(cJSON* record, void* user_data) {\n    (void)user_data;\n    char* json_str = cJSON_PrintUnformatted(record);\n    if (json_str) {\n        printf(\"%s\\n\", json_str);\n        free(json_str);\n    }\n}\n\nint main(void) {\n    run_generator(print_result, NULL);\n    return 0;\n}\n```\n\n| Prolog | C Callback |\n|--------|------------|\n| Multiple solutions | Call callback multiple times |\n| Backtracking | Iterate and call |\n| Lazy evaluation | Process on demand |", "source_file": "other-books/book-c-target/03_generator_mode.md", "prerequisites": ["c-target-001"]}
{"cluster_id": "c-target-001", "question": "How do I generate Makefile and CMake for C targets?", "answer": "UnifyWeaver generates both Makefile and CMake configurations:\n\n**Makefile:**\n```prolog\n?- generate_makefile([program_name(my_filter)], Makefile).\n```\n\nGenerates:\n```makefile\n# Generated by UnifyWeaver C Target\nCC = gcc\nCFLAGS = -Wall -Wextra -O2 -std=c11\nLDFLAGS = -lcjson\n\nTARGET = my_filter\nSOURCES = pipeline.c cJSON.c\n\n.PHONY: all clean\n\nall: $(TARGET)\n\n$(TARGET): $(SOURCES)\n\t$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)\n\nclean:\n\trm -f $(TARGET)\n```\n\n**CMake:**\n```prolog\n?- generate_cmake([project_name('MyFilter')], CMake).\n```\n\nGenerates:\n```cmake\ncmake_minimum_required(VERSION 3.10)\nproject(MyFilter C)\n\nset(CMAKE_C_STANDARD 11)\nset(CMAKE_C_STANDARD_REQUIRED ON)\n\nadd_executable(pipeline pipeline.c cJSON.c)\ntarget_link_libraries(pipeline cjson)\n```", "source_file": "other-books/book-c-target/04_build_systems.md", "prerequisites": ["c-target-001"]}
{"cluster_id": "c-target-001", "question": "How are recursive queries compiled to C?", "answer": "Recursive predicates compile to BFS with adjacency list:\n\n```prolog\n?- compile_recursive(ancestor/2, [target(c)], Code).\n```\n\nGenerated C code:\n```c\n#define MAX_NODES 1000\n\n/* Simple hash table for adjacency list */\ntypedef struct Edge {\n    char* to;\n    struct Edge* next;\n} Edge;\n\ntypedef struct {\n    char* from;\n    Edge* edges;\n} Node;\n\nstatic Node nodes[MAX_NODES];\nstatic int node_count = 0;\n\n/* BFS to find all reachable nodes */\nstatic void find_all(const char* start) {\n    char* queue[MAX_NODES];\n    int visited[MAX_NODES] = {0};\n    int head = 0, tail = 0;\n    \n    // ... BFS implementation\n}\n\n/* BFS to check if target is reachable */\nstatic int check_path(const char* start, const char* target) {\n    // ... BFS with early exit\n}\n```\n\n**C-specific features:**\n- Manual memory management with `strdup`/`malloc`\n- Static arrays for BFS queue and visited set\n- Linked list for adjacency edges\n- `strcmp` for string comparison", "source_file": "other-books/book-c-target/04_recursive_queries.md", "prerequisites": ["c-target-001"]}
