{"cluster_id": "kotlin-target-001", "question": "How do I compile Prolog predicates to Kotlin?", "answer": "Use the Kotlin target module:\n\n```prolog\n?- use_module('src/unifyweaver/targets/kotlin_target').\n\n% Pipeline mode (JSONL streaming)\n?- compile_predicate_to_kotlin(filter/2, [pipeline_input(true)], Code).\n\n% Generator mode (sequence yield)\n?- compile_predicate_to_kotlin(expand/2, [generator_mode(true)], Code).\n\n% Recursive query (transitive closure)\n?- compile_recursive(ancestor/2, [target(kotlin)], Code).\n\n% Export facts\n?- compile_facts_to_kotlin(parent, 2, Code).\n```\n\n**Kotlin advantages:**\n- Concise syntax (less boilerplate than Java)\n- Null safety (`?.` and `?:` operators)\n- Kotlin sequences for lazy evaluation\n- 100% Java interop", "source_file": "other-books/book-kotlin-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "kotlin-target-001", "question": "How does Kotlin pipeline mode work?", "answer": "Pipeline mode uses Kotlin sequences and `mapNotNull` for streaming:\n\n```kotlin\nimport com.google.gson.Gson\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\n\nobject FilterPipeline {\n    private val gson = Gson()\n\n    fun process(record: MutableMap<String, Any?>): MutableMap<String, Any?>? {\n        val value = record[\"value\"] as? Number\n        return if (value != null && value.toDouble() > 50) record else null\n    }\n\n    fun runPipeline() {\n        BufferedReader(InputStreamReader(System.`in`))\n            .lineSequence()\n            .filter { it.isNotBlank() }\n            .mapNotNull { line ->\n                val record: MutableMap<String, Any?> = gson.fromJson(line, mapType)\n                process(record)\n            }\n            .forEach { result ->\n                println(gson.toJson(result))\n            }\n    }\n}\n\nfun main() = FilterPipeline.runPipeline()\n```\n\n**Key patterns:**\n- `.lineSequence()` for lazy stdin reading\n- `.mapNotNull {}` combines map + filter (null = filtered out)\n- `as? Type` for safe casting", "source_file": "other-books/book-kotlin-target/02_pipeline_mode.md", "prerequisites": ["kotlin-target-001"]}
{"cluster_id": "kotlin-target-001", "question": "How does Kotlin generator mode work?", "answer": "Generator mode uses `sequence { yield() }` for lazy generation:\n\n```kotlin\nobject ExpandGenerator {\n    fun process(record: MutableMap<String, Any?>): Sequence<MutableMap<String, Any?>> = sequence {\n        val items = record[\"items\"] as? List<*> ?: emptyList<Any>()\n        for (item in items) {\n            val result = record.toMutableMap()\n            result[\"item\"] = item\n            result.remove(\"items\")\n            yield(result)\n        }\n    }\n\n    fun processAll(records: Sequence<MutableMap<String, Any?>>): Sequence<MutableMap<String, Any?>> {\n        return records.flatMap { process(it) }\n    }\n}\n```\n\n**Example:**\n```bash\necho '{\"id\": 1, \"items\": [\"a\", \"b\", \"c\"]}' | kotlin ExpandGenerator.kt\n# Output:\n{\"id\": 1, \"item\": \"a\"}\n{\"id\": 1, \"item\": \"b\"}\n{\"id\": 1, \"item\": \"c\"}\n```\n\n**Prolog to Kotlin mapping:**\n| Prolog | Kotlin |\n|--------|--------|\n| `member(X, List)` | `for (x in list) { yield(...) }` |\n| Multiple clauses | `sequence { ... }` blocks |\n| Backtracking | `flatMap` composition |", "source_file": "other-books/book-kotlin-target/03_generator_mode.md", "prerequisites": ["kotlin-target-001"]}
{"cluster_id": "kotlin-target-001", "question": "How are recursive queries compiled to Kotlin?", "answer": "Recursive predicates compile to BFS with Kotlin collections:\n\n```kotlin\npackage generated\n\nobject ANCESTORQuery {\n    private val baseRelation = mutableMapOf<String, MutableSet<String>>()\n\n    fun addFact(from: String, to: String) {\n        baseRelation.getOrPut(from) { mutableSetOf() }.add(to)\n    }\n\n    fun findAll(start: String): Set<String> {\n        val visited = mutableSetOf<String>()\n        val queue = ArrayDeque<String>()\n        val results = linkedSetOf<String>()\n\n        queue.add(start)\n        visited.add(start)\n\n        while (queue.isNotEmpty()) {\n            val current = queue.removeFirst()\n            baseRelation[current]?.forEach { next ->\n                if (next !in visited) {\n                    visited.add(next)\n                    queue.add(next)\n                    results.add(next)\n                }\n            }\n        }\n        return results\n    }\n}\n```\n\n**Run:**\n```bash\nkotlinc AncestorQuery.kt -include-runtime -d ancestor.jar\ncat facts.txt | java -jar ancestor.jar abraham\n```\n\n**Kotlin-specific features:**\n- `mutableMapOf`/`mutableSetOf` for efficient mutation\n- `ArrayDeque` for BFS queue\n- `linkedSetOf` preserves insertion order\n- `?.forEach` safe navigation for null maps", "source_file": "other-books/book-kotlin-target/04_recursive_queries.md", "prerequisites": ["kotlin-target-001"]}
