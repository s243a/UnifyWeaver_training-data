{"cluster_id": "fsharp-target-001", "question": "How do I compile Prolog predicates to F#?", "answer": "Use the F# target module:\n\n```prolog\n?- use_module('src/unifyweaver/targets/fsharp_target').\n?- init_fsharp_target.\n\n% Export facts to record types\n?- compile_predicate_to_fsharp(person/2, [], Code).\n\n% Tail recursion (O(1) stack)\n?- compile_tail_recursion_fsharp(sum/2, [], Code).\n\n% Linear recursion with memoization\n?- compile_linear_recursion_fsharp(fib/2, [], Code).\n\n% Mutual recursion (even/odd)\n?- compile_mutual_recursion_fsharp([is_even/1, is_odd/1], [], Code).\n```\n\n**F# advantages:**\n- Immutable records by default\n- Pipeline operator (`|>`)\n- Native mutual recursion with `and` keyword\n- Pattern matching for base cases", "source_file": "other-books/book-fsharp-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "fsharp-target-001", "question": "How do I compile facts to F# records?", "answer": "Prolog facts compile to F# records and accessor functions:\n\n**Prolog:**\n```prolog\nperson(john, 25).\nperson(jane, 30).\n```\n\n**Generated F#:**\n```fsharp\ntype PERSON = {\n    Arg1: string\n    Arg2: string\n}\n\nlet getAllPERSON () =\n    [\n        { Arg1 = \"john\"; Arg2 = \"25\" }\n        { Arg1 = \"jane\"; Arg2 = \"30\" }\n    ]\n\nlet streamPERSON () =\n    getAllPERSON () |> Seq.ofList\n\nlet containsPERSON target =\n    getAllPERSON () |> List.exists ((=) target)\n```\n\n**Run:**\n```bash\ndotnet new console -lang F# -o PersonApp\ncp Person.fs PersonApp/\ncd PersonApp\ndotnet run\n```", "source_file": "other-books/book-fsharp-target/01_introduction.md", "prerequisites": ["fsharp-target-001"]}
{"cluster_id": "fsharp-target-001", "question": "How do recursion patterns compile to F#?", "answer": "Three recursion patterns with idiomatic F# implementations:\n\n**1. Tail Recursion** (O(1) stack):\n```fsharp\nlet sum n =\n    let rec loop current acc =\n        if current <= 0 then acc\n        else loop (current - 1) (acc + current)\n    loop n 0\n```\n\n**2. Linear Recursion** (memoized):\n```fsharp\nopen System.Collections.Generic\n\nlet private memo = Dictionary<int, int>()\n\nlet rec fib n =\n    match memo.TryGetValue(n) with\n    | true, v -> v\n    | false, _ ->\n        let result =\n            match n with\n            | n when n <= 0 -> 0\n            | 1 -> 1\n            | n -> (fib (n - 1)) + n\n        memo.[n] <- result\n        result\n```\n\n**3. Mutual Recursion** (with `and`):\n```fsharp\nlet rec is_even n =\n    match n with\n    | 0 -> true\n    | n when n > 0 -> is_odd (n - 1)\n    | _ -> false\n\nand is_odd n =\n    match n with\n    | 0 -> false\n    | n when n > 0 -> is_even (n - 1)\n    | _ -> false\n```", "source_file": "other-books/book-fsharp-target/03_recursive_queries.md", "prerequisites": ["fsharp-target-001"]}
