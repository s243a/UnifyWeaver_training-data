{"cluster_id": "haskell-target-001", "question": "How do I compile Prolog predicates to Haskell?", "answer": "Use the Haskell target module:\n\n```prolog\n?- compile_facts_to_haskell(parent, 2, Code).\n?- compile_recursion_to_haskell(sum/2, [], Code).\n?- compile_predicate_to_haskell(parent/2, [type(facts)], Code).\n```\n\n**Why Haskell for Prolog?**\n| Prolog | Haskell |\n|--------|--------|\n| Facts + Rules | Data + Functions |\n| Pattern matching (clauses) | Pattern matching (equations) |\n| Backtracking | Lazy evaluation / List monad |\n| Unification | Type inference |\n\n**Example - Facts to Data:**\n```haskell\ndata Person = Tom | Bob | Jim\n  deriving (Eq, Show)\n\nparent :: [(Person, Person)]\nparent = [(Tom, Bob), (Bob, Jim)]\n\nisParent :: Person -> Person -> Bool\nisParent x y = (x, y) `elem` parent\n```", "source_file": "other-books/book-haskell-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "haskell-target-001", "question": "How do I compile tail recursion to Haskell?", "answer": "Use BangPatterns for strict accumulators:\n\n**Prolog:**\n```prolog\nsum_acc([], Acc, Acc).\nsum_acc([H|T], Acc, Sum) :- Acc1 is Acc + H, sum_acc(T, Acc1, Sum).\n```\n\n**Generate:**\n```prolog\n?- compile_module_to_haskell(\n       [pred(sumAcc, 3, list_tail_recursion)],\n       [module_name('SumAcc')], Code).\n```\n\n**Generated Haskell:**\n```haskell\n{-# LANGUAGE BangPatterns #-}\n\nsumAcc :: [Int] -> Int -> Int\nsumAcc [] !acc = acc\nsumAcc (h:t) !acc = sumAcc t (acc + h)\n```\n\n**Why `!acc`?** Without the bang pattern, Haskell builds a thunk chain. With `!acc`, it evaluates immediately - just like Prolog's tail recursion optimization!\n\n**More patterns:**\n```haskell\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\nfib :: Int -> Int\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n - 1) + fib (n - 2)\n```", "source_file": "other-books/book-haskell-target/02_recursion.md", "prerequisites": ["haskell-target-001"]}
{"cluster_id": "haskell-target-001", "question": "How do I compile DCGs to Parsec parser combinators?", "answer": "Use `compile_dcg_to_parsec` or `compile_grammar_to_parsec`:\n\n```prolog\n?- compile_grammar_to_parsec(\n       [(expr --> term),\n        (term --> factor),\n        (factor --> [x])],\n       [module_name('ExprParser'), start_symbol(expr)],\n       Code).\n```\n\n**Generated Haskell:**\n```haskell\nmodule ExprParser \n    ( parseexpr\n    , expr\n    ) where\n\nimport Text.Parsec\nimport Text.Parsec.String (Parser)\n\nparseexpr :: String -> Either ParseError String\nparseexpr = parse expr \"(input)\"\n\nexpr :: Parser String\nexpr = term\n\nterm :: Parser String\nterm = factor\n\nfactor :: Parser String\nfactor = string \"x\"\n```\n\n**DCG to Parsec mapping:**\n| Prolog DCG | Haskell Parsec |\n|------------|----------------|\n| `[char]` | `string \"char\"` |\n| `a, b` | `a *> b` |\n| `a ; b` | `try a <|> b` |\n| `*(A)` | `many A` |\n| `+(A)` | `some A` |\n| `?(A)` | `optional A` |", "source_file": "other-books/book-haskell-target/03_parsec.md", "prerequisites": ["haskell-target-001"]}
