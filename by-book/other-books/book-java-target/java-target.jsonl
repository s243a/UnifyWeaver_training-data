{"cluster_id": "java-target-001", "question": "How do I compile Prolog predicates to Java?", "answer": "Use the Java target module:\n\n```prolog\n?- use_module('src/unifyweaver/targets/java_target').\n\n% Pipeline mode (JSONL processing)\n?- compile_predicate_to_java(filter/2, [pipeline_input(true)], Code).\n\n% Recursive query (transitive closure)\n?- compile_recursive(ancestor/2, [target(java)], Code).\n\n% Export facts\n?- compile_facts_to_java(parent, 2, Code).\n```\n\n**Key features:**\n- Gson for JSON parsing\n- Stream API for pipeline processing\n- Stream.flatMap for generator mode\n- Gradle build generation\n- 42 bindings (String, Math, Collections, I/O, Stream API)", "source_file": "other-books/book-java-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "java-target-001", "question": "What does the Java pipeline mode code look like?", "answer": "Pipeline mode generates Java code using Gson and Stream API:\n\n```java\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class FilterPipeline {\n    private static final Gson gson = new Gson();\n    private static final Type mapType = new TypeToken<Map<String, Object>>(){}.getType();\n\n    public static Map<String, Object> process(Map<String, Object> record) {\n        Object value = record.get(\"value\");\n        if (value instanceof Number && ((Number) value).doubleValue() > 50) {\n            return record;\n        }\n        return null;  // Filter out\n    }\n\n    public static void runPipeline() {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        reader.lines()\n            .filter(line -> !line.isEmpty())\n            .map(line -> gson.fromJson(line, mapType))\n            .map(FilterPipeline::process)\n            .filter(Objects::nonNull)\n            .forEach(result -> System.out.println(gson.toJson(result)));\n    }\n\n    public static void main(String[] args) {\n        runPipeline();\n    }\n}\n```", "source_file": "other-books/book-java-target/02_pipeline_mode.md", "prerequisites": ["java-target-001"]}
{"cluster_id": "java-target-001", "question": "How does Java generator mode work with flatMap?", "answer": "Generator mode uses Java's Stream API with `flatMap` for multiple outputs:\n\n```java\nimport com.google.gson.Gson;\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class ExpandGenerator {\n    private static final Gson gson = new Gson();\n\n    public static Stream<Map<String, Object>> process(Map<String, Object> record) {\n        List<?> items = (List<?>) record.get(\"items\");\n        if (items == null) return Stream.empty();\n        \n        return items.stream().map(item -> {\n            Map<String, Object> result = new HashMap<>(record);\n            result.put(\"item\", item);\n            result.remove(\"items\");\n            return result;\n        });\n    }\n\n    public static Stream<Map<String, Object>> processAll(Stream<Map<String, Object>> records) {\n        return records.flatMap(ExpandGenerator::process);\n    }\n}\n```\n\n**Prolog to Java patterns:**\n| Prolog Pattern | Java Translation |\n|----------------|------------------|\n| `member(X, List)` | `list.stream().map(...)` |\n| Multiple clauses | `Stream.concat(...)` |\n| Recursive calls | `Stream.iterate(...)` |\n| Backtracking | `flatMap` composition |", "source_file": "other-books/book-java-target/03_generator_mode.md", "prerequisites": ["java-target-001"]}
{"cluster_id": "java-target-001", "question": "How are recursive queries compiled to Java?", "answer": "Recursive predicates compile to BFS with HashMap/HashSet:\n\n```prolog\n?- compile_recursive(ancestor/2, [target(java)], Code).\n```\n\nGenerated Java code:\n```java\npackage generated;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class ANCESTOR {\n\n    private static final Map<String, Set<String>> baseRelation = new HashMap<>();\n\n    public static void addFact(String from, String to) {\n        baseRelation.computeIfAbsent(from, k -> new HashSet<>()).add(to);\n    }\n\n    public static Set<String> findAll(String start) {\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        Set<String> results = new LinkedHashSet<>();\n\n        queue.add(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            Set<String> nexts = baseRelation.getOrDefault(current, Collections.emptySet());\n            \n            for (String next : nexts) {\n                if (!visited.contains(next)) {\n                    visited.add(next);\n                    queue.add(next);\n                    results.add(next);\n                }\n            }\n        }\n        return results;\n    }\n}\n```\n\n**Performance:** ~12ms for 10K facts (vs ~850ms in Bash)", "source_file": "other-books/book-java-target/04_recursive_queries.md", "prerequisites": ["java-target-001"]}
