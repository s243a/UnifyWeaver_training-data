{"cluster_id": "clojure-target-001", "question": "How do I compile Prolog predicates to Clojure?", "answer": "Use the Clojure target module:\n\n```prolog\n?- use_module('src/unifyweaver/targets/clojure_target').\n\n% Pipeline mode (threading macros)\n?- compile_predicate_to_clojure(filter/2, [pipeline_input(true)], Code).\n\n% Generator mode (lazy-seq)\n?- compile_predicate_to_clojure(expand/2, [generator_mode(true)], Code).\n\n% Recursive query (loop/recur BFS)\n?- compile_recursive(ancestor/2, [target(clojure)], Code).\n\n% Export facts\n?- compile_facts_to_clojure(parent, 2, Code).\n```\n\n**Clojure advantages:**\n- Lisp with homoiconicity and macros\n- Lazy sequences with `lazy-seq`/`cons`\n- Immutable persistent data structures\n- Threading macros (`->>`) for pipelines\n- JVM interoperability", "source_file": "other-books/book-clojure-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "clojure-target-001", "question": "How does Clojure pipeline mode work?", "answer": "Pipeline mode uses `keep` for filtering and `->>` threading macro:\n\n```clojure\n(ns filter-pipeline\n  (:require [clojure.data.json :as json]\n            [clojure.java.io :as io]))\n\n(defn process [record]\n  ;; Generated from: filter(Input, Output) :- get_field(Input, \"value\", Value), Value > 50, ...\n  (when (> (:value record 0) 50)\n    record))\n\n(defn run-pipeline []\n  (doseq [result (->> (line-seq (io/reader *in*))\n                      (filter seq)\n                      (map #(json/read-str % :key-fn keyword))\n                      (keep process))]\n    (println (json/write-str result))))\n\n(defn -main [& args]\n  (run-pipeline))\n```\n\n**Key patterns:**\n- `->>` threading macro for data flow\n- `keep` combines map + filter (nil = filtered out)\n- `:key-fn keyword` for keyword map keys\n- `when` returns nil on false (filtered by `keep`)", "source_file": "other-books/book-clojure-target/02_pipeline_mode.md", "prerequisites": ["clojure-target-001"]}
{"cluster_id": "clojure-target-001", "question": "How does Clojure generator mode work?", "answer": "Generator mode uses `mapcat` for expansion:\n\n```clojure\n(ns expand-generator\n  (:require [clojure.data.json :as json]))\n\n(defn process [record]\n  ;; Generated from: expand(Input, Output) :- member(Item, Items), ...\n  (let [items (:items record)]\n    (map (fn [item]\n           (-> record\n               (dissoc :items)\n               (assoc :item item)))\n         items)))\n\n(defn process-all [records]\n  (mapcat process records))\n```\n\n**With lazy-seq for recursion:**\n```clojure\n(defn process [record]\n  (lazy-seq\n    (loop [current record\n           results []]\n      (let [n (:n current 0)]\n        (if (<= n 0)\n          (cons current results)\n          (recur (assoc current :n (dec n))\n                 (cons current results)))))))\n```\n\n**Prolog to Clojure mapping:**\n| Prolog | Clojure |\n|--------|--------|\n| `member(X, List)` | `(map (fn [x] ...) list)` |\n| Multiple clauses | `mapcat` composition |\n| Backtracking | Lazy sequence chaining |", "source_file": "other-books/book-clojure-target/03_generator_mode.md", "prerequisites": ["clojure-target-001"]}
{"cluster_id": "clojure-target-001", "question": "How are recursive queries compiled to Clojure?", "answer": "Recursive predicates compile to `loop/recur` BFS:\n\n```clojure\n(ns generated.ancestor-query)\n\n(def base-relation (atom {}))\n\n(defn add-fact [from to]\n  (swap! base-relation update from (fnil conj #{}) to))\n\n(defn find-all [start]\n  (loop [visited #{start}\n         queue [start]\n         results []]\n    (if (empty? queue)\n      results\n      (let [current (first queue)\n            nexts (get @base-relation current #{})]\n        (recur\n          (into visited nexts)\n          (into (rest queue) (remove visited nexts))\n          (into results (remove visited nexts)))))))\n\n(defn check-path [start target]\n  (loop [visited #{start}\n         queue [start]]\n    (cond\n      (empty? queue) false\n      :else\n      (let [current (first queue)\n            nexts (get @base-relation current #{})]\n        (if (contains? nexts target)\n          true\n          (recur\n            (into visited nexts)\n            (into (rest queue) (remove visited nexts))))))))\n```\n\n**Clojure-specific features:**\n- `atom` for thread-safe mutable state\n- `loop/recur` for tail-recursive BFS\n- `fnil` for nil-safe update functions\n- `into`/`remove` for set operations", "source_file": "other-books/book-clojure-target/04_recursive_queries.md", "prerequisites": ["clojure-target-001"]}
