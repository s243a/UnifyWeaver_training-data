{"cluster_id": "wasm-target-001", "question": "How do I compile Prolog predicates to WebAssembly?", "answer": "Use the LLVM target with wasm32 triple:\n\n```prolog\n?- use_module('src/unifyweaver/targets/llvm_target').\n\n?- compile_wasm_module(\n       [func(sum, 2, tail_recursion),\n        func(factorial, 1, factorial)],\n       [module_name(prolog_wasm)],\n       Code),\n   write_llvm_program(Code, 'prolog_wasm.ll').\n```\n\n**Build commands:**\n```bash\nsed -i 's/%%/%/g' prolog_wasm.ll  # Fix Prolog escaping\nllc -march=wasm32 -filetype=obj prolog_wasm.ll -o prolog_wasm.o\nwasm-ld --no-entry --export-all prolog_wasm.o -o prolog_wasm.wasm\n```\n\n**Result:** 376-byte portable WASM module", "source_file": "other-books/book-wasm-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "wasm-target-001", "question": "What does WASM-targeted LLVM IR look like?", "answer": "LLVM IR for WASM uses i32 types and wasm32 target:\n\n```llvm\ntarget triple = \"wasm32-unknown-unknown\"\n\ndefine i32 @sum_impl(i32 %n, i32 %acc) {\nentry:\n  %cmp = icmp sle i32 %n, 0\n  br i1 %cmp, label %base, label %recurse\nbase:\n  ret i32 %acc\nrecurse:\n  %n1 = sub i32 %n, 1\n  %acc1 = add i32 %acc, %n\n  %result = tail call i32 @sum_impl(i32 %n1, i32 %acc1)\n  ret i32 %result\n}\n\ndefine i32 @sum(i32 %n) {\n  %result = call i32 @sum_impl(i32 %n, i32 0)\n  ret i32 %result\n}\n```\n\n**Key differences from native:**\n| Feature | Native | WASM |\n|---------|--------|------|\n| Target | x86_64 | wasm32 |\n| Int type | i64 | i32 |\n| Tail calls | musttail | tail |", "source_file": "other-books/book-wasm-target/02_compilation.md", "prerequisites": ["wasm-target-001"]}
{"cluster_id": "wasm-target-001", "question": "How do I use WASM-compiled Prolog from JavaScript?", "answer": "Load and call WASM exports from Node.js or browser:\n\n**Node.js:**\n```javascript\nconst fs = require('fs');\n\nasync function loadPrologMath(wasmPath) {\n    const bytes = fs.readFileSync(wasmPath);\n    const { instance } = await WebAssembly.instantiate(bytes);\n    return instance.exports;\n}\n\nconst math = await loadPrologMath('./prolog_wasm.wasm');\nconsole.log('sum(10) =', math.sum(10));       // 55\nconsole.log('factorial(5) =', math.factorial(5)); // 120\n```\n\n**Browser:**\n```html\n<script type=\"module\">\nasync function loadPrologMath() {\n    const response = await fetch('prolog_wasm.wasm');\n    const bytes = await response.arrayBuffer();\n    const { instance } = await WebAssembly.instantiate(bytes);\n    return instance.exports;\n}\n\nconst math = await loadPrologMath();\ndocument.getElementById('result').textContent = math.sum(100);\n</script>\n```\n\n**Use cases:** Browser computation, Node.js CLI, Cloudflare Workers, Deno Edge", "source_file": "other-books/book-wasm-target/03_javascript.md", "prerequisites": ["wasm-target-001"]}
{"cluster_id": "wasm-target-001", "question": "How does string support work in WASM?", "answer": "WASM uses linear memory with pointer+length for strings:\n\n**Memory model:**\n```\nWASM Linear Memory\n├── ptr → [UTF-8 bytes...][null]\n│   1024   t o m \\0\n```\n\n**WASM string runtime exports:**\n```llvm\ndefine i32 @alloc(i32 %size) { ... }      ; Bump allocator\ndefine void @dealloc(i32 %ptr, i32 %size) { ... }\ndefine i32 @strlen_wasm(i32 %ptr) { ... }\n```\n\n**TypeScript wrapper:**\n```typescript\nclass GraphWasm {\n  private encodeString(str: string): [number, number] {\n    const bytes = this.encoder.encode(str);\n    const ptr = this.exports.alloc(bytes.length + 1);\n    new Uint8Array(this.memory.buffer, ptr).set(bytes);\n    return [ptr, bytes.length];\n  }\n\n  addEdge(from: string, to: string): void {\n    const [fromPtr, fromLen] = this.encodeString(from);\n    const [toPtr, toLen] = this.encodeString(to);\n    this.exports.addEdge(fromPtr, fromLen, toPtr, toLen);\n  }\n}\n```\n\n**Use with Cytoscape.js for graph visualization.**", "source_file": "other-books/book-wasm-target/04_string_support.md", "prerequisites": ["wasm-target-001"]}
