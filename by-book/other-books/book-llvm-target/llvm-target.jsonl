{"cluster_id": "llvm-target-001", "question": "How do I compile Prolog predicates to LLVM IR?", "answer": "Use the LLVM target module:\n\n```prolog\n?- use_module('src/unifyweaver/targets/llvm_target').\n?- init_llvm_target.\n\n% Tail recursion (O(1) stack with musttail)\n?- compile_tail_recursion_llvm(sum/2, [], Code).\n\n% Linear recursion (static memoization)\n?- compile_linear_recursion_llvm(fib/2, [], Code).\n\n% Mutual recursion (cross musttail)\n?- compile_mutual_recursion_llvm([is_even/1, is_odd/1], [], Code).\n\n% Transitive closure (BFS worklist)\n?- compile_transitive_closure_llvm(reachable/2, [], Code).\n```\n\n**Compile and run:**\n```bash\nsed -i 's/%%/%/g' sum.ll  # Fix Prolog escaping\nllc -filetype=obj sum.ll -o sum.o\nclang sum.o -o sum\n./sum\n```", "source_file": "other-books/book-llvm-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "llvm-target-001", "question": "What does LLVM IR look like for tail recursion?", "answer": "LLVM IR uses `musttail` for guaranteed O(1) stack:\n\n```llvm\n; Header\nsource_filename = \"sum.ll\"\ntarget triple = \"x86_64-pc-linux-gnu\"\n\n; Function with musttail optimization\ndefine i64 @sum(i64 %n, i64 %acc) {\nentry:\n  %cmp = icmp sle i64 %n, 0\n  br i1 %cmp, label %base, label %recurse\n\nbase:\n  ret i64 %acc\n\nrecurse:\n  %n1 = sub i64 %n, 1\n  %acc1 = add i64 %acc, %n\n  %result = musttail call i64 @sum(i64 %n1, i64 %acc1)\n  ret i64 %result\n}\n```\n\n**Key LLVM IR concepts:**\n| Concept | Example |\n|---------|--------|\n| Type | `i64` (64-bit int), `i1` (bool) |\n| Comparison | `icmp sle i64 %n, 0` (signed less-equal) |\n| Branch | `br i1 %cmp, label %a, label %b` |\n| Tail call | `musttail call i64 @fn(...)` |", "source_file": "other-books/book-llvm-target/01_introduction.md", "prerequisites": ["llvm-target-001"]}
{"cluster_id": "llvm-target-001", "question": "How do I integrate LLVM-compiled predicates with C, Go, or Rust?", "answer": "Generate with export flag for C ABI wrapper:\n\n```prolog\ncompile_tail_recursion_llvm(sum/2, [export(true)], Code).\n```\n\n**C Integration:**\n```c\n// prolog_math.h\n#pragma once\n#include <stdint.h>\nint64_t sum_ext(int64_t n);\n\n// main.c\n#include <stdio.h>\n#include \"prolog_math.h\"\nint main() {\n    printf(\"sum(10) = %ld\\n\", sum_ext(10));\n    return 0;\n}\n```\n\n**Go (cgo):**\n```go\npackage main\n// #cgo LDFLAGS: -L. -lmath\n// #include \"prolog_math.h\"\nimport \"C\"\nimport \"fmt\"\nfunc main() {\n    result := C.sum_ext(10)\n    fmt.Println(\"sum(10) =\", result)\n}\n```\n\n**Rust (FFI):**\n```rust\nextern \"C\" { fn sum_ext(n: i64) -> i64; }\nfn main() {\n    let result = unsafe { sum_ext(10) };\n    println!(\"sum(10) = {}\", result);\n}\n```\n\n**Build:**\n```bash\nllc -filetype=obj factorial.ll -o factorial.o\nclang -shared factorial.o -o libmath.so\ngcc -L. -lmath main.c -o main\n```", "source_file": "other-books/book-llvm-target/02_integration.md", "prerequisites": ["llvm-target-001"]}
