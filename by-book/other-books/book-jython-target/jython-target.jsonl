{"cluster_id": "jython-target-001", "question": "How do I compile Prolog predicates to Jython?", "answer": "Use the Jython target module:\n\n```prolog\n?- use_module('src/unifyweaver/targets/jython_target').\n\n% Pipeline mode\n?- compile_predicate_to_jython(filter/2, [pipeline_input(true)], Code).\n\n% Generator mode\n?- compile_predicate_to_jython(expand/2, [generator_mode(true)], Code).\n\n% Recursive query (transitive closure)\n?- compile_recursive(ancestor/2, [target(jython)], Code).\n\n% Export facts\n?- compile_facts_to_jython(parent, 2, Code).\n```\n\n**Jython advantages:**\n- Python 2.7 syntax (familiar to many)\n- JVM integration (access Java libraries)\n- Python generators with `yield`\n- 66 bindings (Python + Java I/O, Collections)", "source_file": "other-books/book-jython-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "jython-target-001", "question": "How does Jython pipeline mode work?", "answer": "Pipeline mode uses Python-style loops with optional Java I/O:\n\n```python\n#!/usr/bin/env jython\nfrom __future__ import print_function\nimport sys\nimport json\nfrom java.io import BufferedReader, InputStreamReader\nfrom java.lang import System as JavaSystem\n\ndef process(record):\n    # Generated from: filter(Input, Output) :- get_field(Input, \"value\", Value), Value > 50, ...\n    value = record.get('value')\n    if value is not None and value > 50:\n        return record\n    return None\n\ndef run_pipeline():\n    reader = BufferedReader(InputStreamReader(JavaSystem.in))\n    line = reader.readLine()\n    while line is not None:\n        if line.strip():\n            record = json.loads(line)\n            result = process(record)\n            if result is not None:\n                print(json.dumps(result))\n        line = reader.readLine()\n\nif __name__ == '__main__':\n    run_pipeline()\n```\n\n**Run:** `echo '{\"value\": 75}' | jython filter_pipeline.py`", "source_file": "other-books/book-jython-target/02_pipeline_mode.md", "prerequisites": ["jython-target-001"]}
{"cluster_id": "jython-target-001", "question": "How does Jython generator mode work?", "answer": "Generator mode uses Python's native `yield` keyword:\n\n```python\n#!/usr/bin/env jython\nfrom __future__ import print_function\nimport json\n\ndef process(record):\n    # Generated from: expand(Input, Output) :- member(Item, Items), ...\n    items = record.get('items', [])\n    for item in items:\n        result = dict(record)\n        result['item'] = item\n        del result['items']\n        yield result\n\ndef process_all(records):\n    for record in records:\n        for result in process(record):\n            yield result\n```\n\n**Example output:**\n```bash\necho '{\"id\": 1, \"items\": [\"a\", \"b\", \"c\"]}' | jython expand_generator.py\n# {\"id\": 1, \"item\": \"a\"}\n# {\"id\": 1, \"item\": \"b\"}\n# {\"id\": 1, \"item\": \"c\"}\n```\n\n**Prolog to Jython mapping:**\n| Prolog | Jython |\n|--------|--------|\n| `member(X, List)` | `for x in list: yield ...` |\n| Multiple clauses | Generator composition |\n| Backtracking | Nested generators |", "source_file": "other-books/book-jython-target/03_generator_mode.md", "prerequisites": ["jython-target-001"]}
{"cluster_id": "jython-target-001", "question": "How are recursive queries compiled to Jython?", "answer": "Recursive predicates compile to BFS with `collections.deque`:\n\n```python\nfrom collections import deque\n\nclass ancestorQuery:\n    def __init__(self):\n        self.base_relation = {}\n\n    def add_fact(self, from_node, to_node):\n        if from_node not in self.base_relation:\n            self.base_relation[from_node] = set()\n        self.base_relation[from_node].add(to_node)\n\n    def find_all(self, start):\n        visited = set([start])\n        queue = deque([start])\n        results = []\n\n        while queue:\n            current = queue.popleft()\n            for next_node in self.base_relation.get(current, set()):\n                if next_node not in visited:\n                    visited.add(next_node)\n                    queue.append(next_node)\n                    results.append(next_node)\n        return results\n\n    def check(self, start, target):\n        if start == target:\n            return False\n        return target in self.find_all(start)\n```\n\n**Jython-specific features:**\n- `collections.deque` for O(1) queue operations\n- Python dict with set values\n- Same API as CPython (Python 3 compatible with minor changes)", "source_file": "other-books/book-jython-target/04_recursive_queries.md", "prerequisites": ["jython-target-001"]}
