{"pair_id": "prolog-dialect-001_p0", "cluster_id": "prolog-dialect-001", "question": "What are the differences between SWI-Prolog and GNU Prolog dialects?", "question_type": "medium", "answer": "The primary differences between the SWI-Prolog and GNU Prolog dialects center on their execution models, startup performance, and library ecosystems. SWI-Prolog is optimized for development flexibility and complex applications, while GNU Prolog prioritizes execution speed and lightweight deployment.\n\n| Feature | SWI-Prolog | GNU Prolog |\n|:---|:---|:---|\n| **Execution** | Interpreted | Native Compilation |\n| **Startup Time** | ~150ms | ~2ms |\n| **Module System** | Full (`use_module`) | Basic (`include`) |\n| **Library Support** | Extensive (HTTP, DB, etc.) | Minimal core |\n| **Debugging** | Rich graphical tools | Basic console tools |\n| **Deployment** | Requires runtime | Standalone executable |\n\n**SWI-Prolog** is the preferred choice for web applications, complex modular systems, and projects requiring extensive third-party libraries. **GNU Prolog** is ideal for high-performance CLI utilities and environments where fast startup and minimal dependencies are critical.\n\nYou can inspect these differences programmatically:\n\n```prolog\n?- dialect_capabilities(swi, Caps).\n% Caps = [name('SWI-Prolog'), compilation(interpreted), constraint_solver(clpfd), module_system(full)]\n\n?- dialect_capabilities(gnu, Caps).\n% Caps = [name('GNU Prolog'), compilation(compiled), constraint_solver(fd), module_system(basic)]\n```\n\nFor more details on dialect-specific features and compatibility, see `education/book-11-prolog-target/03_dialects.md`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/03_dialects.md", "topics": [], "original_answer": "| Feature | SWI-Prolog | GNU Prolog |\n|---------|------------|------------|\n| Execution | Interpreted | Compiled native |\n| Startup | ~150ms | ~2ms |\n| Module System | Full (use_module) | Basic (include) |\n| Libraries | HTTP, DB, extensive | Minimal |\n| Debugging | Rich graphical | Basic |\n| Deployment | Requires runtime | Single executable |\n\n**SWI-Prolog strengths**: Development, web apps, complex modules\n**GNU Prolog strengths**: Standalone binaries, fast startup, minimal deps\n\n```prolog\n?- dialect_capabilities(swi, Caps).\n% Caps = [name('SWI-Prolog'), compilation(interpreted), constraint_solver(clpfd), module_system(full)]\n\n?- dialect_capabilities(gnu, Caps).\n% Caps = [name('GNU Prolog'), compilation(compiled), constraint_solver(fd), module_system(basic)]\n```", "answer_tailored": true}
{"pair_id": "prolog-dialect-001_p0", "cluster_id": "prolog-dialect-001", "question": "How do initialization directives differ between Prolog dialects?", "question_type": "medium", "answer": "Initialization directives differ across Prolog dialects primarily based on whether the code is being compiled into a binary or run in an interpreter. These variations are critical for defining the entry point of an application.\n\n*   **SWI-Prolog:** Generally uses the 2-argument form: `:- initialization(main, main).`\n*   **GNU Prolog (Compiled):** Requires the 1-argument form for `gplc`: `:- initialization(main).`\n*   **GNU Prolog (Interpreted):** Often relies on direct goal execution: `:- main.`\n\nUnifyWeaver simplifies this cross-dialect compatibility using the `dialect_initialization/4` predicate, which dynamically generates the correct string based on the dialect and compilation flags:\n\n```prolog\n% Example: Generating for GNU Prolog in compiled mode\n?- dialect_initialization(gnu, test, [compile(true)], Init).\n% Init = ':- initialization(test).'\n\n% Example: Generating for GNU Prolog in interpreted mode\n?- dialect_initialization(gnu, test, [compile(false)], Init).\n% Init = ':- test.'\n```\n\nFailing to use the correct dialect-specific form typically results in \"no initial goal\" errors during binary execution. Detailed implementation strategies for dialect abstraction can be found in `education/book-11-prolog-target/`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/03_dialects.md", "topics": [], "original_answer": "Critical difference - initialization is dialect and mode specific:\n\n**SWI-Prolog:**\n```prolog\n:- initialization(main, main).  % 2-arg form\n```\n\n**GNU Prolog (Compiled binary):**\n```prolog\n:- initialization(main).  % 1-arg form for gplc\n```\n\n**GNU Prolog (Interpreted):**\n```prolog\n:- main.  % Direct goal execution\n```\n\nUnifyWeaver's `dialect_initialization/4` handles this:\n```prolog\n?- dialect_initialization(gnu, test, [compile(true)], Init).\n% Init = ':- initialization(test).'\n\n?- dialect_initialization(gnu, test, [compile(false)], Init).\n% Init = ':- test.'\n```\n\nUsing wrong form causes \"no initial goal\" errors in compiled binaries.", "answer_tailored": true}
{"pair_id": "prolog-dialect-002_p0", "cluster_id": "prolog-dialect-002", "question": "When should I use SWI-Prolog vs GNU Prolog?", "question_type": "medium", "answer": "Choosing between SWI-Prolog and GNU Prolog depends on whether you are prioritizing development flexibility or deployment efficiency.\n\n**Use SWI-Prolog** during the development and prototyping phases. It is the better choice when you need a rich interactive REPL, advanced debugging tools, or integration with external systems like HTTP servers and databases. Its support for complex module hierarchies makes it ideal for building large-scale applications.\n\n**Use GNU Prolog** when you are ready to deploy to end users or are working in resource-constrained environments. It excels at producing small, standalone native executables with fast startup times and minimal dependencies.\n\nA frequent pattern in UnifyWeaver is to perform primary development in SWI-Prolog and then compile the final product for GNU Prolog to leverage its binary generation capabilities:\n\n```prolog\n% Development workflow in SWI\nswipl my_app.pl\n\n% Deployment workflow: compile to a standalone binary\n?- generate_prolog_script([my_app/0],\n                         [dialect(gnu), compile(true)],\n                         Code),\n   write_prolog_script(Code, 'my_app_gnu.pl',\n                      [dialect(gnu), compile(true)]).\n```\n\nFor further details on managing Prolog dialects, refer to `education/book-11-prolog-target/03_dialects.md`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/03_dialects.md", "topics": [], "original_answer": "**Use SWI-Prolog when:**\n- Development and prototyping\n- Need HTTP server, database integration\n- Complex module hierarchies\n- Rich debugging tools\n- Interactive REPL work\n\n**Use GNU Prolog when:**\n- Standalone executables required\n- Fast startup time critical\n- Minimal dependencies needed\n- Deploying to end users\n- Resource-constrained systems\n\n**Common pattern: Develop with SWI, deploy with GNU**\n```prolog\n% Development\nswipl my_app.pl\n\n% Deploy as standalone binary\n?- generate_prolog_script([my_app/0],\n                         [dialect(gnu), compile(true)],\n                         Code),\n   write_prolog_script(Code, 'my_app_gnu.pl',\n                      [dialect(gnu), compile(true)]).\n\n% Result: my_app_gnu (native binary)\n```", "answer_tailored": true}
