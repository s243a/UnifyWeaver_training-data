{"pair_id": "prolog-firewall-001_p0", "cluster_id": "prolog-firewall-001", "question": "How does the firewall integrate with the Prolog target?", "question_type": "medium", "answer": "The firewall integrates with the Prolog target by regulating code generation and execution through policy-driven directives. It acts as a gatekeeper for several critical integration points:\n\n1. **Target Dialect Selection:** Policies can explicitly permit or restrict specific Prolog environments, such as allowing `prolog_target(swi)` while forbidding `prolog_target(gnu)`.\n2. **Compilation Strategy:** It controls build-time options, such as using `:- disallow(compile(native))` to prevent the creation of native binaries.\n3. **Module Sandboxing:** The firewall manages library imports by allowing safe modules (like `library(lists)`) and blocking potentially dangerous ones (like `library(http/_)`).\n\nIntegration is managed via three operational modes: **guidance** (logging warnings), **enforce** (blocking non-compliant code), and **audit** (comprehensive logging). These settings are consolidated in a `.firewall` configuration file where developers define the enforcement level and specific resource requirements, such as `disallow(network_access)`.\n\nDetailed documentation on these integration mechanisms can be found in `education/book-11-prolog-target/07_firewall_integration.md`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/07_firewall_integration.md", "topics": [], "original_answer": "The firewall controls code generation at multiple points:\n\n**1. Dialect Selection:**\n```prolog\n:- allow(prolog_target(swi)).\n:- disallow(prolog_target(gnu)).\n```\n\n**2. Compilation Control:**\n```prolog\n:- disallow(compile(native)).\n```\n\n**3. Module Imports:**\n```prolog\n:- allow(import_module(library(lists))).\n:- disallow(import_module(library(http/_))).\n```\n\n**Firewall modes:**\n- `guidance` - Warn but allow\n- `enforce` - Block violations\n- `audit` - Log everything\n\n**Policy file example (.firewall):**\n```prolog\n:- firewall_mode(enforce).\n:- allow(prolog_target(swi)).\n:- disallow(network_access).\n:- require(validation(strict)).\n```", "answer_tailored": true}
{"pair_id": "prolog-fallback-001_p0", "cluster_id": "prolog-fallback-001", "question": "How does the Prolog target handle compilation failures?", "question_type": "medium", "answer": "The Prolog target manages compilation failures primarily through the `compile_script_safe/3` predicate, which ensures that execution can continue even if the compilation step fails. By default, the system employs a \"silent fallback\" strategy where it logs a warning and proceeds by executing the script in interpreted mode.\n\nTechnical implementation of this fallback logic:\n\n```prolog\ncompile_script_safe(Dialect, ScriptPath, Options) :-\n    catch(\n        compile_script(Dialect, ScriptPath),\n        error(compilation_failed(FailedDialect, ExitCode), _),\n        (   option(fail_on_compile_error(true), Options)\n        ->  throw(...)  % Strict mode: re-throw\n        ;   % Default: continue with interpreted\n            format('[PrologTarget] WARNING: ~w compilation failed~n', [FailedDialect]),\n            format('[PrologTarget] Continuing with interpreted script~n')\n        )\n    ).\n```\n\nThe system supports several fallback strategies:\n- **Silent Fallback (Default)**: Logs a warning and continues with the interpreted version of the script.\n- **Strict Mode**: If the `fail_on_compile_error(true)` option is provided, the system re-throws the compilation error to halt execution.\n- **Multi-dialect Support**: In version 0.2+, the target can attempt alternative dialects based on a defined preference order if the initial compilation fails.\n\nThis architecture ensures that the script remains usable via interpretation even when specialized compilation is not possible. For further details on these mechanisms, see `education/book-11-prolog-target/`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/08_fallback_mechanisms.md", "topics": [], "original_answer": "The `compile_script_safe/3` predicate provides graceful fallback:\n\n```prolog\ncompile_script_safe(Dialect, ScriptPath, Options) :-\n    catch(\n        compile_script(Dialect, ScriptPath),\n        error(compilation_failed(FailedDialect, ExitCode), _),\n        (   option(fail_on_compile_error(true), Options)\n        ->  throw(...)  % Strict mode: re-throw\n        ;   % Default: continue with interpreted\n            format('[PrologTarget] WARNING: ~w compilation failed~n', [FailedDialect]),\n            format('[PrologTarget] Continuing with interpreted script~n')\n        )\n    ).\n```\n\n**Fallback strategies:**\n1. **Silent fallback** (default): Log warning, use interpreted script\n2. **Strict mode**: `fail_on_compile_error(true)` - throw on failure\n3. **Multi-dialect** (v0.2): Try alternatives in preference order\n\nThe script remains usable interpreted even if compilation fails.", "answer_tailored": true}
{"pair_id": "prolog-fallback-001_p0", "cluster_id": "prolog-fallback-001", "question": "What fallback strategies does the Prolog target support?", "question_type": "medium", "answer": "The Prolog target supports several fallback strategies designed to ensure execution resilience, ranging from compilation recovery to security-driven redirection. These are categorized into current stable features and planned v0.2 enhancements:\n\n### Current Fallback Support (v0.1)\n*   **Compilation-to-Interpreted Fallback**: If a binary build using `gplc` fails, the system automatically transitions to executing the code as an interpreted script.\n*   **Firewall Redirection**: If the security firewall blocks a specific dialect, the system attempts to resolve the query using authorized alternatives.\n\n### Planned Enhancements (v0.2)\n*   **Multi-Dialect Chains**: This allows defining an ordered preference (e.g., `dialects([gnu, swi])`). The system will attempt to execute via GNU compiled, then GNU interpreted, and finally SWI interpreted until it succeeds.\n*   **Capability-Based Switching**: Using `validate_for_dialect/3`, the system can detect compatibility issues with specific predicates and automatically switch to a dialect that supports them.\n*   **Graceful Feature Degradation**: With `fallback(degrade)`, the system can strip unsupported features and continue execution with the remaining compatible logic.\n*   **Heuristic Dialect Selection**: By setting `dialect(auto)`, the compiler analyzes the source code to determine and select the most appropriate Prolog engine automatically.\n\nFor detailed implementation examples, refer to `education/book-11-prolog-target/08_fallback_mechanisms.md`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/08_fallback_mechanisms.md", "topics": [], "original_answer": "**Current (v0.1):**\n\n1. **Compilation Fallback**: If `gplc` fails, continue with interpreted script\n2. **Firewall Fallback**: If dialect blocked, try allowed alternatives\n\n**Planned (v0.2):**\n\n1. **Multi-Dialect Chains:**\n```prolog\n[dialects([gnu, swi]), compile(true), fallback(auto)]\n% Try: GNU compiled \u2192 GNU interpreted \u2192 SWI interpreted\n```\n\n2. **Capability-Based Fallback:**\n```prolog\n?- validate_for_dialect(gnu, [my_pred/2], Issues).\n% If Issues, automatically switch to compatible dialect\n```\n\n3. **Feature Degradation:**\n```prolog\n[fallback(degrade)]  % Remove unsupported features, continue\n```\n\n4. **Automatic Dialect Selection:**\n```prolog\n[dialect(auto)]  % Analyze code, pick best dialect\n```", "answer_tailored": true}
