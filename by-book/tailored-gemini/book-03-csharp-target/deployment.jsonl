{"pair_id": "runtime-architecture_p0", "cluster_id": "runtime-architecture", "question": "What is the C# runtime architecture?", "question_type": "medium", "answer": "The C# runtime architecture for UnifyWeaver follows a layered execution model where high-level Prolog logic is compiled into a QueryPlan (Intermediate Representation) and executed via a shared runtime library.\n\n### Structural Overview\nThe system is organized into three distinct tiers:\n*   **Host Application**: The user-defined program.\n*   **UnifyWeaver.Runtime.dll**: The core engine that interprets the IR and manages execution.\n*   **Data Tier**: Manages the underlying facts and computed relational results.\n\n### Primary Runtime Components\n- **`QueryEngine.cs`**: The central engine driving fixpoint iterations.\n- **`IR.cs`**: Defines the data structures for the Intermediate Representation (e.g., RelationRef, Join).\n- **`SemiNaiveEvaluator.cs`**: Contains logic for optimized relational evaluation.\n- **`TupleStore.cs`**: Provides the in-memory storage backend for tuples.\n\n### Compilation & SCC Management\nThe runtime processes generated artifacts including query plans, base facts, and entry points. To handle mutual recursion (Strongly Connected Components), the architecture utilizes:\n- **`MutualFixpointNode` & `MutualMember`**: Coordinators for complex recursive loops.\n- **`CrossRefNode`**: References across peer predicates.\n- **`EvaluationContext`**: Tracks totals and deltas during fixpoint evaluation.\n- **`HashSet<object[]>`**: Implements Bash-parity deduplication for tuple sets.\n\nDetailed implementation specifications for these libraries are located in `education/book-03-csharp-target/04_runtime_libraries_deployment.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["runtime", "architecture", "deployment"], "original_answer": "## Runtime Architecture\n\n```\nYour Application\n    \u2193 uses\nUnifyWeaver.Runtime.dll  \u2190 Shared query engine\n    \u2193 executes\nQueryPlan (IR)  \u2190 Generated from Prolog\n    \u2193 operates on\nData (facts, computed results)\n```\n\n### Core Runtime Library\n\n- **`QueryEngine.cs`**: Fixpoint iteration engine\n- **`IR.cs`**: IR data structures (RelationRef, Join, etc.)\n- **`SemiNaiveEvaluator.cs`**: Optimization logic\n- **`TupleStore.cs`**: In-memory tuple storage\n\n### Generated Code\n\n- Query plans (IR instances)\n- Base fact data\n- Entry points (Main methods)\n\n### Mutual Fixpoint Artifacts (v0.1)\n\n- `MutualFixpointNode` - Coordinator for SCCs\n- `MutualMember` - Pairs predicate with plans\n- `CrossRefNode` - Reference to peer predicate\n- `EvaluationContext` - Tracks totals/deltas\n- `HashSet<object[]>` - Bash-parity deduplication", "answer_tailored": true}
{"pair_id": "runtime-architecture_p1", "cluster_id": "runtime-architecture", "question": "What components make up the Query Runtime?", "question_type": "medium", "answer": "The UnifyWeaver Query Runtime for the C# target is composed of a shared engine library, generated artifacts, and specialized structures for recursive evaluation.\n\n### Architectural Framework\nYour application interacts with **UnifyWeaver.Runtime.dll**, which serves as the shared query engine. This engine executes **QueryPlan (IR)** instances\u2014compiled directly from Prolog\u2014to process facts and computed results.\n\n### Core Library Components\n- **`QueryEngine.cs`**: The central engine governing fixpoint iteration.\n- **`IR.cs`**: Contains data structures for the Intermediate Representation (e.g., RelationRef, Join).\n- **`SemiNaiveEvaluator.cs`**: Orchestrates optimization logic for efficient evaluation.\n- **`TupleStore.cs`**: Manages the storage of tuples in memory.\n\n### Recursive (Mutual Fixpoint) Artifacts\nTo support complex recursion and Strongly Connected Components (SCCs), the runtime utilizes:\n- **`MutualFixpointNode` & `MutualMember`**: Coordinate and pair predicates within SCCs.\n- **`CrossRefNode`**: Handles references between peer predicates.\n- **`EvaluationContext`**: Monitors totals and deltas across iterations.\n- **`HashSet<object[]>`**: Ensures deduplication consistent with Bash-target behavior.\n\n### Generated Execution Elements\nThe runtime also relies on generated C# code including the specific query plans, base fact data, and application entry points (Main methods).\n\nFor a comprehensive look at deployment and the C# runtime, refer to `education/book-03-csharp-target/04_runtime_libraries_deployment.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["runtime", "architecture", "deployment"], "original_answer": "## Runtime Architecture\n\n```\nYour Application\n    \u2193 uses\nUnifyWeaver.Runtime.dll  \u2190 Shared query engine\n    \u2193 executes\nQueryPlan (IR)  \u2190 Generated from Prolog\n    \u2193 operates on\nData (facts, computed results)\n```\n\n### Core Runtime Library\n\n- **`QueryEngine.cs`**: Fixpoint iteration engine\n- **`IR.cs`**: IR data structures (RelationRef, Join, etc.)\n- **`SemiNaiveEvaluator.cs`**: Optimization logic\n- **`TupleStore.cs`**: In-memory tuple storage\n\n### Generated Code\n\n- Query plans (IR instances)\n- Base fact data\n- Entry points (Main methods)\n\n### Mutual Fixpoint Artifacts (v0.1)\n\n- `MutualFixpointNode` - Coordinator for SCCs\n- `MutualMember` - Pairs predicate with plans\n- `CrossRefNode` - Reference to peer predicate\n- `EvaluationContext` - Tracks totals/deltas\n- `HashSet<object[]>` - Bash-parity deduplication", "answer_tailored": true}
{"pair_id": "runtime-architecture_p2", "cluster_id": "runtime-architecture", "question": "How are generated code and runtime related?", "question_type": "medium", "answer": "Generated code and the runtime library (`UnifyWeaver.Runtime.dll`) operate in a consumer-provider relationship where generated artifacts utilize shared engine components to execute Prolog-derived logic.\n\nThe generated code\u2014comprising IR-based Query plans, base facts, and Main entry points\u2014relies on the runtime for the following core services:\n- **Execution**: The `QueryEngine.cs` provides the fixpoint iteration engine that processes the generated QueryPlan.\n- **Data Structures**: `IR.cs` provides definitions for RelationRef and Join, while `TupleStore.cs` handles in-memory storage.\n- **Optimizations**: `SemiNaiveEvaluator.cs` implements the logic for efficient query evaluation.\n\nIn scenarios involving recursion (v0.1), the runtime provides specialized coordination artifacts like `MutualFixpointNode` and `MutualMember` to manage Strong Connected Components (SCCs), along with an `EvaluationContext` to track totals and deltas across the computation.\n\nFor further details on deployment and runtime structure, see `education/book-03-csharp-target/04_runtime_libraries_deployment.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["runtime", "architecture", "deployment"], "original_answer": "## Runtime Architecture\n\n```\nYour Application\n    \u2193 uses\nUnifyWeaver.Runtime.dll  \u2190 Shared query engine\n    \u2193 executes\nQueryPlan (IR)  \u2190 Generated from Prolog\n    \u2193 operates on\nData (facts, computed results)\n```\n\n### Core Runtime Library\n\n- **`QueryEngine.cs`**: Fixpoint iteration engine\n- **`IR.cs`**: IR data structures (RelationRef, Join, etc.)\n- **`SemiNaiveEvaluator.cs`**: Optimization logic\n- **`TupleStore.cs`**: In-memory tuple storage\n\n### Generated Code\n\n- Query plans (IR instances)\n- Base fact data\n- Entry points (Main methods)\n\n### Mutual Fixpoint Artifacts (v0.1)\n\n- `MutualFixpointNode` - Coordinator for SCCs\n- `MutualMember` - Pairs predicate with plans\n- `CrossRefNode` - Reference to peer predicate\n- `EvaluationContext` - Tracks totals/deltas\n- `HashSet<object[]>` - Bash-parity deduplication", "answer_tailored": true}
{"pair_id": "runtime-architecture_p3", "cluster_id": "runtime-architecture", "question": "What is the QueryEngine?", "question_type": "medium", "answer": "The QueryEngine is the central fixpoint iteration component of the UnifyWeaver C# runtime, responsible for interpreting and executing QueryPlans (IR) generated from Prolog. Located in `QueryEngine.cs` within `UnifyWeaver.Runtime.dll`, it orchestrates the evaluation of data facts and computed results.\n\nThe engine relies on several core modules to manage query execution:\n- **`SemiNaiveEvaluator.cs`**: Implements optimization logic for efficient, incremental fixpoint evaluation.\n- **`IR.cs`**: Defines the intermediate representation data structures, such as Joins and RelationRefs.\n- **`TupleStore.cs`**: Manages in-memory storage and deduplication of tuples using `HashSet<object[]>` for parity with the Bash target.\n\nFor recursive logic, the QueryEngine utilizes mutual fixpoint artifacts\u2014including the `MutualFixpointNode` and `EvaluationContext`\u2014to coordinate the evaluation of Strongly Connected Components (SCCs) and track delta changes across iterations.\n\nFor more details on runtime architecture and deployment, see `education/book-03-csharp-target/04_runtime_libraries_deployment.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["runtime", "architecture", "deployment"], "original_answer": "## Runtime Architecture\n\n```\nYour Application\n    \u2193 uses\nUnifyWeaver.Runtime.dll  \u2190 Shared query engine\n    \u2193 executes\nQueryPlan (IR)  \u2190 Generated from Prolog\n    \u2193 operates on\nData (facts, computed results)\n```\n\n### Core Runtime Library\n\n- **`QueryEngine.cs`**: Fixpoint iteration engine\n- **`IR.cs`**: IR data structures (RelationRef, Join, etc.)\n- **`SemiNaiveEvaluator.cs`**: Optimization logic\n- **`TupleStore.cs`**: In-memory tuple storage\n\n### Generated Code\n\n- Query plans (IR instances)\n- Base fact data\n- Entry points (Main methods)\n\n### Mutual Fixpoint Artifacts (v0.1)\n\n- `MutualFixpointNode` - Coordinator for SCCs\n- `MutualMember` - Pairs predicate with plans\n- `CrossRefNode` - Reference to peer predicate\n- `EvaluationContext` - Tracks totals/deltas\n- `HashSet<object[]>` - Bash-parity deduplication", "answer_tailored": true}
{"pair_id": "dotnet-deployment_p0", "cluster_id": "dotnet-deployment", "question": "How do I deploy C# generated code?", "question_type": "medium", "answer": "Deploying C# code generated by UnifyWeaver is primarily handled through the `dotnet publish` command, offering several options based on your distribution requirements.\n\n### Primary Deployment Options\n\n**Self-Contained (No Dependencies):**\nThis approach bundles the .NET runtime with your application, ensuring it runs on systems without pre-existing software dependencies. It results in a larger package (~60MB) but guarantees portability.\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n```\nTo simplify distribution even further, you can package the entire application into a single executable:\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained -p:PublishSingleFile=true\n```\n\n**Framework-Dependent (Lightweight):**\nIf the target machine already has the .NET runtime installed, you can produce a much smaller package (around 200KB).\n```bash\ndotnet publish -c Release\n```\n\n### Cross-Platform Targets\nUse the Runtime Identifier (RID) flag to target specific operating systems:\n*   **Linux:** `-r linux-x64`\n*   **Windows:** `-r win-x64`\n*   **macOS:** `-r osx-x64`\n\n### Library Distribution\nIf you are deploying the generated code as a shared library or runtime component, you can package it as a NuGet file:\n```bash\ndotnet pack -c Release\n# Generates a .nupkg file in the bin/Release/ directory\n```\n\nFor more detailed information on managing runtime libraries and deployment configurations for C#, see the documentation in `education/book-03-csharp-target/`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["deployment", "publish", "cross-platform", "nuget"], "original_answer": "## Deployment Scenarios\n\n### Console Application\n\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# Output: bin/Release/net6.0/linux-x64/publish/\n```\n\n### Cross-Platform Publishing\n\n**Windows:**\n```bash\ndotnet publish -r win-x64 --self-contained\n```\n\n**Linux:**\n```bash\ndotnet publish -r linux-x64 --self-contained\n```\n\n**macOS:**\n```bash\ndotnet publish -r osx-x64 --self-contained\n```\n\n### Deployment Types\n\n**Framework-Dependent (smaller):**\n```bash\ndotnet publish -c Release\n# ~200KB, requires .NET runtime on target\n```\n\n**Self-Contained (no dependencies):**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# ~60MB, includes .NET runtime\n```\n\n**Single-File:**\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\n### NuGet Package\n\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Generates: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```", "answer_tailored": true}
{"pair_id": "dotnet-deployment_p1", "cluster_id": "dotnet-deployment", "question": "How do I create a NuGet package?", "question_type": "medium", "answer": "To create a NuGet package for the UnifyWeaver C# runtime or compiled outputs, you utilize the `dotnet pack` command. This process typically involves initializing a class library and then packaging it for distribution:\n\n```bash\n# Initialize a new class library project\ndotnet new classlib -n UnifyWeaver.Runtime\n\n# Generate the NuGet package\ndotnet pack -c Release\n```\n\nThe command produces a `.nupkg` file (e.g., `bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg`) which can be uploaded to a repository or used locally. For more advanced deployment scenarios and runtime library details, consult `education/book-03-csharp-target/04_runtime_libraries_deployment.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["deployment", "publish", "cross-platform", "nuget"], "original_answer": "## Deployment Scenarios\n\n### Console Application\n\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# Output: bin/Release/net6.0/linux-x64/publish/\n```\n\n### Cross-Platform Publishing\n\n**Windows:**\n```bash\ndotnet publish -r win-x64 --self-contained\n```\n\n**Linux:**\n```bash\ndotnet publish -r linux-x64 --self-contained\n```\n\n**macOS:**\n```bash\ndotnet publish -r osx-x64 --self-contained\n```\n\n### Deployment Types\n\n**Framework-Dependent (smaller):**\n```bash\ndotnet publish -c Release\n# ~200KB, requires .NET runtime on target\n```\n\n**Self-Contained (no dependencies):**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# ~60MB, includes .NET runtime\n```\n\n**Single-File:**\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\n### NuGet Package\n\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Generates: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```", "answer_tailored": true}
{"pair_id": "dotnet-deployment_p2", "cluster_id": "dotnet-deployment", "question": "What are the deployment options?", "question_type": "medium", "answer": "UnifyWeaver provides several deployment options for C# targets, allowing you to choose between lightweight distributions or fully independent binaries.\n\n### Deployment Types\n- **Framework-Dependent:** Produces a small package (~200KB) that relies on the .NET runtime being present on the host machine.\n  ```bash\n  dotnet publish -c Release\n  ```\n- **Self-Contained:** Includes the .NET runtime within the application package (~60MB), ensuring it can run on systems without pre-installed dependencies.\n  ```bash\n  dotnet publish -c Release -r linux-x64 --self-contained\n  ```\n- **Single-File:** Consolidates the entire application and its dependencies into one executable for simplified distribution.\n  ```bash\n  dotnet publish -c Release -r linux-x64 --self-contained -p:PublishSingleFile=true\n  ```\n\n### Platform-Specific Publishing\nYou can target different operating systems by specifying the Runtime Identifier (RID):\n- **Windows:** `-r win-x64`\n- **Linux:** `-r linux-x64`\n- **macOS:** `-r osx-x64`\n\n### Library Distribution\nTo distribute the runtime or generated logic as a reusable component, you can package it as a NuGet package:\n```bash\ndotnet pack -c Release\n```\n\nFor a deeper dive into runtime libraries and deployment configurations, see `education/book-03-csharp-target/04_runtime_libraries_deployment.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["deployment", "publish", "cross-platform", "nuget"], "original_answer": "## Deployment Scenarios\n\n### Console Application\n\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# Output: bin/Release/net6.0/linux-x64/publish/\n```\n\n### Cross-Platform Publishing\n\n**Windows:**\n```bash\ndotnet publish -r win-x64 --self-contained\n```\n\n**Linux:**\n```bash\ndotnet publish -r linux-x64 --self-contained\n```\n\n**macOS:**\n```bash\ndotnet publish -r osx-x64 --self-contained\n```\n\n### Deployment Types\n\n**Framework-Dependent (smaller):**\n```bash\ndotnet publish -c Release\n# ~200KB, requires .NET runtime on target\n```\n\n**Self-Contained (no dependencies):**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# ~60MB, includes .NET runtime\n```\n\n**Single-File:**\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\n### NuGet Package\n\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Generates: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```", "answer_tailored": true}
{"pair_id": "dotnet-deployment_p3", "cluster_id": "dotnet-deployment", "question": "How do I publish for different platforms?", "question_type": "medium", "answer": "To publish UnifyWeaver's C# target for specific platforms, you use the `dotnet publish` command combined with the `-r` (runtime) identifier flag.\n\n### Platform-Specific Commands\nYou can target different operating systems by specifying the appropriate Runtime Identifier:\n\n*   **Windows:** `dotnet publish -r win-x64 --self-contained`\n*   **Linux:** `dotnet publish -r linux-x64 --self-contained`\n*   **macOS:** `dotnet publish -r osx-x64 --self-contained`\n\n### Deployment Options\n*   **Self-Contained Deployment:** This bundles the .NET runtime with your application, allowing it to run on machines without .NET installed.\n    ```bash\n    dotnet publish -c Release -r linux-x64 --self-contained\n    ```\n*   **Framework-Dependent:** Produces a much smaller output (approx. 200KB) but requires the target system to have the compatible .NET runtime.\n    ```bash\n    dotnet publish -c Release\n    ```\n*   **Single-File Executable:** To combine all assets into a single binary, use the `PublishSingleFile` property:\n    ```bash\n    dotnet publish -c Release -r linux-x64 --self-contained -p:PublishSingleFile=true\n    ```\n\n### Creating NuGet Packages\nIf you are distributing the runtime as a library, use:\n```bash\ndotnet pack -c Release\n```\n\nDetailed documentation on deployment strategies and runtime library configuration can be found in `education/book-03-csharp-target/04_runtime_libraries_deployment.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["deployment", "publish", "cross-platform", "nuget"], "original_answer": "## Deployment Scenarios\n\n### Console Application\n\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# Output: bin/Release/net6.0/linux-x64/publish/\n```\n\n### Cross-Platform Publishing\n\n**Windows:**\n```bash\ndotnet publish -r win-x64 --self-contained\n```\n\n**Linux:**\n```bash\ndotnet publish -r linux-x64 --self-contained\n```\n\n**macOS:**\n```bash\ndotnet publish -r osx-x64 --self-contained\n```\n\n### Deployment Types\n\n**Framework-Dependent (smaller):**\n```bash\ndotnet publish -c Release\n# ~200KB, requires .NET runtime on target\n```\n\n**Self-Contained (no dependencies):**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# ~60MB, includes .NET runtime\n```\n\n**Single-File:**\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\n### NuGet Package\n\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Generates: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```", "answer_tailored": true}
{"pair_id": "csharp-testing_p0", "cluster_id": "csharp-testing", "question": "How do I test C# Query Runtime?", "question_type": "medium", "answer": "Testing the C# Query Runtime involves several strategies ranging from quick validation of the compiler logic to full integration within a CI/CD pipeline.\n\n### Validation via Skip Execution\nTo verify the Prolog-to-C# compilation logic (including facts, joins, and recursion) without requiring the .NET runtime to execute, use the `SKIP_CSHARP_EXECUTION` environment variable:\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\n### Manual Build-and-Run Verification\nFor end-to-end verification of the generated code:\n1. Locate the generated project in `output/csharp/<uuid>/`.\n2. Execute `dotnet build --no-restore` within that directory.\n3. Run the compiled binary and confirm the output (e.g., checking for specific values like `0, 2, 4` in an even/odd test).\n\n### xUnit Integration\nYou can wrap query execution in standard xUnit facts to programmatically assert correctness:\n```csharp\n[Fact]\npublic void Execute_ShouldReturnExpectedAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n### Automated CI with GitHub Actions\nIncorporate C# testing into your CI pipeline by setting up the .NET environment and triggering the compilation:\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v3\n  with:\n    dotnet-version: 6.0.x\n- name: Generate and Test\n  run: |\n    swipl -g \"compile_all, halt\"\n    dotnet build\n    dotnet test\n```\n\nFor more detailed information on deployment and runtime libraries, see `education/book-03-csharp-target/04_runtime_libraries_deployment.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["testing", "skip-execution", "validation", "ci-cd"], "original_answer": "## Testing the Query Runtime\n\n### Skip Execution Mode\n\nValidate without running dotnet:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nCovers: facts, joins, selections, arithmetic, linear/mutual recursion.\n\n### Build-First Workflow\n\n1. Generate project under `output/csharp/<uuid>/`\n2. Run `dotnet build --no-restore`\n3. Execute the compiled binary\n4. Verify output (e.g., `0, 2, 4` for even/odd)\n\n### Unit Tests (xUnit)\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n### GitHub Actions CI\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```", "answer_tailored": true}
{"pair_id": "csharp-testing_p1", "cluster_id": "csharp-testing", "question": "What is SKIP_CSHARP_EXECUTION?", "question_type": "medium", "answer": "`SKIP_CSHARP_EXECUTION` is an environment variable used to enable **Skip Execution Mode** during the testing of C# query targets. When set to `1`, it allows you to validate the compilation and logic\u2014including facts, joins, selections, arithmetic, and recursion\u2014without actually invoking the `dotnet` runtime.\n\nExample usage for validation:\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nThis mode is a key part of the C# testing suite, allowing for rapid verification of generated project structures before performing a full `dotnet build` and execution. For more details on the C# runtime and deployment workflows, see `education/book-03-csharp-target/`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["testing", "skip-execution", "validation", "ci-cd"], "original_answer": "## Testing the Query Runtime\n\n### Skip Execution Mode\n\nValidate without running dotnet:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nCovers: facts, joins, selections, arithmetic, linear/mutual recursion.\n\n### Build-First Workflow\n\n1. Generate project under `output/csharp/<uuid>/`\n2. Run `dotnet build --no-restore`\n3. Execute the compiled binary\n4. Verify output (e.g., `0, 2, 4` for even/odd)\n\n### Unit Tests (xUnit)\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n### GitHub Actions CI\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```", "answer_tailored": true}
{"pair_id": "csharp-testing_p2", "cluster_id": "csharp-testing", "question": "How do I validate generated code without running it?", "question_type": "medium", "answer": "To validate generated C# code without executing the final binary, you can utilize Skip Execution Mode or a build-only workflow.\n\n### Skip Execution Mode\nYou can verify the Prolog-to-C# compilation logic and generated types without invoking the .NET runtime by setting the `SKIP_CSHARP_EXECUTION` environment variable:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\nThis validates the mapping of facts, joins, selections, arithmetic, and recursive structures.\n\n### Build-First Validation\nYou can check for compilation errors using the .NET CLI without running the application logic:\n1. Locate the generated project (typically in `output/csharp/<uuid>/`).\n2. Execute `dotnet build --no-restore` to confirm the code is syntactically and structurally sound.\n\n### Unit Tests (xUnit)\nDefine formal constraints and expected outputs using xUnit to validate the generated code's behavior:\n```csharp\n[Fact]\npublic void Execute_ShouldReturnExpectedResults()\n{\n    var results = MyQuery.Execute().ToList();\n    Assert.NotNull(results);\n}\n```\n\n### GitHub Actions CI\nAutomate validation by splitting the pipeline into generation and build phases in your workflow:\n```yaml\nsteps:\n- name: Generate C#\n  run: swipl -g \"compile_all, halt\"\n- name: Compile Only\n  run: dotnet build\n```\n\nFor more comprehensive details on runtime libraries and deployment strategies, refer to `education/book-03-csharp-target/04_runtime_libraries_deployment.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["testing", "skip-execution", "validation", "ci-cd"], "original_answer": "## Testing the Query Runtime\n\n### Skip Execution Mode\n\nValidate without running dotnet:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nCovers: facts, joins, selections, arithmetic, linear/mutual recursion.\n\n### Build-First Workflow\n\n1. Generate project under `output/csharp/<uuid>/`\n2. Run `dotnet build --no-restore`\n3. Execute the compiled binary\n4. Verify output (e.g., `0, 2, 4` for even/odd)\n\n### Unit Tests (xUnit)\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n### GitHub Actions CI\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```", "answer_tailored": true}
{"pair_id": "csharp-testing_p3", "cluster_id": "csharp-testing", "question": "How do I set up CI/CD for UnifyWeaver?", "question_type": "medium", "answer": "To set up CI/CD for UnifyWeaver, you should automate the workflow of generating target code from Prolog and then building/testing that code in its native environment. For C# projects, this is most effectively handled via GitHub Actions.\n\n### GitHub Actions Workflow\nDefine a CI pipeline that handles environment setup, code generation, and verification:\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v3\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```\n\n### Verification Strategies\n*   **Automated Build Workflow**: Ensure your pipeline generates the project (typically under `output/csharp/<uuid>/`), executes `dotnet build --no-restore`, and verifies the resulting binary's output.\n*   **XUnit Integration**: Include unit tests within your C# project to validate query results, such as checking that `AncestorQuery.Execute()` returns the correct ancestor relations via `Assert.Contains`.\n*   **Rapid Validation**: For faster CI cycles, you can validate the compiler's output without running the .NET runtime by setting the `SKIP_CSHARP_EXECUTION=1` environment variable during the Prolog test phase.\n\nSee `education/book-03-csharp-target/` for more details on runtime libraries and deployment.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["testing", "skip-execution", "validation", "ci-cd"], "original_answer": "## Testing the Query Runtime\n\n### Skip Execution Mode\n\nValidate without running dotnet:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nCovers: facts, joins, selections, arithmetic, linear/mutual recursion.\n\n### Build-First Workflow\n\n1. Generate project under `output/csharp/<uuid>/`\n2. Run `dotnet build --no-restore`\n3. Execute the compiled binary\n4. Verify output (e.g., `0, 2, 4` for even/odd)\n\n### Unit Tests (xUnit)\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n### GitHub Actions CI\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```", "answer_tailored": true}
