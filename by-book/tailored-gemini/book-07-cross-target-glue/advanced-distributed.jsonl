{"pair_id": "b7-c12a-service-mesh_p0", "cluster_id": "b7-c12a-service-mesh", "question": "What is a service mesh?", "question_type": "medium", "answer": "A service mesh is a specialized infrastructure layer within UnifyWeaver designed to manage service-to-service communication, ensuring reliability and observability through declarative Prolog patterns. It abstracts away the complexity of networking via three primary mechanisms:\n\n### Load Balancing\nUnifyWeaver allows you to distribute traffic across multiple service instances using strategies such as `round_robin`, `random`, or `least_connections`.\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)\n]).\n```\n\n### Circuit Breakers\nTo prevent cascading failures, the compiler supports circuit breakers that \"open\" after a defined error threshold is reached, optionally routing traffic to a specified fallback predicate.\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % failures before open\n    timeout(30),            % seconds before half-open\n    fallback(local_cache/2) % predicate to use when open\n]).\n```\n\n### Health Checks\nThe mesh monitors service vitality through automated checks against specific endpoints at regular intervals to ensure only healthy instances receive traffic.\n```prolog\n:- health_check(service_name, [\n    endpoint('/health'),\n    interval(10),\n    timeout(5)\n]).\n```\n\nDetailed implementations and further service mesh patterns can be found in `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12a_service_mesh.md", "topics": ["service-mesh", "load-balancing", "circuit-breaker"], "original_answer": "## Service Mesh Patterns\n\n### Load Balancing Strategies\n\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)  % or: random, least_connections\n]).\n```\n\n### Circuit Breakers\n\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % failures before open\n    timeout(30),            % seconds before half-open\n    fallback(local_cache/2) % use when open\n]).\n```\n\n### Health Checks\n\n```prolog\n:- health_check(service_name, [\n    endpoint('/health'),\n    interval(10),\n    timeout(5)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c12a-service-mesh_p1", "cluster_id": "b7-c12a-service-mesh", "question": "How does load balancing work?", "question_type": "medium", "answer": "In UnifyWeaver, load balancing is handled by defining service instances and their associated distribution strategies within the service mesh layer. This is achieved using the `declare_service/2` directive, which specifies the target instances and the balancing logic to be applied.\n\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)  % Support for round_robin, random, or least_connections\n]).\n```\n\nTo maintain system stability alongside load balancing, UnifyWeaver also supports circuit breakers to handle service failures and health checks to ensure traffic is only routed to responsive nodes:\n\n```prolog\n% Circuit breaker configuration\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % Failures before opening the circuit\n    timeout(30),            % Seconds to wait before testing recovery\n    fallback(local_cache/2) % Fallback predicate\n]).\n\n% Health check configuration\n:- health_check(service_name, [\n    endpoint('/health'),\n    interval(10),\n    timeout(5)\n]).\n```\n\nDetailed information on these patterns can be found in `education/book-07-cross-target-glue/12a_service_mesh.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12a_service_mesh.md", "topics": ["service-mesh", "load-balancing", "circuit-breaker"], "original_answer": "## Service Mesh Patterns\n\n### Load Balancing Strategies\n\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)  % or: random, least_connections\n]).\n```\n\n### Circuit Breakers\n\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % failures before open\n    timeout(30),            % seconds before half-open\n    fallback(local_cache/2) % use when open\n]).\n```\n\n### Health Checks\n\n```prolog\n:- health_check(service_name, [\n    endpoint('/health'),\n    interval(10),\n    timeout(5)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c12a-service-mesh_p2", "cluster_id": "b7-c12a-service-mesh", "question": "What are circuit breakers?", "question_type": "medium", "answer": "Circuit breakers in UnifyWeaver are a service mesh pattern designed to improve system resilience by preventing cascading failures. When a remote service fails repeatedly, the circuit breaker \"opens,\" intercepting further calls and optionally redirecting them to a fallback mechanism until the service recovers.\n\nIn UnifyWeaver, you declare a circuit breaker using the `declare_circuit_breaker/2` directive:\n\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % Open circuit after 5 failures\n    timeout(30),            % Wait 30 seconds before testing recovery\n    fallback(local_cache/2) % Predicate to use while the circuit is open\n]).\n```\n\nThe configuration includes:\n- **threshold**: The number of consecutive failures allowed before the circuit transitions to an open state.\n- **timeout**: The duration in seconds the circuit remains open before attempting to transition to a \"half-open\" state to check if the service has recovered.\n- **fallback**: A predicate that handles the request while the primary service is unavailable, such as serving data from a local cache.\n\nFor more details on implementing these patterns, see `education/book-07-cross-target-glue/12a_service_mesh.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12a_service_mesh.md", "topics": ["service-mesh", "load-balancing", "circuit-breaker"], "original_answer": "## Service Mesh Patterns\n\n### Load Balancing Strategies\n\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)  % or: random, least_connections\n]).\n```\n\n### Circuit Breakers\n\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % failures before open\n    timeout(30),            % seconds before half-open\n    fallback(local_cache/2) % use when open\n]).\n```\n\n### Health Checks\n\n```prolog\n:- health_check(service_name, [\n    endpoint('/health'),\n    interval(10),\n    timeout(5)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c12b-polyglot_p0", "cluster_id": "b7-c12b-polyglot", "question": "How do polyglot distributed systems work?", "question_type": "medium", "answer": "Polyglot distributed systems in UnifyWeaver work by orchestrating services written in diverse languages\u2014such as Go, Python, and Rust\u2014into a unified execution pipeline. This allows the system to leverage the strengths of different targets for specific tasks, such as a Go parser feeding into a Python ML service, which then passes data to a Rust aggregator before reaching a Go-based API.\n\nThe functionality is driven by three core mechanisms:\n\n1. **Cross-Language Communication**: UnifyWeaver facilitates seamless data transitions across language boundaries, allowing disparate services to act as a single distributed unit.\n2. **Sharding Management**: For high-volume data, the system uses Prolog declarations to automate sharding across the network. By specifying shard keys and distribution strategies (like `hash_mod`), UnifyWeaver handles data partitioning:\n   ```prolog\n   :- declare_sharding(large_dataset/2, [\n       shard_key(id),\n       shard_count(4),\n       strategy(hash_mod)\n   ]).\n   ```\n3. **Automated Protocol Negotiation**: Services dynamically select the most efficient serialization format (e.g., JSON, MessagePack, or Protobuf) supported by both the source and destination targets:\n   ```prolog\n   :- declare_connection(go_service, python_service, [\n       negotiate_format([json, msgpack, protobuf])\n   ]).\n   ```\n\nThis approach ensures that polyglot architectures remain performant and scalable without requiring manual implementation of cross-target glue code. For further details on implementing these distributed patterns, refer to `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12b_polyglot_distributed.md", "topics": ["polyglot", "sharding", "cross-language"], "original_answer": "## Polyglot Distributed Systems\n\n### Cross-Language Communication\n\nDifferent services can use different languages:\n\n```\nGo (parser) \u2192 Python (ML) \u2192 Rust (aggregator) \u2192 Go (API)\n```\n\n### Sharding (Phases 4-6)\n\n```prolog\n:- declare_sharding(large_dataset/2, [\n    shard_key(id),\n    shard_count(4),\n    strategy(hash_mod)\n]).\n```\n\n### Protocol Negotiation\n\n```prolog\n% Automatic format selection\n:- declare_connection(go_service, python_service, [\n    negotiate_format([json, msgpack, protobuf])\n]).\n```\n\nServices negotiate the most efficient format both support.", "answer_tailored": true}
{"pair_id": "b7-c12b-polyglot_p1", "cluster_id": "b7-c12b-polyglot", "question": "What is sharding in cross-target glue?", "question_type": "medium", "answer": "Sharding in UnifyWeaver's cross-target glue is a mechanism for partitioning and distributing large datasets across multiple service instances within a polyglot distributed system. This process is managed via the `:- declare_sharding/2` directive, which defines the distribution logic for a specific dataset.\n\nA standard sharding declaration looks like this:\n\n```prolog\n:- declare_sharding(large_dataset/2, [\n    shard_key(id),\n    shard_count(4),\n    strategy(hash_mod)\n]).\n```\n\nThe primary components of this configuration include:\n*   **shard_key**: The attribute (e.g., `id`) used to determine which shard a record belongs to.\n*   **shard_count**: The total number of shards the dataset is divided into.\n*   **strategy**: The algorithm used for partitioning, such as `hash_mod`.\n\nSharding is typically implemented during Phases 4 through 6 of the compilation and execution lifecycle. For a comprehensive look at distributed polyglot architectures and service negotiation, refer to `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12b_polyglot_distributed.md", "topics": ["polyglot", "sharding", "cross-language"], "original_answer": "## Polyglot Distributed Systems\n\n### Cross-Language Communication\n\nDifferent services can use different languages:\n\n```\nGo (parser) \u2192 Python (ML) \u2192 Rust (aggregator) \u2192 Go (API)\n```\n\n### Sharding (Phases 4-6)\n\n```prolog\n:- declare_sharding(large_dataset/2, [\n    shard_key(id),\n    shard_count(4),\n    strategy(hash_mod)\n]).\n```\n\n### Protocol Negotiation\n\n```prolog\n% Automatic format selection\n:- declare_connection(go_service, python_service, [\n    negotiate_format([json, msgpack, protobuf])\n]).\n```\n\nServices negotiate the most efficient format both support.", "answer_tailored": true}
{"pair_id": "b7-c12b-polyglot_p2", "cluster_id": "b7-c12b-polyglot", "question": "How does protocol negotiation work?", "question_type": "medium", "answer": "Protocol negotiation in UnifyWeaver facilitates automatic format selection between services, ensuring they use the most efficient communication protocol that both parties support. This is configured using the `:- declare_connection` directive, which specifies a prioritized list of formats for the system to evaluate during the handshake.\n\n```prolog\n% Configure automatic protocol selection\n:- declare_connection(sender_service, receiver_service, [\n    negotiate_format([json, msgpack, protobuf])\n]).\n```\n\nBy defining these parameters, the cross-target glue can dynamically choose between options like JSON, MessagePack, or Protocol Buffers based on mutual compatibility. This ensures optimized data exchange in polyglot distributed systems, such as when a Go-based API interacts with a Python-based ML service. For more information on implementing these patterns, see `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12b_polyglot_distributed.md", "topics": ["polyglot", "sharding", "cross-language"], "original_answer": "## Polyglot Distributed Systems\n\n### Cross-Language Communication\n\nDifferent services can use different languages:\n\n```\nGo (parser) \u2192 Python (ML) \u2192 Rust (aggregator) \u2192 Go (API)\n```\n\n### Sharding (Phases 4-6)\n\n```prolog\n:- declare_sharding(large_dataset/2, [\n    shard_key(id),\n    shard_count(4),\n    strategy(hash_mod)\n]).\n```\n\n### Protocol Negotiation\n\n```prolog\n% Automatic format selection\n:- declare_connection(go_service, python_service, [\n    negotiate_format([json, msgpack, protobuf])\n]).\n```\n\nServices negotiate the most efficient format both support.", "answer_tailored": true}
{"pair_id": "b7-c12c-discovery-tracing_p0", "cluster_id": "b7-c12c-discovery-tracing", "question": "How does service discovery work?", "question_type": "medium", "answer": "Service discovery in UnifyWeaver is managed by declaring services through the `:- declare_discovery` Prolog directive. This mechanism (introduced in Phase 7) allows the compiler to resolve service locations using backends like Consul, etcd, or DNS. \n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\nComplementing discovery, UnifyWeaver also supports distributed tracing (Phase 8) to maintain observability across service calls. This is configured via `:- declare_tracing`, supporting propagation formats like W3C Trace Context and B3 (Zipkin) for backends such as Jaeger. All generated target code automatically handles trace ID propagation, ensuring correlation across the distributed system:\n\n```go\nctx = context.WithValue(ctx, \"trace_id\", traceID)\n```\n\nFor more information on these cross-target glue features, refer to `education/book-07-cross-target-glue/12c_discovery_tracing.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12c_discovery_tracing.md", "topics": ["service-discovery", "distributed-tracing", "consul"], "original_answer": "## Service Discovery & Tracing\n\n### Service Discovery (Phase 7)\n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\n**Backends:** Consul, etcd, DNS\n\n### Distributed Tracing (Phase 8)\n\n```prolog\n:- declare_tracing([\n    backend(jaeger),\n    propagation(w3c),  % or: b3\n    sample_rate(0.1)\n]).\n```\n\n**Propagation:** W3C Trace Context, B3 (Zipkin)\n\n### Trace Correlation\n\nAll generated code includes trace ID propagation:\n\n```go\nctx = context.WithValue(ctx, \"trace_id\", traceID)\n```", "answer_tailored": true}
{"pair_id": "b7-c12c-discovery-tracing_p1", "cluster_id": "b7-c12c-discovery-tracing", "question": "What is distributed tracing?", "question_type": "medium", "answer": "Distributed tracing in UnifyWeaver is a system for tracking requests as they flow through multiple services and across different target languages. It is managed via the `declare_tracing/1` predicate, which allows you to configure the tracing infrastructure globally.\n\nKey components of the tracing system include:\n- **Backend Support:** Integration with platforms like Jaeger for collecting and visualizing traces.\n- **Propagation Standards:** Support for industry-standard headers such as W3C Trace Context and B3 (Zipkin) to ensure compatibility across heterogeneous environments.\n- **Sampling Control:** The ability to define a `sample_rate` to manage performance overhead and data volume.\n- **Trace Correlation:** UnifyWeaver automatically generates code that handles trace ID propagation. For example, in the Go target, this involves passing the `trace_id` through the standard `context` package.\n\nFor a deeper dive into service discovery and tracing configurations, see the documentation in `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12c_discovery_tracing.md", "topics": ["service-discovery", "distributed-tracing", "consul"], "original_answer": "## Service Discovery & Tracing\n\n### Service Discovery (Phase 7)\n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\n**Backends:** Consul, etcd, DNS\n\n### Distributed Tracing (Phase 8)\n\n```prolog\n:- declare_tracing([\n    backend(jaeger),\n    propagation(w3c),  % or: b3\n    sample_rate(0.1)\n]).\n```\n\n**Propagation:** W3C Trace Context, B3 (Zipkin)\n\n### Trace Correlation\n\nAll generated code includes trace ID propagation:\n\n```go\nctx = context.WithValue(ctx, \"trace_id\", traceID)\n```", "answer_tailored": true}
{"pair_id": "b7-c12c-discovery-tracing_p2", "cluster_id": "b7-c12c-discovery-tracing", "question": "How do I use Consul with UnifyWeaver?", "question_type": "medium", "answer": "To use Consul for service discovery in UnifyWeaver, you use the `declare_discovery` directive to define how services should be resolved at runtime. This allows your compiled code to dynamically locate dependencies using the Consul backend.\n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\nBy specifying `backend(consul)`, UnifyWeaver generates the necessary glue code to query Consul for the service matching the given `service_name` and optional `tags`. While Consul is a primary backend, etcd and DNS are also supported. For comprehensive observability, you can pair this with `declare_tracing` to enable distributed tracing (such as Jaeger) with automatic W3C or B3 header propagation across all generated code.\n\nFor more details on implementing service discovery and tracing, see the documentation in `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12c_discovery_tracing.md", "topics": ["service-discovery", "distributed-tracing", "consul"], "original_answer": "## Service Discovery & Tracing\n\n### Service Discovery (Phase 7)\n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\n**Backends:** Consul, etcd, DNS\n\n### Distributed Tracing (Phase 8)\n\n```prolog\n:- declare_tracing([\n    backend(jaeger),\n    propagation(w3c),  % or: b3\n    sample_rate(0.1)\n]).\n```\n\n**Propagation:** W3C Trace Context, B3 (Zipkin)\n\n### Trace Correlation\n\nAll generated code includes trace ID propagation:\n\n```go\nctx = context.WithValue(ctx, \"trace_id\", traceID)\n```", "answer_tailored": true}
{"pair_id": "b7-c12d-kg-topology_p0", "cluster_id": "b7-c12d-kg-topology", "question": "What is KG Topology?", "question_type": "medium", "answer": "KG Topology refers to the structural arrangement and routing logic of the Knowledge Graph within UnifyWeaver, where expert systems function as multi-interface nodes that can serve several semantic domains simultaneously. These nodes are defined by discovery metadata, including semantic centroids and interface topics, which allow the system to navigate complex data environments.\n\nThe network utilizes **Kleinberg Small-World Routing** to manage connectivity:\n\n*   **Node Location:** Represented as an interface centroid within an embedding space.\n*   **Greedy Routing:** Data is forwarded to the centroid with the highest similarity to the target.\n*   **Path Folding:** The system dynamically creates shortcuts after successful matches to optimize future traversal.\n*   **HTL (Hops to Live):** A constraint that defines the maximum number of hops allowed before a search terminates.\n\nFor implementation examples of discovery metadata and routing configurations, see `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12d_kg_topology.md", "topics": ["knowledge-graph", "kleinberg-routing", "semantic-search"], "original_answer": "## Knowledge Graph Topology\n\n### Multi-Interface Nodes\n\nOne expert system can serve multiple semantic domains:\n\n```prolog\nservice(csv_expert_node, [\n    discovery_metadata([\n        semantic_centroid(\"base64_vector...\"),\n        interface_topics([csv, delimited, tabular])\n    ]),\n    routing(kleinberg([\n        alpha(2.0),\n        max_hops(10),\n        path_folding(true)\n    ]))\n]).\n```\n\n### Kleinberg Small-World Routing\n\n| Concept | Application |\n|---------|-------------|\n| Node location | Interface centroid in embedding space |\n| Greedy routing | Forward to most similar centroid |\n| Path folding | Dynamic shortcuts after matches |\n| HTL | Maximum hops before giving up |", "answer_tailored": true}
{"pair_id": "b7-c12d-kg-topology_p1", "cluster_id": "b7-c12d-kg-topology", "question": "How does Kleinberg routing work?", "question_type": "medium", "answer": "Kleinberg routing in UnifyWeaver facilitates efficient small-world navigation across knowledge graph topologies by using semantic embeddings to guide discovery. It operates through several core mechanisms:\n\n*   **Greedy Routing:** Messages are forwarded to the neighbor whose semantic centroid\u2014its location in the embedding space\u2014is most similar to the target query.\n*   **Centroid-Based Positioning:** Each node's \"location\" is determined by the interface topics it serves (e.g., CSV, tabular data), represented as a vector.\n*   **Path Folding:** The system creates dynamic shortcuts after successful matches, optimizing future routing paths between nodes.\n*   **Hop Limits (HTL):** A `max_hops` parameter (typically 10) prevents infinite loops and limits search depth.\n\nIn Prolog, this is configured within the `service/2` predicate:\n\n```prolog\nrouting(kleinberg([\n    alpha(2.0),\n    max_hops(10),\n    path_folding(true)\n]))\n```\n\nFor more details on knowledge graph topology and interface centroids, see `education/book-07-cross-target-glue/12d_kg_topology.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12d_kg_topology.md", "topics": ["knowledge-graph", "kleinberg-routing", "semantic-search"], "original_answer": "## Knowledge Graph Topology\n\n### Multi-Interface Nodes\n\nOne expert system can serve multiple semantic domains:\n\n```prolog\nservice(csv_expert_node, [\n    discovery_metadata([\n        semantic_centroid(\"base64_vector...\"),\n        interface_topics([csv, delimited, tabular])\n    ]),\n    routing(kleinberg([\n        alpha(2.0),\n        max_hops(10),\n        path_folding(true)\n    ]))\n]).\n```\n\n### Kleinberg Small-World Routing\n\n| Concept | Application |\n|---------|-------------|\n| Node location | Interface centroid in embedding space |\n| Greedy routing | Forward to most similar centroid |\n| Path folding | Dynamic shortcuts after matches |\n| HTL | Maximum hops before giving up |", "answer_tailored": true}
{"pair_id": "b7-c12d-kg-topology_p2", "cluster_id": "b7-c12d-kg-topology", "question": "What are multi-interface semantic nodes?", "question_type": "medium", "answer": "Multi-interface semantic nodes are expert systems within the UnifyWeaver knowledge graph topology designed to serve multiple semantic domains from a single point. In this architecture, a node such as a `csv_expert_node` identifies itself through discovery metadata containing a `semantic_centroid` (its position in the embedding space) and a list of `interface_topics` (e.g., `csv`, `delimited`, `tabular`).\n\n```prolog\nservice(csv_expert_node, [\n    discovery_metadata([\n        semantic_centroid(\"base64_vector...\"),\n        interface_topics([csv, delimited, tabular])\n    ]),\n    routing(kleinberg([\n        alpha(2.0),\n        max_hops(10),\n        path_folding(true)\n    ]))\n]).\n```\n\nThese nodes facilitate efficient navigation using Kleinberg Small-World Routing. The routing logic treats the interface centroid as the node's location in embedding space, allowing for greedy routing where requests are forwarded to the most similar centroid. The system also supports path folding for dynamic shortcuts and HTL (Hops To Live) to prevent infinite loops. Detailed implementation patterns for these topologies are covered in `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12d_kg_topology.md", "topics": ["knowledge-graph", "kleinberg-routing", "semantic-search"], "original_answer": "## Knowledge Graph Topology\n\n### Multi-Interface Nodes\n\nOne expert system can serve multiple semantic domains:\n\n```prolog\nservice(csv_expert_node, [\n    discovery_metadata([\n        semantic_centroid(\"base64_vector...\"),\n        interface_topics([csv, delimited, tabular])\n    ]),\n    routing(kleinberg([\n        alpha(2.0),\n        max_hops(10),\n        path_folding(true)\n    ]))\n]).\n```\n\n### Kleinberg Small-World Routing\n\n| Concept | Application |\n|---------|-------------|\n| Node location | Interface centroid in embedding space |\n| Greedy routing | Forward to most similar centroid |\n| Path folding | Dynamic shortcuts after matches |\n| HTL | Maximum hops before giving up |", "answer_tailored": true}
