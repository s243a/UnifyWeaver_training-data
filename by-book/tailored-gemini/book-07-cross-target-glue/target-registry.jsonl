{"pair_id": "b7-c3-target-registry_p0", "cluster_id": "b7-c3-target-registry", "question": "What is the target registry?", "question_type": "medium", "answer": "The target registry is the central management system in UnifyWeaver for target metadata, runtime families, and predicate-to-target mappings. It serves as the directory the compiler uses to resolve where and how a specific predicate should be executed across different backends.\n\n### Registry API\n\nThe registry is managed via the `target_registry` module with the following primary predicates:\n\n*   `register_target/3`: Adds a new target to the system.\n*   `target_family/2`: Identifies the grouping (family) of a specific target.\n*   `targets_same_family/2`: Checks if two targets belong to the same runtime environment.\n*   `default_location/2`: Defines the standard execution environment for a target.\n*   `default_transport/3`: Specifies the communication method between different locations.\n\n### Declaring Target Implementations\n\nYou map Prolog predicates to specific target implementations using the `declare_target` directive:\n\n```prolog\n% Mapping a predicate to a Python implementation\n:- declare_target(process_data/2, python).\n\n% Mapping with specific execution options\n:- declare_target(process_data/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\n### Supported Runtime Families\n\nTargets are organized into families to streamline cross-target glue logic:\n\n| Family | Included Targets |\n|--------|------------------|\n| **shell** | bash, awk, sed, perl |\n| **dotnet** | csharp, powershell, ironpython |\n| **native** | go, rust, c |\n\nFor further details on target orchestration and metadata management, see `education/book-07-cross-target-glue/03_target_registry.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["target-registry", "declare-target", "target-mapping"], "original_answer": "## Target Registry\n\nThe target registry manages target metadata, runtime families, and predicate mappings.\n\n### API\n\n```prolog\n:- module(target_registry, [\n    register_target/3,      % Register a new target\n    target_family/2,        % Query target's family\n    targets_same_family/2,  % Check family membership\n    default_location/2,     % Default location for target\n    default_transport/3     % Default transport between locations\n]).\n```\n\n### Declaring Targets\n\n```prolog\n% Basic declaration\n:- declare_target(analyze/2, python).\n\n% With options\n:- declare_target(analyze/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\n### Built-in Families\n\n| Family | Targets |\n|--------|--------|\n| shell | bash, awk, sed, perl |\n| dotnet | csharp, powershell, ironpython |\n| native | go, rust, c |", "answer_tailored": true}
{"pair_id": "b7-c3-target-registry_p1", "cluster_id": "b7-c3-target-registry", "question": "How do I declare a target for a predicate?", "question_type": "medium", "answer": "To declare a target for a predicate in UnifyWeaver, you use the `declare_target` directive to map a specific predicate and its arity to a target runtime.\n\n### Basic Declaration\nThe simplest way to bind a predicate to a target (such as Python, Bash, or Go) is with the following syntax:\n\n```prolog\n:- declare_target(analyze/2, python).\n```\n\n### Declaration with Options\nFor more control over the execution environment, you can provide an options list to specify data formats, execution locations, or timeouts:\n\n```prolog\n:- declare_target(process_data/3, go, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\n### The Target Registry\nAll declarations are managed by the `target_registry` module, which categorizes targets into families:\n*   **shell**: bash, awk, sed, perl\n*   **dotnet**: csharp, powershell, ironpython\n*   **native**: go, rust, c\n\nThe registry provides an API for managing runtime metadata, including `register_target/3`, `target_family/2`, and `default_transport/3`. For a complete overview of target management and runtime families, refer to the documentation in `education/book-07-cross-target-glue/03_target_registry.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["target-registry", "declare-target", "target-mapping"], "original_answer": "## Target Registry\n\nThe target registry manages target metadata, runtime families, and predicate mappings.\n\n### API\n\n```prolog\n:- module(target_registry, [\n    register_target/3,      % Register a new target\n    target_family/2,        % Query target's family\n    targets_same_family/2,  % Check family membership\n    default_location/2,     % Default location for target\n    default_transport/3     % Default transport between locations\n]).\n```\n\n### Declaring Targets\n\n```prolog\n% Basic declaration\n:- declare_target(analyze/2, python).\n\n% With options\n:- declare_target(analyze/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\n### Built-in Families\n\n| Family | Targets |\n|--------|--------|\n| shell | bash, awk, sed, perl |\n| dotnet | csharp, powershell, ironpython |\n| native | go, rust, c |", "answer_tailored": true}
{"pair_id": "b7-c3-target-registry_p2", "cluster_id": "b7-c3-target-registry", "question": "What is declare_target/3?", "question_type": "medium", "answer": "`declare_target/3` is a Prolog directive used to map a predicate to a specific execution target while providing detailed configuration options. It allows you to define how a predicate should be handled by the compiler, including execution parameters and metadata.\n\nThe directive takes three arguments:\n1. The predicate indicator (Name/Arity).\n2. The target language (e.g., `python`, `go`, `bash`).\n3. A list of options for fine-grained control.\n\n### Example Usage\n```prolog\n:- declare_target(analyze/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\nThis mechanism is part of the target registry system, which categorizes targets into families like `shell` (bash, awk), `dotnet` (csharp, powershell), and `native` (go, rust). By using `declare_target/3`, you can specify essential runtime details such as the communication transport or the data serialization format required for cross-target glue.\n\nFor more information on target metadata and the registry API, see `education/book-07-cross-target-glue/03_target_registry.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["target-registry", "declare-target", "target-mapping"], "original_answer": "## Target Registry\n\nThe target registry manages target metadata, runtime families, and predicate mappings.\n\n### API\n\n```prolog\n:- module(target_registry, [\n    register_target/3,      % Register a new target\n    target_family/2,        % Query target's family\n    targets_same_family/2,  % Check family membership\n    default_location/2,     % Default location for target\n    default_transport/3     % Default transport between locations\n]).\n```\n\n### Declaring Targets\n\n```prolog\n% Basic declaration\n:- declare_target(analyze/2, python).\n\n% With options\n:- declare_target(analyze/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\n### Built-in Families\n\n| Family | Targets |\n|--------|--------|\n| shell | bash, awk, sed, perl |\n| dotnet | csharp, powershell, ironpython |\n| native | go, rust, c |", "answer_tailored": true}
{"pair_id": "b7-c3-location-resolution_p0", "cluster_id": "b7-c3-location-resolution", "question": "How does location resolution work?", "question_type": "medium", "answer": "Location resolution in UnifyWeaver determines how the system selects execution environments and transport mechanisms for predicates. It manages the transition between different target languages and physical locations.\n\n### Location Declarations\nExplicit routing is handled via `declare_location/2`, allowing you to force remote execution or process isolation:\n\n```prolog\n% Route execution to a specific network host\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n\n% Force execution in a separate local process\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\n### Resolution Logic\nThe compiler follows a specific set of rules to determine the transport layer:\n1. **Same family, local:** Default to in-process execution.\n2. **Different family, local:** Utilize pipes for inter-process communication.\n3. **Remote:** Employ network protocols like HTTP or raw sockets.\n\n### Override Hierarchy\nThe resolution behavior is controlled through levels of specificity in `declare_target/2`:\n\n1. **Basic (Defaults):** Just identifies the target language.\n   `:- declare_target(analyze/2, python).`\n2. **Intermediate (Format):** Specifies the data exchange format.\n   `:- declare_target(analyze/2, python, [format(json)]).`\n3. **Advanced (Full Control):** Explicitly defines location, timeouts, and retry strategies.\n   ```prolog\n   :- declare_target(analyze/2, python, [\n       format(json), location(local_process), timeout(30), retry(3)\n   ]).\n   ```\n\nFor a deeper dive into the registry system, refer to `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["location", "transport", "resolution"], "original_answer": "## Location and Transport Resolution\n\n### Location Declarations\n\n```prolog\n% Force remote execution\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n\n% Force separate process\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\n### Resolution Rules\n\n1. **Same family, local** \u2192 In-process (if supported)\n2. **Different family, local** \u2192 Pipes\n3. **Remote** \u2192 HTTP/socket\n\n### Override Hierarchy\n\n```prolog\n% Level 1: Just works (defaults)\n:- declare_target(analyze/2, python).\n\n% Level 2: Specify format\n:- declare_target(analyze/2, python, [format(json)]).\n\n% Level 3: Full control\n:- declare_target(analyze/2, python, [\n    format(json), location(local_process), timeout(30), retry(3)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c3-location-resolution_p1", "cluster_id": "b7-c3-location-resolution", "question": "What is declare_location/2?", "question_type": "medium", "answer": "`declare_location/2` is a directive in UnifyWeaver used to define the execution environment and transport mechanism for a specific predicate. It allows you to explicitly control where a predicate runs\u2014whether in the current process, a separate local process, or on a remote server.\n\n### Location Declarations\n\nYou can use the directive to force remote execution or process isolation:\n\n```prolog\n% Configure remote execution via HTTP\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n\n% Force execution in a separate local process\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\n### Resolution Rules\n\nThe system resolves the transport method based on the declared location and the target language family:\n1. **In-process:** Default for predicates in the same language family on the local machine.\n2. **Pipes:** Used for local communication between different language families.\n3. **HTTP/Sockets:** Used for remote locations defined via `declare_location/2`.\n\n### Override Hierarchy\n\nLocation settings can be integrated into the `declare_target/3` directive for more granular control:\n\n```prolog\n% Default target declaration\n:- declare_target(analyze/2, python).\n\n% Specifying data format\n:- declare_target(analyze/2, python, [format(json)]).\n\n% Full control over location, format, and reliability\n:- declare_target(analyze/2, python, [\n    format(json), \n    location(local_process), \n    timeout(30), \n    retry(3)\n]).\n```\n\nFor more details on managing cross-target execution environments, see `education/book-07-cross-target-glue/03_target_registry.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["location", "transport", "resolution"], "original_answer": "## Location and Transport Resolution\n\n### Location Declarations\n\n```prolog\n% Force remote execution\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n\n% Force separate process\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\n### Resolution Rules\n\n1. **Same family, local** \u2192 In-process (if supported)\n2. **Different family, local** \u2192 Pipes\n3. **Remote** \u2192 HTTP/socket\n\n### Override Hierarchy\n\n```prolog\n% Level 1: Just works (defaults)\n:- declare_target(analyze/2, python).\n\n% Level 2: Specify format\n:- declare_target(analyze/2, python, [format(json)]).\n\n% Level 3: Full control\n:- declare_target(analyze/2, python, [\n    format(json), location(local_process), timeout(30), retry(3)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c3-location-resolution_p2", "cluster_id": "b7-c3-location-resolution", "question": "How do I specify remote execution?", "question_type": "medium", "answer": "To specify remote execution in UnifyWeaver, you use the `declare_location/2` directive to map a predicate to a specific network endpoint. By defining the `host`, `port`, and `transport` parameters, you instruct the compiler to route calls to that predicate via the network rather than executing them locally.\n\n### Explicit Remote Location\nUse the following syntax to force a predicate to execute on a remote worker:\n\n```prolog\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n```\n\n### Integrated Target Control\nYou can also specify remote execution within a target declaration using the `location` property. This allows you to bundle remote routing with other configuration options like data formats and retry logic:\n\n```prolog\n:- declare_target(analyze/2, python, [\n    format(json),\n    location('remote-node-01'),\n    timeout(30),\n    retry(3)\n]).\n```\n\n### Transport Resolution\nThe system resolves execution locations based on the following hierarchy:\n1. **Local, Same Language:** In-process call.\n2. **Local, Different Language:** Inter-process communication via pipes.\n3. **Remote:** Network communication via HTTP or sockets.\n\nFor a deep dive into how the compiler handles cross-node coordination and transport layers, refer to the documentation in `education/book-07-cross-target-glue/03_target_registry.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["location", "transport", "resolution"], "original_answer": "## Location and Transport Resolution\n\n### Location Declarations\n\n```prolog\n% Force remote execution\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n\n% Force separate process\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\n### Resolution Rules\n\n1. **Same family, local** \u2192 In-process (if supported)\n2. **Different family, local** \u2192 Pipes\n3. **Remote** \u2192 HTTP/socket\n\n### Override Hierarchy\n\n```prolog\n% Level 1: Just works (defaults)\n:- declare_target(analyze/2, python).\n\n% Level 2: Specify format\n:- declare_target(analyze/2, python, [format(json)]).\n\n% Level 3: Full control\n:- declare_target(analyze/2, python, [\n    format(json), location(local_process), timeout(30), retry(3)\n]).\n```", "answer_tailored": true}
