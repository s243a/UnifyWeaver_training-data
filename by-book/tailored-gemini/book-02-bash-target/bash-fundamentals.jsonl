{"pair_id": "bash-subshells_p0", "cluster_id": "bash-subshells", "question": "What is a bash subshell and why do pipes create one?", "question_type": "medium", "answer": "A Bash subshell is a child process that runs a duplicate of the current shell to execute a specific command or block. Pipes (`|`) create subshells because Bash executes piped commands in parallel; both the producer (left side) and the consumer (right side) must run simultaneously to stream data through the pipe, which requires separate process environments.\n\n### Technical Implications\n- **Isolation**: The subshell receives a copy of all variables. However, because it is a separate process, any modifications to those variables (such as increments in a `while` loop) are lost when the subshell finishes and do not affect the parent shell.\n- **Detection**: You can distinguish a subshell from the parent by comparing `$BASHPID` within the pipe to the parent\u2019s `$$`.\n- **Workarounds**: If you need to retain variable changes, use process substitution (e.g., `done < <(command)`) or enable the `lastpipe` shell option (Bash 4.2+).\n\nFor more details on managing scope and using process substitution, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["subshell", "pipes", "variable-scope", "child-process"], "original_answer": "## Bash Subshells\n\nA subshell is a child process running a copy of bash.\n\n### The Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\n### Why This Happens\n\nPipes (`|`) create a subshell for the right side:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (changes here)\n   count still 0                  (discarded when done)\n```\n\nThe subshell gets a **copy** of variables. Changes don't affect the parent.\n\n### Why Bash Does This\n\nPipes enable parallelism:\n- Both sides run simultaneously\n- Data flows through the pipe\n- Requires separate processes\n\n### Detecting Subshells\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs = different processes\n```\n\n### Solutions\n\n1. **Process Substitution** - avoid pipe subshell\n2. **Here-string** - for simple cases\n3. **Temp files** - explicit state passing\n4. **lastpipe option** - bash 4.2+ only\n\nSee: Process substitution training for solution details.", "answer_tailored": true}
{"pair_id": "bash-subshells_p1", "cluster_id": "bash-subshells", "question": "Why don't variables persist after a pipe?", "question_type": "medium", "answer": "Variables do not persist after a pipe because Bash executes the right-hand side of a pipeline within a **subshell**. A subshell is a separate child process that receives a copy of the parent shell's variables; however, any modifications made within that process are local and are discarded when the subshell terminates.\n\n### The Subshell Mechanism\nWhen you run a command like `cat data.txt | while read line; do ((count++)); done`, the following occurs:\n1. **Forking:** Bash creates a child process (subshell) for the `while` loop.\n2. **Isolation:** The subshell increments its own copy of `count`.\n3. **Termination:** Once the input ends, the subshell exits. The parent shell's version of `count` remains unchanged because processes cannot natively modify the memory of their parents.\n\n### Why This Design Exists\nPipes are designed to facilitate **parallelism**. By running both sides of the pipe in separate processes simultaneously, the system can stream data through the kernel buffer efficiently without waiting for the first command to fully complete.\n\n### Diagnostic Verification\nYou can confirm this process separation by comparing the parent Process ID with the subshell's ID:\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n```\n\n### Common Workarounds\nTo ensure variables persist after processing data, use techniques that avoid the pipe-induced subshell:\n1. **Process Substitution:** Use `while read line; do ... done < <(command)`. This keeps the loop in the main shell.\n2. **Here-strings:** For simple inputs, use `done <<< \"$(command)\"`.\n3. **lastpipe Option:** In Bash 4.2+, you can use `shopt -s lastpipe` (with job control disabled) to run the final command of a pipeline in the current shell environment.\n4. **Temporary Files:** Redirect output to a file and read it into the current shell context.\n\nFor detailed implementation patterns and examples, refer to `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["subshell", "pipes", "variable-scope", "child-process"], "original_answer": "## Bash Subshells\n\nA subshell is a child process running a copy of bash.\n\n### The Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\n### Why This Happens\n\nPipes (`|`) create a subshell for the right side:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (changes here)\n   count still 0                  (discarded when done)\n```\n\nThe subshell gets a **copy** of variables. Changes don't affect the parent.\n\n### Why Bash Does This\n\nPipes enable parallelism:\n- Both sides run simultaneously\n- Data flows through the pipe\n- Requires separate processes\n\n### Detecting Subshells\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs = different processes\n```\n\n### Solutions\n\n1. **Process Substitution** - avoid pipe subshell\n2. **Here-string** - for simple cases\n3. **Temp files** - explicit state passing\n4. **lastpipe option** - bash 4.2+ only\n\nSee: Process substitution training for solution details.", "answer_tailored": true}
{"pair_id": "bash-subshells_p2", "cluster_id": "bash-subshells", "question": "What is the pipe subshell problem?", "question_type": "medium", "answer": "The pipe subshell problem is a common scoping issue in Bash where commands on the right-hand side of a pipe (`|`) are executed within a separate child process, known as a subshell. Because this subshell receives a copy of the parent's environment rather than sharing its memory, any changes made to variables inside the pipeline are lost when the subshell terminates.\n\n### Technical Demonstration\nIn the following example, the variable `count` remains `0` in the parent shell despite being incremented inside the loop:\n\n```bash\ncount=0\nprintf \"item1\\nitem2\\nitem3\" | while read line; do\n    ((count++))\ndone\necho \"Final Count: $count\"  # Result: 0\n```\n\n### Why It Happens\nBash uses subshells for pipes to support parallelism, allowing both sides of the pipe to run concurrently. You can detect this process separation by comparing the parent Process ID (`$$`) with the subshell ID (`$BASHPID`):\n\n```bash\necho \"Parent PID: $$\"\necho \"trigger\" | { echo \"Subshell PID: $BASHPID\"; }\n```\n\n### Solutions\nTo avoid losing variable state, you can use these alternatives:\n1.  **Process Substitution:** `while read line; do ... done < <(command)` runs the loop in the parent shell.\n2.  **Here-strings:** Useful for passing simple strings into a loop without a pipe.\n3.  **The `lastpipe` Option:** In Bash 4.2+, running `shopt -s lastpipe` (with job control disabled) allows the last command in a pipeline to execute in the current shell.\n\nFor a deep dive into implementing these solutions, refer to the documentation in `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["subshell", "pipes", "variable-scope", "child-process"], "original_answer": "## Bash Subshells\n\nA subshell is a child process running a copy of bash.\n\n### The Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\n### Why This Happens\n\nPipes (`|`) create a subshell for the right side:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (changes here)\n   count still 0                  (discarded when done)\n```\n\nThe subshell gets a **copy** of variables. Changes don't affect the parent.\n\n### Why Bash Does This\n\nPipes enable parallelism:\n- Both sides run simultaneously\n- Data flows through the pipe\n- Requires separate processes\n\n### Detecting Subshells\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs = different processes\n```\n\n### Solutions\n\n1. **Process Substitution** - avoid pipe subshell\n2. **Here-string** - for simple cases\n3. **Temp files** - explicit state passing\n4. **lastpipe option** - bash 4.2+ only\n\nSee: Process substitution training for solution details.", "answer_tailored": true}
{"pair_id": "bash-subshells_p3", "cluster_id": "bash-subshells", "question": "How do pipes affect variable scope in bash?", "question_type": "medium", "answer": "Pipes affect variable scope in Bash by executing the command on the right side of the pipe within a **subshell**. This subshell is a separate child process that operates on a copy of the parent shell's variables; consequently, any changes or increments made to variables inside the pipe do not propagate back to the parent environment.\n\n### The Subshell Challenge\n\nWhen you pipe data into a loop, the isolation prevents persistent state changes:\n\n```bash\ntotal=0\nprintf \"row1\\nrow2\" | while read data; do\n    ((total++))\ndone\necho \"Total: $total\"  # Outputs: 0\n```\n\nBecause the `while` loop runs in a parallel child process to handle the incoming stream, the `total` variable updated inside the loop is discarded as soon as the subshell exits.\n\n### Why This Occurs\n\nBash utilizes subshells for pipes to support **parallelism**. Both sides of the pipe execute simultaneously, with data flowing through a kernel buffer. This requires distinct process spaces, which inherently isolates variable scope. You can detect this by comparing `$$` (the main shell PID) with `$BASHPID` inside a piped segment.\n\n### Recommended Solutions\n\nTo maintain variable state while processing streams, consider these alternatives:\n\n1.  **Process Substitution**: Redirect the output of a command into a loop using `while read line; do ... done < <(command)`. This keeps the loop in the parent shell.\n2.  **The `lastpipe` Option**: In Bash 4.2+, you can use `shopt -s lastpipe` (with job control disabled) to run the final segment of a pipeline in the current shell context.\n3.  **Here-strings**: Use `done <<< \"$(command)\"` for smaller datasets.\n4.  **Temporary Files**: Write intermediate data to a file to be read by the parent process.\n\nDetailed implementation patterns for these solutions can be found in `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["subshell", "pipes", "variable-scope", "child-process"], "original_answer": "## Bash Subshells\n\nA subshell is a child process running a copy of bash.\n\n### The Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\n### Why This Happens\n\nPipes (`|`) create a subshell for the right side:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (changes here)\n   count still 0                  (discarded when done)\n```\n\nThe subshell gets a **copy** of variables. Changes don't affect the parent.\n\n### Why Bash Does This\n\nPipes enable parallelism:\n- Both sides run simultaneously\n- Data flows through the pipe\n- Requires separate processes\n\n### Detecting Subshells\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs = different processes\n```\n\n### Solutions\n\n1. **Process Substitution** - avoid pipe subshell\n2. **Here-string** - for simple cases\n3. **Temp files** - explicit state passing\n4. **lastpipe option** - bash 4.2+ only\n\nSee: Process substitution training for solution details.", "answer_tailored": true}
{"pair_id": "process-substitution_p0", "cluster_id": "process-substitution", "question": "What is process substitution in bash?", "question_type": "medium", "answer": "Process substitution in Bash is a mechanism that allows the output (or input) of a command to be treated as a file. It enables you to pass the results of a process to another command that normally expects a filename, without the need for manual temporary file management.\n\n### Syntax\n- `< <(command)`: Makes the output of `command` available as input (reads from a file descriptor).\n- `> >(command)`: Sends output to the input of `command` (writes to a file descriptor).\n\n### Mechanism and Advantages\nUnder the hood, Bash creates a named pipe or a file descriptor (like `/dev/fd/63`). The primary advantage over standard piping (`|`) is that it avoids the creation of a subshell for the receiving command. This is critical for maintaining variable state:\n\n```bash\n# Standard Pipe: Variables inside the loop are lost when the subshell ends\ncount=0\necho -e \"1\\n2\" | while read n; do ((count++)); done\necho $count # Outputs 0\n\n# Process Substitution: Loop runs in the current shell\ncount=0\nwhile read n; do ((count++)); done < <(echo -e \"1\\n2\")\necho $count # Outputs 2\n```\n\n### Comparison Table\n\n| Feature | Piping (`cmd1 \\| cmd2`) | Process Substitution (`cmd2 < <(cmd1)`) |\n| :--- | :--- | :--- |\n| **Shell Context** | Executes in a subshell | Executes in the current shell |\n| **Variable Scope** | Changes lost after pipe | Changes persist in current shell |\n| **Implementation** | `stdout` to `stdin` link | Temporary file descriptor (`/dev/fd/N`) |\n\n### UnifyWeaver Usage\nUnifyWeaver leverages process substitution when compiling Prolog predicates to Bash, particularly for streaming results in recursive queries where state (like a \"visited\" set) must be maintained in the current shell's associative arrays:\n\n```bash\n# Generated code for path discovery\nwhile IFS=\",\" read -r node; do\n    if [[ -z \"${visited[$node]}\" ]]; then\n        visited[\"$node\"]=1\n        echo \"$node\"\n    fi\ndone < <(get_neighbors \"$current_node\")\n```\n\nFor more details on Bash target optimization and variable scoping, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["process-substitution", "file-descriptor", "redirection"], "original_answer": "## Process Substitution\n\nProcess substitution runs a command and makes its output available as a file.\n\n### Syntax\n\n```bash\n< <(command)   # Input from command output\n> >(command)   # Output to command input\n```\n\n### How It Works\n\n```bash\n# Pipe (creates subshell for while loop)\ncommand | while read line; do ...; done\n\n# Process substitution (loop runs in current shell)\nwhile read line; do ...; done < <(command)\n```\n\n### Why It Solves the Subshell Problem\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\nThe `< <(...)` creates a file descriptor that the current shell reads from. No subshell is created for the loop.\n\n### Under the Hood\n\n```bash\n# Process substitution creates /dev/fd/N\necho <(echo hello)\n# Output: /dev/fd/63 (or similar)\n\n# It's like:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Comparison\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\n### UnifyWeaver Usage\n\n```bash\n# From generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```", "answer_tailored": true}
{"pair_id": "process-substitution_p1", "cluster_id": "process-substitution", "question": "How does < <(...) work?", "question_type": "medium", "answer": "The `< <(...)` syntax in Bash is a combination of standard input redirection and process substitution, allowing a command's output to be treated as a file without creating a subshell for the reading process.\n\n### Core Mechanism\nProcess substitution, denoted by `<(command)`, executes the inner command and connects its output to a named pipe or a file descriptor (such as `/dev/fd/63`). The leading `<` then redirects this descriptor into the current shell's command, such as a `while` loop.\n\n### Solving the Subshell Problem\nThe primary advantage over a standard pipe (`command | while ...`) is that the reading loop stays within the current shell environment. This ensures that any variable modifications made inside the loop persist after the loop completes.\n\n**Example Comparison:**\n```bash\n# Using a pipe: 'count' remains 0 because the loop runs in a subshell\ncount=0\necho -e \"1\\n2\" | while read n; do ((count++)); done\necho $count # Outputs 0\n\n# Using process substitution: 'count' increments in the current shell\ncount=0\nwhile read n; do ((count++)); done < <(echo -e \"1\\n2\")\necho $count # Outputs 2\n```\n\n### UnifyWeaver Implementation\nUnifyWeaver utilizes this pattern in its Bash target to handle recursive queries and transitive closures. By using `< <(...)`, the generated code can stream data through filters (like `grep`) while maintaining the state of visited nodes or accumulation counters in the primary shell.\n\n```bash\n# Typical generated code for graph traversal\nwhile IFS=\":\" read -r from to; do\n    # Logic to update shared state\ndone < <(edge_stream | grep \"^$current:\")\n```\n\nFor more detailed examples and an analysis of variable scope, refer to `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["process-substitution", "file-descriptor", "redirection"], "original_answer": "## Process Substitution\n\nProcess substitution runs a command and makes its output available as a file.\n\n### Syntax\n\n```bash\n< <(command)   # Input from command output\n> >(command)   # Output to command input\n```\n\n### How It Works\n\n```bash\n# Pipe (creates subshell for while loop)\ncommand | while read line; do ...; done\n\n# Process substitution (loop runs in current shell)\nwhile read line; do ...; done < <(command)\n```\n\n### Why It Solves the Subshell Problem\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\nThe `< <(...)` creates a file descriptor that the current shell reads from. No subshell is created for the loop.\n\n### Under the Hood\n\n```bash\n# Process substitution creates /dev/fd/N\necho <(echo hello)\n# Output: /dev/fd/63 (or similar)\n\n# It's like:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Comparison\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\n### UnifyWeaver Usage\n\n```bash\n# From generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```", "answer_tailored": true}
{"pair_id": "process-substitution_p2", "cluster_id": "process-substitution", "question": "Why use process substitution instead of pipes?", "question_type": "medium", "answer": "Process substitution is used instead of pipes primarily to solve the \"subshell problem\" in Bash. When you pipe data into a loop (e.g., `command | while read line`), Bash executes the loop in a subshell. This means any variables modified or initialized inside the loop are lost once the loop completes.\n\nBy using process substitution (`while read line; do ...; done < <(command)`), the loop runs in the current shell environment, allowing variables to persist:\n\n```bash\n# Using process substitution to maintain state\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"line1\\nline2\\nline3\")\necho \"Total: $count\"  # Correctly outputs: Total: 3\n```\n\n### Technical Comparison\n\n| Feature | Pipe (`cmd | while`) | Process Substitution (`< <(cmd)`) |\n| :--- | :--- | :--- |\n| **Loop Execution** | Subshell | Current Shell |\n| **Variable Persistence** | No (lost on exit) | Yes (persists in current scope) |\n| **Mechanism** | Standard stream | File descriptor (e.g., `/dev/fd/63`) |\n\n### How it Works\nThe syntax `< <(command)` instructs the shell to run the command and map its output to a temporary file descriptor. The shell then treats this descriptor as an input file for the `read` command, avoiding the creation of a subshell for the consumer of the data.\n\n### UnifyWeaver Context\nUnifyWeaver utilizes this pattern when generating transitive closure or graph traversal code in Bash to ensure that state tracked in associative arrays (like a `visited` set) remains accessible throughout the execution:\n\n```bash\nwhile IFS=\":\" read -r from to; do\n    if [[ -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```\n\nFor a deeper dive into Bash scope and stream redirection, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["process-substitution", "file-descriptor", "redirection"], "original_answer": "## Process Substitution\n\nProcess substitution runs a command and makes its output available as a file.\n\n### Syntax\n\n```bash\n< <(command)   # Input from command output\n> >(command)   # Output to command input\n```\n\n### How It Works\n\n```bash\n# Pipe (creates subshell for while loop)\ncommand | while read line; do ...; done\n\n# Process substitution (loop runs in current shell)\nwhile read line; do ...; done < <(command)\n```\n\n### Why It Solves the Subshell Problem\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\nThe `< <(...)` creates a file descriptor that the current shell reads from. No subshell is created for the loop.\n\n### Under the Hood\n\n```bash\n# Process substitution creates /dev/fd/N\necho <(echo hello)\n# Output: /dev/fd/63 (or similar)\n\n# It's like:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Comparison\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\n### UnifyWeaver Usage\n\n```bash\n# From generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```", "answer_tailored": true}
{"pair_id": "process-substitution_p3", "cluster_id": "process-substitution", "question": "What's the difference between | and < <(...)?", "question_type": "medium", "answer": "The primary difference between a pipe (`|`) and process substitution (`< <(...)`) is how Bash manages the execution environment and variable scope. When you use a pipe, the command on the receiving end (such as a `while` loop) is executed in a subshell. Consequently, any variables modified inside that loop are lost once the loop terminates. Process substitution avoids this by treating the command's output as a file, allowing the loop to run in the current shell and preserve its state.\n\n### Key Differences\n\n| Feature | Pipe (`cmd | while`) | Process Substitution (`while ... < <(cmd)`) |\n| :--- | :--- | :--- |\n| **Environment** | Runs in a subshell | Runs in the current shell |\n| **Variable Persistence** | Lost after the loop | Maintained after the loop |\n| **Mechanism** | Standard stream redirection | Temporary file descriptor (`/dev/fd/N`) |\n\n### Practical Example\n\nIn a pipe, the counter below would return to `0` after the loop. With process substitution, it correctly reflects the increments:\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"line1\\nline2\\nline3\")\n\necho \"Final Count: $count\" # Outputs: 3\n```\n\n### Technical Implementation\n\nUnder the hood, `< <(command)` creates a named pipe or a file descriptor that the shell can read from just like a standard file. This is functionally similar to:\n```bash\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Usage in UnifyWeaver\n\nUnifyWeaver utilizes process substitution in its generated Bash targets to ensure that state\u2014such as associative arrays used for tracking visited nodes in a recursive query\u2014remains consistent across the entire execution. \n\n```bash\n# Example from generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```\n\nFor more information on variable scoping and process management in the Bash target, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["process-substitution", "file-descriptor", "redirection"], "original_answer": "## Process Substitution\n\nProcess substitution runs a command and makes its output available as a file.\n\n### Syntax\n\n```bash\n< <(command)   # Input from command output\n> >(command)   # Output to command input\n```\n\n### How It Works\n\n```bash\n# Pipe (creates subshell for while loop)\ncommand | while read line; do ...; done\n\n# Process substitution (loop runs in current shell)\nwhile read line; do ...; done < <(command)\n```\n\n### Why It Solves the Subshell Problem\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\nThe `< <(...)` creates a file descriptor that the current shell reads from. No subshell is created for the loop.\n\n### Under the Hood\n\n```bash\n# Process substitution creates /dev/fd/N\necho <(echo hello)\n# Output: /dev/fd/63 (or similar)\n\n# It's like:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Comparison\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\n### UnifyWeaver Usage\n\n```bash\n# From generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```", "answer_tailored": true}
{"pair_id": "bash-arrays_p0", "cluster_id": "bash-arrays", "question": "How do bash associative arrays work?", "question_type": "medium", "answer": "Bash associative arrays function as string-indexed dictionaries, allowing you to map arbitrary string keys to values. Unlike standard indexed arrays, they must be explicitly initialized before use.\n\n### Declaration and Initialization\nYou must use the `-A` flag to define an associative array:\n```bash\n# Define the array\ndeclare -A registry\n\n# Assign values\nregistry[\"host\"]=\"localhost\"\nregistry[\"port\"]=\"8080\"\n\n# Access specific values\necho \"${registry[\"host\"]}\"  # localhost\n```\n\n### Managing Data\n*   **Keys and Values**: Use `${!registry[@]}` to retrieve all keys and `${registry[@]}` to retrieve all values.\n*   **Array Size**: `${#registry[@]}` returns the total number of elements.\n*   **Existence Checks**: Use `[[ -v registry[$key] ]]` to see if a key is defined, or `[[ -n \"${registry[$key]}\" ]]` to check if the value is non-empty.\n*   **Removal**: Use `unset registry[$key]` to delete a specific entry.\n\n### Scoping\n*   **Local**: Within a function, use `local -A` to prevent the array from leaking into the global environment.\n*   **Global**: Use `declare -gA` to ensure the array is accessible across different function scopes.\n\n### Why UnifyWeaver Uses Them\nUnifyWeaver relies on associative arrays to handle complex Prolog-to-Bash compilation tasks efficiently:\n1.  **O(1) Retrieval**: Fast lookups for facts and mapped data.\n2.  **State Management**: Tracking visited nodes in recursive traversals (e.g., `visited[\"$node\"]=1`) to avoid cycles.\n3.  **Deduplication**: Ensuring unique results when aggregating data from multiple sources.\n\nDetailed examples and further context on variable scoping can be found in `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["associative-arrays", "declare", "hash-table", "indexed-arrays"], "original_answer": "## Bash Arrays\n\nBash supports two types of arrays: indexed and associative.\n\n### Indexed Arrays\n\n```bash\n# Declare and initialize\nfruits=(apple banana cherry)\n\n# Access by index\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\n\n# All elements\necho ${fruits[@]}    # apple banana cherry\n```\n\n### Associative Arrays\n\n```bash\n# MUST declare with -A\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n\n# All keys\necho ${!colors[@]}    # sky grass sun\n\n# All values\necho ${colors[@]}     # blue green yellow\n```\n\n### Why UnifyWeaver Uses Associative Arrays\n\n**1. O(1) Lookup**\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Deduplication (visited tracking)**\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Fact Storage**\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\n### Global vs Local Arrays\n\n```bash\n# Global (persists across functions)\ndeclare -gA memo_table\n\n# Local (only in function)\nmy_func() {\n    local -A temp_array\n}\n```\n\n### Common Operations\n\n```bash\n# Check if key exists\n[[ -v array[$key] ]]\n\n# Check if value is non-empty\n[[ -n \"${array[$key]}\" ]]\n\n# Delete key\nunset array[$key]\n\n# Array size\necho ${#array[@]}\n```", "answer_tailored": true}
{"pair_id": "bash-arrays_p1", "cluster_id": "bash-arrays", "question": "What's the difference between indexed and associative arrays?", "question_type": "medium", "answer": "The primary difference between indexed and associative arrays in Bash is the type of key used to access data: **indexed arrays** use zero-based integers, while **associative arrays** (available in Bash 4.0+) use strings as keys.\n\n### Indexed Arrays\nIndexed arrays are the default and do not require special declaration. They are ideal for ordered lists.\n```bash\n# Initialization and access\nfruits=(apple banana cherry)\necho ${fruits[0]}    # apple\necho ${fruits[@]}    # All elements: apple banana cherry\n```\n\n### Associative Arrays\nAssociative arrays **must** be explicitly declared using the `-A` flag. They function like maps or dictionaries, allowing for lexical keys.\n```bash\ndeclare -A colors\ncolors[sky]=blue\ncolors[grass]=green\n\necho ${colors[sky]}   # blue\necho ${!colors[@]}    # All keys: sky grass\necho ${colors[@]}     # All values: blue green\n```\n\n### Key Distinctions and Usage in UnifyWeaver\n*   **Declaration:** Indexed arrays are created with `name=(...)`; associative arrays require `declare -A name`.\n*   **Performance:** Associative arrays provide O(1) constant-time lookups. UnifyWeaver leverages this for deduplication (tracking `visited` nodes) and fact storage (e.g., `parent_data[alice:bob]=1`).\n*   **Existence Checks:** Use `[[ -v array[$key] ]]` to verify if a key exists, or `[[ -n \"${array[$key]}\" ]]` to check if a value is non-empty.\n*   **Scoping:** Within functions, use `local -A` to ensure the array does not leak into the global scope. For persistent caches like memoization tables, use `declare -gA`.\n\nFor more details on variable scoping and array management within the Bash target, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["associative-arrays", "declare", "hash-table", "indexed-arrays"], "original_answer": "## Bash Arrays\n\nBash supports two types of arrays: indexed and associative.\n\n### Indexed Arrays\n\n```bash\n# Declare and initialize\nfruits=(apple banana cherry)\n\n# Access by index\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\n\n# All elements\necho ${fruits[@]}    # apple banana cherry\n```\n\n### Associative Arrays\n\n```bash\n# MUST declare with -A\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n\n# All keys\necho ${!colors[@]}    # sky grass sun\n\n# All values\necho ${colors[@]}     # blue green yellow\n```\n\n### Why UnifyWeaver Uses Associative Arrays\n\n**1. O(1) Lookup**\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Deduplication (visited tracking)**\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Fact Storage**\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\n### Global vs Local Arrays\n\n```bash\n# Global (persists across functions)\ndeclare -gA memo_table\n\n# Local (only in function)\nmy_func() {\n    local -A temp_array\n}\n```\n\n### Common Operations\n\n```bash\n# Check if key exists\n[[ -v array[$key] ]]\n\n# Check if value is non-empty\n[[ -n \"${array[$key]}\" ]]\n\n# Delete key\nunset array[$key]\n\n# Array size\necho ${#array[@]}\n```", "answer_tailored": true}
{"pair_id": "bash-arrays_p2", "cluster_id": "bash-arrays", "question": "How do I declare an associative array in bash?", "question_type": "medium", "answer": "To declare an associative array in Bash, you must use the `declare -A` command. Unlike indexed arrays, associative arrays allow you to use string keys for data retrieval.\n\n### Declaration and Usage\n```bash\n# Explicit declaration is required\ndeclare -A user_data\n\n# Assigning values via string keys\nuser_data[username]=\"admin\"\nuser_data[role]=\"superuser\"\n\n# Inline initialization\ndeclare -A colors=([sky]=\"blue\" [grass]=\"green\")\n\n# Accessing a value by key\necho \"${user_data[username]}\"  # Output: admin\n```\n\n### Scope and Visibility\n*   **Local Scope:** Use `local -A array_name` inside functions to restrict the array's visibility.\n*   **Global Scope:** Use `declare -gA array_name` to ensure the array persists across different scopes.\n\n### Common Operations\n*   **List all keys:** `${!user_data[@]}`\n*   **List all values:** `${user_data[@]}`\n*   **Check if a key exists:** `[[ -v user_data[$key] ]]`\n*   **Get total element count:** `${#user_data[@]}`\n*   **Remove a specific key:** `unset user_data[$key]`\n\n### Why UnifyWeaver Uses Associative Arrays\nUnifyWeaver leverages associative arrays for O(1) performance in critical tasks such as:\n1.  **Fact Storage:** Storing relationships (e.g., `parent_data[alice:bob]=1`).\n2.  **Deduplication:** Tracking visited nodes during recursion to prevent infinite loops.\n3.  **Constant-time Lookups:** Quickly verifying the existence of keys without iterating.\n\nFor more information on variable scoping and array management within Bash targets, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["associative-arrays", "declare", "hash-table", "indexed-arrays"], "original_answer": "## Bash Arrays\n\nBash supports two types of arrays: indexed and associative.\n\n### Indexed Arrays\n\n```bash\n# Declare and initialize\nfruits=(apple banana cherry)\n\n# Access by index\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\n\n# All elements\necho ${fruits[@]}    # apple banana cherry\n```\n\n### Associative Arrays\n\n```bash\n# MUST declare with -A\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n\n# All keys\necho ${!colors[@]}    # sky grass sun\n\n# All values\necho ${colors[@]}     # blue green yellow\n```\n\n### Why UnifyWeaver Uses Associative Arrays\n\n**1. O(1) Lookup**\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Deduplication (visited tracking)**\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Fact Storage**\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\n### Global vs Local Arrays\n\n```bash\n# Global (persists across functions)\ndeclare -gA memo_table\n\n# Local (only in function)\nmy_func() {\n    local -A temp_array\n}\n```\n\n### Common Operations\n\n```bash\n# Check if key exists\n[[ -v array[$key] ]]\n\n# Check if value is non-empty\n[[ -n \"${array[$key]}\" ]]\n\n# Delete key\nunset array[$key]\n\n# Array size\necho ${#array[@]}\n```", "answer_tailored": true}
{"pair_id": "bash-arrays_p3", "cluster_id": "bash-arrays", "question": "Why does UnifyWeaver use associative arrays?", "question_type": "medium", "answer": "UnifyWeaver uses Bash associative arrays to provide efficient data structures for compiled Prolog logic, specifically for high-performance lookups, cycle detection, and fact management.\n\n**Primary Use Cases in UnifyWeaver:**\n\n*   **O(1) Constant Time Lookups**: Associative arrays allow UnifyWeaver to verify the existence of a fact or retrieve a value instantly, regardless of the dataset size.\n    ```bash\n    # Constant time existence check\n    [[ -v parent_data[$key] ]] && echo \"Fact exists\"\n    ```\n*   **Recursive Deduplication (Visited Tracking)**: To handle recursive queries safely, UnifyWeaver tracks visited states to avoid infinite loops.\n    ```bash\n    declare -A visited\n    if [[ -z \"${visited[$node]}\" ]]; then\n        visited[$node]=1\n        process_node \"$node\"\n    fi\n    ```\n*   **Fact Representation**: Relationships between entities are stored using string keys, often concatenating arguments to represent multi-arity Prolog facts.\n    ```bash\n    declare -A parent_data=( [alice:bob]=1 [bob:charlie]=1 )\n    ```\n\n**Scope and Management:**\n\n*   **Global Memoization**: Tables used for memoizing recursive results are declared globally with `declare -gA`.\n*   **Local State**: Temporary processing arrays within functions use `local -A`.\n*   **Lifecycle**: Keys are removed using `unset array[$key]` and the total count of stored facts can be retrieved via `${#array[@]}`.\n\nWhile Bash also supports indexed arrays (e.g., `fruits=(apple banana)`), their O(N) lookup time makes them unsuitable for the primary fact-checking logic generated by UnifyWeaver.\n\nFor more information on Bash variable scoping and process substitution, refer to `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["associative-arrays", "declare", "hash-table", "indexed-arrays"], "original_answer": "## Bash Arrays\n\nBash supports two types of arrays: indexed and associative.\n\n### Indexed Arrays\n\n```bash\n# Declare and initialize\nfruits=(apple banana cherry)\n\n# Access by index\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\n\n# All elements\necho ${fruits[@]}    # apple banana cherry\n```\n\n### Associative Arrays\n\n```bash\n# MUST declare with -A\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n\n# All keys\necho ${!colors[@]}    # sky grass sun\n\n# All values\necho ${colors[@]}     # blue green yellow\n```\n\n### Why UnifyWeaver Uses Associative Arrays\n\n**1. O(1) Lookup**\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Deduplication (visited tracking)**\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Fact Storage**\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\n### Global vs Local Arrays\n\n```bash\n# Global (persists across functions)\ndeclare -gA memo_table\n\n# Local (only in function)\nmy_func() {\n    local -A temp_array\n}\n```\n\n### Common Operations\n\n```bash\n# Check if key exists\n[[ -v array[$key] ]]\n\n# Check if value is non-empty\n[[ -n \"${array[$key]}\" ]]\n\n# Delete key\nunset array[$key]\n\n# Array size\necho ${#array[@]}\n```", "answer_tailored": true}
{"pair_id": "bash-redirections_p0", "cluster_id": "bash-redirections", "question": "How do bash redirections and file descriptors work?", "question_type": "medium", "answer": "Bash manages data streams using **File Descriptors (FDs)**, which are integer references to open files or I/O channels. By default, every process starts with three standard streams:\n*   **0 (stdin):** Standard Input (defaults to keyboard)\n*   **1 (stdout):** Standard Output (defaults to terminal)\n*   **2 (stderr):** Standard Error (defaults to terminal)\n\n### Core Redirection Syntax\nRedirection operators allow you to reroute these streams to files or other descriptors:\n- **Output Redirection (`>` and `>>`):** Use `command > file` to overwrite a file with stdout, or `command >> file` to append data to the end of it.\n- **Input Redirection (`<`):** Use `command < file` to feed the contents of a file into a command's stdin.\n- **Error Redirection (`2>`):** Specifically capture error messages using `command 2> error.log`.\n- **Combined Streams:** Use `&> file` or `command > file 2>&1` to redirect both stdout and stderr to the same destination.\n\n### Inline Data Handling\n- **Here Documents (`<<EOF`):** Used to pass multiple lines of text as stdin within a script.\n- **Here Strings (`<<<`):** A concise way to pass a single string or variable as stdin.\n\n### Process Substitution and FDs\nProcess substitution (`<(command)`) is a powerful feature that creates an ephemeral file descriptor (e.g., `/dev/fd/63`) containing the command's output. This allows Bash to treat the output of a process as if it were a physical file.\n\n### Role in UnifyWeaver\nUnifyWeaver relies on these redirection patterns to ensure efficient data streaming between compiled predicates. For example, it uses the `< <(command)` pattern to pipe data into loops without spawning a subshell, which ensures that variable changes made inside the loop persist in the main script:\n\n```bash\n# UnifyWeaver streaming pattern\nwhile read -r record; do\n    process_data \"$record\"\ndone < <(source_command)\n```\n\nDetailed technical explanations of these Bash execution mechanics can be found in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["file-descriptors", "redirection", "stdin", "stdout", "stderr"], "original_answer": "## Bash Redirections and File Descriptors\n\nFile descriptors are integer references to open files/streams.\n\n### Standard Descriptors\n\n| FD | Name | Default |\n|----|------|--------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Terminal (errors) |\n\n### Basic Redirections\n\n```bash\n# Redirect stdout to file\ncommand > output.txt\n\n# Redirect stdin from file\ncommand < input.txt\n\n# Redirect stderr to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or (bash 4+)\ncommand &> output.txt\n```\n\n### Append vs Overwrite\n\n```bash\n# Overwrite\necho \"new\" > file.txt\n\n# Append\necho \"more\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document (multi-line input)\ncat <<EOF\nLine 1\nLine 2\nEOF\n\n# Here string (single string as input)\nread var <<< \"hello world\"\n```\n\n### Process Substitution and FDs\n\n```bash\n# <(...) creates a file descriptor\necho <(echo hello)\n# Output: /dev/fd/63\n\n# < <(...) redirects stdin from that FD\nwhile read line; do\n    echo \"Got: $line\"\ndone < <(echo -e \"a\\nb\\nc\")\n```\n\n### Why This Matters for UnifyWeaver\n\nGenerated code uses these patterns:\n```bash\n# Read from command output without subshell\nwhile IFS=\":\" read -r from to; do\n    process \"$from\" \"$to\"\ndone < <(edge_stream)\n\n# Suppress errors\nresult=$(command 2>/dev/null)\n```", "answer_tailored": true}
{"pair_id": "bash-redirections_p1", "cluster_id": "bash-redirections", "question": "What are file descriptors 0, 1, and 2?", "question_type": "medium", "answer": "In Bash, file descriptors 0, 1, and 2 are integer references to the standard input, output, and error streams used by every process.\n\n*   **FD 0 (stdin):** Standard Input, which defaults to keyboard input.\n*   **FD 1 (stdout):** Standard Output, which defaults to the terminal for normal program results.\n*   **FD 2 (stderr):** Standard Error, which defaults to the terminal for error messages and diagnostics.\n\n### Common Redirections\nYou can control where these streams go using specific syntax:\n- `command < input.txt`: Reads input for FD 0 from a file.\n- `command > output.txt`: Sends FD 1 to a file (overwriting).\n- `command 2> errors.txt`: Sends FD 2 to a file.\n- `command &> combined.txt`: Redirects both stdout and stderr to the same location.\n\n### Application in UnifyWeaver\nUnifyWeaver utilizes these descriptors to manage data flow when compiling Prolog logic into Bash scripts. Key techniques include:\n- **Process Substitution:** Patterns like `while read line; do ... done < <(stream_command)` allow UnifyWeaver to feed the output of one process into the stdin of another without losing variable scope in a subshell.\n- **Stream Management:** Redirecting `2>/dev/null` is frequently used in generated code to suppress non-critical warnings during complex data joins or ingestions.\n\nFor more detailed examples of process substitution and stream handling, see **education/book-02-bash-target/04_variable_scope_and_process_substitution.md**.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["file-descriptors", "redirection", "stdin", "stdout", "stderr"], "original_answer": "## Bash Redirections and File Descriptors\n\nFile descriptors are integer references to open files/streams.\n\n### Standard Descriptors\n\n| FD | Name | Default |\n|----|------|--------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Terminal (errors) |\n\n### Basic Redirections\n\n```bash\n# Redirect stdout to file\ncommand > output.txt\n\n# Redirect stdin from file\ncommand < input.txt\n\n# Redirect stderr to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or (bash 4+)\ncommand &> output.txt\n```\n\n### Append vs Overwrite\n\n```bash\n# Overwrite\necho \"new\" > file.txt\n\n# Append\necho \"more\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document (multi-line input)\ncat <<EOF\nLine 1\nLine 2\nEOF\n\n# Here string (single string as input)\nread var <<< \"hello world\"\n```\n\n### Process Substitution and FDs\n\n```bash\n# <(...) creates a file descriptor\necho <(echo hello)\n# Output: /dev/fd/63\n\n# < <(...) redirects stdin from that FD\nwhile read line; do\n    echo \"Got: $line\"\ndone < <(echo -e \"a\\nb\\nc\")\n```\n\n### Why This Matters for UnifyWeaver\n\nGenerated code uses these patterns:\n```bash\n# Read from command output without subshell\nwhile IFS=\":\" read -r from to; do\n    process \"$from\" \"$to\"\ndone < <(edge_stream)\n\n# Suppress errors\nresult=$(command 2>/dev/null)\n```", "answer_tailored": true}
{"pair_id": "bash-redirections_p2", "cluster_id": "bash-redirections", "question": "What does < and > mean in bash?", "question_type": "medium", "answer": "In Bash, the `<` and `>` symbols are redirection operators used to control the flow of data between commands, files, and streams. Specifically, `>` handles output redirection, while `<` handles input redirection.\n\n### Standard Streams and File Descriptors\nBash uses integer file descriptors (FDs) to track data streams:\n*   **0 (stdin):** Standard input (defaults to keyboard).\n*   **1 (stdout):** Standard output (defaults to terminal).\n*   **2 (stderr):** Standard error (defaults to terminal).\n\n### Output Redirection (`>`)\nThe `>` operator directs a command's output away from the terminal and into a file or another stream:\n*   `command > file.txt`: Redirects stdout to a file, overwriting any existing content.\n*   `command >> file.txt`: Appends stdout to the end of the file instead of overwriting.\n*   `command 2> errors.txt`: Redirects only the error stream (stderr).\n*   `command &> file.txt`: Redirects both stdout and stderr to the same file.\n\n### Input Redirection (`<`)\nThe `<` operator allows a command to read data from a file or string instead of the keyboard:\n*   `command < input.txt`: Feeds the contents of a file into the command's stdin.\n*   `command <<EOF`: A \"Here Document,\" used for passing multiple lines of text as input.\n*   `read var <<< \"string\"`: A \"Here String,\" which passes a single string as input.\n\n### Redirection in UnifyWeaver\nUnifyWeaver generates Bash code that frequently uses these operators for efficient data handling. For example, it uses redirection combined with process substitution (`<(...)`) to stream data into loops without spawning subshells that would isolate variable changes:\n\n```bash\n# Streaming input from a command output directly into a loop\nwhile IFS=\":\" read -r key value; do\n    process_data \"$key\" \"$value\"\ndone < <(edge_stream_source)\n```\n\nFor more detailed information on how these operators are utilized in the Bash target, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["file-descriptors", "redirection", "stdin", "stdout", "stderr"], "original_answer": "## Bash Redirections and File Descriptors\n\nFile descriptors are integer references to open files/streams.\n\n### Standard Descriptors\n\n| FD | Name | Default |\n|----|------|--------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Terminal (errors) |\n\n### Basic Redirections\n\n```bash\n# Redirect stdout to file\ncommand > output.txt\n\n# Redirect stdin from file\ncommand < input.txt\n\n# Redirect stderr to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or (bash 4+)\ncommand &> output.txt\n```\n\n### Append vs Overwrite\n\n```bash\n# Overwrite\necho \"new\" > file.txt\n\n# Append\necho \"more\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document (multi-line input)\ncat <<EOF\nLine 1\nLine 2\nEOF\n\n# Here string (single string as input)\nread var <<< \"hello world\"\n```\n\n### Process Substitution and FDs\n\n```bash\n# <(...) creates a file descriptor\necho <(echo hello)\n# Output: /dev/fd/63\n\n# < <(...) redirects stdin from that FD\nwhile read line; do\n    echo \"Got: $line\"\ndone < <(echo -e \"a\\nb\\nc\")\n```\n\n### Why This Matters for UnifyWeaver\n\nGenerated code uses these patterns:\n```bash\n# Read from command output without subshell\nwhile IFS=\":\" read -r from to; do\n    process \"$from\" \"$to\"\ndone < <(edge_stream)\n\n# Suppress errors\nresult=$(command 2>/dev/null)\n```", "answer_tailored": true}
{"pair_id": "bash-redirections_p3", "cluster_id": "bash-redirections", "question": "How does redirection relate to process substitution?", "question_type": "medium", "answer": "Redirection relates to process substitution by providing the mechanism to consume the temporary file descriptors that process substitution creates. While process substitution (`<(command)`) generates a transient file path\u2014often seen as `/dev/fd/62`\u2014it requires the redirection operator (`<`) to feed that stream into a command's standard input.\n\nThis relationship is most visible in the syntax `command < <(subcommand)`, where the first `<` is the redirection operator and the `<(...)` is the process substitution itself. In UnifyWeaver\u2019s Bash target, this combination is preferred over standard pipes (`|`) because it prevents the receiving command (such as a `while` loop) from running in a subshell, which is critical for preserving variable scope in the main process.\n\nKey technical components include:\n- **File Descriptors:** Integers (0 for stdin, 1 for stdout, 2 for stderr) that reference open streams.\n- **Input Redirection (`<`):** Directs the content of a file or file descriptor into a command.\n- **Process Substitution (`<(...)`):** Executes a command and makes its output available via a temporary file descriptor.\n\nBy combining these, UnifyWeaver can read from command outputs without losing state, as seen in patterns like `done < <(edge_stream)`. For a comprehensive guide on variable scope and stream management, see `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["file-descriptors", "redirection", "stdin", "stdout", "stderr"], "original_answer": "## Bash Redirections and File Descriptors\n\nFile descriptors are integer references to open files/streams.\n\n### Standard Descriptors\n\n| FD | Name | Default |\n|----|------|--------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Terminal (errors) |\n\n### Basic Redirections\n\n```bash\n# Redirect stdout to file\ncommand > output.txt\n\n# Redirect stdin from file\ncommand < input.txt\n\n# Redirect stderr to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or (bash 4+)\ncommand &> output.txt\n```\n\n### Append vs Overwrite\n\n```bash\n# Overwrite\necho \"new\" > file.txt\n\n# Append\necho \"more\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document (multi-line input)\ncat <<EOF\nLine 1\nLine 2\nEOF\n\n# Here string (single string as input)\nread var <<< \"hello world\"\n```\n\n### Process Substitution and FDs\n\n```bash\n# <(...) creates a file descriptor\necho <(echo hello)\n# Output: /dev/fd/63\n\n# < <(...) redirects stdin from that FD\nwhile read line; do\n    echo \"Got: $line\"\ndone < <(echo -e \"a\\nb\\nc\")\n```\n\n### Why This Matters for UnifyWeaver\n\nGenerated code uses these patterns:\n```bash\n# Read from command output without subshell\nwhile IFS=\":\" read -r from to; do\n    process \"$from\" \"$to\"\ndone < <(edge_stream)\n\n# Suppress errors\nresult=$(command 2>/dev/null)\n```", "answer_tailored": true}
{"pair_id": "bash-trap_p0", "cluster_id": "bash-trap", "question": "What does the trap command do in bash?", "question_type": "medium", "answer": "In Bash, the `trap` command is used to register handlers\u2014specific commands or functions\u2014that are executed when the shell receives system signals or encounters certain execution events. This mechanism is essential for ensuring that scripts clean up after themselves and handle interruptions gracefully.\n\n### Basic Syntax\n```bash\ntrap 'commands_to_execute' SIGNAL [SIGNAL ...]\n```\n\n### Frequently Used Signals\n*   **EXIT**: Triggered when the script finishes for any reason (normal completion or error).\n*   **INT**: Triggered by an interrupt signal, typically when the user presses Ctrl+C.\n*   **TERM**: Triggered when the script receives a generic termination signal.\n*   **PIPE**: Triggered when a pipe is broken (e.g., if a downstream reader like `head` closes before the script finishes writing).\n*   **ERR**: Triggered whenever a command within the script returns a non-zero exit status.\n\n### Standard Cleanup Pattern\nThe most common application of `trap` is managing the lifecycle of temporary files:\n```bash\n# Create a temporary file\ntmp_data=$(mktemp)\n\n# Register a cleanup command to run automatically on exit\ntrap \"rm -f $tmp_data\" EXIT\n\n# The file will be deleted whether the script succeeds or fails\nprocess_data \"$tmp_data\"\n```\n\n### UnifyWeaver Implementation\nUnifyWeaver's Bash target relies on `trap` to manage internal state during operations like recursive queries or graph traversals. For instance, in a Breadth-First Search (BFS) implementation:\n```bash\ncompute_reaches() {\n    local queue_file=\"/tmp/weaver_queue_$$\"\n    \n    # Ensure temporary files are removed on exit or if the pipeline is cut short\n    trap \"rm -f $queue_file\" EXIT PIPE\n    \n    # ... logic for traversing data ...\n}\n```\nTrapping **PIPE** is particularly important for UnifyWeaver. If a user runs a query and pipes the output to `head -n 1`, the shell sends a `SIGPIPE` once the requirement is met. Without the `PIPE` trap, the script might terminate immediately and leave stale temporary files on the system.\n\n### Advanced Controls\n*   **Ignoring signals**: Use an empty string to ignore a signal (e.g., `trap '' INT` to disable Ctrl+C).\n*   **Resetting signals**: Use a dash to restore default behavior (e.g., `trap - EXIT`).\n*   **Cumulative traps**: When adding logic to an existing trap, ensure you don't overwrite previous handlers unless intended.\n\nFor further details on how the Bash target manages process substitution and signal scopes, refer to `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["trap", "signals", "cleanup", "EXIT", "PIPE"], "original_answer": "## Bash Trap Command\n\nThe `trap` command registers handlers for signals and events.\n\n### Basic Syntax\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\n### Common Signals\n\n| Signal | When Triggered |\n|--------|---------------|\n| EXIT | Script exits (any reason) |\n| INT | Ctrl+C pressed |\n| TERM | Kill signal received |\n| PIPE | Broken pipe (reader closed) |\n| ERR | Command returns non-zero |\n\n### Cleanup Pattern\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Why EXIT and PIPE?\n\n- **EXIT**: Normal termination, errors, Ctrl+C\n- **PIPE**: Reader closes pipe early (e.g., `head -1`)\n\nWithout PIPE trap:\n```bash\nreaches_all \"a\" | head -1\n# Temp files might not be cleaned up!\n```\n\n### Multiple Traps\n\n```bash\n# Add to existing trap (don't replace)\ntrap 'echo \"Cleaning up...\"; rm -f $tmp' EXIT\n\n# Reset trap\ntrap - EXIT\n\n# Ignore signal\ntrap '' INT  # Ctrl+C ignored\n```", "answer_tailored": true}
{"pair_id": "bash-trap_p1", "cluster_id": "bash-trap", "question": "How do I clean up temp files on exit?", "question_type": "medium", "answer": "To automatically clean up temporary files upon exit, use the Bash `trap` command to register removal logic against the `EXIT` signal. This ensures that resources are released regardless of whether the script finishes normally or terminates due to an error.\n\n### Implementation Pattern\nThe standard approach involves creating a file with `mktemp` and immediately setting a trap to remove it:\n\n```bash\n# Generate unique temp file\ntmp_file=$(mktemp)\n\n# Ensure removal on exit\ntrap \"rm -f $tmp_file\" EXIT\n\n# Safe to use $tmp_file here...\n```\n\n### Handling Pipelines and SIGPIPE\nIn UnifyWeaver's generated code, it is critical to trap the `PIPE` signal as well. This prevents stale files if a downstream command (such as `head -n 1`) closes the pipeline early, which would otherwise bypass a simple `EXIT` trap in some environments:\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on normal EXIT or broken PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic utilizing temp files ...\n}\n```\n\n### Essential Signals for Cleanup\n| Signal | Trigger Event |\n|--------|---------------|\n| **EXIT** | Triggered when the shell script exits for any reason. |\n| **PIPE** | Triggered when a reader closes the pipe early (crucial for streaming). |\n| **INT** | Triggered by a user interrupt (Ctrl+C). |\n| **TERM** | Triggered by a termination/kill signal. |\n| **ERR** | Triggered when a command returns a non-zero exit status. |\n\n### Advanced Trap Management\n- **Resetting**: Use `trap - EXIT` to restore default exit behavior.\n- **Ignoring**: Use `trap '' INT` to make the script ignore specific signals like Ctrl+C.\n- **Modification**: Be careful when setting new traps, as a new `trap` command for the same signal will overwrite the previous one unless logic is included to append to the existing handler.\n\nFor a comprehensive guide on process management and variable scope within the Bash target, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["trap", "signals", "cleanup", "EXIT", "PIPE"], "original_answer": "## Bash Trap Command\n\nThe `trap` command registers handlers for signals and events.\n\n### Basic Syntax\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\n### Common Signals\n\n| Signal | When Triggered |\n|--------|---------------|\n| EXIT | Script exits (any reason) |\n| INT | Ctrl+C pressed |\n| TERM | Kill signal received |\n| PIPE | Broken pipe (reader closed) |\n| ERR | Command returns non-zero |\n\n### Cleanup Pattern\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Why EXIT and PIPE?\n\n- **EXIT**: Normal termination, errors, Ctrl+C\n- **PIPE**: Reader closes pipe early (e.g., `head -1`)\n\nWithout PIPE trap:\n```bash\nreaches_all \"a\" | head -1\n# Temp files might not be cleaned up!\n```\n\n### Multiple Traps\n\n```bash\n# Add to existing trap (don't replace)\ntrap 'echo \"Cleaning up...\"; rm -f $tmp' EXIT\n\n# Reset trap\ntrap - EXIT\n\n# Ignore signal\ntrap '' INT  # Ctrl+C ignored\n```", "answer_tailored": true}
{"pair_id": "bash-trap_p2", "cluster_id": "bash-trap", "question": "Why use trap with EXIT and PIPE?", "question_type": "medium", "answer": "Using `trap` with both `EXIT` and `PIPE` ensures that temporary resources, such as files or named pipes, are reliably cleaned up regardless of how a script or function terminates. While `EXIT` covers normal completion, manual interruptions (Ctrl+C), and fatal errors, the `PIPE` signal is crucial when a command is used within a pipeline.\n\n### The Importance of PIPE\nIn UnifyWeaver's compiled Bash code, functions often utilize temporary files for complex logic like Breadth-First Search (BFS). If a user pipes the output of such a function to a command that terminates early (e.g., `reaches_all \"node\" | head -n 5`), the shell sends a `SIGPIPE` to the producer. Without a specific trap for `PIPE`, the function might terminate immediately and leave orphaned temporary files in the system.\n\n### Common Signal Handlers\n| Signal | Trigger Event |\n|--------|---------------|\n| **EXIT** | Triggered when the script or function exits for any reason. |\n| **PIPE** | Triggered by a broken pipe (e.g., a downstream reader closes early). |\n| **INT** | Triggered by an interrupt signal (Ctrl+C). |\n| **ERR** | Triggered when a command returns a non-zero exit status. |\n\n### Implementation Pattern\nUnifyWeaver generates cleanup logic that typically follows this structure:\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Ensures cleanup on both standard exit and broken pipes\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS or recursive logic ...\n}\n```\n\nBy combining these signals, UnifyWeaver maintains system hygiene even in interrupted streaming contexts. For a deeper dive into how variable scope and process substitution interact with these traps, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["trap", "signals", "cleanup", "EXIT", "PIPE"], "original_answer": "## Bash Trap Command\n\nThe `trap` command registers handlers for signals and events.\n\n### Basic Syntax\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\n### Common Signals\n\n| Signal | When Triggered |\n|--------|---------------|\n| EXIT | Script exits (any reason) |\n| INT | Ctrl+C pressed |\n| TERM | Kill signal received |\n| PIPE | Broken pipe (reader closed) |\n| ERR | Command returns non-zero |\n\n### Cleanup Pattern\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Why EXIT and PIPE?\n\n- **EXIT**: Normal termination, errors, Ctrl+C\n- **PIPE**: Reader closes pipe early (e.g., `head -1`)\n\nWithout PIPE trap:\n```bash\nreaches_all \"a\" | head -1\n# Temp files might not be cleaned up!\n```\n\n### Multiple Traps\n\n```bash\n# Add to existing trap (don't replace)\ntrap 'echo \"Cleaning up...\"; rm -f $tmp' EXIT\n\n# Reset trap\ntrap - EXIT\n\n# Ignore signal\ntrap '' INT  # Ctrl+C ignored\n```", "answer_tailored": true}
{"pair_id": "bash-trap_p3", "cluster_id": "bash-trap", "question": "What signals can trap handle?", "question_type": "medium", "answer": "The Bash `trap` command is used to capture and handle a variety of system signals and shell-specific events, ensuring scripts can perform necessary cleanup or error logging.\n\n### Supported Signals and Events\nThe most common signals handled by `trap` include:\n- **EXIT**: Triggered whenever the script terminates, whether due to successful completion, an error, or an external signal.\n- **INT (Interrupt)**: Sent when the user interrupts the process, typically via `Ctrl+C`.\n- **TERM (Termination)**: The standard signal used by the `kill` command to request a process stop.\n- **PIPE**: Occurs when a process tries to write to a pipe that has already been closed by the reader (e.g., when using `head`).\n- **ERR**: A special shell event that triggers the handler whenever a command returns a non-zero exit status.\n\n### Usage in UnifyWeaver\nUnifyWeaver frequently employs `trap` to manage temporary files during recursive operations. By registering a cleanup command for both `EXIT` and `PIPE`, the system ensures that temporary queue files are deleted even if a pipeline is terminated early.\n\n```bash\n# Example cleanup pattern for temporary files\ntrap \"rm -f $queue_file\" EXIT PIPE\n```\n\n### Signal Management\n- **Defining Traps**: `trap 'commands' SIGNAL` registers the handler.\n- **Ignoring Signals**: `trap '' SIGNAL` causes the script to ignore the specified signal (useful for preventing `Ctrl+C` from interrupting critical sections).\n- **Resetting**: `trap - SIGNAL` restores the default system behavior for that signal.\n\nFor detailed information on how these signals are utilized within generated code, refer to `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["trap", "signals", "cleanup", "EXIT", "PIPE"], "original_answer": "## Bash Trap Command\n\nThe `trap` command registers handlers for signals and events.\n\n### Basic Syntax\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\n### Common Signals\n\n| Signal | When Triggered |\n|--------|---------------|\n| EXIT | Script exits (any reason) |\n| INT | Ctrl+C pressed |\n| TERM | Kill signal received |\n| PIPE | Broken pipe (reader closed) |\n| ERR | Command returns non-zero |\n\n### Cleanup Pattern\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Why EXIT and PIPE?\n\n- **EXIT**: Normal termination, errors, Ctrl+C\n- **PIPE**: Reader closes pipe early (e.g., `head -1`)\n\nWithout PIPE trap:\n```bash\nreaches_all \"a\" | head -1\n# Temp files might not be cleaned up!\n```\n\n### Multiple Traps\n\n```bash\n# Add to existing trap (don't replace)\ntrap 'echo \"Cleaning up...\"; rm -f $tmp' EXIT\n\n# Reset trap\ntrap - EXIT\n\n# Ignore signal\ntrap '' INT  # Ctrl+C ignored\n```", "answer_tailored": true}
{"pair_id": "bash-string-ops_p0", "cluster_id": "bash-string-ops", "question": "What do ${string#pattern} and ${string%pattern} do?", "question_type": "medium", "answer": "In Bash, `${string#pattern}` and `${string%pattern}` are parameter expansion operations used to strip prefixes and suffixes from a string.\n\n*   **`${string#pattern}`**: Removes the **shortest** matching prefix from the beginning of the string.\n*   **`${string%pattern}`**: Removes the **shortest** matching suffix from the end of the string.\n\nIf you need to remove the **longest** matching pattern instead, you can double the symbols: `${string##pattern}` (longest prefix) and `${string%%pattern}` (longest suffix).\n\n### Application in UnifyWeaver\nUnifyWeaver frequently uses these expansions to clean up data structures during parsing, such as removing brackets from a list string:\n\n```bash\n# Example: Stripping list delimiters\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Removes the leading '['\nlist=\"${list%]}\"   # Removes the trailing ']'\n# Result: a,b,c\n```\n\nThese operations are highly efficient for recursive processing in the Bash target because they avoid the overhead of calling external utilities like `sed` or `awk`. Detailed examples of these expansions in the context of recursive compilation can be found in `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["string-manipulation", "parameter-expansion", "substring", "pattern-matching"], "original_answer": "## Bash String Operations\n\nBash has powerful string manipulation via parameter expansion.\n\n### Remove Prefix/Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from start\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from start\necho ${str##*/}   # (for paths)\n\n# Remove longest match from end\necho ${str%%/*}   # (for paths)\n```\n\n### UnifyWeaver List Parsing\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove [\nlist=\"${list%]}\"   # Remove ]\n# Result: a,b,c\n```\n\n### Substring Extraction\n\n```bash\nstr=\"hello world\"\n\n# From position 0, length 5\necho ${str:0:5}    # hello\n\n# From position 6\necho ${str:6}      # world\n\n# Single character at position\necho ${str:0:1}    # h\n```\n\n### String Length\n\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n### Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first occurrence\necho ${str/world/there}   # hello there world\n\n# Replace all occurrences\necho ${str//world/there}  # hello there there\n```\n\n### Pattern Matching in Conditions\n\n```bash\n# Regex match\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob match\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n### UnifyWeaver Tree Parsing\n\n```bash\n# Character-by-character iteration\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```", "answer_tailored": true}
{"pair_id": "bash-string-ops_p1", "cluster_id": "bash-string-ops", "question": "How does bash string manipulation work?", "question_type": "medium", "answer": "Bash handles string manipulation primarily through parameter expansion and built-in pattern matching, which UnifyWeaver leverages for parsing complex structures like lists and trees.\n\n### Trimming Prefixes and Suffixes\nYou can remove patterns from the beginning or end of a string using specific operators:\n- **Shortest match from start:** `${var#pattern}`\n- **Longest match from start:** `${var##pattern}`\n- **Shortest match from end:** `${var%pattern}`\n- **Longest match from end:** `${var%%pattern}`\n\nIn UnifyWeaver, this is often used to strip brackets from list strings:\n```bash\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"\nlist=\"${list%]}\" # Result: a,b,c\n```\n\n### Substring Extraction and Length\n- **Substring:** Use `${var:offset:length}`. For instance, `${str:0:5}` extracts the first five characters.\n- **Length:** Use `${#var}` to retrieve the total character count.\n\nUnifyWeaver's tree parsing logic utilizes these for character-by-character iteration:\n```bash\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```\n\n### Search and Replace\n- **First occurrence:** `${var/pattern/replacement}`\n- **Global replacement:** `${var//pattern/replacement}`\n\n### Conditional Pattern Matching\nBash supports both glob and regex matching within double brackets:\n- **Regex:** `if [[ \"$str\" =~ ^[0-9]+$ ]]; then ...`\n- **Glob:** `if [[ \"$str\" == *world* ]]; then ...`\n\nFor more advanced examples and recursive parsing implementations in the Bash target, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["string-manipulation", "parameter-expansion", "substring", "pattern-matching"], "original_answer": "## Bash String Operations\n\nBash has powerful string manipulation via parameter expansion.\n\n### Remove Prefix/Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from start\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from start\necho ${str##*/}   # (for paths)\n\n# Remove longest match from end\necho ${str%%/*}   # (for paths)\n```\n\n### UnifyWeaver List Parsing\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove [\nlist=\"${list%]}\"   # Remove ]\n# Result: a,b,c\n```\n\n### Substring Extraction\n\n```bash\nstr=\"hello world\"\n\n# From position 0, length 5\necho ${str:0:5}    # hello\n\n# From position 6\necho ${str:6}      # world\n\n# Single character at position\necho ${str:0:1}    # h\n```\n\n### String Length\n\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n### Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first occurrence\necho ${str/world/there}   # hello there world\n\n# Replace all occurrences\necho ${str//world/there}  # hello there there\n```\n\n### Pattern Matching in Conditions\n\n```bash\n# Regex match\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob match\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n### UnifyWeaver Tree Parsing\n\n```bash\n# Character-by-character iteration\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```", "answer_tailored": true}
{"pair_id": "bash-string-ops_p2", "cluster_id": "bash-string-ops", "question": "How do I remove prefixes and suffixes in bash?", "question_type": "medium", "answer": "In Bash, you can remove prefixes and suffixes using parameter expansion. This is a common technique used in UnifyWeaver for parsing structured strings like lists or file paths.\n\n### Removing Prefixes\nUse the `#` operator for the shortest match or `##` for the longest match from the beginning of the string:\n- `${var#prefix}`: Removes the shortest leading match.\n- `${var##prefix}`: Removes the longest leading match.\n\n### Removing Suffixes\nUse the `%` operator for the shortest match or `%%` for the longest match from the end of the string:\n- `${var%suffix}`: Removes the shortest trailing match.\n- `${var%%suffix}`: Removes the longest trailing match.\n\n### Practical Examples\nTo parse a bracketed list like `[a,b,c]` into a raw comma-separated string:\n```bash\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Removes leading '[' -> \"a,b,c]\"\nlist=\"${list%]}\"   # Removes trailing ']' -> \"a,b,c\"\n```\n\nTo extract a filename from a full path:\n```bash\npath=\"/path/to/file.txt\"\nfilename=\"${path##*/}\"  # Removes everything up to the last '/' -> \"file.txt\"\n```\n\nTo extract the directory from a full path:\n```bash\ndirectory=\"${path%/*}\"  # Removes the shortest match from the end starting with '/' -> \"/path/to\"\n```\n\nFor more advanced string manipulation and its application in recursive parsing within UnifyWeaver, see the documentation in `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["string-manipulation", "parameter-expansion", "substring", "pattern-matching"], "original_answer": "## Bash String Operations\n\nBash has powerful string manipulation via parameter expansion.\n\n### Remove Prefix/Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from start\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from start\necho ${str##*/}   # (for paths)\n\n# Remove longest match from end\necho ${str%%/*}   # (for paths)\n```\n\n### UnifyWeaver List Parsing\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove [\nlist=\"${list%]}\"   # Remove ]\n# Result: a,b,c\n```\n\n### Substring Extraction\n\n```bash\nstr=\"hello world\"\n\n# From position 0, length 5\necho ${str:0:5}    # hello\n\n# From position 6\necho ${str:6}      # world\n\n# Single character at position\necho ${str:0:1}    # h\n```\n\n### String Length\n\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n### Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first occurrence\necho ${str/world/there}   # hello there world\n\n# Replace all occurrences\necho ${str//world/there}  # hello there there\n```\n\n### Pattern Matching in Conditions\n\n```bash\n# Regex match\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob match\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n### UnifyWeaver Tree Parsing\n\n```bash\n# Character-by-character iteration\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```", "answer_tailored": true}
{"pair_id": "bash-string-ops_p3", "cluster_id": "bash-string-ops", "question": "What string operations does UnifyWeaver's generated code use?", "question_type": "medium", "answer": "UnifyWeaver's generated Bash code utilizes a variety of native string operations via parameter expansion to ensure high-performance data processing without external dependencies. These operations are critical for tasks like parsing recursive structures and validating data types.\n\n### Key String Operations Used\n\n*   **Prefix and Suffix Stripping:** The compiler uses `${str#[}` and `${str%]}` to remove shortest matches from the start or end of a string, or `${str##*}` and `${str%%*}` for longest matches. This is frequently used in parsing Prolog-style list syntax `[H|T]` by stripping the enclosing brackets.\n*   **Substring Extraction (Slicing):** Substrings are extracted using `${str:offset:length}`. For example, `${tree_str:i:1}` is used in tree parsing to inspect characters one by one during depth-first traversal.\n*   **String Length:** The `${#str}` operation provides the length of a string, which controls loop boundaries for character-by-character iteration.\n*   **Search and Replace:** Generated code uses `${str/pattern/replacement}` (first occurrence) and `${str//pattern/replacement}` (all occurrences) for efficient data transformation.\n*   **Pattern Matching:**\n    *   **Regex matching:** `[[ \"$str\" =~ ^[0-9]+$ ]]` is used for numeric and type constraints.\n    *   **Glob matching:** `[[ \"$str\" == *pattern* ]]` allows for efficient substring presence checks.\n\nThese operations allow the generated Bash targets to handle complex recursive parsing, such as character-level tree analysis, while maintaining the efficiency of a native script. For a deeper look at the Bash compilation strategy, see `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["string-manipulation", "parameter-expansion", "substring", "pattern-matching"], "original_answer": "## Bash String Operations\n\nBash has powerful string manipulation via parameter expansion.\n\n### Remove Prefix/Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from start\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from start\necho ${str##*/}   # (for paths)\n\n# Remove longest match from end\necho ${str%%/*}   # (for paths)\n```\n\n### UnifyWeaver List Parsing\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove [\nlist=\"${list%]}\"   # Remove ]\n# Result: a,b,c\n```\n\n### Substring Extraction\n\n```bash\nstr=\"hello world\"\n\n# From position 0, length 5\necho ${str:0:5}    # hello\n\n# From position 6\necho ${str:6}      # world\n\n# Single character at position\necho ${str:0:1}    # h\n```\n\n### String Length\n\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n### Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first occurrence\necho ${str/world/there}   # hello there world\n\n# Replace all occurrences\necho ${str//world/there}  # hello there there\n```\n\n### Pattern Matching in Conditions\n\n```bash\n# Regex match\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob match\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n### UnifyWeaver Tree Parsing\n\n```bash\n# Character-by-character iteration\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```", "answer_tailored": true}
