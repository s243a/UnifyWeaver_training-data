{"pair_id": "compiler-driver_p0", "cluster_id": "compiler-driver", "question": "What is the UnifyWeaver compiler driver?", "question_type": "medium", "answer": "The UnifyWeaver compiler driver is a module (`compiler_driver.pl`) that enables automated \"one-click\" compilation of Prolog predicates and their dependencies into target scripts. It simplifies the development workflow by handling the manual overhead of resolving predicate relationships.\n\nKey functions of the driver include:\n*   **Dependency Analysis**: Automatically scanning the source code to identify all predicates required by the target.\n*   **Recursive Compilation**: Building each dependency in the correct sequence before compiling the main predicate.\n*   **Cycle & Redundancy Tracking**: Preventing infinite loops and redundant compilation of shared dependencies.\n*   **Resource Mapping**: Returning a list of all generated script paths for easy integration into test runners or larger pipelines.\n\nYou can invoke the driver using the `compile/3` predicate:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n% Compile a predicate and all its dependencies recursively\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\nBy providing a unified manifest of generated files, the driver allows developers to easily source all necessary components in a single execution script or test runner. For more details on recursive compilation and its application to the Bash target, see `education/book-02-bash-target/09_recursive_compilation.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compiler-driver", "one-click-compilation", "dependency-resolution"], "original_answer": "## The Compiler Driver\n\nThe `compiler_driver.pl` module provides **one-click compilation** with automatic dependency resolution.\n\n### The Problem\n\nManual compilation requires:\n1. Compile `parent/2` facts \u2192 `parent.sh`\n2. Compile `ancestor/2` rule \u2192 `ancestor.sh`\n\nThis is tedious and error-prone for complex projects.\n\n### The Solution: compile/3\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n?- ['education/family_tree'].\n\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One call compiles everything!**\n\n### How It Works\n\n1. **Dependency Analysis**: Scans predicate to find dependencies\n2. **Recursive Compilation**: Compiles each dependency first\n3. **Tracks Compiled**: Avoids redundant work and infinite loops\n4. **Compiles Target**: Finally compiles requested predicate\n5. **Returns List**: All generated script paths\n\n### Generating Test Runners\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nThe `Scripts` variable gives the exact files to source.", "answer_tailored": true}
{"pair_id": "compiler-driver_p1", "cluster_id": "compiler-driver", "question": "How do I compile with automatic dependency resolution?", "question_type": "medium", "answer": "To compile with automatic dependency resolution in UnifyWeaver, you should use the `compiler_driver.pl` module and its primary predicate, `compile/3`. This module handles \"one-click compilation\" by automatically identifying and processing all dependencies for a requested predicate.\n\n### Implementation\n\nFirst, ensure the compiler driver and your logic are loaded:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- ['path/to/your_logic.pl'].\n```\n\nYou can then trigger the recursive compilation by specifying the predicate and an output directory:\n\n```prolog\n?- compile(my_predicate/2, [output_dir('output')], Scripts).\n```\n\n### Automation Workflow\n\nThe compiler driver simplifies complex builds through several key mechanisms:\n*   **Automatic Dependency Discovery**: It scans the predicate definitions to build a dependency tree.\n*   **Recursive Processing**: It ensures that every required fact or rule is compiled into its target language equivalent before the main predicate.\n*   **State Tracking**: It prevents infinite recursion and redundant compilation by keeping a record of already-processed components.\n*   **Path Management**: The `Scripts` variable captures a list of every generated script path, which is essential for building runners or deployment packages.\n\n### Example: Generating a Shell Runner\n\nYou can use the output of `compile/3` to create a master Bash script that sources all necessary dependencies:\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    format(S, \"#!/bin/bash\\n\", []),\n    forall(member(Script, Scripts), format(S, \"source ~w\\n\", [Script])),\n    close(S).\n```\n\nFor more information on the compiler driver's internals and dependency management, see `education/book-02-bash-target/09_recursive_compilation.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compiler-driver", "one-click-compilation", "dependency-resolution"], "original_answer": "## The Compiler Driver\n\nThe `compiler_driver.pl` module provides **one-click compilation** with automatic dependency resolution.\n\n### The Problem\n\nManual compilation requires:\n1. Compile `parent/2` facts \u2192 `parent.sh`\n2. Compile `ancestor/2` rule \u2192 `ancestor.sh`\n\nThis is tedious and error-prone for complex projects.\n\n### The Solution: compile/3\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n?- ['education/family_tree'].\n\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One call compiles everything!**\n\n### How It Works\n\n1. **Dependency Analysis**: Scans predicate to find dependencies\n2. **Recursive Compilation**: Compiles each dependency first\n3. **Tracks Compiled**: Avoids redundant work and infinite loops\n4. **Compiles Target**: Finally compiles requested predicate\n5. **Returns List**: All generated script paths\n\n### Generating Test Runners\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nThe `Scripts` variable gives the exact files to source.", "answer_tailored": true}
{"pair_id": "compiler-driver_p2", "cluster_id": "compiler-driver", "question": "What does compile/3 do?", "question_type": "medium", "answer": "`compile/3` is the core predicate of the UnifyWeaver compiler driver, designed to automate the compilation process by resolving and building predicate dependencies recursively. It eliminates the need for manual, multi-step compilation of individual facts and rules.\n\nWhen invoked, `compile/3` performs the following actions:\n1.  **Dependency Analysis**: It scans the target predicate to identify all required sub-predicates.\n2.  **Recursive Compilation**: It ensures every dependency is compiled into the target language before processing the requested predicate.\n3.  **Cyclic Protection**: It tracks previously compiled predicates to prevent infinite loops and redundant file generation.\n4.  **Path Collection**: It returns a list of all generated script paths in the order they should be sourced or executed.\n\n**Usage Example:**\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\nThis predicate is essential for creating automated test runners or deployment scripts, as the `Scripts` output provides the exact file list needed to source the environment. Detailed implementation details and examples can be found in `education/book-02-bash-target/09_recursive_compilation.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compiler-driver", "one-click-compilation", "dependency-resolution"], "original_answer": "## The Compiler Driver\n\nThe `compiler_driver.pl` module provides **one-click compilation** with automatic dependency resolution.\n\n### The Problem\n\nManual compilation requires:\n1. Compile `parent/2` facts \u2192 `parent.sh`\n2. Compile `ancestor/2` rule \u2192 `ancestor.sh`\n\nThis is tedious and error-prone for complex projects.\n\n### The Solution: compile/3\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n?- ['education/family_tree'].\n\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One call compiles everything!**\n\n### How It Works\n\n1. **Dependency Analysis**: Scans predicate to find dependencies\n2. **Recursive Compilation**: Compiles each dependency first\n3. **Tracks Compiled**: Avoids redundant work and infinite loops\n4. **Compiles Target**: Finally compiles requested predicate\n5. **Returns List**: All generated script paths\n\n### Generating Test Runners\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nThe `Scripts` variable gives the exact files to source.", "answer_tailored": true}
{"pair_id": "compiler-driver_p3", "cluster_id": "compiler-driver", "question": "How is one-click compilation achieved?", "question_type": "medium", "answer": "One-click compilation in UnifyWeaver is achieved through the **`compiler_driver.pl`** module, specifically using the **`compile/3`** predicate. This tool automates the entire build process by resolving dependencies that would otherwise require manual, error-prone compilation of individual facts and rules.\n\n### How `compile/3` Works\nThe driver simplifies the workflow into a single Prolog call:\n1.  **Dependency Analysis**: It scans the target predicate to identify all required sub-predicates.\n2.  **Recursive Compilation**: It ensures every dependency is compiled first before processing the requested predicate.\n3.  **Redundancy Tracking**: The system tracks which components have already been built to prevent infinite loops and unnecessary re-compilation.\n4.  **Path Aggregation**: It returns a list of all generated script paths, allowing for easy integration into test runners or master scripts.\n\n### Usage Example\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- ['path/to/source'].\n\n% Compiles the predicate and all its dependencies into the output directory\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\nBy using the `Scripts` list returned by the driver, you can automatically generate test runners that source all necessary components in the correct order. For a detailed breakdown of the recursive compilation logic, refer to `education/book-02-bash-target/09_recursive_compilation.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compiler-driver", "one-click-compilation", "dependency-resolution"], "original_answer": "## The Compiler Driver\n\nThe `compiler_driver.pl` module provides **one-click compilation** with automatic dependency resolution.\n\n### The Problem\n\nManual compilation requires:\n1. Compile `parent/2` facts \u2192 `parent.sh`\n2. Compile `ancestor/2` rule \u2192 `ancestor.sh`\n\nThis is tedious and error-prone for complex projects.\n\n### The Solution: compile/3\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n?- ['education/family_tree'].\n\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One call compiles everything!**\n\n### How It Works\n\n1. **Dependency Analysis**: Scans predicate to find dependencies\n2. **Recursive Compilation**: Compiles each dependency first\n3. **Tracks Compiled**: Avoids redundant work and infinite loops\n4. **Compiles Target**: Finally compiles requested predicate\n5. **Returns List**: All generated script paths\n\n### Generating Test Runners\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nThe `Scripts` variable gives the exact files to source.", "answer_tailored": true}
{"pair_id": "compile-api-reference_p0", "cluster_id": "compile-api-reference", "question": "What is the difference between compile/3 and compile_recursive/3?", "question_type": "medium", "answer": "The primary difference between `compile/3` and `compile_recursive/3` is how they handle dependency resolution. `compile/3` is the recommended high-level interface that automatically identifies and generates code for all supporting predicates required by your target, whereas `compile_recursive/3` is a lower-level tool that compiles only the specific predicate provided without resolving its dependencies.\n\n### compile/3 (High-Level API)\nThis is the standard entry point for most compilation tasks. It traverses the predicate's dependency tree to ensure all required logic is included in the output.\n- **Usage:** `compile(Predicate, Options, GeneratedScripts)`\n- **Behavior:** Automatically generates files for the requested predicate and its sub-predicates (e.g., compiling `ancestor/2` would also produce `parent.sh` if needed).\n- **Common Options:** Includes `output_dir(Dir)`, `target(bash)`, and `unique(true/false)`.\n\n### compile_recursive/3 (Low-Level/Internal)\nThis interface is typically used when you need granular control or are manually managing dependencies.\n- **Usage:** `compile_recursive(Predicate, Options, GeneratedCode)`\n- **Behavior:** It compiles *only* the single specified predicate. It does not look for or generate code for any other predicates called within the body.\n- **Output:** Returns the generated code directly rather than a list of file paths.\n\n### Summary Comparison\n| Feature | compile/3 | compile_recursive/3 |\n|---------|-----------|---------------------|\n| **Primary Use** | Standard compilation | Manual/Advanced control |\n| **Dependency Handling** | Automatic resolution | None (Manual) |\n| **Output Type** | List of file paths | Raw generated code |\n\nFor a comprehensive guide on managing dependency trees and recursive compilation logic, see **education/book-02-bash-target/09_recursive_compilation.md**.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compile/3", "compile_recursive/3", "api", "options"], "original_answer": "## Compile API Reference\n\n### compile/3 (Recommended)\n\nThe high-level interface with automatic dependency resolution:\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Parameters:**\n- `Predicate`: `name/arity` (e.g., `ancestor/2`)\n- `Options`: List of options\n- `GeneratedScripts`: Output - list of generated file paths\n\n**Common Options:**\n\n| Option | Description |\n|--------|-------------|\n| `output_dir(Dir)` | Where to save generated scripts |\n| `target(bash)` | Target language (default: bash) |\n| `unique(true/false)` | Constraint for deduplication |\n\n### compile_recursive/3 (Low-level)\n\nCompiles a single predicate without dependency resolution:\n\n```prolog\n% Compiles ONLY ancestor/2, not its dependencies\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n**When to use each:**\n\n| Function | Use When |\n|----------|----------|\n| `compile/3` | Normal compilation - handles everything |\n| `compile_recursive/3` | Manual control, dependencies already compiled |\n\n### Example\n\n```prolog\n% Automatic (recommended)\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% Manual (advanced)\n?- compile_recursive(parent/2, [], ParentCode),\n   compile_recursive(ancestor/2, [], AncestorCode).\n```", "answer_tailored": true}
{"pair_id": "compile-api-reference_p1", "cluster_id": "compile-api-reference", "question": "What options does compile/3 accept?", "question_type": "medium", "answer": "The `compile/3` predicate is the primary high-level interface for UnifyWeaver compilation, facilitating automatic dependency resolution with the signature `compile(Predicate, Options, GeneratedScripts)`. It accepts the following configuration options:\n\n*   **`output_dir(Dir)`**: Defines the target directory for saving the generated scripts.\n*   **`target(Lang)`**: Specifies the compilation target language (e.g., `bash`, which is the default).\n*   **`unique(true/false)`**: Enables or disables record deduplication constraints in the output.\n\nWhile `compile/3` is recommended for standard workflows, low-level control can be achieved via `compile_recursive/3`. For further technical details and examples of recursive compilation, refer to `education/book-02-bash-target/09_recursive_compilation.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compile/3", "compile_recursive/3", "api", "options"], "original_answer": "## Compile API Reference\n\n### compile/3 (Recommended)\n\nThe high-level interface with automatic dependency resolution:\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Parameters:**\n- `Predicate`: `name/arity` (e.g., `ancestor/2`)\n- `Options`: List of options\n- `GeneratedScripts`: Output - list of generated file paths\n\n**Common Options:**\n\n| Option | Description |\n|--------|-------------|\n| `output_dir(Dir)` | Where to save generated scripts |\n| `target(bash)` | Target language (default: bash) |\n| `unique(true/false)` | Constraint for deduplication |\n\n### compile_recursive/3 (Low-level)\n\nCompiles a single predicate without dependency resolution:\n\n```prolog\n% Compiles ONLY ancestor/2, not its dependencies\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n**When to use each:**\n\n| Function | Use When |\n|----------|----------|\n| `compile/3` | Normal compilation - handles everything |\n| `compile_recursive/3` | Manual control, dependencies already compiled |\n\n### Example\n\n```prolog\n% Automatic (recommended)\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% Manual (advanced)\n?- compile_recursive(parent/2, [], ParentCode),\n   compile_recursive(ancestor/2, [], AncestorCode).\n```", "answer_tailored": true}
{"pair_id": "compile-api-reference_p2", "cluster_id": "compile-api-reference", "question": "How do I specify the output directory?", "question_type": "medium", "answer": "To specify the output directory in UnifyWeaver, use the `output_dir(Dir)` option within the `compile/3` predicate. This high-level interface is the recommended way to generate scripts as it automatically handles dependency resolution and organizes the results into your chosen folder.\n\n### Implementation Example\nYou can define the target directory by passing it in the options list:\n\n```prolog\n% Compiles the predicate and saves all generated files to the 'out' directory\n?- compile(ancestor/2, [output_dir('out')], Scripts).\n% Scripts = ['out/parent.sh', 'out/ancestor.sh'].\n```\n\n### Key Technical Details\n*   **Predicate Interface:** `compile(Predicate, Options, GeneratedScripts)`\n*   **Targeting:** While the default is `bash`, you can combine `output_dir(Dir)` with `target(Language)` to control both the location and the output format.\n*   **Comparison:** Unlike the low-level `compile_recursive/3` which returns raw code for a single predicate, `compile/3` uses the `output_dir` setting to write the entire dependency tree to disk.\n\nFor further details on managing build artifacts and recursive compilation, see `education/book-02-bash-target/09_recursive_compilation.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compile/3", "compile_recursive/3", "api", "options"], "original_answer": "## Compile API Reference\n\n### compile/3 (Recommended)\n\nThe high-level interface with automatic dependency resolution:\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Parameters:**\n- `Predicate`: `name/arity` (e.g., `ancestor/2`)\n- `Options`: List of options\n- `GeneratedScripts`: Output - list of generated file paths\n\n**Common Options:**\n\n| Option | Description |\n|--------|-------------|\n| `output_dir(Dir)` | Where to save generated scripts |\n| `target(bash)` | Target language (default: bash) |\n| `unique(true/false)` | Constraint for deduplication |\n\n### compile_recursive/3 (Low-level)\n\nCompiles a single predicate without dependency resolution:\n\n```prolog\n% Compiles ONLY ancestor/2, not its dependencies\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n**When to use each:**\n\n| Function | Use When |\n|----------|----------|\n| `compile/3` | Normal compilation - handles everything |\n| `compile_recursive/3` | Manual control, dependencies already compiled |\n\n### Example\n\n```prolog\n% Automatic (recommended)\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% Manual (advanced)\n?- compile_recursive(parent/2, [], ParentCode),\n   compile_recursive(ancestor/2, [], AncestorCode).\n```", "answer_tailored": true}
{"pair_id": "compile-api-reference_p3", "cluster_id": "compile-api-reference", "question": "Which compile function should I use?", "question_type": "medium", "answer": "For most standard use cases, you should use **`compile/3`**. It is the recommended high-level interface because it automatically handles dependency resolution, ensuring that all necessary predicates are compiled into the final output.\n\n### `compile/3` (Recommended)\nUse this for normal compilation tasks where you want the system to manage the relationship between predicates.\n\n```prolog\n% Example: Automatically resolves and compiles all dependencies\n?- compile(ancestor/2, [output_dir('out'), target(bash)], GeneratedScripts).\n```\n\n**Key Features:**\n- **Automatic Dependency Resolution:** Identifies and compiles all helper predicates.\n- **Script Management:** Returns a list of all generated file paths in `GeneratedScripts`.\n- **Flexible Options:** Supports `output_dir(Dir)`, `target(bash/python/go/etc.)`, and deduplication via `unique(true)`.\n\n### `compile_recursive/3` (Low-level)\nYou should only use **`compile_recursive/3`** if you require manual control over the compilation process and are managing dependencies yourself. It compiles the specific predicate logic provided but does not attempt to resolve or compile any sub-calls.\n\n```prolog\n% Compiles ONLY the logic for parent/2\n?- compile_recursive(parent/2, [], BashCode).\n```\n\n| Function | Best Use Case |\n|----------|---------------|\n| `compile/3` | Standard development; handles the full dependency tree automatically. |\n| `compile_recursive/3` | Advanced/Manual control; dependencies are already handled or not needed. |\n\nFor more detailed technical documentation on how the compiler handles recursive structures and dependency trees, refer to **`education/book-02-bash-target/09_recursive_compilation.md`**.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compile/3", "compile_recursive/3", "api", "options"], "original_answer": "## Compile API Reference\n\n### compile/3 (Recommended)\n\nThe high-level interface with automatic dependency resolution:\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Parameters:**\n- `Predicate`: `name/arity` (e.g., `ancestor/2`)\n- `Options`: List of options\n- `GeneratedScripts`: Output - list of generated file paths\n\n**Common Options:**\n\n| Option | Description |\n|--------|-------------|\n| `output_dir(Dir)` | Where to save generated scripts |\n| `target(bash)` | Target language (default: bash) |\n| `unique(true/false)` | Constraint for deduplication |\n\n### compile_recursive/3 (Low-level)\n\nCompiles a single predicate without dependency resolution:\n\n```prolog\n% Compiles ONLY ancestor/2, not its dependencies\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n**When to use each:**\n\n| Function | Use When |\n|----------|----------|\n| `compile/3` | Normal compilation - handles everything |\n| `compile_recursive/3` | Manual control, dependencies already compiled |\n\n### Example\n\n```prolog\n% Automatic (recommended)\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% Manual (advanced)\n?- compile_recursive(parent/2, [], ParentCode),\n   compile_recursive(ancestor/2, [], AncestorCode).\n```", "answer_tailored": true}
