{"pair_id": "target-sec-001_p0", "cluster_id": "target-sec-001", "question": "What are the security characteristics of different compilation targets?", "question_type": "medium", "answer": "UnifyWeaver compilation targets possess distinct security profiles categorized by their compile-time safety, runtime sandboxing capabilities, and memory management models:\n\n*   **Bash & AWK**: Offer minimal security, with low compile safety and little to no runtime isolation.\n*   **Python & Prolog (SWI)**: Provide a medium security tier featuring managed memory and limited sandboxing.\n*   **Go & C#/.NET**: Deliver high security through OS-level or CLR-based sandboxing and managed or safe memory handling.\n*   **Rust**: Provides the highest security level with guaranteed memory safety and OS-level sandboxing.\n\nFor production deployments, Go and Rust are recommended for their robust safety features, whereas Bash is better suited for development and debugging. Detailed security specifications can be found in `education/book-08-security-firewall/04_target_security.md`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/04_target_security.md", "topics": [], "original_answer": "Security comparison matrix:\n| Target | Compile Safety | Runtime Sandbox | Memory Safety |\n|--------|---------------|-----------------|---------------|\n| Bash | Low | None | N/A |\n| AWK | Low | Limited | N/A |\n| Python | Medium | Limited | Managed |\n| Go | High | OS-level | Safe |\n| Rust | Very High | OS-level | Guaranteed |\n| C#/.NET | High | CLR sandbox | Managed |\n| Prolog (SWI) | Medium | Limited | Managed |\n\nGo and Rust are recommended for production, Bash for development only.", "answer_tailored": true}
{"pair_id": "target-sec-001_p0", "cluster_id": "target-sec-001", "question": "What are the security risks with Bash target?", "question_type": "medium", "answer": "The primary security risks for the Bash target involve (1) Command injection from unvalidated input, (2) Shell expansion vulnerabilities like globbing and variable expansion, (3) Privilege escalation via sudo or setuid, and (4) Path manipulation or PATH injection. UnifyWeaver addresses these risks by generating hardened scripts that use `set -euo pipefail`, strict variable quoting, and absolute paths while explicitly avoiding `eval`.\n\n```bash\n#!/bin/bash\nset -euo pipefail\ninput=\"${1:-}\"  # All variables are strictly quoted\nresult=$((input * 2))  # Safe arithmetic processing\n```\n\nFor more details on these protections, see `education/book-08-security-firewall/04_target_security.md` and the Bash-specific implementation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/04_target_security.md", "topics": [], "original_answer": "Bash has four main risks: (1) Command injection - user input in commands; (2) Shell expansion - glob and variable expansion; (3) Privilege escalation - sudo/setuid; (4) Path manipulation - PATH injection. Mitigation: Use strict quoting, `set -euo pipefail`, absolute paths, never use eval. UnifyWeaver generates safe Bash with these protections by default:\n\n```bash\n#!/bin/bash\nset -euo pipefail\ninput=\"${1:-}\"  # Variables always quoted\nresult=$((input * 2))  # Safe arithmetic\n```", "answer_tailored": true}
{"pair_id": "target-sec-002_p0", "cluster_id": "target-sec-002", "question": "How do I configure target-specific firewall policies?", "question_type": "medium", "answer": "To configure target-specific firewall policies, you use Prolog-based directives that specify allowed or denied imports, namespaces, and language features for each compilation target. This allows you to enforce security constraints tailored to the specific backend being used.\n\n```prolog\n% Python: Control specific module imports\n:- deny(python_import(subprocess)).\n:- deny(python_import(pickle)).\n:- allow(python_import(json)).\n\n% Go: Apply conditional logic to imports\n:- deny(go_import(\"os/exec\")) :- \\+ shell_allowed.\n:- allow(go_import(\"encoding/json\")).\n\n% Rust: Manage unsafe features and crate access\n:- deny(rust_feature(unsafe)) :- \\+ unsafe_approved.\n:- allow(rust_crate(\"serde\")).\n\n% C#/.NET: Block access to sensitive namespaces\n:- deny(dotnet_namespace(\"System.Diagnostics.Process\")).\n```\n\nThese policies ensure that the compiled output adheres to your security requirements by restricting high-risk functionality. Detailed implementation guidance can be found in `education/book-08-security-firewall/`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/04_target_security.md", "topics": [], "original_answer": "Each target has specific controls:\n\n```prolog\n% Python restrictions\n:- deny(python_import(subprocess)).\n:- deny(python_import(pickle)).\n:- allow(python_import(json)).\n\n% Go restrictions\n:- deny(go_import(\"os/exec\")) :- \\+ shell_allowed.\n:- allow(go_import(\"encoding/json\")).\n\n% Rust restrictions\n:- deny(rust_feature(unsafe)) :- \\+ unsafe_approved.\n:- allow(rust_crate(\"serde\")).\n\n% C#/.NET restrictions\n:- deny(dotnet_namespace(\"System.Diagnostics.Process\")).\n```", "answer_tailored": true}
{"pair_id": "target-sec-002_p0", "cluster_id": "target-sec-002", "question": "Which target is best for production security?", "question_type": "medium", "answer": "Go and Rust are the most secure targets for production environments. Go provides significant compile-time safety, memory protection, and static typing, while its import system prevents hijacking. Rust delivers the highest level of security with strict memory safety guarantees, no data races, and a minimal attack surface. In contrast, Bash is better suited for development and Python for environments with strict import controls. For enterprise needs, C#/.NET utilizes the CLR sandbox and Code Access Security. Detailed information on target-specific security can be found in education/book-08-security-firewall/.", "answer_variant": "default", "answer_source": "book-08-security-firewall/04_target_security.md", "topics": [], "original_answer": "Go and Rust are best for production: Go offers high compile-time safety, static typing, no eval, memory safety, and compile-time imports preventing hijacking. Rust provides very high safety with guaranteed memory safety, no null pointers, no data races, and minimal attack surface. Use Bash only for development, Python for controlled environments with import restrictions. C#/.NET is good for enterprise with CLR sandbox and Code Access Security.", "answer_tailored": true}
