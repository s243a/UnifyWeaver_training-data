{"pair_id": "firewall-001_p0", "cluster_id": "firewall-001", "question": "How do I declare a firewall policy in UnifyWeaver?", "question_type": "medium", "answer": "To declare a firewall policy in UnifyWeaver, you define security constraints within `.firewall` files using Prolog predicates. You manage the compiler's security posture by setting an enforcement mode and specifying allowed or restricted actions using the `allow/1`, `deny/1`, and `require/1` predicates.\n\nExample policy declaration:\n\n```prolog\n% Set the enforcement level (e.g., enforce or audit)\n:- firewall_mode(enforce).\n\n% Permit specific target languages\n:- allow(target(bash)).\n:- allow(target(go)).\n\n% Restrict targets, native compilation, or specific library modules\n:- deny(target(python)).\n:- deny(compile(native)).\n:- deny(import_module(library(http/_))).\n```\n\nThese declarations allow you to establish fine-grained control over the compilation environment, ensuring that only trusted targets and modules are utilized. For more details on policy implementation and available constraints, refer to `education/book-08-security-firewall/`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Firewall policies are declared in .firewall files using Prolog predicates:\n\n```prolog\n% Set enforcement mode\n:- firewall_mode(enforce).\n\n% Allow specific targets\n:- allow(target(bash)).\n:- allow(target(go)).\n\n% Deny specific targets\n:- deny(target(python)).\n\n% Deny compilation\n:- deny(compile(native)).\n\n% Deny modules\n:- deny(import_module(library(http/_))).\n```\n\nUse `allow/1` to permit, `deny/1` to block, and `require/1` for mandatory conditions.", "answer_tailored": true}
{"pair_id": "firewall-001_p0", "cluster_id": "firewall-001", "question": "What firewall policy predicates are available?", "question_type": "medium", "answer": "UnifyWeaver provides four core firewall policy predicates: `allow/1` for explicitly permitting operations (e.g., `allow(target(go))`), `deny/1` for forbidding them (e.g., `deny(compile(native))`), `require/1` for enforcing mandatory conditions (e.g., `require(validation(passed))`), and `implies/2` for establishing conditional rules (e.g., `implies(compile(native), code_review(required))`). These policies support logical composition through AND, OR, and NOT (`\\+` negation). For more details, consult `education/book-08-security-firewall/`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Four main predicates: (1) `allow/1` - explicitly permit operations like `allow(target(go))`; (2) `deny/1` - explicitly deny operations like `deny(compile(native))`; (3) `require/1` - make conditions mandatory like `require(validation(passed))`; (4) `implies/2` - conditional policies like `implies(compile(native), code_review(required))`. Policies can be composed with AND (multiple conditions), OR (multiple rules), and NOT (`\\+` negation).", "answer_tailored": true}
{"pair_id": "firewall-002_p0", "cluster_id": "firewall-002", "question": "How do I create a target whitelist firewall policy?", "question_type": "medium", "answer": "To create a target whitelist firewall policy, you explicitly permit authorized targets followed by a catch-all rejection rule to establish a secure default-deny posture.\n\nExample `.firewall` configuration:\n```prolog\n% Whitelist specific compilation targets\n:- allow(target(bash)).\n:- allow(target(go)).\n:- allow(target(rust)).\n:- deny(target(_)).  % Block all other targets\n```\n\nThe anonymous variable `_` in the final `deny` clause ensures that any target not matched by a preceding `allow` directive is rejected. For more details on configuring security policies, see `education/book-08-security-firewall/`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Create a whitelist by allowing specific targets then denying all others:\n\n```prolog\n% .firewall - Target whitelist\n:- allow(target(bash)).\n:- allow(target(go)).\n:- allow(target(rust)).\n:- deny(target(_)).  % Deny all others\n```\n\nThe underscore `_` matches any target not previously allowed, creating a secure default-deny policy.", "answer_tailored": true}
{"pair_id": "firewall-002_p0", "cluster_id": "firewall-002", "question": "How do I create environment-specific firewall policies?", "question_type": "medium", "answer": "In UnifyWeaver, environment-specific firewall policies are defined by applying conditional constraints using the `environment/1` predicate. This allows you to differentiate between permissive development settings and strict production requirements within your Prolog rules.\n\n```prolog\n% Development environment: allow all targets and compilations\n:- allow(target(_)) :- environment(development).\n:- allow(compile(_)) :- environment(development).\n\n% Production environment: restrict targets and mandate validation\n:- allow(target(go)) :- environment(production).\n:- allow(target(rust)) :- environment(production).\n:- deny(target(python)) :- environment(production).\n:- require(validation(passed)) :- environment(production).\n```\n\nAdditionally, you can manage environment-specific security by loading separate `.firewall` files tailored to each deployment stage. Detailed examples of policy configuration can be found in `education/book-08-security-firewall/`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Use conditional rules based on environment:\n\n```prolog\n% Development: permissive\n:- allow(target(_)) :- environment(development).\n:- allow(compile(_)) :- environment(development).\n\n% Production: strict\n:- allow(target(go)) :- environment(production).\n:- allow(target(rust)) :- environment(production).\n:- deny(target(python)) :- environment(production).\n:- require(validation(passed)) :- environment(production).\n```\n\nDifferent .firewall files can be loaded per environment.", "answer_tailored": true}
{"pair_id": "firewall-003_p0", "cluster_id": "firewall-003", "question": "How do I debug firewall policies?", "question_type": "medium", "answer": "Debugging firewall policies in UnifyWeaver involves three main techniques: enabling trace mode, listing active rules, and performing dry runs.\n\n1. **Trace Mode**: Setting `:- set_firewall_flag(trace, true).` provides a detailed log of the decision process, showing exactly which rules are being evaluated and where a match occurs (e.g., `[Firewall] Rule 3: deny(target(python)) - MATCH`).\n2. **Rule Inspection**: You can display all currently active firewall policies by executing the predicate `?- list_firewall_rules.`.\n3. **Dry Run**: To validate policy behavior against specific actions without actually executing them, use `firewall_dry_run/2`:\n   ```prolog\n   ?- firewall_dry_run([check(target(python)), check(target(go))], Results).\n   % Results = [denied(target(python)), allowed(target(go))].\n   ```\n\nRefer to `education/book-08-security-firewall/` for more in-depth information on firewall debugging and security policy management.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Three methods: (1) Trace mode shows decision process:\n```prolog\n:- set_firewall_flag(trace, true).\n% Shows: [Firewall] Checking: target(python)\n%        [Firewall] Rule 3: deny(target(python)) - MATCH\n```\n\n(2) List policies: `?- list_firewall_rules.`\n\n(3) Dry run tests policies without executing:\n```prolog\n?- firewall_dry_run([check(target(python)), check(target(go))], Results).\nResults = [denied(target(python)), allowed(target(go))].\n```", "answer_tailored": true}
