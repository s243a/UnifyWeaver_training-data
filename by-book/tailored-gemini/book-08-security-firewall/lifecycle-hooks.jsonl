{"pair_id": "hooks-001_p0", "cluster_id": "hooks-001", "question": "What are lifecycle hooks in UnifyWeaver?", "question_type": "medium", "answer": "Lifecycle hooks in UnifyWeaver are automated actions that trigger during specific events in a service's deployment and runtime lifecycle. They enable the execution of logic at critical transition points following the sequence: `pre_deploy` -> Deploy -> `post_deploy` -> Running -> `pre_shutdown` -> Shutdown -> `post_shutdown`.\n\nHooks are defined using the `declare_lifecycle_hook` predicate:\n\n```prolog\n:- declare_lifecycle_hook(api_service, pre_deploy, health_check).\n:- declare_lifecycle_hook(api_service, post_deploy, warm_cache).\n:- declare_lifecycle_hook(api_service, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(api_service, on_health_failure, custom('alert.sh')).\n```\n\nThese hooks are used to ensure system readiness, optimize performance, and handle failures (such as `on_health_failure`). For detailed implementation guides, refer to `education/book-08-security-firewall/`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/03_lifecycle_hooks.md", "topics": [], "original_answer": "Lifecycle hooks are actions that execute automatically at specific events during service deployment and operation. The lifecycle flow is: pre_deploy -> Deploy -> post_deploy -> Running -> pre_shutdown -> Shutdown -> post_shutdown. Declare hooks with:\n\n```prolog\n:- declare_lifecycle_hook(api_service, pre_deploy, health_check).\n:- declare_lifecycle_hook(api_service, post_deploy, warm_cache).\n:- declare_lifecycle_hook(api_service, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(api_service, on_health_failure, custom('alert.sh')).\n```", "answer_tailored": true}
{"pair_id": "hooks-001_p0", "cluster_id": "hooks-001", "question": "What lifecycle hook events are available?", "question_type": "medium", "answer": "UnifyWeaver supports five distinct lifecycle hook events to manage different stages of an application's operation:\n\n- `pre_deploy`: Runs prior to deployment for backup and validation tasks.\n- `post_deploy`: Executes after deployment is complete, typically for cache warming and health verification.\n- `pre_shutdown`: Triggered before the process stops to allow for state saving and connection draining.\n- `post_shutdown`: Finalizes the process with cleanup operations and notifications.\n- `on_health_failure`: Activated when a health check fails, enabling automated recovery or alerting.\n\nYou can register multiple hooks for each event, which will then execute sequentially. Further documentation on these hooks can be found in `education/book-08-security-firewall/`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/03_lifecycle_hooks.md", "topics": [], "original_answer": "Five hook events: (1) `pre_deploy` - before deployment for validation/backup; (2) `post_deploy` - after deployment for health checks/cache warming; (3) `pre_shutdown` - before stopping for connection draining/state saving; (4) `post_shutdown` - after stopping for cleanup/notification; (5) `on_health_failure` - when health check fails for alerting/recovery. Multiple hooks can be declared for the same event and execute sequentially.", "answer_tailored": true}
{"pair_id": "hooks-002_p0", "cluster_id": "hooks-002", "question": "What built-in hook actions are available?", "question_type": "medium", "answer": "UnifyWeaver provides five primary built-in lifecycle hook actions for managing services:\n\n1. **`drain_connections`**: Pauses transitions until all active network connections have completed gracefully.\n2. **`health_check`**: Uses HTTP requests to verify that the service is responsive and functioning correctly.\n3. **`warm_cache`**: Triggers routines to pre-populate caches before the service handles live traffic.\n4. **`save_state`**: Persists the current service state to stable storage prior to shutdown.\n5. **`custom(Command)`**: Executes an arbitrary shell command as part of the hook lifecycle.\n\nThese are declared in Prolog as follows:\n\n```prolog\n:- declare_lifecycle_hook(svc, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(svc, post_deploy, custom('notify.sh deployed')).\n```\n\nFor more details on implementing these hooks, see `education/book-08-security-firewall/03_lifecycle_hooks.md`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/03_lifecycle_hooks.md", "topics": [], "original_answer": "Five built-in actions: (1) `drain_connections` - wait for active connections to complete; (2) `health_check` - verify service is responding via HTTP; (3) `warm_cache` - pre-populate caches; (4) `save_state` - persist service state before shutdown; (5) `custom(Command)` - run arbitrary shell command. Example:\n\n```prolog\n:- declare_lifecycle_hook(svc, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(svc, post_deploy, custom('notify.sh deployed')).\n```", "answer_tailored": true}
{"pair_id": "hooks-002_p0", "cluster_id": "hooks-002", "question": "How does deploy_with_hooks work?", "question_type": "medium", "answer": "The `deploy_with_hooks/2` predicate handles the complete deployment sequence by orchestrating four key phases: security validation, pre-deployment hook execution, the core deployment itself, and post-deployment hooks. If a failure is encountered at any point, the deployment is aborted and an error is returned. For shutting down services with similar hook logic, the system provides `graceful_stop/3`.\n\n```prolog\ndeploy_secure :-\n    validate_security(api_service, Errors),\n    (Errors == []\n    ->  deploy_with_hooks(api_service, Result)\n    ;   format('Security errors: ~w~n', [Errors]), fail\n    ).\n```\n\nFurther details on hook implementation and service lifecycles can be found in `education/book-08-security-firewall/03_lifecycle_hooks.md`.", "answer_variant": "default", "answer_source": "book-08-security-firewall/03_lifecycle_hooks.md", "topics": [], "original_answer": "The `deploy_with_hooks/2` predicate executes the full deployment flow: (1) Validate security requirements; (2) Execute pre-deploy hooks; (3) Perform actual deployment; (4) Execute post-deploy hooks. If any step fails, deployment aborts with appropriate error. Use `graceful_stop/3` for shutdown with hooks:\n\n```prolog\ndeploy_secure :-\n    validate_security(api_service, Errors),\n    (Errors == []\n    ->  deploy_with_hooks(api_service, Result)\n    ;   format('Security errors: ~w~n', [Errors]), fail\n    ).\n```", "answer_tailored": true}
