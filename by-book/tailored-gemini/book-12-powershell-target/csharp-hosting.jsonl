{"pair_id": "ps-hosting-001_p0", "cluster_id": "ps-hosting-001", "question": "How does in-process C# hosting work with PowerShell?", "question_type": "medium", "answer": "In-process C# hosting integrates PowerShell logic directly into C# applications by generating a dual-output: the PowerShell function definitions and a C# wrapper class. This is managed via the `compile_with_csharp_host/4` predicate:\n\n```prolog\n?- compile_with_csharp_host(\n       [filter_users/2, transform_data/2],\n       [namespace('MyApp.Generated'), class('DataProcessor')],\n       PSCode,    % PowerShell logic\n       CSharpCode % C# host class\n   ).\n```\n\nThe generated C# host manages the PowerShell runspace and exposes methods that call the PowerShell functions using an internal bridge:\n\n```csharp\npublic class PowerShellHost {\n    public PowerShellHost(string scriptBlock) { /* init runspace */ }\n    \n    public IEnumerable<dynamic> filter_users(string arg1, string arg2) {\n        var script = \"filter_users $arg1 $arg2\";\n        return PowerShellBridge.Invoke<object, dynamic>(script, null);\n    }\n}\n```\n\nOnce initialized, the host allows you to iterate over results as dynamic objects:\n\n```csharp\nvar host = new PowerShellHost(psScript);\nforeach (var user in host.filter_users(\"val1\", \"val2\")) {\n    Console.WriteLine($\"User: {user.X}\");\n}\n```\n\nThe primary advantage of this approach is zero serialization overhead, as objects are passed directly through the bridge. For more details on hosting configuration, see `education/book-12-powershell-target/06_csharp_hosting.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/06_csharp_hosting.md", "topics": [], "original_answer": "Generate dual outputs with `compile_with_csharp_host/4`:\n\n```prolog\n?- compile_with_csharp_host(\n       [filter_users/2, transform_data/2],\n       [namespace('MyApp.Generated'), class('DataProcessor')],\n       PSCode,    % PowerShell functions\n       CSharpCode % C# wrapper class\n   ).\n```\n\n**Generated C# host:**\n```csharp\npublic class PowerShellHost {\n    public PowerShellHost(string scriptBlock) { /* init runspace */ }\n    \n    public IEnumerable<dynamic> filter_users(string arg1, string arg2) {\n        var script = \"filter_users $arg1 $arg2\";\n        return PowerShellBridge.Invoke<object, dynamic>(script, null);\n    }\n}\n```\n\n**Usage:**\n```csharp\nvar host = new PowerShellHost(psScript);\nforeach (var user in host.filter_users(\"\", \"\")) {\n    Console.WriteLine($\"ID: {user.X}\");\n}\n```\n\nAdvantage: Zero serialization overhead - objects pass directly.", "answer_tailored": true}
{"pair_id": "ps-hosting-001_p0", "cluster_id": "ps-hosting-001", "question": "What bridges does UnifyWeaver support for .NET interop?", "question_type": "medium", "answer": "UnifyWeaver supports three primary bridge architectures for .NET interop, enabling C# applications to host PowerShell or Python logic through the following patterns:\n\n1.  **PowerShell Bridge**: Directly hosts PowerShell environments within a C# namespace.\n    ```prolog\n    ?- generate_csharp_bridge(powershell, [namespace('MyApp')], Code).\n    ```\n2.  **IronPython Bridge**: An in-process solution (~0ms latency) for hosting Python code without subprocess overhead, ideal for pure Python logic.\n3.  **CPython Fallback**: A pipe-based bridge (~5\u201310ms latency) used when the logic requires C extensions like `numpy` or `pandas` that are incompatible with IronPython.\n\nThe system includes automatic runtime detection via `dotnet_glue:python_runtime_choice/2`, which selects the bridge based on library requirements:\n*   **In-Process**: Selected for standard libraries (e.g., `json`, `re`) via IronPython.\n*   **Pipe-Based**: Selected for C extensions (e.g., `numpy`) via the CPython pipe.\n\nFor detailed hosting configurations and performance benchmarks, refer to `education/book-12-powershell-target/06_csharp_hosting.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/06_csharp_hosting.md", "topics": [], "original_answer": "Three bridge types:\n\n```prolog\n% PowerShell bridge (C# hosts PowerShell)\n?- generate_csharp_bridge(powershell, [namespace('MyApp')], Code).\n\n% IronPython bridge (C# hosts Python - no subprocess)\n?- generate_csharp_bridge(ironpython, [namespace('MyApp')], Code).\n\n% CPython fallback (pipe-based - for numpy, pandas)\n?- generate_csharp_bridge(cpython, [], Code).\n```\n\n**Performance comparison:**\n| Pattern | Latency | Use Case |\n|---------|---------|----------|\n| In-Process | ~0ms | Same AppDomain, direct objects |\n| Pipe-Based | ~5-10ms | Cross-process, JSON serialization |\n\n**Runtime detection:**\n```prolog\n?- dotnet_glue:python_runtime_choice([json, re], Runtime).\nRuntime = ironpython.  % All IronPython-compatible\n\n?- dotnet_glue:python_runtime_choice([numpy], Runtime).\nRuntime = cpython_pipe.  % C extensions need CPython\n```", "answer_tailored": true}
