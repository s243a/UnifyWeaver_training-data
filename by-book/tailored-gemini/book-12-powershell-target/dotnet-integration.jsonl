{"pair_id": "ps-dotnet-001_p0", "cluster_id": "ps-dotnet-001", "question": "How do I use inline C# with the PowerShell target?", "question_type": "medium", "answer": "To incorporate inline C# within the PowerShell target, utilize the `dotnet_source` plugin. You define the C# code as a string in Prolog and pass it to the compiler via the `csharp_inline` configuration option.\n\n```prolog\n:- use_module(library(dotnet_source)).\n\nCSharpCode = '\nusing System;\nnamespace UnifyWeaver.Generated.StringReverser {\n    public class StringReverserHandler {\n        public string ProcessStringReverser(string input) {\n            char[] chars = input.ToCharArray();\n            Array.Reverse(chars);\n            return new string(chars);\n        }\n    }\n}\n',\n\nConfig = [csharp_inline(CSharpCode)],\ndotnet_source:compile_source(string_reverser/2, Config, [], PowerShellCode).\n```\n\nThe compiler generates PowerShell that uses `Add-Type` to register the C# code during the `begin` phase, ensuring the .NET classes are available for the duration of the script:\n\n```powershell\nbegin {\n    Add-Type -TypeDefinition $csharpCode\n    $handler = New-Object UnifyWeaver.Generated.StringReverser.StringReverserHandler\n}\nprocess {\n    $handler.ProcessStringReverser($InputData)\n}\n```\n\nFor a deep dive into .NET interoperability and advanced integration patterns, see `education/book-12-powershell-target/04_dotnet_integration.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/04_dotnet_integration.md", "topics": [], "original_answer": "Use the `dotnet_source` plugin to embed C# code:\n\n```prolog\n:- use_module(library(dotnet_source)).\n\nCSharpCode = '\nusing System;\nnamespace UnifyWeaver.Generated.StringReverser {\n    public class StringReverserHandler {\n        public string ProcessStringReverser(string input) {\n            char[] chars = input.ToCharArray();\n            Array.Reverse(chars);\n            return new string(chars);\n        }\n    }\n}\n',\n\nConfig = [csharp_inline(CSharpCode)],\ndotnet_source:compile_source(string_reverser/2, Config, [], PowerShellCode).\n```\n\n**Generated PowerShell:**\n```powershell\nbegin {\n    Add-Type -TypeDefinition $csharpCode\n    $handler = New-Object UnifyWeaver.Generated.StringReverser.StringReverserHandler\n}\nprocess {\n    $handler.ProcessStringReverser($InputData)\n}\n```", "answer_tailored": true}
{"pair_id": "ps-dotnet-001_p0", "cluster_id": "ps-dotnet-001", "question": "How does DLL caching work for 138x speedup?", "question_type": "medium", "answer": "DLL caching achieves a 138x performance boost (reducing execution from ~386ms to ~2.8ms) by persisting compiled C# snippets to disk and loading them directly on subsequent calls. This avoids the overhead of invoking the Roslyn compiler for every execution.\n\nTo use this feature, enable `pre_compile(true)` in the Prolog configuration:\n\n```prolog\nConfig = [csharp_inline(CSharpCode), pre_compile(true)],\ndotnet_source:compile_source(my_pred/2, Config, [], Code).\n```\n\n**The caching mechanism operates as follows:**\n1. **Source Hashing:** The system generates a SHA256 hash of the C# source code to create a unique identifier.\n2. **Cache Lookup:** It checks for a corresponding DLL in `$env:TEMP/unifyweaver_dotnet_cache/{hash}.dll`.\n3. **Execution Path:**\n   - **Cache Hit:** The existing DLL is loaded immediately using `Add-Type -Path`, completing in approximately 2.8ms.\n   - **Cache Miss:** The compiler is invoked, the resulting DLL is saved to the cache, and then loaded, taking about 386ms.\n\nThe generated PowerShell code implements this check to ensure subsequent runs are near-instant:\n```powershell\n$codeHash = Get-StringHash $csharpCode\n$cachedDll = \"$env:TEMP/unifyweaver_dotnet_cache/$codeHash.dll\"\n\nif (Test-Path $cachedDll) {\n    Add-Type -Path $cachedDll  # Instant load!\n} else {\n    # Compile and cache for future use...\n}\n```\n\nFor more details on .NET integration and optimization, see `education/book-12-powershell-target/04_dotnet_integration.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/04_dotnet_integration.md", "topics": [], "original_answer": "Enable caching with `pre_compile(true)`:\n\n```prolog\nConfig = [csharp_inline(CSharpCode), pre_compile(true)],\ndotnet_source:compile_source(my_pred/2, Config, [], Code).\n```\n\n**How it works:**\n1. Hash the C# source (SHA256)\n2. Check cache: `$env:TEMP/unifyweaver_dotnet_cache/{hash}.dll`\n3. Cache hit: Load existing DLL (~2.8ms)\n4. Cache miss: Compile, save to cache, load (~386ms)\n\n**Generated:**\n```powershell\n$codeHash = Get-StringHash $csharpCode\n$cachedDll = \"$env:TEMP/unifyweaver_dotnet_cache/$codeHash.dll\"\n\nif (Test-Path $cachedDll) {\n    Add-Type -Path $cachedDll  # Fast!\n} else {\n    # Compile and cache...\n}\n```\n\n**Result:** First run ~386ms, subsequent runs ~2.8ms.", "answer_tailored": true}
{"pair_id": "ps-dotnet-002_p0", "cluster_id": "ps-dotnet-002", "question": "How do I use NuGet packages in PowerShell target?", "question_type": "medium", "answer": "To use NuGet packages in the PowerShell target, you must configure the compiler to use external compilation mode and specify the required packages within the `references` option.\n\n```prolog\nConfig = [\n    csharp_inline(CSharpCode),\n    compile_mode(external),\n    references(['LiteDB', 'System.Text.Json'])\n],\ndotnet_source:compile_source(Goal/Arity, Config, [], Result).\n```\n\nWhen `compile_mode(external)` is active, UnifyWeaver automates the following integration process:\n1. It scaffolds a temporary .NET project structure.\n2. It generates a `.csproj` file that automatically includes `<PackageReference>` tags for every library listed in your `references`.\n3. It executes `dotnet restore` and `dotnet build` to resolve dependencies and compile the bridge assembly.\n4. It loads the resulting DLL into the PowerShell session, allowing you to interact with the external types.\n\nNote that this process requires the .NET SDK to be installed on the machine performing the compilation. For further details on .NET integration and dependency management, see `education/book-12-powershell-target/04_dotnet_integration.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/04_dotnet_integration.md", "topics": [], "original_answer": "Use `compile_mode(external)` with `references`:\n\n```prolog\nConfig = [\n    csharp_inline(CSharpCode),\n    compile_mode(external),\n    references(['LiteDB', 'System.Text.Json'])\n],\ndotnet_source:compile_source(db_query/3, Config, [], Code).\n```\n\n**Generated process:**\n1. Creates temporary .NET project\n2. Writes `.csproj` with PackageReferences\n3. Runs `dotnet restore` and `dotnet build`\n4. Loads compiled DLL\n5. Creates instance and calls methods\n\n**Example .csproj:**\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup><TargetFramework>net8.0</TargetFramework></PropertyGroup>\n  <ItemGroup>\n    <PackageReference Include=\"LiteDB\" Version=\"5.0.0\" />\n  </ItemGroup>\n</Project>\n```\n\nRequires .NET SDK installed.", "answer_tailored": true}
