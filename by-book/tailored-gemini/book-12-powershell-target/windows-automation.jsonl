{"pair_id": "ps-windows-001_p0", "cluster_id": "ps-windows-001", "question": "How do I automate Windows services with the PowerShell target?", "question_type": "medium", "answer": "To automate Windows services with the PowerShell target, you model service states and monitoring logic as Prolog facts and rules. The UnifyWeaver compiler then translates this declarative logic into functional PowerShell code that interacts with the Windows Service Control Manager using cmdlets like `Get-Service`.\n\n**Prolog Service Definitions:**\n```prolog\nservice(spooler, 'Print Spooler', automatic).\nservice(wuauserv, 'Windows Update', manual).\n\nrunning(Name) :- service(Name, _, _), service_status(Name, 'Running').\n\nservice_alert(Name, Msg) :-\n    service(Name, _, automatic),\n    \\+ running(Name),\n    format(string(Msg), \"Critical ~w not running\", [Name]).\n```\n\n**Compiled PowerShell Output:**\n```powershell\nfunction Test-ServiceRunning {\n    [CmdletBinding()]\n    param([string]$ServiceName)\n    \n    $svc = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue\n    $svc -and $svc.Status -eq 'Running'\n}\n\nfunction Watch-CriticalServices {\n    $critical = @('spooler', 'wuauserv')\n    foreach ($name in $critical) {\n        $svc = Get-Service -Name $name\n        if ($svc.StartType -eq 'Automatic' -and $svc.Status -ne 'Running') {\n            Write-Warning \"ALERT: $name not running\"\n        }\n    }\n}\n```\nFor detailed patterns on managing Windows-specific workloads, see `education/book-12-powershell-target/05_windows_automation.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/05_windows_automation.md", "topics": [], "original_answer": "Model services as Prolog facts and rules:\n\n```prolog\nservice(spooler, 'Print Spooler', automatic).\nservice(wuauserv, 'Windows Update', manual).\n\nrunning(Name) :- service(Name, _, _), service_status(Name, 'Running').\n\nservice_alert(Name, Msg) :-\n    service(Name, _, automatic),\n    \\+ running(Name),\n    format(string(Msg), \"Critical ~w not running\", [Name]).\n```\n\n**Generated PowerShell:**\n```powershell\nfunction Test-ServiceRunning {\n    [CmdletBinding()]\n    param([string]$ServiceName)\n    \n    $svc = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue\n    $svc -and $svc.Status -eq 'Running'\n}\n\nfunction Watch-CriticalServices {\n    $critical = @('spooler', 'wuauserv')\n    foreach ($name in $critical) {\n        $svc = Get-Service -Name $name\n        if ($svc.StartType -eq 'Automatic' -and $svc.Status -ne 'Running') {\n            Write-Warning \"ALERT: $name not running\"\n        }\n    }\n}\n```", "answer_tailored": true}
{"pair_id": "ps-windows-001_p0", "cluster_id": "ps-windows-001", "question": "How do I access the Windows Registry with the PowerShell target?", "question_type": "medium", "answer": "To access the Windows Registry using UnifyWeaver's PowerShell target, you model registry keys and values as Prolog facts. The compiler then generates idiomatic PowerShell functions that utilize standard cmdlets like `Get-ItemProperty` and `Set-ItemProperty` to interact with the registry providers (HKLM, HKCU, etc.).\n\n**Prolog Representation:**\n```prolog\n% Define registry facts\nreg_value('HKLM:\\SOFTWARE\\MyApp', 'Version', '1.0.0').\n\n% Logic to check for installed applications\napp_installed(AppName) :-\n    reg_value(Path, 'DisplayName', AppName),\n    sub_string(Path, _, _, _, 'Uninstall').\n```\n\n**Compiled PowerShell Output:**\n```powershell\nfunction Get-AppInstalled {\n    param([string]$AppName)\n    \n    $paths = @(\n        'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',\n        'HKLM:\\SOFTWARE\\WOW6432Node\\...\\Uninstall\\*'\n    )\n    \n    $paths | ForEach-Object {\n        Get-ItemProperty -Path $_ -ErrorAction SilentlyContinue\n    } | Where-Object { $_.DisplayName -like \"*$AppName*\" }\n}\n\nfunction Set-UserPreference {\n    [CmdletBinding(SupportsShouldProcess=$true)]\n    param([string]$AppName, [string]$Key, $Value)\n    \n    $path = \"HKCU:\\Software\\$AppName\"\n    # Utilizes ShouldProcess for safe registry modifications\n    if ($PSCmdlet.ShouldProcess($path, \"Set $Key\")) {\n        Set-ItemProperty -Path $path -Name $Key -Value $Value\n    }\n}\n```\n\nFor a deep dive into Windows-specific automation patterns, see `education/book-12-powershell-target/`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/05_windows_automation.md", "topics": [], "original_answer": "Model registry as facts:\n\n```prolog\nreg_value('HKLM:\\SOFTWARE\\MyApp', 'Version', '1.0.0').\n\napp_installed(AppName) :-\n    reg_value(Path, 'DisplayName', AppName),\n    sub_string(Path, _, _, _, 'Uninstall').\n```\n\n**Generated PowerShell:**\n```powershell\nfunction Get-AppInstalled {\n    param([string]$AppName)\n    \n    $paths = @(\n        'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',\n        'HKLM:\\SOFTWARE\\WOW6432Node\\...\\Uninstall\\*'\n    )\n    \n    $paths | ForEach-Object {\n        Get-ItemProperty -Path $_ -ErrorAction SilentlyContinue\n    } | Where-Object { $_.DisplayName -like \"*$AppName*\" }\n}\n\nfunction Set-UserPreference {\n    [CmdletBinding(SupportsShouldProcess=$true)]\n    param([string]$AppName, [string]$Key, $Value)\n    \n    $path = \"HKCU:\\Software\\$AppName\"\n    if ($PSCmdlet.ShouldProcess($path, \"Set $Key\")) {\n        Set-ItemProperty -Path $path -Name $Key -Value $Value\n    }\n}\n```", "answer_tailored": true}
{"pair_id": "ps-windows-002_p0", "cluster_id": "ps-windows-002", "question": "How do I query WMI/CIM with the PowerShell target?", "question_type": "medium", "answer": "To query WMI or CIM instances with the PowerShell target, you model system data as Prolog facts. UnifyWeaver compiles these into PowerShell functions that use `Get-CimInstance` to fetch and filter object properties.\n\n**Example Prolog Rule:**\n```prolog\nlow_disk(DeviceId) :-\n    disk_info(DeviceId, Size, FreeSpace),\n    Percent is (FreeSpace / Size) * 100,\n    Percent < 10.\n```\n\n**Generated PowerShell Implementation:**\n```powershell\nfunction Get-DiskFact {\n    Get-CimInstance Win32_LogicalDisk -Filter \"DriveType=3\" |\n        ForEach-Object {\n            [PSCustomObject] @{\n                DeviceId = $_.DeviceID\n                Size = $_.Size\n                FreeSpace = $_.FreeSpace\n                PercentFree = [math]::Round(($_.FreeSpace / $_.Size) * 100, 2)\n            }\n        }\n}\n\nfunction Test-LowDisk {\n    param([int]$ThresholdPercent = 10)\n    Get-DiskFact | Where-Object { $_.PercentFree -lt $ThresholdPercent }\n}\n```\n\nYou can interact with various CIM classes such as `Win32_ComputerSystem`, `Win32_OperatingSystem`, `Win32_LogicalDisk`, `Win32_Service`, and `Win32_Process`. Further details on Windows-specific automation can be found in `education/book-12-powershell-target/`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/05_windows_automation.md", "topics": [], "original_answer": "Model system info as facts:\n\n```prolog\nlow_disk(DeviceId) :-\n    disk_info(DeviceId, Size, FreeSpace),\n    Percent is (FreeSpace / Size) * 100,\n    Percent < 10.\n```\n\n**Generated PowerShell:**\n```powershell\nfunction Get-DiskFact {\n    Get-CimInstance Win32_LogicalDisk -Filter \"DriveType=3\" |\n        ForEach-Object {\n            [PSCustomObject]@{\n                DeviceId = $_.DeviceID\n                Size = $_.Size\n                FreeSpace = $_.FreeSpace\n                PercentFree = [math]::Round(($_.FreeSpace / $_.Size) * 100, 2)\n            }\n        }\n}\n\nfunction Test-LowDisk {\n    param([int]$ThresholdPercent = 10)\n    Get-DiskFact | Where-Object { $_.PercentFree -lt $ThresholdPercent }\n}\n```\n\n**Common CIM classes:** Win32_ComputerSystem, Win32_OperatingSystem, Win32_LogicalDisk, Win32_Service, Win32_Process", "answer_tailored": true}
