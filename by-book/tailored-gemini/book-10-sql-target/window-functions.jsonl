{"pair_id": "sql-window-001_p0", "cluster_id": "sql-window-001", "question": "How do window functions work in the SQL target?", "question_type": "medium", "answer": "In the UnifyWeaver SQL target, window functions are implemented using the `sql_window` predicate. These functions allow for calculations across a set of rows related to the current row without collapsing the output, unlike traditional aggregations.\n\nThe predicate supports the following syntax patterns:\n```prolog\nsql_window(Function, Args, PartitionBy, OrderBy)\nsql_window(Function, Args, PartitionBy, OrderBy, FrameSpec)\n```\n\nAn example of ranking employees by salary within their respective departments would be:\n```prolog\nemployees_ranked(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n```\n\nThis generates the SQL equivalent: `RANK() OVER (PARTITION BY dept ORDER BY salary DESC)`. For further details on windowing and advanced frame specifications, refer to `education/book-10-sql-target/`.", "answer_variant": "default", "answer_source": "book-10-sql-target/06_window_functions.md", "topics": [], "original_answer": "Window functions calculate across related rows without collapsing them like aggregations. Syntax:\n\n```prolog\nsql_window(Function, Args, PartitionBy, OrderBy)\nsql_window(Function, Args, PartitionBy, OrderBy, FrameSpec)\n```\n\nExample - rank employees by salary within department:\n```prolog\nemployees_ranked(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n```\n\nGenerates: `RANK() OVER (PARTITION BY dept ORDER BY salary DESC)`", "answer_tailored": true}
{"pair_id": "sql-window-001_p0", "cluster_id": "sql-window-001", "question": "What ranking functions does the SQL target support?", "question_type": "medium", "answer": "The UnifyWeaver SQL target supports three distinct ranking functions for windowed queries, each offering different logic for handling ties:\n\n1. **ROW_NUMBER**: Provides a unique, sequential integer for every row within a partition (e.g., 1, 2, 3, 4).\n   ```prolog\n   RowNum = sql_window(row_number, [], [Dept], [(Salary, desc)])\n   ```\n2. **RANK**: Assigns the same rank to tied values but leaves gaps in the numbering sequence (e.g., 1, 1, 3, 4).\n   ```prolog\n   Rank = sql_window(rank, [], [Dept], [(Salary, desc)])\n   ```\n3. **DENSE_RANK**: Assigns the same rank to ties without skipping any subsequent integers (e.g., 1, 1, 2, 3).\n   ```prolog\n   DenseRank = sql_window(dense_rank, [], [Dept], [(Salary, desc)])\n   ```\n\n**Comparison for dataset [100K, 100K, 90K, 80K]:**\n\n| ROW_NUMBER | RANK | DENSE_RANK |\n|------------|------|------------|\n| 1          | 1    | 1          |\n| 2          | 1    | 1          |\n| 3          | 3    | 2          |\n| 4          | 4    | 3          |\n\nFor further details on window function implementation, refer to `education/book-10-sql-target/06_window_functions.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/06_window_functions.md", "topics": [], "original_answer": "Three ranking functions with different tie-handling:\n\n```prolog\n% ROW_NUMBER - unique sequential numbers (1, 2, 3, 4...)\nRowNum = sql_window(row_number, [], [Dept], [(Salary, desc)])\n\n% RANK - same rank for ties, with gaps (1, 1, 3, 4...)\nRank = sql_window(rank, [], [Dept], [(Salary, desc)])\n\n% DENSE_RANK - same rank for ties, no gaps (1, 1, 2, 3...)\nDenseRank = sql_window(dense_rank, [], [Dept], [(Salary, desc)])\n```\n\nComparison for [100K, 100K, 90K, 80K]:\n| ROW_NUMBER | RANK | DENSE_RANK |\n|------------|------|------------|\n| 1 | 1 | 1 |\n| 2 | 1 | 1 |\n| 3 | 3 | 2 |\n| 4 | 4 | 3 |", "answer_tailored": true}
{"pair_id": "sql-window-002_p0", "cluster_id": "sql-window-002", "question": "How do I use LAG and LEAD in the SQL target?", "question_type": "medium", "answer": "To use `LAG` and `LEAD` in the SQL target, you employ the `sql_window/4` predicate to access neighboring rows within a specific partition. `LAG` retrieves values from preceding rows, while `LEAD` fetches from subsequent ones:\n\n```prolog\n% Use LAG to access the previous row's value\nsales_with_previous(Salesperson, Amount, SaleDate, PrevAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    PrevAmount = sql_window(lag, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n\n% Use LEAD to access the next row's value\nsales_with_next(Salesperson, Amount, SaleDate, NextAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    NextAmount = sql_window(lead, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n```\n\nIn these examples, the second argument in the function list (e.g., `[Amount, 1]`) represents the row offset. You can also utilize `first_value` and `last_value` for partition extremes. Detailed documentation on windowing operations is available in `education/book-10-sql-target/06_window_functions.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/06_window_functions.md", "topics": [], "original_answer": "LAG accesses previous rows, LEAD accesses following rows:\n\n```prolog\n% LAG - previous row's value\nsales_with_previous(Salesperson, Amount, SaleDate, PrevAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    PrevAmount = sql_window(lag, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n\n% LEAD - next row's value\nsales_with_next(Salesperson, Amount, SaleDate, NextAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    NextAmount = sql_window(lead, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n```\n\nThe second argument is the offset (how many rows). Also available: `first_value`, `last_value` for partition extremes.", "answer_tailored": true}
{"pair_id": "sql-window-002_p0", "cluster_id": "sql-window-002", "question": "How do I specify window frames in the SQL target?", "question_type": "medium", "answer": "To specify window frames in the SQL target, you use the five-argument version of the `sql_window` function, which includes a `FrameSpec` parameter. This allows for precise control over the range of rows included in a window calculation relative to the current row.\n\nThe predicate signature is:\n```prolog\nsql_window(Function, Args, PartitionBy, OrderBy, FrameSpec)\n```\n\n**Specifying a Running Total (Unbounded Preceding to Current Row):**\n```prolog\nrunning_total(Person, Date, Amount, Total) :-\n    sales(_, Person, _, Amount, Date),\n    Total = sql_window(sum, [Amount], [Person], [(Date, asc)],\n                       rows_between(unbounded_preceding, current_row)).\n```\n\n**Specifying a 3-Day Moving Average:**\n```prolog\nmoving_avg_3day(Person, Date, Amount, MovingAvg) :-\n    sales(_, Person, _, Amount, Date),\n    MovingAvg = sql_window(avg, [Amount], [Person], [(Date, asc)],\n                           rows_between(2 preceding, current_row)).\n```\n\nThe `rows_between` specification supports the following boundaries:\n*   `unbounded_preceding`\n*   `unbounded_following`\n*   `current_row`\n*   `N preceding`\n*   `N following`\n\nFor more comprehensive details on windowing logic, see `education/book-10-sql-target/06_window_functions.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/06_window_functions.md", "topics": [], "original_answer": "Control exactly which rows are included using the 5-argument form:\n\n```prolog\nsql_window(Function, Args, PartitionBy, OrderBy, FrameSpec)\n```\n\n**Running total (default frame):**\n```prolog\nrunning_total(Person, Date, Amount, Total) :-\n    sales(_, Person, _, Amount, Date),\n    Total = sql_window(sum, [Amount], [Person], [(Date, asc)],\n                       rows_between(unbounded_preceding, current_row)).\n```\n\n**3-day moving average:**\n```prolog\nmoving_avg_3day(Person, Date, Amount, MovingAvg) :-\n    sales(_, Person, _, Amount, Date),\n    MovingAvg = sql_window(avg, [Amount], [Person], [(Date, asc)],\n                           rows_between(2 preceding, current_row)).\n```\n\nBoundaries: `unbounded_preceding`, `current_row`, `unbounded_following`, `N preceding`, `N following`", "answer_tailored": true}
