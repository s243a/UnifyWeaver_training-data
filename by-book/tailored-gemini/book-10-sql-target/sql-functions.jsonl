{"pair_id": "sql-func-001_p0", "cluster_id": "sql-func-001", "question": "How do I handle NULL values in the SQL target?", "question_type": "medium", "answer": "In the SQL target, you handle NULL values using built-in predicates that map to standard SQL functions for null management and testing.\n\n**sql_coalesce** - Returns the first non-NULL value in a provided list:\n```prolog\nemployee_with_dept(Name, Dept) :-\n    employees(_, Name, D, _, _, _),\n    Dept = sql_coalesce([D, 'Unknown']).\n```\n\n**sql_nullif** - Returns NULL if the two provided values are equal:\n```prolog\nproduct_real_price(Name, Price) :-\n    products(_, Name, _, P, _, _),\n    Price = sql_nullif(P, 0).  % Returns NULL if P is 0\n```\n\n**sql_is_null / sql_is_not_null** - Used to filter records based on whether a field contains a NULL value:\n```prolog\n% Filter for records where ShipDate is NULL\nunshipped_orders(Id) :-\n    orders(Id, _, _, ShipDate, _),\n    sql_is_null(ShipDate).\n\n% Filter for records where ShipDate contains a value\nshipped_orders(Id, ShipDate) :-\n    orders(Id, _, _, ShipDate, _),\n    sql_is_not_null(ShipDate).\n```\n\nFor more details on implementing SQL-specific logic, see the documentation in `education/book-10-sql-target/`.", "answer_variant": "default", "answer_source": "book-10-sql-target/10_sql_functions.md", "topics": [], "original_answer": "**COALESCE** - first non-NULL value:\n```prolog\nemployee_with_dept(Name, Dept) :-\n    employees(_, Name, D, _, _, _),\n    Dept = sql_coalesce([D, 'Unknown']).\n```\n\n**NULLIF** - return NULL if values equal:\n```prolog\nproduct_real_price(Name, Price) :-\n    products(_, Name, _, P, _, _),\n    Price = sql_nullif(P, 0).  % Treat 0 as NULL\n```\n\n**IS NULL / IS NOT NULL** - test for NULL:\n```prolog\nunshipped_orders(Id) :-\n    orders(Id, _, _, ShipDate, _),\n    sql_is_null(ShipDate).\n\nshipped_orders(Id, ShipDate) :-\n    orders(Id, _, _, ShipDate, _),\n    sql_is_not_null(ShipDate).\n```", "answer_tailored": true}
{"pair_id": "sql-func-001_p0", "cluster_id": "sql-func-001", "question": "What string functions does the SQL target support?", "question_type": "medium", "answer": "The SQL target supports several built-in predicates for string manipulation during query compilation:\n\n- **`sql_concat(List)`**: Joins multiple values or fields into a single string (e.g., `sql_concat([Name, ' - ', Dept])`).\n- **`sql_upper(Value)` / `sql_lower(Value)`**: Converts the provided text to uppercase or lowercase.\n- **`sql_substring(Value, Start, Length)`**: Extracts a specific portion of a string.\n- **`sql_trim(Value)` / `sql_ltrim(Value)` / `sql_rtrim(Value)`**: Strips whitespace from the beginning, end, or both sides of a string.\n- **`sql_length(Value)`**: Returns the character count of the string.\n- **`sql_replace(String, Old, New)`**: Substitutes occurrences of a specific substring with new text.\n\nThese functions can be nested for multi-step transformations:\n```prolog\n% Example: Trimming and converting to uppercase\nResult = sql_upper(sql_trim(Name))\n```\n\nFor more details on implementing these in your SQL queries, see `education/book-10-sql-target/`.", "answer_variant": "default", "answer_source": "book-10-sql-target/10_sql_functions.md", "topics": [], "original_answer": "```prolog\n% CONCAT - concatenate values\nInfo = sql_concat([Name, ' - ', Dept])\n\n% UPPER / LOWER - change case\nUpper = sql_upper(Name)\nLower = sql_lower(Name)\n\n% SUBSTRING - extract part of string\nInitials = sql_substring(Name, 1, 1)\n\n% TRIM / LTRIM / RTRIM - remove whitespace\nTrimmed = sql_trim(Name)\nLeftTrimmed = sql_ltrim(Name)\n\n% LENGTH - string length\nLen = sql_length(Name)\n\n% REPLACE - substitute text\nEmail = sql_replace(E, '@', ' at ')\n```\n\nFunctions can be nested:\n```prolog\nResult = sql_upper(sql_trim(Name))\n```", "answer_tailored": true}
{"pair_id": "sql-func-002_p0", "cluster_id": "sql-func-002", "question": "What date functions does the SQL target support?", "question_type": "medium", "answer": "The SQL target in UnifyWeaver provides a suite of built-in functions for manipulating dates and timestamps:\n\n- **Type Conversion**: Use `sql_date(Value)` to extract the date portion or `sql_datetime(Value)` for full timestamps.\n- **Arithmetic**: `sql_date_add(Base, Amount, Unit)` allows adding intervals (using `days`, `months`, or `years`), while `sql_date_diff(End, Start)` calculates the number of days between two dates.\n- **Component Extraction**: `sql_extract(Part, Value)` retrieves specific parts such as `year`, `month`, `day`, `hour`, `minute`, or `second`.\n- **Formatting**: `sql_strftime(Format, Value)` provides custom string formatting using codes like `%Y` (year), `%m` (month), `%d` (day), `%H` (hour), `%M` (minute), and `%S` (second).\n\nDetailed examples and implementation specifics can be found in `education/book-10-sql-target/10_sql_functions.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/10_sql_functions.md", "topics": [], "original_answer": "```prolog\n% DATE / DATETIME - extract/convert\nDateOnly = sql_date(OrderDate)\nDT = sql_datetime(OrderDate)\n\n% DATE_ADD - add interval\nDueDate = sql_date_add(OrderDate, 7, days)  % days, months, years\n\n% DATE_DIFF - days between dates\nDays = sql_date_diff(ShipDate, OrderDate)\n\n% EXTRACT - get date parts\nYear = sql_extract(year, HireDate)   % year, month, day, hour, minute, second\nMonth = sql_extract(month, HireDate)\n\n% STRFTIME - custom format\nFormatted = sql_strftime('%Y-%m-%d', OrderDate)\n```\n\nFormat codes: `%Y` (year), `%m` (month), `%d` (day), `%H` (hour), `%M` (minute), `%S` (second)", "answer_tailored": true}
{"pair_id": "sql-func-002_p0", "cluster_id": "sql-func-002", "question": "How do I use pattern matching in the SQL target?", "question_type": "medium", "answer": "Pattern matching in the SQL target is primarily achieved using the `sql_like/2` predicate, which supports standard SQL wildcards: `%` for any character sequence and `_` for a single character.\n\n### String Pattern Matching\n```prolog\n% Match any sequence starting with 'J'\nstarts_with_j(Name) :- \n    employees(_, Name, _, _, _, _), \n    sql_like(Name, 'J%').\n\n% Match any sequence containing 'son'\ncontains_son(Name) :- \n    employees(_, Name, _, _, _, _), \n    sql_like(Name, '%son%').\n\n% Negation is also supported via sql_not_like/2\nnot_test(Name) :- \n    employees(_, Name, _, _, _, _), \n    sql_not_like(Name, 'Test%').\n```\n\n### Related Matching Predicates\nBeyond string patterns, the SQL target provides predicates for range and set matching:\n\n*   **Set Membership (`sql_in/2`)**: Checks if a value exists within a provided list.\n    ```prolog\n    engineering_depts(Name, Dept) :-\n        employees(_, Name, Dept, _, _, _),\n        sql_in(Dept, [engineering, 'r&d', development]).\n    ```\n*   **Range Matching (`sql_between/3`)**: Filters values within a specific numeric or temporal range.\n    ```prolog\n    mid_salary(Name, Salary) :-\n        employees(_, Name, _, Salary, _, _),\n        sql_between(Salary, 50000, 100000).\n    ```\n\nFor a comprehensive list of supported SQL operators, see `education/book-10-sql-target/10_sql_functions.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/10_sql_functions.md", "topics": [], "original_answer": "**BETWEEN** - range test:\n```prolog\nmid_salary(Name, Salary) :-\n    employees(_, Name, _, Salary, _, _),\n    sql_between(Salary, 50000, 100000).\n\n% Also: sql_not_between(Salary, 40000, 80000)\n```\n\n**LIKE** - wildcard matching:\n```prolog\n% % matches any sequence, _ matches single char\nj_names(Name) :- employees(_, Name, _, _, _, _), sql_like(Name, 'J%').\nson_names(Name) :- employees(_, Name, _, _, _, _), sql_like(Name, '%son%').\n\n% Also: sql_not_like(Name, 'Test%')\n```\n\n**IN** - list membership:\n```prolog\nengineering_depts(Name, Dept) :-\n    employees(_, Name, Dept, _, _, _),\n    sql_in(Dept, [engineering, 'r&d', development]).\n\n% Also: sql_not_in(Dept, [admin, hr])\n```", "answer_tailored": true}
