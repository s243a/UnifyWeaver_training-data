{"pair_id": "sql-subquery-001_p0", "cluster_id": "sql-subquery-001", "question": "How do I use IN subqueries in the SQL target?", "question_type": "medium", "answer": "To use IN subqueries in the SQL target, employ the `sql_in_subquery/2` predicate to check if a specific column value exists within the results of another defined predicate.\n\n```prolog\n% Define the predicate to be used as a subquery\nprofitable_store(StoreName) :-\n    stores(StoreName, _, Revenue),\n    Revenue > 500000.\n\n% Use sql_in_subquery in the main query logic\npremium_inventories(Item, Store) :-\n    inventory(Item, Store, Quantity),\n    sql_in_subquery(Store, profitable_store/1).\n```\n\nWhen compiled, this generates a standard SQL `WHERE Store IN (SELECT StoreName FROM ...)` clause. This approach allows for modular query design while maintaining efficient SQL output. For further details on handling nested queries and subquery optimization, see `education/book-10-sql-target/05_subqueries.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/05_subqueries.md", "topics": [], "original_answer": "Use `sql_in_subquery/2` to check if a column value exists in another query's results:\n\n```prolog\n% Define subquery predicate\nhigh_budget_dept(DeptName) :-\n    departments(_, DeptName, Budget, _),\n    Budget > 1000000.\n\n% Main query using IN subquery\nemployees_in_rich_depts(EmpName, Dept) :-\n    employees(_, EmpName, Dept, _, _),\n    sql_in_subquery(Dept, high_budget_dept/1).\n```\n\nGenerates: `SELECT name, dept FROM employees WHERE dept IN (SELECT name FROM departments WHERE budget > 1000000)`", "answer_tailored": true}
{"pair_id": "sql-subquery-001_p0", "cluster_id": "sql-subquery-001", "question": "How do I use EXISTS subqueries?", "question_type": "medium", "answer": "In UnifyWeaver's SQL target, you implement existence checks using the `sql_exists/1` predicate. This predicate evaluates whether a subquery returns any rows and is generally more efficient than `IN` clauses when working with large datasets.\n\nExample usage:\n```prolog\n% Define the subquery\ndept_has_employees(DeptName) :-\n    employees(_, _, DeptName, _, _).\n\n% Filter departments that have at least one employee\nactive_departments(DeptName, Budget) :-\n    departments(_, DeptName, Budget, _),\n    sql_exists(dept_has_employees(DeptName)).\n```\n\nThe compiler translates this into a SQL `WHERE EXISTS` clause (e.g., `WHERE EXISTS (SELECT 1 FROM employees WHERE dept = d.name)`).\n\nTo verify that no rows match a subquery, use the `sql_not_exists/1` predicate:\n```prolog\nproducts_never_ordered(Name, Price) :-\n    products(_, Name, _, Price),\n    sql_not_exists(product_ordered(Name)).\n```\n\nFor further details on subquery compilation and optimization, see `education/book-10-sql-target/05_subqueries.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/05_subqueries.md", "topics": [], "original_answer": "Use `sql_exists/1` to check if ANY rows exist in the subquery. It's more efficient than IN for large datasets:\n\n```prolog\ndept_has_employees(DeptName) :-\n    employees(_, _, DeptName, _, _).\n\nactive_departments(DeptName, Budget) :-\n    departments(_, DeptName, Budget, _),\n    sql_exists(dept_has_employees(DeptName)).\n```\n\nGenerates: `WHERE EXISTS (SELECT 1 FROM employees WHERE dept = d.name)`\n\nFor negation, use `sql_not_exists/1`:\n```prolog\nproducts_never_ordered(Name, Price) :-\n    products(_, Name, _, Price),\n    sql_not_exists(product_ordered(Name)).\n```", "answer_tailored": true}
{"pair_id": "sql-subquery-002_p0", "cluster_id": "sql-subquery-002", "question": "What's the difference between correlated and non-correlated subqueries?", "question_type": "medium", "answer": "In UnifyWeaver's SQL target, the primary difference is whether the subquery relies on variables from the outer query's scope.\n\n**Non-correlated subqueries** are independent and execute once. The result set is determined entirely before the outer query uses it. These are typically implemented using `sql_in_subquery/2`:\n```prolog\n% This subquery runs independently to find high-average departments\navg_salary_dept(Dept) :-\n    employees(_, _, Dept, Salary, _),\n    sql_group_by([Dept]),\n    AvgSal = sql_avg(Salary),\n    sql_having(AvgSal > 60000).\n\nemployees_in_high_avg_depts(Name) :-\n    employees(_, Name, Dept, _, _),\n    sql_in_subquery(Dept, avg_salary_dept/1).\n```\n\n**Correlated subqueries** reference data from the outer query, meaning they are conceptually re-evaluated for every row processed by the outer query. These are most often used with `sql_exists/1`:\n```prolog\n% This subquery references 'DeptName' from the calling context\ndept_employee_exists(DeptName) :-\n    employees(_, _, DeptName, _, _).\n\ndepts_with_staff(Name) :-\n    departments(_, Name, _, _),\n    sql_exists(dept_employee_exists(Name)).\n```\n\nNon-correlated queries offer better modularity for static filters, whereas correlated queries allow for row-by-row validation against external tables. For further details on SQL subquery compilation, see `education/book-10-sql-target/05_subqueries.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/05_subqueries.md", "topics": [], "original_answer": "**Non-correlated**: Subquery runs once, independently of outer query:\n```prolog\navg_salary_dept(Dept) :-\n    employees(_, _, Dept, Salary, _),\n    sql_group_by([Dept]),\n    AvgSal = sql_avg(Salary),\n    sql_having(AvgSal > 60000).\n\nemployees_in_high_avg_depts(Name) :-\n    employees(_, Name, Dept, _, _),\n    sql_in_subquery(Dept, avg_salary_dept/1).\n```\n\n**Correlated**: Subquery references outer query (runs once per outer row):\n```prolog\ndept_employee_exists(DeptName) :-\n    employees(_, _, DeptName, _, _).  % DeptName from outer\n\ndepts_with_staff(Name) :-\n    departments(_, Name, _, _),\n    sql_exists(dept_employee_exists(Name)).  % Correlated\n```\n\nEXISTS subqueries are typically correlated.", "answer_tailored": true}
