{"pair_id": "constraint-usage_p0", "cluster_id": "constraint-usage", "question": "What are constraints in UnifyWeaver and how do I use them?", "question_type": "medium", "answer": "In UnifyWeaver, constraints are metadata declarations that inform the compiler about the logical properties of your predicates. By specifying whether a predicate's results are unique or if their order must be preserved, you allow the compiler to generate more efficient target code\u2014such as choosing between a simple stream, a sorting operation, or a hash-set filter.\n\n### How to Use Constraints\n\nYou primarily apply constraints using the `constraint/2` pragma in your Prolog source. This tells the `constraint_analyzer.pl` how to treat the predicate during the compilation phase.\n\n```prolog\n% Recommended: Pragma-style declaration\n:- constraint(user_access/2, [unique(true), unordered(false)]).\n\n% Alternative: Programmatic declaration\n?- declare_constraint(my_helper/3, [unique(false)]).\n```\n\n### Key Available Constraints\n\n| Constraint | Behavior | Compilation Impact |\n|------------|----------|-------------------|\n| `unique(true)` | Deduplicates results (Default) | Uses tools like `sort -u` or hash sets to ensure no repeats. |\n| `unique(false)` | Allows duplicates | Generates raw output, avoiding the overhead of deduplication. |\n| `unordered(true)` | Order does not matter (Default) | Allows high-performance sorting or parallel processing. |\n| `unordered(false)` | Preserves result sequence | Forces the use of order-preserving filters (like hash tables). |\n\n### Impact on Code Generation\n\nThe compiler adjusts the output based on these settings. For example, in the Bash target:\n\n*   **`unique(true), unordered(true)`**: Generates `results | sort -u`.\n*   **`unique(true), unordered(false)`**: Generates a `while` loop with an associative array (`declare -A seen`) to filter duplicates while maintaining the original order.\n*   **`unique(false)`**: Simply outputs the `results` directly.\n\n### Usage Examples\n\n```prolog\n% Use for time-series or logs where order is critical\n:- constraint(transaction_history/2, [unordered(false)]).\n\n% Use for aggregation or counting where duplicates are necessary\n:- constraint(item_occurrence/2, [unique(false)]).\n\n% Default behavior is suitable for standard set relations\n:- constraint(parent_of/2, [unique(true), unordered(true)]).\n```\n\nTo verify the constraints currently applied to a predicate, you can use:\n`?- get_constraints(predicate_name/arity, List).`\n\nFor a deeper look at target-specific optimizations, refer to `education/book-01-foundations/` and the language-specific chapters such as `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/constraint_analyzer.pl", "topics": ["constraints", "unique", "ordered", "deduplication", "optimization"], "original_answer": "## Constraints in UnifyWeaver\n\nConstraints tell the compiler about properties of your predicates, enabling optimizations.\n\n### Available Constraints\n\n| Constraint | Meaning | Default |\n|------------|---------|--------|\n| `unique(true)` | Predicate never returns duplicates | true |\n| `unique(false)` | May return duplicates | false |\n| `unordered(true)` | Order doesn't matter | true |\n| `unordered(false)` | Order must be preserved | false |\n\n### Declaring Constraints\n\n```prolog\n% Pragma-style (recommended)\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n\n% Or programmatically\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### How Constraints Affect Code Generation\n\n**With `unique(true), unordered(true)` (default):**\n```bash\n# Uses sort -u for deduplication\nresults | sort -u\n```\n\n**With `unique(true), unordered(false)`:**\n```bash\n# Uses hash table to preserve order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**With `unique(false)`:**\n```bash\n# No deduplication - raw output\nresults\n```\n\n### When to Override Defaults\n\n```prolog\n% Temporal data - order matters!\n:- constraint(event_log/2, [unordered(false)]).\n\n% May have duplicates (counting queries)\n:- constraint(word_count/2, [unique(false)]).\n\n% Set-like operations (default is fine)\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\n### Checking Active Constraints\n\n```prolog\n?- get_constraints(my_pred/2, C).\nC = [unique(true), unordered(true)].\n```", "answer_tailored": true}
{"pair_id": "constraint-usage_p1", "cluster_id": "constraint-usage", "question": "What does unique(true) mean in UnifyWeaver?", "question_type": "medium", "answer": "In UnifyWeaver, the `unique(true)` constraint indicates that a predicate is guaranteed to never return duplicate results. This is the default setting for all predicates, informing the compiler that it can safely perform deduplication optimizations during code generation.\n\n### Performance and Optimization\nThe technical implementation of `unique(true)` depends on whether the results are also marked as `unordered`:\n\n*   **With `unordered(true)` (Default):** The compiler optimizes for set-like operations. In the Bash target, this typically results in using `sort -u` for efficient deduplication.\n*   **With `unordered(false)`:** If result order must be preserved, the compiler generates logic using a hash table (e.g., `declare -A seen` in Bash) to filter out duplicates as they appear.\n\n### Declaring the Constraint\nYou can explicitly define this property using a pragma or a programmatic declaration:\n\n```prolog\n% Recommended pragma-style declaration\n:- constraint(my_predicate/2, [unique(true), unordered(true)]).\n\n% Programmatic alternative\n?- declare_constraint(my_predicate/2, [unique(true)]).\n```\n\n### When to Change the Default\nYou should only override this to `unique(false)` if your logic explicitly requires duplicates, such as in \"word count\" or other frequency-based aggregation queries.\n\nFor more details on how these properties affect specific compilation outputs, refer to the target-specific chapters in the education series, such as `education/book-02-bash-target/` or `education/book-03-python-target/`. The core logic for these optimizations resides in `src/unifyweaver/core/constraint_analyzer.pl`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/constraint_analyzer.pl", "topics": ["constraints", "unique", "ordered", "deduplication", "optimization"], "original_answer": "## Constraints in UnifyWeaver\n\nConstraints tell the compiler about properties of your predicates, enabling optimizations.\n\n### Available Constraints\n\n| Constraint | Meaning | Default |\n|------------|---------|--------|\n| `unique(true)` | Predicate never returns duplicates | true |\n| `unique(false)` | May return duplicates | false |\n| `unordered(true)` | Order doesn't matter | true |\n| `unordered(false)` | Order must be preserved | false |\n\n### Declaring Constraints\n\n```prolog\n% Pragma-style (recommended)\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n\n% Or programmatically\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### How Constraints Affect Code Generation\n\n**With `unique(true), unordered(true)` (default):**\n```bash\n# Uses sort -u for deduplication\nresults | sort -u\n```\n\n**With `unique(true), unordered(false)`:**\n```bash\n# Uses hash table to preserve order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**With `unique(false)`:**\n```bash\n# No deduplication - raw output\nresults\n```\n\n### When to Override Defaults\n\n```prolog\n% Temporal data - order matters!\n:- constraint(event_log/2, [unordered(false)]).\n\n% May have duplicates (counting queries)\n:- constraint(word_count/2, [unique(false)]).\n\n% Set-like operations (default is fine)\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\n### Checking Active Constraints\n\n```prolog\n?- get_constraints(my_pred/2, C).\nC = [unique(true), unordered(true)].\n```", "answer_tailored": true}
{"pair_id": "constraint-usage_p2", "cluster_id": "constraint-usage", "question": "How do constraints affect generated code?", "question_type": "medium", "answer": "Constraints in UnifyWeaver directly determine the logic and shell utilities injected into the generated code by defining the properties of a predicate's result set. These hints allow the compiler to optimize for performance while ensuring data integrity.\n\n### Primary Constraints\n*   **`unique`**: Specifies if the output should be deduplicated (Default: `true`).\n*   **`unordered`**: Specifies if the original sequence of the data must be maintained (Default: `true`).\n\n### How Constraints Modify Output (Bash Target)\nThe compiler selects different execution strategies based on these settings:\n\n1.  **`unique(true), unordered(true)` (Default)**:\n    Generates a `sort -u` pipeline, providing the most efficient deduplication when order is not a concern.\n2.  **`unique(true), unordered(false)`**:\n    Generates an associative array check (`[[ -z \"${seen[$line]}\" ]]`) to filter duplicates while preserving the incoming stream order.\n3.  **`unique(false)`**:\n    Generates raw output streams without any deduplication overhead, ideal for counting or temporal logs.\n\n### Declaration and Usage\nYou can override defaults using the `constraint/2` pragma:\n```prolog\n% Ensure event order is preserved for temporal analysis\n:- constraint(system_logs/3, [unique(false), unordered(false)]).\n```\n\n### Technical Reference\nThe analyzer logic is located in `src/unifyweaver/core/constraint_analyzer.pl`. For detailed examples of how these translate to specific target languages, see `education/book-02-bash-target/` for shell scripts or `education/book-04-python-target/` for Python implementations.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/constraint_analyzer.pl", "topics": ["constraints", "unique", "ordered", "deduplication", "optimization"], "original_answer": "## Constraints in UnifyWeaver\n\nConstraints tell the compiler about properties of your predicates, enabling optimizations.\n\n### Available Constraints\n\n| Constraint | Meaning | Default |\n|------------|---------|--------|\n| `unique(true)` | Predicate never returns duplicates | true |\n| `unique(false)` | May return duplicates | false |\n| `unordered(true)` | Order doesn't matter | true |\n| `unordered(false)` | Order must be preserved | false |\n\n### Declaring Constraints\n\n```prolog\n% Pragma-style (recommended)\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n\n% Or programmatically\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### How Constraints Affect Code Generation\n\n**With `unique(true), unordered(true)` (default):**\n```bash\n# Uses sort -u for deduplication\nresults | sort -u\n```\n\n**With `unique(true), unordered(false)`:**\n```bash\n# Uses hash table to preserve order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**With `unique(false)`:**\n```bash\n# No deduplication - raw output\nresults\n```\n\n### When to Override Defaults\n\n```prolog\n% Temporal data - order matters!\n:- constraint(event_log/2, [unordered(false)]).\n\n% May have duplicates (counting queries)\n:- constraint(word_count/2, [unique(false)]).\n\n% Set-like operations (default is fine)\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\n### Checking Active Constraints\n\n```prolog\n?- get_constraints(my_pred/2, C).\nC = [unique(true), unordered(true)].\n```", "answer_tailored": true}
{"pair_id": "constraint-usage_p3", "cluster_id": "constraint-usage", "question": "What deduplication strategies does UnifyWeaver support?", "question_type": "medium", "answer": "UnifyWeaver supports several deduplication strategies that are automatically selected based on the `unique` and `unordered` constraints applied to a predicate.\n\n### Supported Deduplication Strategies\n\n1.  **Unordered Set Deduplication (Default):** For predicates marked `unique(true)` and `unordered(true)`, the compiler employs high-performance set-based filtering. In the Bash target, this is typically realized via `sort -u`.\n2.  **Stable (Order-Preserving) Deduplication:** When a predicate requires `unique(true)` but must maintain its sequence (`unordered(false)`), UnifyWeaver generates logic that tracks seen items using a hash table or associative array. This ensures only the first instance of a duplicate is emitted without reordering the stream.\n3.  **Stream Pass-Through (No Deduplication):** If a predicate is explicitly marked `unique(false)`, the compiler omits deduplication logic entirely. This is used for performance-sensitive paths or when duplicates are required for aggregations (e.g., counting occurrences).\n\n### Implementation via Constraints\n\nDeduplication behavior is controlled using the `:- constraint/2` pragma in your Prolog source:\n\n```prolog\n% Standard set-based deduplication\n:- constraint(user_permissions/2, [unique(true), unordered(true)]).\n\n% Deduplicate while preserving original order\n:- constraint(audit_trail/2, [unique(true), unordered(false)]).\n\n% Disable deduplication for raw data streams\n:- constraint(raw_metrics/2, [unique(false)]).\n```\n\nBy declaring these properties, the compiler can optimize the generated code for targets like Bash, Python, and Go. For more technical details on constraint implementation, see `src/unifyweaver/core/constraint_analyzer.pl` or refer to the examples in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/constraint_analyzer.pl", "topics": ["constraints", "unique", "ordered", "deduplication", "optimization"], "original_answer": "## Constraints in UnifyWeaver\n\nConstraints tell the compiler about properties of your predicates, enabling optimizations.\n\n### Available Constraints\n\n| Constraint | Meaning | Default |\n|------------|---------|--------|\n| `unique(true)` | Predicate never returns duplicates | true |\n| `unique(false)` | May return duplicates | false |\n| `unordered(true)` | Order doesn't matter | true |\n| `unordered(false)` | Order must be preserved | false |\n\n### Declaring Constraints\n\n```prolog\n% Pragma-style (recommended)\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n\n% Or programmatically\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### How Constraints Affect Code Generation\n\n**With `unique(true), unordered(true)` (default):**\n```bash\n# Uses sort -u for deduplication\nresults | sort -u\n```\n\n**With `unique(true), unordered(false)`:**\n```bash\n# Uses hash table to preserve order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**With `unique(false)`:**\n```bash\n# No deduplication - raw output\nresults\n```\n\n### When to Override Defaults\n\n```prolog\n% Temporal data - order matters!\n:- constraint(event_log/2, [unordered(false)]).\n\n% May have duplicates (counting queries)\n:- constraint(word_count/2, [unique(false)]).\n\n% Set-like operations (default is fine)\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\n### Checking Active Constraints\n\n```prolog\n?- get_constraints(my_pred/2, C).\nC = [unique(true), unordered(true)].\n```", "answer_tailored": true}
{"pair_id": "troubleshooting-compilation_p0", "cluster_id": "troubleshooting-compilation", "question": "How do I debug compilation errors in UnifyWeaver?", "question_type": "medium", "answer": "To debug compilation errors in UnifyWeaver, you should verify your Prolog environment, utilize compiler debug flags, and trace the generated code in its target environment.\n\n### 1. Resolve \"Procedure Not Found\" Errors\nIf you receive `ERROR: Unknown procedure: my_pred/N`, the compiler cannot find your predicate. Ensure it is loaded and has the correct arity:\n* **Verify:** Use `?- listing(my_pred).` to see what is currently in memory.\n* **Load:** Use `?- ['path/to/file.pl'].` to load your source code.\n* **Assert:** For quick tests, you can use `?- assertz(my_pred(a, b)).`\n\n### 2. Enable Compiler Debugging and Tracing\nWhen a predicate compiles but behaves unexpectedly, use the verbose flag and debug options to see how the compiler is classifying your logic:\n```prolog\n% Enable detailed compiler output\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debug mode enabled\n?- compile(my_pred/2, [target(bash), debug(true)], S).\n```\nReview the \"Classification\" output (e.g., `transitive_closure` or `join_operation`) to ensure UnifyWeaver correctly identifies your predicate's pattern.\n\n### 3. Handle Firewall Information\nIf you see `INFO: No firewall rules defined`, UnifyWeaver is using an implicit allow policy. This is standard for development. To configure security constraints, use the `core/firewall.pl` module:\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### 4. Debugging the Generated Output (e.g., Bash)\nIf the Prolog logic is sound but the generated code fails:\n1. **Prolog First:** Run the predicate in native Prolog to confirm the results are correct.\n2. **Inspect Source:** Check the generated file (e.g., `output/my_pred.sh`) for proper array initialization and key formatting (`key1:key2`).\n3. **Shell Tracing:** Source the script and use `set -x` to trace the execution flow:\n   ```bash\n   source my_pred.sh\n   set -x\n   my_pred_stream\n   set +x\n   ```\n\n### Troubleshooting Common Issues\n\n| Symptom | Probable Cause | Fix |\n|---------|----------------|-----|\n| No output results | Source facts are missing | Check `listing(pred)` in Prolog |\n| Infinite loops | Missing cycle detection | Apply `unique(true)` constraint |\n| Duplicate records | Strategy mismatch | Verify deduplication constraints |\n| Arity mismatch | Predicate signature error | Ensure `pred/N` matches your facts |\n\nFor more detailed target-specific debugging, refer to the tutorials in `education/book-02-bash-target/` or the examples in the `playbooks/` directory.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/firewall.pl", "topics": ["troubleshooting", "errors", "debugging", "firewall", "compilation-errors"], "original_answer": "## Troubleshooting UnifyWeaver Compilation\n\n### Error: \"procedure not found\"\n\n**Cause:** The predicate isn't loaded or has wrong arity.\n\n```prolog\n?- compile(my_pred/2, [target(bash)], S).\nERROR: Unknown procedure: my_pred/2\n```\n\n**Fix:**\n```prolog\n% Check what's loaded\n?- listing(my_pred).\n\n% Load your file\n?- ['my_predicates.pl'].\n\n% Or assert directly\n?- assertz(my_pred(a, b)).\n```\n\n### Info: \"No firewall rules defined\"\n\n```\nINFO: No firewall rules defined. Using implicit allow.\n```\n\n**Meaning:** The firewall security system isn't configured. This is OK for development.\n\n**To configure:**\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### Wrong Results in Generated Bash\n\n**Step 1: Test Prolog logic first**\n```prolog\n?- my_pred(X, Y).\n% Verify results are correct in Prolog\n```\n\n**Step 2: Check generated code structure**\n```bash\ncat output/my_pred.sh\n# Look for:\n# - Correct key format (arg1:arg2)\n# - Proper array initialization\n# - Visited tracking for recursion\n```\n\n**Step 3: Debug with traces**\n```bash\nsource my_pred.sh\nset -x  # Enable bash tracing\nmy_pred_stream\nset +x\n```\n\n### Common Issues\n\n| Symptom | Cause | Fix |\n|---------|-------|-----|\n| Empty output | Facts not loaded | Check `listing(pred)` |\n| Infinite loop | No cycle detection | Add `unique(true)` constraint |\n| Duplicates | Wrong dedup strategy | Check constraints |\n| Key not found | Wrong arity | Verify `pred/N` matches facts |\n\n### Debugging Recursive Predicates\n\n```prolog\n% Enable compiler tracing\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debug info\n?- compile(reaches/2, [target(bash), debug(true)], S).\n\n% Check classification\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf classification is wrong, simplify your rules to match known patterns.", "answer_tailored": true}
{"pair_id": "troubleshooting-compilation_p1", "cluster_id": "troubleshooting-compilation", "question": "What does 'procedure not found' mean during compilation?", "question_type": "medium", "answer": "In UnifyWeaver, the \"procedure not found\" (or \"Unknown procedure\") error during compilation signifies that the compiler cannot locate the specific predicate definition you are attempting to target. This usually occurs because the source file hasn't been consulted into the Prolog environment or there is a mismatch in the arity (the number of arguments) specified.\n\n### Common Causes and Fixes\n\n*   **Missing Predicate:** The predicate hasn't been loaded into the current session. Use `listing/1` to verify what is currently in memory:\n    ```prolog\n    ?- listing(my_predicate).\n    ```\n*   **Arity Mismatch:** You may be targeting a predicate with the wrong number of arguments. For example, if you attempt to compile `my_pred/2` but only `my_pred/1` is defined, the compiler will fail:\n    ```prolog\n    ?- compile(my_pred/2, [target(bash)], S).\n    % ERROR: Unknown procedure: my_pred/2\n    ```\n*   **Unloaded Source:** Ensure your logic is properly loaded using the consult command:\n    ```prolog\n    ?- ['path/to/your_file.pl'].\n    ```\n\n### Related Debugging Tips\n\nIf your procedure is found but the compilation produces unexpected results:\n*   **Trace logic in Prolog:** Verify the predicate works correctly in the Prolog shell before compiling.\n*   **Check Arity in Facts:** Ensure that your fact base matches the arity expected by your rules (e.g., `pred/N`).\n*   **Enable Verbose Logging:** Set `set_prolog_flag(verbose, normal)` to see how the compiler is classifying your predicates (e.g., as a transitive closure or a simple join).\n\nFor a complete guide on environment setup and basic compilation commands, see the documentation in `education/book-01-foundations/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/firewall.pl", "topics": ["troubleshooting", "errors", "debugging", "firewall", "compilation-errors"], "original_answer": "## Troubleshooting UnifyWeaver Compilation\n\n### Error: \"procedure not found\"\n\n**Cause:** The predicate isn't loaded or has wrong arity.\n\n```prolog\n?- compile(my_pred/2, [target(bash)], S).\nERROR: Unknown procedure: my_pred/2\n```\n\n**Fix:**\n```prolog\n% Check what's loaded\n?- listing(my_pred).\n\n% Load your file\n?- ['my_predicates.pl'].\n\n% Or assert directly\n?- assertz(my_pred(a, b)).\n```\n\n### Info: \"No firewall rules defined\"\n\n```\nINFO: No firewall rules defined. Using implicit allow.\n```\n\n**Meaning:** The firewall security system isn't configured. This is OK for development.\n\n**To configure:**\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### Wrong Results in Generated Bash\n\n**Step 1: Test Prolog logic first**\n```prolog\n?- my_pred(X, Y).\n% Verify results are correct in Prolog\n```\n\n**Step 2: Check generated code structure**\n```bash\ncat output/my_pred.sh\n# Look for:\n# - Correct key format (arg1:arg2)\n# - Proper array initialization\n# - Visited tracking for recursion\n```\n\n**Step 3: Debug with traces**\n```bash\nsource my_pred.sh\nset -x  # Enable bash tracing\nmy_pred_stream\nset +x\n```\n\n### Common Issues\n\n| Symptom | Cause | Fix |\n|---------|-------|-----|\n| Empty output | Facts not loaded | Check `listing(pred)` |\n| Infinite loop | No cycle detection | Add `unique(true)` constraint |\n| Duplicates | Wrong dedup strategy | Check constraints |\n| Key not found | Wrong arity | Verify `pred/N` matches facts |\n\n### Debugging Recursive Predicates\n\n```prolog\n% Enable compiler tracing\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debug info\n?- compile(reaches/2, [target(bash), debug(true)], S).\n\n% Check classification\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf classification is wrong, simplify your rules to match known patterns.", "answer_tailored": true}
{"pair_id": "troubleshooting-compilation_p2", "cluster_id": "troubleshooting-compilation", "question": "What is the firewall and how does it affect compilation?", "question_type": "medium", "answer": "The firewall in UnifyWeaver is a security subsystem located in `src/unifyweaver/core/firewall.pl` that governs which compilation targets and system capabilities (such as shell execution) are permitted. It affects compilation by acting as a gatekeeper; the compiler validates the requested target and the features utilized in your Prolog rules against the active security policy. If a compilation task violates a defined policy, the compiler will refuse to generate the output code.\n\n### Firewall Status and Configuration\nIf you see the message `INFO: No firewall rules defined. Using implicit allow.`, the security system is unconfigured, which is the default for development. To enforce restrictions, you must load the firewall module and define a policy:\n\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n% Example: Allow Bash generation but block shell execution capabilities\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### Common Compilation and Troubleshooting Issues\nWhile the firewall controls security, other factors can prevent successful compilation or execution:\n\n*   **Procedure Not Found:** This error occurs if the predicate isn't loaded or has the wrong arity. Verify your facts with `listing(my_pred).` or ensure your file is loaded using `['my_predicates.pl'].`\n*   **Infinite Loops:** If generated code hangs, it often lacks cycle detection. Add the `unique(true)` constraint to your compilation options.\n*   **Logic Verification:** Always test your predicates in the Prolog REPL first to ensure the results are correct before attempting compilation to a target language.\n*   **Debugging Recursive Predicates:** You can enable verbose compiler output using `set_prolog_flag(verbose, normal).` and compile with `debug(true)` to see how the compiler classifies your rules (e.g., as a transitive closure).\n\nFor a deeper understanding of security constraints and target-specific compilation, refer to `education/book-01-foundations/` and `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/firewall.pl", "topics": ["troubleshooting", "errors", "debugging", "firewall", "compilation-errors"], "original_answer": "## Troubleshooting UnifyWeaver Compilation\n\n### Error: \"procedure not found\"\n\n**Cause:** The predicate isn't loaded or has wrong arity.\n\n```prolog\n?- compile(my_pred/2, [target(bash)], S).\nERROR: Unknown procedure: my_pred/2\n```\n\n**Fix:**\n```prolog\n% Check what's loaded\n?- listing(my_pred).\n\n% Load your file\n?- ['my_predicates.pl'].\n\n% Or assert directly\n?- assertz(my_pred(a, b)).\n```\n\n### Info: \"No firewall rules defined\"\n\n```\nINFO: No firewall rules defined. Using implicit allow.\n```\n\n**Meaning:** The firewall security system isn't configured. This is OK for development.\n\n**To configure:**\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### Wrong Results in Generated Bash\n\n**Step 1: Test Prolog logic first**\n```prolog\n?- my_pred(X, Y).\n% Verify results are correct in Prolog\n```\n\n**Step 2: Check generated code structure**\n```bash\ncat output/my_pred.sh\n# Look for:\n# - Correct key format (arg1:arg2)\n# - Proper array initialization\n# - Visited tracking for recursion\n```\n\n**Step 3: Debug with traces**\n```bash\nsource my_pred.sh\nset -x  # Enable bash tracing\nmy_pred_stream\nset +x\n```\n\n### Common Issues\n\n| Symptom | Cause | Fix |\n|---------|-------|-----|\n| Empty output | Facts not loaded | Check `listing(pred)` |\n| Infinite loop | No cycle detection | Add `unique(true)` constraint |\n| Duplicates | Wrong dedup strategy | Check constraints |\n| Key not found | Wrong arity | Verify `pred/N` matches facts |\n\n### Debugging Recursive Predicates\n\n```prolog\n% Enable compiler tracing\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debug info\n?- compile(reaches/2, [target(bash), debug(true)], S).\n\n% Check classification\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf classification is wrong, simplify your rules to match known patterns.", "answer_tailored": true}
{"pair_id": "troubleshooting-compilation_p3", "cluster_id": "troubleshooting-compilation", "question": "My generated Bash code gives wrong results - how do I debug?", "question_type": "medium", "answer": "To debug incorrect results in generated Bash code, you should follow a systematic approach to isolate whether the issue is in the source Prolog logic or the compiler's target mapping.\n\n### 1. Validate Prolog Logic First\nBefore investigating the Bash output, ensure the predicate behaves correctly in the Prolog environment:\n```prolog\n?- my_pred(X, Y).\n% Confirm that the results here match your expectations.\n```\nIf Prolog returns incorrect results, use `listing(my_pred)` to verify your facts are loaded or `trace.` to step through the execution.\n\n### 2. Enable Compiler Diagnostics\nRe-compile your predicate with the `debug` option enabled to see how UnifyWeaver classifies your logic (e.g., as a join, transitive closure, or simple scan):\n```prolog\n?- compile(my_pred/2, [target(bash), debug(true)], Script).\n```\nCheck the \"Analyzing\" output to ensure the compiler identified the correct recursive pattern.\n\n### 3. Trace Bash Execution\nTo see exactly what the generated script is doing at runtime, use Bash's built-in tracing:\n```bash\nsource output/my_pred.sh\nset -x          # Enable execution trace\nmy_pred_stream  # Run the generated function\nset +x          # Disable trace\n```\nLook for issues in key formatting (e.g., `arg1:arg2`), array initialization, or the `visited` tracking logic used for recursion.\n\n### 4. Common Runtime Symptoms\n\n| Symptom | Probable Cause | Resolution |\n|---------|---------------|------------|\n| **Empty Output** | Facts not loaded during compilation | Run `listing(pred)` before `compile`. |\n| **Infinite Loop** | Missing cycle detection | Add `unique(true)` constraint to the predicate. |\n| **Duplicate Rows** | Incorrect deduplication strategy | Check `distinct` or `key_strategy` constraints. |\n| **Missing Rows** | Key format/Arity mismatch | Verify `pred/N` arity matches your data source. |\n\n### 5. Inspect Generated Structure\nManually inspect the `.sh` file. Key areas to check:\n- **Key Generation:** Ensure composite keys are delimited correctly.\n- **Visited Sets:** For recursive queries, ensure the `visited` associative array is being populated to prevent infinite loops.\n- **Data Ingestion:** Verify that the input stream (CSV/JSONL) matches the expected field order.\n\nFor detailed information on Bash-specific implementation patterns, see `education/book-02-bash-target/`. For general debugging of the compilation pipeline, refer to `education/book-05-compilation-pipeline/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/firewall.pl", "topics": ["troubleshooting", "errors", "debugging", "firewall", "compilation-errors"], "original_answer": "## Troubleshooting UnifyWeaver Compilation\n\n### Error: \"procedure not found\"\n\n**Cause:** The predicate isn't loaded or has wrong arity.\n\n```prolog\n?- compile(my_pred/2, [target(bash)], S).\nERROR: Unknown procedure: my_pred/2\n```\n\n**Fix:**\n```prolog\n% Check what's loaded\n?- listing(my_pred).\n\n% Load your file\n?- ['my_predicates.pl'].\n\n% Or assert directly\n?- assertz(my_pred(a, b)).\n```\n\n### Info: \"No firewall rules defined\"\n\n```\nINFO: No firewall rules defined. Using implicit allow.\n```\n\n**Meaning:** The firewall security system isn't configured. This is OK for development.\n\n**To configure:**\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### Wrong Results in Generated Bash\n\n**Step 1: Test Prolog logic first**\n```prolog\n?- my_pred(X, Y).\n% Verify results are correct in Prolog\n```\n\n**Step 2: Check generated code structure**\n```bash\ncat output/my_pred.sh\n# Look for:\n# - Correct key format (arg1:arg2)\n# - Proper array initialization\n# - Visited tracking for recursion\n```\n\n**Step 3: Debug with traces**\n```bash\nsource my_pred.sh\nset -x  # Enable bash tracing\nmy_pred_stream\nset +x\n```\n\n### Common Issues\n\n| Symptom | Cause | Fix |\n|---------|-------|-----|\n| Empty output | Facts not loaded | Check `listing(pred)` |\n| Infinite loop | No cycle detection | Add `unique(true)` constraint |\n| Duplicates | Wrong dedup strategy | Check constraints |\n| Key not found | Wrong arity | Verify `pred/N` matches facts |\n\n### Debugging Recursive Predicates\n\n```prolog\n% Enable compiler tracing\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debug info\n?- compile(reaches/2, [target(bash), debug(true)], S).\n\n% Check classification\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf classification is wrong, simplify your rules to match known patterns.", "answer_tailored": true}
