{"pair_id": "bash-target-design_p0", "cluster_id": "bash-target-design", "question": "How does UnifyWeaver generate Bash code?", "question_type": "medium", "answer": "UnifyWeaver generates Bash code by compiling Prolog logic into template-driven shell scripts designed for stream-based execution. \n\n### Data Representation\nProlog facts are transformed into `declare -A` associative arrays within the generated script. This allows for O(1) lookups and efficient deduplication. For example, a fact like `parent(alice, bob)` becomes a key in a Bash array, and the compiler generates companion functions to stream these facts or perform reverse lookups.\n\n### Compiling Recursion\nTo handle recursive predicates and transitive closures without the risk of stack overflows in shell environments, UnifyWeaver implements logic using Breadth-First Search (BFS) loops. Key components of this implementation include:\n- **Queue-based Traversal**: Iteratively expanding the frontier of the query.\n- **Memoization**: Utilizing a `visited` associative array to track state, which provides built-in cycle detection and prevents infinite loops.\n\n### Streaming Architecture\nThe generated code adheres to the Unix philosophy by using stdout for streaming results. This allows generated functions to be piped together or integrated with standard command-line utilities.\n\nFor more technical details on the specific code generation templates, see `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["bash", "code-generation", "associative-arrays", "streaming", "templates"], "original_answer": "## Bash Target Design\n\nThe Bash target uses template-driven code generation to create shell scripts that operate over textual streams.\n\n## Facts \u2192 Associative Arrays\n\nProlog facts compile to `declare -A` associative arrays:\n\n```prolog\n% Prolog facts\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nGenerated Bash:\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n\nparent_reverse_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        IFS=\":\" read -r a b <<< \"$key\"\n        echo \"$b:$a\"\n    done\n}\n```\n\n## Recursion \u2192 BFS with Memoization\n\nTransitive closures use BFS loops with visited tracking:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Initialize with base cases\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS traversal\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\n## Key Features\n\n- **Deduplication**: `declare -A` provides O(1) lookup\n- **Streaming**: Functions output to stdout for piping\n- **Cycle detection**: `visited` array prevents infinite loops", "answer_tailored": true}
{"pair_id": "bash-target-design_p1", "cluster_id": "bash-target-design", "question": "How are Prolog facts compiled to Bash?", "question_type": "medium", "answer": "Prolog facts are compiled to Bash by mapping them to associative arrays (`declare -A`) where composite keys represent the serialized arguments of each fact. This template-driven approach enables the generated shell scripts to perform efficient O(1) lookups and operate over textual streams.\n\n### Fact Translation\nEach fact is transformed into an entry in a global associative array. Arguments are typically joined with colons to form a unique key.\n\n**Prolog Input:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated Bash Implementation:**\n```bash\n#!/bin/bash\n# Data storage for the 'parent' predicate\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\n# Standard lookup function\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream function for iteration\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n```\n\n### Key Technical Mechanisms\n- **Associative Array Storage**: Using `declare -A` allows the Bash target to provide high-performance deduplication and member checking without external dependencies.\n- **Stream-Oriented Design**: The compiler generates helper functions (like `parent_stream`) that output results to stdout, allowing Prolog queries to integrate with standard Unix pipes.\n- **Recursive Support**: While facts use arrays, recursive rules derived from these facts are compiled into BFS loops with memoization to prevent infinite cycles in the shell environment.\n\nFor a comprehensive guide on shell-based code generation, see `education/book-01-foundations/03_unifyweaver_architecture.md` and the target-specific documentation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["bash", "code-generation", "associative-arrays", "streaming", "templates"], "original_answer": "## Bash Target Design\n\nThe Bash target uses template-driven code generation to create shell scripts that operate over textual streams.\n\n## Facts \u2192 Associative Arrays\n\nProlog facts compile to `declare -A` associative arrays:\n\n```prolog\n% Prolog facts\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nGenerated Bash:\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n\nparent_reverse_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        IFS=\":\" read -r a b <<< \"$key\"\n        echo \"$b:$a\"\n    done\n}\n```\n\n## Recursion \u2192 BFS with Memoization\n\nTransitive closures use BFS loops with visited tracking:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Initialize with base cases\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS traversal\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\n## Key Features\n\n- **Deduplication**: `declare -A` provides O(1) lookup\n- **Streaming**: Functions output to stdout for piping\n- **Cycle detection**: `visited` array prevents infinite loops", "answer_tailored": true}
{"pair_id": "bash-target-design_p2", "cluster_id": "bash-target-design", "question": "What does generated Bash code look like?", "question_type": "medium", "answer": "Generated Bash code in UnifyWeaver consists of template-driven shell scripts that leverage associative arrays for fact storage and iterative loops for recursive logic.\n\n### Fact Compilation\nProlog facts are mapped to `declare -A` associative arrays. For instance, a fact like `parent(alice, bob)` is stored as a delimited key (e.g., `[alice:bob]=1`). The compiler generates several helper functions for each fact:\n- **Lookup functions**: Use `[[ -n \"${array[$key]}\" ]]` for O(1) verification of specific relationships.\n- **Stream functions**: Iterate over array keys using `for key in \"${!array[@]}\"` to output data to stdout for piping.\n\n### Recursive Logic and BFS\nTo handle complex recursion (such as transitive closures) efficiently in a shell environment, UnifyWeaver generates Breadth-First Search (BFS) loops rather than relying on deep function recursion. These implementations feature:\n- **Memoization and Cycle Detection**: A `visited` associative array tracks explored nodes to prevent infinite loops in cyclic graphs.\n- **Queue Management**: Bash arrays manage the traversal frontier during BFS execution.\n- **Streaming Architecture**: Logic is structured to output results to stdout, allowing generated scripts to integrate into standard Unix pipelines.\n\nThis design ensures that Prolog's declarative logic remains performant and robust when compiled to native shell scripts. For a detailed breakdown of the implementation, refer to `education/book-01-foundations/03_unifyweaver_architecture.md` and the target-specific guides in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["bash", "code-generation", "associative-arrays", "streaming", "templates"], "original_answer": "## Bash Target Design\n\nThe Bash target uses template-driven code generation to create shell scripts that operate over textual streams.\n\n## Facts \u2192 Associative Arrays\n\nProlog facts compile to `declare -A` associative arrays:\n\n```prolog\n% Prolog facts\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nGenerated Bash:\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n\nparent_reverse_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        IFS=\":\" read -r a b <<< \"$key\"\n        echo \"$b:$a\"\n    done\n}\n```\n\n## Recursion \u2192 BFS with Memoization\n\nTransitive closures use BFS loops with visited tracking:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Initialize with base cases\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS traversal\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\n## Key Features\n\n- **Deduplication**: `declare -A` provides O(1) lookup\n- **Streaming**: Functions output to stdout for piping\n- **Cycle detection**: `visited` array prevents infinite loops", "answer_tailored": true}
{"pair_id": "bash-target-design_p3", "cluster_id": "bash-target-design", "question": "How does Bash target handle recursion?", "question_type": "medium", "answer": "The Bash target implements recursion by transforming Prolog's recursive definitions into iterative Breadth-First Search (BFS) loops with explicit memoization. Because standard shell environments are not optimized for deep recursion or backtracking, UnifyWeaver's compiler generates Bash scripts that utilize associative arrays (`declare -A`) to track visited states and manage queues for transitive closures.\n\n### How it Works:\n\n- **Fact Storage**: Prolog facts are mapped to associative arrays using colon-delimited keys (e.g., `[alice:bob]=1`).\n- **BFS Logic**: Recursive rules are processed using a `while` loop that maintains a frontier queue. This approach ensures all reachable states are discovered without hitting shell stack limits.\n- **Cycle Detection**: A `visited` associative array provides O(1) deduplication, effectively preventing infinite loops in cyclic graphs.\n- **Stream Processing**: Result sets are streamed through stdout, enabling high-performance composition via shell pipes.\n\n```bash\n# Example BFS structure for recursive rules\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Initialize queue with base cases from parent_stream\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # Process queue until exhausted\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier by joining current results with facts\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\nThis design ensures that complex recursive queries remain performant and stable within a shell environment. Detailed implementation patterns can be found in `education/book-02-bash-target/` and `education/book-01-foundations/03_unifyweaver_architecture.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["bash", "code-generation", "associative-arrays", "streaming", "templates"], "original_answer": "## Bash Target Design\n\nThe Bash target uses template-driven code generation to create shell scripts that operate over textual streams.\n\n## Facts \u2192 Associative Arrays\n\nProlog facts compile to `declare -A` associative arrays:\n\n```prolog\n% Prolog facts\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nGenerated Bash:\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n\nparent_reverse_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        IFS=\":\" read -r a b <<< \"$key\"\n        echo \"$b:$a\"\n    done\n}\n```\n\n## Recursion \u2192 BFS with Memoization\n\nTransitive closures use BFS loops with visited tracking:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Initialize with base cases\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS traversal\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\n## Key Features\n\n- **Deduplication**: `declare -A` provides O(1) lookup\n- **Streaming**: Functions output to stdout for piping\n- **Cycle detection**: `visited` array prevents infinite loops", "answer_tailored": true}
