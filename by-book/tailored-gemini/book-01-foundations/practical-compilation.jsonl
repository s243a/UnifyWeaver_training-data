{"pair_id": "practical-compilation_p0", "cluster_id": "practical-compilation", "question": "How do I compile a Prolog predicate to Bash with UnifyWeaver?", "question_type": "medium", "answer": "To compile a Prolog predicate into a functional Bash script with UnifyWeaver, you utilize the `compile/3` predicate within an initialized SWI-Prolog session. \n\n### 1. Initialize the Environment\nLaunch SWI-Prolog from the project root using the initialization file:\n```bash\nswipl -f init.pl\n```\n\n### 2. Load the Compiler Driver\nImport the module responsible for handling target-specific compilation:\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n```\n\n### 3. Define Your Logic\nProvide the Prolog facts or rules you wish to compile. For example:\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n```\n\n### 4. Execute the Compilation\nInvoke the compiler by specifying the predicate indicator and the Bash target:\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n```\nThe `Scripts` variable will return the path to the generated `.sh` file (e.g., `education/output/advanced/edge.sh`).\n\n### 5. Test the Generated Code\nThe generated script uses associative arrays to model the Prolog data. You can source the file and run the generated functions:\n```bash\nsource education/output/advanced/edge.sh\n\n# Query a fact\nedge a b\n\n# Stream all keys\nedge_stream\n```\n\nThe generated Bash code implements lookups and streaming as follows:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\nFor more information on optimization and Bash-specific features, see `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "docs/targets/bash.md", "topics": ["compilation", "bash", "how-to", "compile", "generated-code"], "original_answer": "## Compiling Prolog to Bash\n\nHere's the complete step-by-step process:\n\n### Step 1: Start SWI-Prolog with UnifyWeaver\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### Step 2: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n### Step 3: Define Your Predicates\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n### Step 4: Compile to Bash\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n### Step 5: View Generated Code\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nOutput:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Step 6: Test the Generated Code\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```", "answer_tailored": true}
{"pair_id": "practical-compilation_p1", "cluster_id": "practical-compilation", "question": "What is the step-by-step process to compile Prolog to Bash?", "question_type": "medium", "answer": "Compiling Prolog predicates into executable Bash scripts using UnifyWeaver involves a straightforward workflow within the SWI-Prolog environment:\n\n### 1. Initialize the Environment\nLaunch SWI-Prolog from the project root and load the initialization script:\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### 2. Load the Compiler Driver\nImport the core compilation module to enable the target-language drivers:\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n```\n\n### 3. Define the Prolog Logic\nDefine or load the predicates you intend to compile. For example, asserting facts for a directed graph:\n```prolog\n?- assertz(edge(a, b)), assertz(edge(b, c)), assertz(edge(c, d)).\n```\n\n### 4. Execute the Compilation\nUse the `compile/3` predicate, specifying `bash` as the target. The compiler will generate an optimized Bash script:\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n% Scripts = ['education/output/advanced/edge.sh'].\n```\n\n### 5. Inspect the Generated Code\nReview the resulting Shell script to see how the Prolog facts were mapped to Bash associative arrays and functions:\n```bash\ncat education/output/advanced/edge.sh\n```\n\n### 6. Test the Functions\nSource the generated file to use the predicates as standard Bash functions for lookups or streaming:\n```bash\nsource education/output/advanced/edge.sh\nedge a b        # Tests for a specific fact\nedge_stream     # Iterates through all facts\n```\n\nFor more detailed information on Bash-specific optimization and constraints, refer to the documentation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "docs/targets/bash.md", "topics": ["compilation", "bash", "how-to", "compile", "generated-code"], "original_answer": "## Compiling Prolog to Bash\n\nHere's the complete step-by-step process:\n\n### Step 1: Start SWI-Prolog with UnifyWeaver\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### Step 2: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n### Step 3: Define Your Predicates\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n### Step 4: Compile to Bash\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n### Step 5: View Generated Code\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nOutput:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Step 6: Test the Generated Code\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```", "answer_tailored": true}
{"pair_id": "practical-compilation_p2", "cluster_id": "practical-compilation", "question": "How do I use the UnifyWeaver compiler?", "question_type": "medium", "answer": "To use the UnifyWeaver compiler, you follow a streamlined workflow within the SWI-Prolog environment to translate Prolog predicates into executable code for your chosen target language, such as Bash.\n\n### 1. Initialize the Environment\nStart by launching SWI-Prolog from the project root using the provided initialization script:\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### 2. Load the Compiler Driver\nImport the necessary modules to enable compilation features:\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n```\n\n### 3. Define your Prolog Logic\nLoad or assert the predicates you intend to compile. For instance, defining a simple set of facts:\n```prolog\n?- assertz(edge(node1, node2)).\n?- assertz(edge(node2, node3)).\n```\n\n### 4. Run the Compilation\nInvoke the `compile/3` predicate, specifying the predicate indicator and the desired target language (e.g., Bash, Python, or Go):\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n```\nThe compiler will analyze the clauses and generate a corresponding script, typically located in `education/output/`.\n\n### 5. Execute the Generated Code\nThe resulting script transforms your Prolog logic into native target functions. For Bash, you can source the file and call the generated functions directly:\n```bash\nsource education/output/advanced/edge.sh\n# Query a specific fact\nedge node1 node2\n# Stream all results\nedge_stream\n```\n\nFor a comprehensive guide on different compilation targets and advanced configuration options, see the documentation in `education/book-01-foundations/` and target-specific modules like `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "docs/targets/bash.md", "topics": ["compilation", "bash", "how-to", "compile", "generated-code"], "original_answer": "## Compiling Prolog to Bash\n\nHere's the complete step-by-step process:\n\n### Step 1: Start SWI-Prolog with UnifyWeaver\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### Step 2: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n### Step 3: Define Your Predicates\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n### Step 4: Compile to Bash\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n### Step 5: View Generated Code\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nOutput:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Step 6: Test the Generated Code\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```", "answer_tailored": true}
{"pair_id": "practical-compilation_p3", "cluster_id": "practical-compilation", "question": "What command compiles a predicate?", "question_type": "medium", "answer": "To compile a predicate in UnifyWeaver, you use the `compile/3` predicate. \n\nFirst, ensure you have initialized the environment and loaded the compiler driver:\n```prolog\n?- [init].\n?- use_module(unifyweaver(core/compiler_driver)).\n```\n\nThe specific command to trigger compilation is:\n```prolog\n?- compile(PredicateName/Arity, [target(TargetLanguage)], Scripts).\n```\n\nFor example, to compile a predicate named `edge/2` into a Bash script:\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n```\n\nThis command generates the corresponding source code (e.g., a `.sh` file located in `education/output/`) which implements the Prolog logic using target-native structures like associative arrays or functions. For more information on the compilation process and target-specific details, refer to `education/book-02-bash-target/` and `docs/targets/bash.md`.", "answer_variant": "default", "answer_source": "docs/targets/bash.md", "topics": ["compilation", "bash", "how-to", "compile", "generated-code"], "original_answer": "## Compiling Prolog to Bash\n\nHere's the complete step-by-step process:\n\n### Step 1: Start SWI-Prolog with UnifyWeaver\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### Step 2: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n### Step 3: Define Your Predicates\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n### Step 4: Compile to Bash\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n### Step 5: View Generated Code\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nOutput:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Step 6: Test the Generated Code\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```", "answer_tailored": true}
{"pair_id": "generated-code-facts_p0", "cluster_id": "generated-code-facts", "question": "What does generated Bash code look like for Prolog facts?", "question_type": "medium", "answer": "Generated Bash code for Prolog facts is implemented using associative arrays to provide high-performance, O(1) lookups. This compilation strategy allows UnifyWeaver to handle large sets of facts efficiently within a shell environment.\n\n### Compilation Example\n\n**Prolog Input Facts:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n**Generated Bash Output:**\n```bash\n#!/bin/bash\n# parent - fact lookup table\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Fast lookup function\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Iterate through all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (e.g., child to parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Use Associative Arrays?\n*   **Constant Time Lookups:** Checking if a fact exists (e.g., `[[ -n \"${parent_data[$key]}\" ]]`) is an O(1) operation.\n*   **Automatic Deduplication:** Bash ensures that keys are unique, which handles redundant Prolog facts automatically.\n*   **Scalability:** Modern Bash (4.0+) handles large arrays efficiently, making it suitable for significant datasets.\n*   **Streaming Support:** Native iteration using `${!array[@]}` allows for efficient data streaming.\n\n### Usage Pattern\n```bash\nsource parent.sh\n\n# Query existence\nparent alice bob\n# Output: alice:bob\n\n# Stream all entries\nparent_stream\n```\n\nFor further details on Bash-specific generation patterns, refer to `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/stream_compiler.pl", "topics": ["facts", "associative-arrays", "bash", "generated-code", "declare"], "original_answer": "## Generated Code for Facts\n\nProlog facts compile to Bash associative arrays for O(1) lookup:\n\n### Input: Prolog Facts\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n### Output: Generated Bash\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Associative Arrays?\n\n1. **O(1) lookup** - `[[ -n \"${parent_data[$key]}\" ]]` is constant time\n2. **Deduplication** - Keys are unique by definition\n3. **Memory efficient** - Bash 4+ handles large arrays well\n4. **Streaming** - `${!array[@]}` iterates all keys\n\n### Usage\n\n```bash\nsource parent.sh\n\n# Check if alice is parent of bob\nparent alice bob\n# Output: alice:bob\n\n# List all parent relationships  \nparent_stream\n# Output:\n# alice:bob\n# bob:charlie\n# charlie:david\n```", "answer_tailored": true}
{"pair_id": "generated-code-facts_p1", "cluster_id": "generated-code-facts", "question": "How are Prolog facts compiled to Bash?", "question_type": "medium", "answer": "UnifyWeaver compiles Prolog facts into Bash associative arrays to facilitate high-performance O(1) lookups and efficient data streaming. This approach leverages the native indexing capabilities of Bash 4+ to handle fact-checking and iteration without the overhead of linear searches.\n\n### Compilation Mechanism\nEach Prolog predicate is transformed into a `declare -A` associative array. The arguments of each fact are concatenated (typically using a colon separator) to form unique keys within the array.\n\n**Prolog Input:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated Bash Output:**\n```bash\n# Predicate storage\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\n# O(1) Lookup Function\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Full Fact Streaming\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Key Technical Features:\n1. **Constant-Time Verification**: By using `[[ -n \"${parent_data[$key]}\" ]]`, the generated code can verify if a fact exists in O(1) time.\n2. **Automatic Deduplication**: The nature of associative arrays ensures that duplicate Prolog facts are naturally collapsed into single unique keys.\n3. **Flexible Access Patterns**: While the primary array allows for fast ground checks, the compiler also generates stream functions that use `IFS=\":\" read` to decompose keys, enabling reverse lookups and variable unification.\n4. **Memory Efficiency**: This method allows Bash to manage large datasets natively, making it suitable for complex logic compiled from `src/unifyweaver/core/stream_compiler.pl`.\n\nFor further details on how predicates are mapped to shell environments, see the documentation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/stream_compiler.pl", "topics": ["facts", "associative-arrays", "bash", "generated-code", "declare"], "original_answer": "## Generated Code for Facts\n\nProlog facts compile to Bash associative arrays for O(1) lookup:\n\n### Input: Prolog Facts\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n### Output: Generated Bash\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Associative Arrays?\n\n1. **O(1) lookup** - `[[ -n \"${parent_data[$key]}\" ]]` is constant time\n2. **Deduplication** - Keys are unique by definition\n3. **Memory efficient** - Bash 4+ handles large arrays well\n4. **Streaming** - `${!array[@]}` iterates all keys\n\n### Usage\n\n```bash\nsource parent.sh\n\n# Check if alice is parent of bob\nparent alice bob\n# Output: alice:bob\n\n# List all parent relationships  \nparent_stream\n# Output:\n# alice:bob\n# bob:charlie\n# charlie:david\n```", "answer_tailored": true}
{"pair_id": "generated-code-facts_p2", "cluster_id": "generated-code-facts", "question": "Why does UnifyWeaver use associative arrays?", "question_type": "medium", "answer": "UnifyWeaver uses associative arrays primarily to ensure O(1) lookup efficiency when translating Prolog facts into target scripts, such as Bash. This design choice allows for constant-time membership checks, automatic deduplication of records, and efficient memory usage.\n\n### Technical Implementation\n\nWhen Prolog facts are compiled, they are represented as a `declare -A` structure where compound keys represent the relationship:\n\n```bash\n# Compiled Prolog facts\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\n# O(1) lookup implementation\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n```\n\n### Benefits of this Approach\n\n1.  **Lookup Speed:** Fact verification happens in constant time (`O(1)`) regardless of the dataset size.\n2.  **Uniqueness:** The nature of associative arrays automatically prevents duplicate keys, ensuring data integrity.\n3.  **Streaming Support:** Using `${!parent_data[@]}` enables high-speed iteration and streaming of all facts within a predicate.\n4.  **Resource Efficiency:** Modern shell environments (Bash 4.0+) are highly optimized for handling large-scale associative arrays.\n\nFor more information on fact compilation and target language mapping, refer to the documentation in `education/book-02-bash-target/` and the implementation details in `src/unifyweaver/core/stream_compiler.pl`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/stream_compiler.pl", "topics": ["facts", "associative-arrays", "bash", "generated-code", "declare"], "original_answer": "## Generated Code for Facts\n\nProlog facts compile to Bash associative arrays for O(1) lookup:\n\n### Input: Prolog Facts\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n### Output: Generated Bash\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Associative Arrays?\n\n1. **O(1) lookup** - `[[ -n \"${parent_data[$key]}\" ]]` is constant time\n2. **Deduplication** - Keys are unique by definition\n3. **Memory efficient** - Bash 4+ handles large arrays well\n4. **Streaming** - `${!array[@]}` iterates all keys\n\n### Usage\n\n```bash\nsource parent.sh\n\n# Check if alice is parent of bob\nparent alice bob\n# Output: alice:bob\n\n# List all parent relationships  \nparent_stream\n# Output:\n# alice:bob\n# bob:charlie\n# charlie:david\n```", "answer_tailored": true}
{"pair_id": "generated-code-facts_p3", "cluster_id": "generated-code-facts", "question": "What is the structure of generated fact lookup code?", "question_type": "medium", "answer": "The structure of generated fact lookup code in UnifyWeaver transforms Prolog facts into optimized Bash associative arrays to provide O(1) retrieval. \n\n### Implementation Structure\n\nWhen compiling facts from `src/unifyweaver/core/stream_compiler.pl`, the compiler generates three primary components in the target Bash script:\n\n1.  **Data Storage**: An associative array where keys are formed by colon-separated arguments (e.g., `[arg1:arg2]=1`). This ensures unique entries and constant-time existence checks.\n2.  **Lookup Function**: A specific function for the predicate that validates if a composite key exists within the array.\n3.  **Stream Functions**: Iterative functions that use `${!array[@]}` to stream all stored facts or perform reverse lookups by parsing keys (e.g., `child -> parent`).\n\n### Example Transformation\n\n**Prolog Source:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated Bash Structure:**\n```bash\n# Data Definition\ndeclare -A parent_data=( [alice:bob]=1 [bob:charlie]=1 )\n\n# O(1) Lookup\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Key Streaming\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do echo \"$key\"; done\n}\n```\n\n### Architectural Benefits\n*   **Performance**: Lookups are constant time regardless of dataset size.\n*   **Integrity**: Associative array keys naturally prevent duplicate facts.\n*   **Flexibility**: The streaming architecture allows Bash to simulate Prolog's backtracking by iterating over keys and splitting them back into individual variables.\n\nFor a deep dive into how different targets handle fact structures, see `education/book-02-bash-target/` for Bash specifics and `education/book-05-go-target/` for compiled Go implementations.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/stream_compiler.pl", "topics": ["facts", "associative-arrays", "bash", "generated-code", "declare"], "original_answer": "## Generated Code for Facts\n\nProlog facts compile to Bash associative arrays for O(1) lookup:\n\n### Input: Prolog Facts\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n### Output: Generated Bash\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Associative Arrays?\n\n1. **O(1) lookup** - `[[ -n \"${parent_data[$key]}\" ]]` is constant time\n2. **Deduplication** - Keys are unique by definition\n3. **Memory efficient** - Bash 4+ handles large arrays well\n4. **Streaming** - `${!array[@]}` iterates all keys\n\n### Usage\n\n```bash\nsource parent.sh\n\n# Check if alice is parent of bob\nparent alice bob\n# Output: alice:bob\n\n# List all parent relationships  \nparent_stream\n# Output:\n# alice:bob\n# bob:charlie\n# charlie:david\n```", "answer_tailored": true}
{"pair_id": "generated-code-transitive_p0", "cluster_id": "generated-code-transitive", "question": "How does UnifyWeaver compile a transitive closure to Bash?", "question_type": "medium", "answer": "To compile a transitive closure (such as a `reaches/2` predicate) to Bash, UnifyWeaver identifies the recursive pattern and generates an optimized Breadth-First Search (BFS) implementation. This iterative approach is chosen over native recursion to bypass Bash's strict stack depth limits and handle cycles efficiently.\n\n### Logic Analysis\nThe compiler identifies standard transitive closure patterns in the Prolog source:\n\n```prolog\n% Base case: direct edge\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case: transitive step\nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\nDuring compilation, the system classifies the predicate:\n```text\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nStatus: Generating BFS-based Bash script\n```\n\n### Generated Bash Implementation\nThe resulting script utilizes associative arrays for visited-node tracking and a file-based queue to maintain the search frontier:\n\n```bash\n#!/bin/bash\n# reaches - Transitive closure implementation for Bash\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_q_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # Iterative BFS Traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Frontier expansion via edge stream\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                    echo \"$to\" >> \"${queue_file}.next\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n        mv \"${queue_file}.next\" \"$queue_file\" 2>/dev/null || break\n    done\n    rm -f \"$queue_file\"\n}\n\nreaches() {\n    local src=\"$1\"\n    local dst=\"$2\"\n    \n    if [[ -z \"$dst\" ]]; then\n        reaches_all \"$src\" | sort -u\n    else\n        reaches_all \"$src\" | grep -q \"^$src:$dst$\"\n    fi\n}\n```\n\n### Key Technical Strategies\n1. **Iterative BFS**: Replaces depth-first recursion with a loop-based BFS to ensure stability in the shell environment.\n2. **Cycle Detection**: Uses `declare -A visited` to prevent infinite loops in cyclic graphs.\n3. **Queue Management**: Utilizes temporary files in `/tmp` for the BFS queue, allowing the script to process graphs that exceed available memory.\n4. **Deduplication**: Incorporates `sort -u` to ensure unique results in the reachability set.\n\n### Usage Example\n```bash\nsource edge.sh\nsource reaches.sh\n\n# List all nodes reachable from node 'A'\nreaches A\n\n# Boolean check for reachability\nif reaches A D; then\n    echo \"Path exists\"\nfi\n```\n\nFor more details on how UnifyWeaver handles shell-specific code generation, refer to `education/book-02-bash-target/`. For the underlying logic classification, see `src/unifyweaver/core/advanced/linear_recursion.pl`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/advanced/linear_recursion.pl", "topics": ["transitive-closure", "recursion", "bfs", "generated-code", "reaches"], "original_answer": "## Transitive Closure Compilation\n\nUnifyWeaver detects transitive closure patterns and generates optimized BFS code:\n\n### Input: Prolog Rules\n\n```prolog\n% Base case\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case  \nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Detection\n\n```prolog\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n### Output: BFS with Visited Tracking\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Optimizations\n\n1. **BFS not recursion** - Avoids Bash stack limits\n2. **Visited tracking** - `declare -A visited` prevents cycles\n3. **Deduplication** - `sort -u` removes duplicates\n4. **Temp files** - Queue stored in `/tmp` for large graphs\n\n### Usage\n\n```bash\nsource edge.sh reaches.sh\n\n# Find all nodes reachable from 'a'\nreaches a\n# Output: a:b  a:c  a:d\n\n# Check if 'd' is reachable from 'a'\nreaches a d && echo \"yes\" || echo \"no\"\n# Output: yes\n```", "answer_tailored": true}
{"pair_id": "generated-code-transitive_p1", "cluster_id": "generated-code-transitive", "question": "What does generated code for recursive predicates look like?", "question_type": "medium", "answer": "When UnifyWeaver compiles recursive predicates, it typically transforms the recursive logic into an iterative structure (such as a BFS loop) in the target language. This approach ensures that the generated code is not limited by the target environment's call stack and can safely handle cycles in the data.\n\n### Example: Transitive Closure Pattern\n\nOne of the most common recursive structures UnifyWeaver detects is transitive closure.\n\n#### Input: Prolog Rules\n```prolog\n% Base case: X can reach Y if an edge exists\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case: X can reach Y if X can reach Z and Z can reach Y\nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n#### Compiler Detection\nThe compiler analyzes the dependency graph to classify the recursion:\n```text\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n#### Generated Bash Output (Iterative BFS)\nThe resulting code avoids recursion entirely, using an associative array for visited nodes and a temporary file as a queue:\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # Breadth-First Search traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand the frontier from the current node\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Technical Strategies\n1. **Iterative Transformation:** Replaces functional recursion with BFS to bypass shell stack limits.\n2. **Cycle Detection:** Uses `declare -A visited` to prevent infinite loops in cyclic graphs.\n3. **Data Scaling:** Uses temporary files in `/tmp` for the BFS queue to handle large-scale graph traversals.\n4. **Target Optimization:** Employs `sort -u` for efficient deduplication of paths.\n\nFor a deeper look at how different targets handle recursive logic, see `education/book-02-bash-target/` or the implementation details in `src/unifyweaver/core/advanced/linear_recursion.pl`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/advanced/linear_recursion.pl", "topics": ["transitive-closure", "recursion", "bfs", "generated-code", "reaches"], "original_answer": "## Transitive Closure Compilation\n\nUnifyWeaver detects transitive closure patterns and generates optimized BFS code:\n\n### Input: Prolog Rules\n\n```prolog\n% Base case\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case  \nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Detection\n\n```prolog\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n### Output: BFS with Visited Tracking\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Optimizations\n\n1. **BFS not recursion** - Avoids Bash stack limits\n2. **Visited tracking** - `declare -A visited` prevents cycles\n3. **Deduplication** - `sort -u` removes duplicates\n4. **Temp files** - Queue stored in `/tmp` for large graphs\n\n### Usage\n\n```bash\nsource edge.sh reaches.sh\n\n# Find all nodes reachable from 'a'\nreaches a\n# Output: a:b  a:c  a:d\n\n# Check if 'd' is reachable from 'a'\nreaches a d && echo \"yes\" || echo \"no\"\n# Output: yes\n```", "answer_tailored": true}
{"pair_id": "generated-code-transitive_p2", "cluster_id": "generated-code-transitive", "question": "How is ancestor/2 compiled to Bash?", "question_type": "medium", "answer": "UnifyWeaver compiles the `ancestor/2` predicate to Bash by identifying it as a transitive closure pattern and transforming it into an iterative Breadth-First Search (BFS). This approach is used instead of direct recursion to avoid Bash's internal stack depth limitations and to handle potentially cyclic data safely.\n\n### Compilation Strategy\n\nThe compiler (specifically the logic in `src/unifyweaver/core/advanced/linear_recursion.pl`) analyzes the rules for `ancestor/2`. If it finds a base case and a recursive step linking through a `parent/2` relation, it classifies it for BFS generation.\n\n```bash\n#!/bin/bash\n# ancestor - Transitive closure of parent/2 generated by UnifyWeaver\n\nancestor_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/ancestor_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # Iterative BFS prevents stack overflow\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Query the parent data source\n            while IFS=\":\" read -r p c; do\n                if [[ \"$p\" == \"$current\" && -z \"${visited[$c]}\" ]]; then\n                    visited[\"$c\"]=1\n                    echo \"$start:$c\"\n                    echo \"$c\" >> \"$queue_file.tmp\"\n                fi\n            done < <(parent_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n        mv \"$queue_file.tmp\" \"$queue_file\" 2>/dev/null || break\n    done\n}\n\nancestor() {\n    local person=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        ancestor_all \"$person\" | sort -u\n    else\n        ancestor_all \"$person\" | grep -q \"^$person:$target$\"\n    fi\n}\n```\n\n### Key Technical Implementations\n\n1.  **Iterative BFS Transformation**: By converting the recursive Prolog logic into a `while` loop, the generated script stays within Bash's operational limits even for very deep lineages.\n2.  **Cycle Detection**: The use of `declare -A visited` (associative arrays) ensures that the traversal does not enter infinite loops if the data contains cycles.\n3.  **Queue Management**: The compiler utilizes temporary files in `/tmp` to manage the BFS frontier, allowing the system to process large graphs that might exceed memory if stored entirely in shell variables.\n4.  **Deduplication**: Results are passed through `sort -u` to ensure a clean set of unique ancestor-descendant pairs.\n\nFor more information on how Prolog predicates are mapped to shell-based execution flows, refer to the documentation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/advanced/linear_recursion.pl", "topics": ["transitive-closure", "recursion", "bfs", "generated-code", "reaches"], "original_answer": "## Transitive Closure Compilation\n\nUnifyWeaver detects transitive closure patterns and generates optimized BFS code:\n\n### Input: Prolog Rules\n\n```prolog\n% Base case\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case  \nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Detection\n\n```prolog\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n### Output: BFS with Visited Tracking\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Optimizations\n\n1. **BFS not recursion** - Avoids Bash stack limits\n2. **Visited tracking** - `declare -A visited` prevents cycles\n3. **Deduplication** - `sort -u` removes duplicates\n4. **Temp files** - Queue stored in `/tmp` for large graphs\n\n### Usage\n\n```bash\nsource edge.sh reaches.sh\n\n# Find all nodes reachable from 'a'\nreaches a\n# Output: a:b  a:c  a:d\n\n# Check if 'd' is reachable from 'a'\nreaches a d && echo \"yes\" || echo \"no\"\n# Output: yes\n```", "answer_tailored": true}
{"pair_id": "generated-code-transitive_p3", "cluster_id": "generated-code-transitive", "question": "What optimization does UnifyWeaver use for transitive closures?", "question_type": "medium", "answer": "UnifyWeaver optimizes transitive closures by detecting recursive patterns in Prolog rules and compiling them into iterative Breadth-First Search (BFS) logic with built-in cycle detection. This approach ensures that reachability queries are efficient and scalable, avoiding the stack depth limitations inherent in the recursive function calls of target languages like Bash or PowerShell.\n\n### Optimization Highlights\n\n*   **Iterative BFS over Recursion**: The compiler replaces naive recursive calls with an iterative loop structure. This is critical for targets with limited stack sizes, allowing the generated code to traverse deep graphs that would otherwise cause a stack overflow.\n*   **Cycle Prevention via Visited Tracking**: To handle cyclic datasets, UnifyWeaver generates code that maintains a \"visited\" set (e.g., using `declare -A visited` in Bash). This prevents infinite loops by ensuring each node is only processed once.\n*   **Scalable Frontier Queues**: The implementation uses a queue to manage the traversal frontier. For the Bash target, these queues are often backed by temporary files in `/tmp`, enabling the system to process massive graphs that exceed available memory.\n*   **Automatic Pattern Recognition**: During the compilation of rules such as `reaches(X, Y) :- edge(X, Z), reaches(Z, Y)`, the core analyzer classifies the logic as a `transitive_closure` and applies the optimized BFS template.\n\n### Technical Implementation\n\nWhen a transitive closure is detected, the generated target code follows this pattern:\n1.  **Initialize**: Sets up a queue with the starting node and initializes a visited tracker.\n2.  **Traverse**: Iteratively expands the frontier by reading from the queue and checking the underlying data source (e.g., `edge_stream`).\n3.  **Filter**: Only new, unvisited nodes are added back to the queue and echoed to the output.\n4.  **Deduplicate**: Final results are typically passed through a uniqueness filter (like `sort -u`) to ensure set semantics.\n\nFor a deeper look at the detection logic, see `src/unifyweaver/core/advanced/linear_recursion.pl`. Detailed target-specific BFS implementations can be found in `education/book-02-bash-target/` and `education/book-05-python-target/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/advanced/linear_recursion.pl", "topics": ["transitive-closure", "recursion", "bfs", "generated-code", "reaches"], "original_answer": "## Transitive Closure Compilation\n\nUnifyWeaver detects transitive closure patterns and generates optimized BFS code:\n\n### Input: Prolog Rules\n\n```prolog\n% Base case\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case  \nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Detection\n\n```prolog\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n### Output: BFS with Visited Tracking\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Optimizations\n\n1. **BFS not recursion** - Avoids Bash stack limits\n2. **Visited tracking** - `declare -A visited` prevents cycles\n3. **Deduplication** - `sort -u` removes duplicates\n4. **Temp files** - Queue stored in `/tmp` for large graphs\n\n### Usage\n\n```bash\nsource edge.sh reaches.sh\n\n# Find all nodes reachable from 'a'\nreaches a\n# Output: a:b  a:c  a:d\n\n# Check if 'd' is reachable from 'a'\nreaches a d && echo \"yes\" || echo \"no\"\n# Output: yes\n```", "answer_tailored": true}
