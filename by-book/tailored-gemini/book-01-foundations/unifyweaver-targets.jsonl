{"pair_id": "unifyweaver-targets_p0", "cluster_id": "unifyweaver-targets", "question": "What target languages does UnifyWeaver support?", "question_type": "medium", "answer": "UnifyWeaver facilitates the compilation of Prolog predicates into a broad spectrum of target environments, categorized by their execution model and language family:\n\n*   **Shell and Scripting**: Bash, PowerShell, and AWK are supported for building Unix-style pipelines.\n*   **Systems Languages**: Compilation targets include Go, Rust, LLVM, and WASM for performance-critical applications.\n*   **Managed Frameworks**: Both the .NET ecosystem (C#, F#, VB.NET) and JVM (Java, Kotlin, Jython) are supported.\n*   **Dynamic and Functional**: Python, TypeScript, Haskell, and Prolog targets are available.\n*   **Database**: SQL is supported for declarative data operations.\n\nEach target utilizes a specific compilation strategy optimized for its environment:\n- **Stream-based pipelines**: Used by Bash, Go, and Rust for efficient data processing.\n- **Generators**: Python targets leverage `yield` for lazy evaluation.\n- **Query Runtimes**: C# Query targets use semi-naive evaluation to handle complex recursion.\n- **Declarative**: SQL targets generate direct database queries or views.\n\nTo compile your code, load the `unifyweaver(core/compiler_driver)` module and invoke the `compile/3` predicate with the desired `target(Name)` option. For more information on language support and selection criteria, see `education/book-01-foundations/01_introduction.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["targets", "bash", "python", "csharp", "go", "rust", "sql", "compilation"], "original_answer": "UnifyWeaver supports compilation to many target languages, organized by category:\n\n| Category | Targets |\n|----------|--------|\n| Shell/Scripting | Bash, PowerShell, AWK |\n| Systems Languages | Go, Rust, LLVM, WASM |\n| .NET Ecosystem | C# (Stream & Query), F#, VB.NET |\n| JVM Languages | Java, Kotlin, Jython |\n| Dynamic Languages | Python, TypeScript |\n| Functional | Haskell, Prolog |\n| Data | SQL |\n\n## Compiling to a Target\n\n```prolog\n% Load the compiler\n?- use_module(unifyweaver(core/compiler_driver)).\n\n% Compile to Bash\n?- compile(my_predicate/2, [target(bash)], Scripts).\n\n% Compile to Python\n?- compile(my_predicate/2, [target(python)], Scripts).\n\n% Compile to C# Query Runtime\n?- compile(my_predicate/2, [target(csharp_query)], Scripts).\n```\n\n## Compilation Approaches\n\nDifferent targets use different strategies:\n\n- **Stream-based pipelines** (Bash, Go, Rust) - Unix-style pipes and filters\n- **Generators** (Python) - Lazy evaluation with `yield`\n- **Query runtimes** (C# Query) - Semi-naive evaluation for complex recursion\n- **Declarative SQL** - Direct database execution\n\n## Target Selection Guide\n\n| Need | Use |\n|------|-----|\n| Shell scripts, Unix pipelines | Bash |\n| Standalone binary, no deps | Go or Rust |\n| Complex recursion in .NET | C# Query Runtime |\n| Database views | SQL |\n| Python ecosystem | Python |", "answer_tailored": true}
{"pair_id": "unifyweaver-targets_p1", "cluster_id": "unifyweaver-targets", "question": "How do I compile to a specific target?", "question_type": "medium", "answer": "To compile your Prolog code to a specific target language, use the `compile/3` predicate provided by the compiler driver and specify the `target(Name)` option.\n\nFirst, load the required module:\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n```\n\nThen, execute the compilation by passing the predicate and your chosen target:\n- **Bash:** `?- compile(my_predicate/2, [target(bash)], Scripts).`\n- **Python:** `?- compile(my_predicate/2, [target(python)], Scripts).`\n- **Go/Rust:** `?- compile(my_predicate/2, [target(go)], Scripts).`\n- **C# Query:** `?- compile(my_predicate/2, [target(csharp_query)], Scripts).`\n\nUnifyWeaver automatically maps your logic to the most appropriate strategy for the selected target:\n*   **Stream Pipelines:** Bash, Go, and Rust use Unix-style pipe-and-filter architectures.\n*   **Lazy Generators:** Python targets utilize `yield` for memory-efficient iteration.\n*   **Query Runtimes:** C# Query employs semi-naive evaluation to handle complex recursion.\n*   **Declarative SQL:** Logic is compiled directly into database-executable views.\n\nSupported targets range across shell scripting (Bash, AWK, PowerShell), systems languages (Rust, Go), the .NET/JVM ecosystems, and data-centric SQL. For a full list of supported languages and detailed selection criteria, refer to `education/book-01-foundations/01_introduction.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["targets", "bash", "python", "csharp", "go", "rust", "sql", "compilation"], "original_answer": "UnifyWeaver supports compilation to many target languages, organized by category:\n\n| Category | Targets |\n|----------|--------|\n| Shell/Scripting | Bash, PowerShell, AWK |\n| Systems Languages | Go, Rust, LLVM, WASM |\n| .NET Ecosystem | C# (Stream & Query), F#, VB.NET |\n| JVM Languages | Java, Kotlin, Jython |\n| Dynamic Languages | Python, TypeScript |\n| Functional | Haskell, Prolog |\n| Data | SQL |\n\n## Compiling to a Target\n\n```prolog\n% Load the compiler\n?- use_module(unifyweaver(core/compiler_driver)).\n\n% Compile to Bash\n?- compile(my_predicate/2, [target(bash)], Scripts).\n\n% Compile to Python\n?- compile(my_predicate/2, [target(python)], Scripts).\n\n% Compile to C# Query Runtime\n?- compile(my_predicate/2, [target(csharp_query)], Scripts).\n```\n\n## Compilation Approaches\n\nDifferent targets use different strategies:\n\n- **Stream-based pipelines** (Bash, Go, Rust) - Unix-style pipes and filters\n- **Generators** (Python) - Lazy evaluation with `yield`\n- **Query runtimes** (C# Query) - Semi-naive evaluation for complex recursion\n- **Declarative SQL** - Direct database execution\n\n## Target Selection Guide\n\n| Need | Use |\n|------|-----|\n| Shell scripts, Unix pipelines | Bash |\n| Standalone binary, no deps | Go or Rust |\n| Complex recursion in .NET | C# Query Runtime |\n| Database views | SQL |\n| Python ecosystem | Python |", "answer_tailored": true}
{"pair_id": "unifyweaver-targets_p2", "cluster_id": "unifyweaver-targets", "question": "Which target should I use for my project?", "question_type": "medium", "answer": "The target you should choose for your project depends on your specific performance requirements and the execution environment. UnifyWeaver supports a wide variety of target languages organized by their execution model:\n\n| Target Category | Examples |\n|----------|--------|\n| **Shell/Scripting** | Bash, PowerShell, AWK |\n| **Systems Languages** | Go, Rust, LLVM, WASM |\n| **.NET Ecosystem** | C# (Query & Stream), F#, VB.NET |\n| **JVM Languages** | Java, Kotlin, Jython |\n| **Dynamic Languages** | Python, TypeScript |\n| **Functional/Data** | Haskell, SQL |\n\n### Selection Guide\n- **Use Bash** for shell integration and Unix pipelines. (See `education/book-02-bash-target/`)\n- **Use Go or Rust** when you need a high-performance, standalone binary with zero dependencies. (See `education/book-04-go-target/` and `education/book-05-rust-target/`)\n- **Use C# Query Runtime** for handling deep recursion in .NET applications using semi-naive evaluation. (See `education/book-06-csharp-target/`)\n- **Use Python** to leverage the Python library ecosystem via generator-based evaluation. (See `education/book-03-python-target/`)\n- **Use SQL** for direct database execution or creating views. (See `education/book-10-sql-target/`)\n\n### Compilation Example\nYou can trigger compilation via the `compiler_driver` module by specifying your desired target:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n% Example: Compiling a predicate to the Go target\n?- compile(my_predicate/2, [target(go)], Scripts).\n```\n\nEach target employs a specific strategy suited to its language features, such as **stream-based pipelines** for shell targets, **generators** for Python, or **query runtimes** for complex .NET recursion. For more details on these evaluation strategies, see `education/book-01-foundations/01_introduction.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["targets", "bash", "python", "csharp", "go", "rust", "sql", "compilation"], "original_answer": "UnifyWeaver supports compilation to many target languages, organized by category:\n\n| Category | Targets |\n|----------|--------|\n| Shell/Scripting | Bash, PowerShell, AWK |\n| Systems Languages | Go, Rust, LLVM, WASM |\n| .NET Ecosystem | C# (Stream & Query), F#, VB.NET |\n| JVM Languages | Java, Kotlin, Jython |\n| Dynamic Languages | Python, TypeScript |\n| Functional | Haskell, Prolog |\n| Data | SQL |\n\n## Compiling to a Target\n\n```prolog\n% Load the compiler\n?- use_module(unifyweaver(core/compiler_driver)).\n\n% Compile to Bash\n?- compile(my_predicate/2, [target(bash)], Scripts).\n\n% Compile to Python\n?- compile(my_predicate/2, [target(python)], Scripts).\n\n% Compile to C# Query Runtime\n?- compile(my_predicate/2, [target(csharp_query)], Scripts).\n```\n\n## Compilation Approaches\n\nDifferent targets use different strategies:\n\n- **Stream-based pipelines** (Bash, Go, Rust) - Unix-style pipes and filters\n- **Generators** (Python) - Lazy evaluation with `yield`\n- **Query runtimes** (C# Query) - Semi-naive evaluation for complex recursion\n- **Declarative SQL** - Direct database execution\n\n## Target Selection Guide\n\n| Need | Use |\n|------|-----|\n| Shell scripts, Unix pipelines | Bash |\n| Standalone binary, no deps | Go or Rust |\n| Complex recursion in .NET | C# Query Runtime |\n| Database views | SQL |\n| Python ecosystem | Python |", "answer_tailored": true}
{"pair_id": "unifyweaver-targets_p3", "cluster_id": "unifyweaver-targets", "question": "What compilation approaches does UnifyWeaver use?", "question_type": "medium", "answer": "UnifyWeaver employs several distinct compilation approaches tailored to the specific execution model of the target language:\n\n- **Stream-based Pipelines:** Used for Bash, Go, and Rust to create Unix-style pipes and filter chains for efficient data processing.\n- **Generators:** Leveraged by the Python target to provide lazy evaluation using native `yield` iterators.\n- **Query Runtimes:** Utilized by the C# Query target, employing semi-naive evaluation to handle complex recursive predicates.\n- **Declarative SQL:** Direct translation of Prolog logic into database-native SQL execution.\n\nThe compiler driver allows you to select these strategies by specifying the target during compilation:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(my_predicate/2, [target(bash)], Scripts).   % Stream-based\n?- compile(my_predicate/2, [target(python)], Scripts). % Generators\n```\n\nSupported targets span several categories, including Shell (Bash, PowerShell, AWK), Systems (Go, Rust, WASM), .NET (C#, F#), and Data (SQL). For a deep dive into the foundational architecture of these compilation strategies, refer to `education/book-01-foundations/01_introduction.md`. Specific implementation details for targets like Bash can be found in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["targets", "bash", "python", "csharp", "go", "rust", "sql", "compilation"], "original_answer": "UnifyWeaver supports compilation to many target languages, organized by category:\n\n| Category | Targets |\n|----------|--------|\n| Shell/Scripting | Bash, PowerShell, AWK |\n| Systems Languages | Go, Rust, LLVM, WASM |\n| .NET Ecosystem | C# (Stream & Query), F#, VB.NET |\n| JVM Languages | Java, Kotlin, Jython |\n| Dynamic Languages | Python, TypeScript |\n| Functional | Haskell, Prolog |\n| Data | SQL |\n\n## Compiling to a Target\n\n```prolog\n% Load the compiler\n?- use_module(unifyweaver(core/compiler_driver)).\n\n% Compile to Bash\n?- compile(my_predicate/2, [target(bash)], Scripts).\n\n% Compile to Python\n?- compile(my_predicate/2, [target(python)], Scripts).\n\n% Compile to C# Query Runtime\n?- compile(my_predicate/2, [target(csharp_query)], Scripts).\n```\n\n## Compilation Approaches\n\nDifferent targets use different strategies:\n\n- **Stream-based pipelines** (Bash, Go, Rust) - Unix-style pipes and filters\n- **Generators** (Python) - Lazy evaluation with `yield`\n- **Query runtimes** (C# Query) - Semi-naive evaluation for complex recursion\n- **Declarative SQL** - Direct database execution\n\n## Target Selection Guide\n\n| Need | Use |\n|------|-----|\n| Shell scripts, Unix pipelines | Bash |\n| Standalone binary, no deps | Go or Rust |\n| Complex recursion in .NET | C# Query Runtime |\n| Database views | SQL |\n| Python ecosystem | Python |", "answer_tailored": true}
