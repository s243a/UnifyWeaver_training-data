{"pair_id": "prolog-unification_p0", "cluster_id": "prolog-unification", "question": "How does unification work in Prolog?", "question_type": "medium", "answer": "Unification in Prolog is the fundamental process of matching two terms to determine if they can be made identical. If the terms can match, any variables within them are **instantiated**\u2014meaning they are assigned specific values\u2014to achieve this identity.\n\nThe mechanism follows these core rules:\n* **Atoms:** Unify only with themselves (e.g., `alice = alice` succeeds, while `alice = bob` fails).\n* **Variables:** Unify with any term, including atoms or complex structures. Once a variable is bound (e.g., `X = alice`), it carries that value throughout the rest of the unification process.\n* **Structures:** Unify if they share the same functor and arity, and all of their respective arguments also unify (e.g., `point(1, Y) = point(X, 2)` results in `X=1` and `Y=2`).\n\nProlog employs unification during query execution to match your goals against the facts and rules stored in the database. In the context of **UnifyWeaver**, this core operation is combined with \"weaving\" to transform declarative patterns into optimized executable code for targets like Bash, Python, or Go.\n\nFor a comprehensive guide on these mechanics, refer to the documentation in `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "unification", "pattern-matching", "variable-binding"], "original_answer": "## Unification: The Engine of Prolog\n\n**Unification** is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n\n## Unification Rules\n\n```prolog\n% Atoms unify only with themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with any term\nX = alice.            % X is now 'alice'\nX = foo(1, 2).        % X is now 'foo(1, 2)'\n\n% Structures unify if functor, arity, and all args unify\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\n## Unification in Queries\n\nWhen you query, Prolog unifies your query with facts/rules:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog tries to unify:\n%   file_dependency('main.o', Dep)\n% with\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\n## Why \"UnifyWeaver\"?\n\nThe name comes from **unification** (Prolog's core operation) + **weaving** (interconnecting data threads). UnifyWeaver unifies your declarative specifications and weaves them into executable code:\n\n```prolog\n% Your specification (unified pattern)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Woven into optimized Bash/Python/Go/etc.\n```", "answer_tailored": true}
{"pair_id": "prolog-unification_p1", "cluster_id": "prolog-unification", "question": "What is pattern matching in Prolog?", "question_type": "medium", "answer": "Pattern matching in Prolog is primarily achieved through a process called **Unification**. This is the core mechanism where the system attempts to match two terms and, if possible, **instantiates** variables (assigns them specific values) to make the terms identical.\n\n### Core Rules of Unification\n- **Atoms:** These match only with themselves (e.g., `alice = alice` succeeds, while `alice = bob` fails).\n- **Variables:** A variable will unify with any term. Once unified, the variable is bound to that specific term.\n- **Structures:** Complex terms unify if they share the same functor (name), arity (number of arguments), and if all their respective arguments can also be unified. For example, `point(1, Y) = point(X, 2)` results in `X=1` and `Y=2`.\n\n### Pattern Matching in Queries\nWhen you perform a query, Prolog uses unification to search its database for facts or rules that match your request. If you have a fact `depends('main.o', 'main.c')` and query `?- depends('main.o', Source)`, Prolog unifies the query with the fact, resulting in `Source = 'main.c'`.\n\n### The \"Unify\" in UnifyWeaver\nThe name **UnifyWeaver** is derived from this unification process. The system takes your declarative Prolog patterns and \"weaves\" them into optimized, executable code for target environments like Bash, Python, or Go.\n\nFor a comprehensive guide on these fundamentals, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "unification", "pattern-matching", "variable-binding"], "original_answer": "## Unification: The Engine of Prolog\n\n**Unification** is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n\n## Unification Rules\n\n```prolog\n% Atoms unify only with themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with any term\nX = alice.            % X is now 'alice'\nX = foo(1, 2).        % X is now 'foo(1, 2)'\n\n% Structures unify if functor, arity, and all args unify\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\n## Unification in Queries\n\nWhen you query, Prolog unifies your query with facts/rules:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog tries to unify:\n%   file_dependency('main.o', Dep)\n% with\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\n## Why \"UnifyWeaver\"?\n\nThe name comes from **unification** (Prolog's core operation) + **weaving** (interconnecting data threads). UnifyWeaver unifies your declarative specifications and weaves them into executable code:\n\n```prolog\n% Your specification (unified pattern)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Woven into optimized Bash/Python/Go/etc.\n```", "answer_tailored": true}
{"pair_id": "prolog-unification_p2", "cluster_id": "prolog-unification", "question": "How do Prolog variables get their values?", "question_type": "medium", "answer": "Prolog variables receive their values through a process called **unification**, which is the core engine of the language. When Prolog attempts to match two terms, any variables involved are **instantiated** (assigned values) to make the terms identical.\n\n### How Unification Works\n\nVariables get their values based on several matching rules:\n- **Direct Assignment:** A variable will unify with any term it encounters. For example, in the operation `X = alice`, `X` is instantiated to the atom `'alice'`.\n- **Structural Matching:** If matching two structures, Prolog ensures the functors and arity (number of arguments) are the same, then recursively unifies the arguments. In `point(1, Y) = point(X, 2)`, the variable `X` becomes `1` and `Y` becomes `2`.\n- **Atoms:** Atoms only unify with themselves (e.g., `alice = alice` succeeds, but `alice = bob` fails).\n\n### Unification in Queries\n\nWhen you execute a query, Prolog searches its database for facts or rules that can unify with your request. For instance, if the database contains the fact `file_dependency('main.o', 'main.c')`, the query `?- file_dependency('main.o', Dep).` succeeds by instantiating the variable `Dep` with `'main.c'`.\n\n### Role in UnifyWeaver\n\nIn the UnifyWeaver ecosystem, unification allows you to define declarative specifications that the compiler then \"weaves\" into executable code for targets like Bash, Python, or Go. By matching high-level patterns to specific data threads, UnifyWeaver can automate complex code generation.\n\nFor a detailed breakdown of these concepts, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "unification", "pattern-matching", "variable-binding"], "original_answer": "## Unification: The Engine of Prolog\n\n**Unification** is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n\n## Unification Rules\n\n```prolog\n% Atoms unify only with themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with any term\nX = alice.            % X is now 'alice'\nX = foo(1, 2).        % X is now 'foo(1, 2)'\n\n% Structures unify if functor, arity, and all args unify\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\n## Unification in Queries\n\nWhen you query, Prolog unifies your query with facts/rules:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog tries to unify:\n%   file_dependency('main.o', Dep)\n% with\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\n## Why \"UnifyWeaver\"?\n\nThe name comes from **unification** (Prolog's core operation) + **weaving** (interconnecting data threads). UnifyWeaver unifies your declarative specifications and weaves them into executable code:\n\n```prolog\n% Your specification (unified pattern)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Woven into optimized Bash/Python/Go/etc.\n```", "answer_tailored": true}
{"pair_id": "prolog-unification_p3", "cluster_id": "prolog-unification", "question": "Why is it called UnifyWeaver?", "question_type": "medium", "answer": "The name **UnifyWeaver** is derived from **unification**\u2014Prolog's core mechanism for matching terms\u2014and the process of **weaving** those declarative specifications into executable code.\n\n### The Engine: Unification\nUnification is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n*   **Atoms** unify only with themselves (e.g., `alice = alice`).\n*   **Variables** unify with any term (e.g., `X = alice`).\n*   **Structures** unify only if their functor, arity, and all arguments match (e.g., `point(1, Y) = point(X, 2)` succeeds with `X=1, Y=2`, but `point(1, 2) = point(1, 2, 3)` fails due to different arity).\n\nIn practice, Prolog unifies your queries with facts or rules. For example, a query like `?- file_dependency('main.o', Dep).` unifies with the fact `file_dependency('main.o', 'main.c')`, resulting in `Dep = 'main.c'`.\n\n### Weaving the Result\nUnifyWeaver takes these unified logic patterns and \"weaves\" them into optimized, interconnected threads of execution in target languages like Bash, Python, Go, or SQL. It transforms high-level declarative rules\u2014such as recursive data traversals\u2014into performant, real-world implementations.\n\nFor a detailed breakdown of these Prolog fundamentals, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "unification", "pattern-matching", "variable-binding"], "original_answer": "## Unification: The Engine of Prolog\n\n**Unification** is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n\n## Unification Rules\n\n```prolog\n% Atoms unify only with themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with any term\nX = alice.            % X is now 'alice'\nX = foo(1, 2).        % X is now 'foo(1, 2)'\n\n% Structures unify if functor, arity, and all args unify\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\n## Unification in Queries\n\nWhen you query, Prolog unifies your query with facts/rules:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog tries to unify:\n%   file_dependency('main.o', Dep)\n% with\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\n## Why \"UnifyWeaver\"?\n\nThe name comes from **unification** (Prolog's core operation) + **weaving** (interconnecting data threads). UnifyWeaver unifies your declarative specifications and weaves them into executable code:\n\n```prolog\n% Your specification (unified pattern)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Woven into optimized Bash/Python/Go/etc.\n```", "answer_tailored": true}
