{"pair_id": "prolog-to-bash-bridge_p0", "cluster_id": "prolog-to-bash-bridge", "question": "How do Prolog predicates become Bash scripts?", "question_type": "medium", "answer": "UnifyWeaver translates Prolog predicates into executable Bash scripts by mapping logical relations to shell-native structures like associative arrays and functions.\n\n### The Transformation Process\n\n1.  **Predicate Definition**: Definitions start in Prolog as facts (base assertions) and rules (derived logic). For instance, a `parent/2` fact and a recursive `ancestor/2` rule.\n2.  **Compilation**: The `unifyweaver` compiler driver processes these predicates into target code:\n    ```prolog\n    ?- use_module(unifyweaver(core/compiler_driver)).\n    ?- compile(ancestor/2, [output_dir('out')], Scripts).\n    ```\n3.  **Mapping to Bash**:\n    *   **Facts** are transformed into **associative arrays** where keys represent bound arguments (e.g., `declare -A parent_data=([abraham:isaac]=1)`).\n    *   **Rules** become **Bash functions** that encapsulate the logic.\n    *   **Recursion** is converted from logical depth into **Breadth-First Search (BFS) loops** with memoization to ensure termination and performance in the shell.\n    *   **Backtracking** is handled via **streaming output**, allowing results to flow through standard shell pipes.\n\n### Key Technical Mappings\n\n| Prolog Concept | Bash Implementation |\n| :--- | :--- |\n| Facts | Associative Arrays |\n| Rules | Functions |\n| Recursion | BFS with Memoization |\n| Unification | String/Key Matching |\n| Backtracking | Streaming Output |\n\nOnce generated, you source the resulting `.sh` files to execute the predicates as standard shell commands. For a detailed look at the Bash compilation target, see `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["compilation", "prolog", "bash", "workflow", "bridge"], "original_answer": "## From Prolog to Bash: The Complete Workflow\n\nThis bridges Book 1 (Prolog fundamentals) with Book 2 (Bash compilation).\n\n### Step 1: Define in Prolog (Book 1)\n\n```prolog\n% Facts - basic assertions\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules - derived relationships\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### Step 2: Compile with UnifyWeaver (Book 2)\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n### Step 3: What Gets Generated\n\n```bash\n# parent.sh - Facts become associative arrays\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh - Rules become BFS with memoization\nancestor_all() {\n    declare -A visited\n    # ... BFS traversal using parent_data\n}\n```\n\n### Step 4: Execute\n\n```bash\nsource output/parent.sh\nsource output/ancestor.sh\nancestor abraham jacob  # Finds path!\n```\n\n### Key Transformations\n\n| Prolog (Book 1) | Bash (Book 2) |\n|-----------------|---------------|\n| Facts | Associative arrays |\n| Rules | Functions |\n| Recursion | BFS loops |\n| Unification | Key matching |\n| Backtracking | Streaming output |", "answer_tailored": true}
{"pair_id": "prolog-to-bash-bridge_p1", "cluster_id": "prolog-to-bash-bridge", "question": "What is the complete workflow from Prolog to Bash?", "question_type": "medium", "answer": "The workflow for compiling Prolog logic into executable Bash scripts follows a structured path from logical definition to shell execution:\n\n### 1. Define Logic in Prolog\nFirst, establish your facts and rules within a Prolog source file. This stage focuses on pure logical relationships (refer to `education/book-01-foundations/` for fundamentals).\n\n```prolog\n% Facts\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### 2. Compile via UnifyWeaver\nInvoke the compiler driver to translate the Prolog predicates into Bash-compatible code. Detailed compilation options and target-specific flags are covered in `education/book-02-bash-target/`.\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('out')], Scripts).\n% Scripts = ['out/parent.sh', 'out/ancestor.sh'].\n```\n\n### 3. Transformation Mechanics\nThe compiler maps Prolog's declarative constructs to Bash's procedural environment:\n\n| Prolog Feature | Bash Implementation |\n|----------------|---------------------|\n| **Facts** | **Associative Arrays**: Data is stored in `declare -A` maps for rapid lookup. |\n| **Rules** | **Shell Functions**: Logic is encapsulated in functions with local scopes. |\n| **Recursion** | **BFS Loops**: Deep recursion is flattened into Breadth-First Search with memoization. |\n| **Unification**| **Key Matching**: Term matching is handled via string-based key construction. |\n| **Backtracking**| **Streaming**: Multiple solutions are returned via standard output streams. |\n\n### 4. Execution\nFinally, source the generated artifacts in your shell and run the logic directly as a command:\n\n```bash\nsource out/parent.sh\nsource out/ancestor.sh\n\n# Query the logic\nancestor abraham jacob\n```", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["compilation", "prolog", "bash", "workflow", "bridge"], "original_answer": "## From Prolog to Bash: The Complete Workflow\n\nThis bridges Book 1 (Prolog fundamentals) with Book 2 (Bash compilation).\n\n### Step 1: Define in Prolog (Book 1)\n\n```prolog\n% Facts - basic assertions\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules - derived relationships\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### Step 2: Compile with UnifyWeaver (Book 2)\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n### Step 3: What Gets Generated\n\n```bash\n# parent.sh - Facts become associative arrays\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh - Rules become BFS with memoization\nancestor_all() {\n    declare -A visited\n    # ... BFS traversal using parent_data\n}\n```\n\n### Step 4: Execute\n\n```bash\nsource output/parent.sh\nsource output/ancestor.sh\nancestor abraham jacob  # Finds path!\n```\n\n### Key Transformations\n\n| Prolog (Book 1) | Bash (Book 2) |\n|-----------------|---------------|\n| Facts | Associative arrays |\n| Rules | Functions |\n| Recursion | BFS loops |\n| Unification | Key matching |\n| Backtracking | Streaming output |", "answer_tailored": true}
{"pair_id": "prolog-to-bash-bridge_p2", "cluster_id": "prolog-to-bash-bridge", "question": "How do Book 1 concepts connect to Book 2?", "question_type": "medium", "answer": "Book 1 establishes the foundational Prolog logic (facts and rules) that UnifyWeaver uses as source material for the Bash compilation processes detailed in Book 2. This connection represents the transition from declarative, high-level logic to imperative, executable shell scripts.\n\n### The Connection in Practice\n\nThe workflow bridges these books by translating logical relationships into portable shell utilities:\n\n1.  **Logic Definition (Book 1):** You define relationships in Prolog, such as recursive ancestor rules.\n2.  **Compilation (Book 2):** The UnifyWeaver compiler transforms these rules into optimized Bash functions and associative arrays.\n3.  **Execution:** The generated scripts (e.g., `parent.sh`, `ancestor.sh`) are sourced and called directly from the terminal.\n\n### Key Technical Mappings\n\n| Prolog Concept (Book 1) | Bash Implementation (Book 2) |\n|:--- |:--- |\n| **Facts** | Associative arrays for rapid lookups |\n| **Rules** | Standard shell functions |\n| **Recursion** | BFS traversal loops with memoization |\n| **Unification** | Key-based string matching |\n| **Backtracking** | Streaming output via standard streams |\n\nBy applying the Prolog fundamentals from Book 1, you can generate complex, high-performance shell tools using the compilation techniques found in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["compilation", "prolog", "bash", "workflow", "bridge"], "original_answer": "## From Prolog to Bash: The Complete Workflow\n\nThis bridges Book 1 (Prolog fundamentals) with Book 2 (Bash compilation).\n\n### Step 1: Define in Prolog (Book 1)\n\n```prolog\n% Facts - basic assertions\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules - derived relationships\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### Step 2: Compile with UnifyWeaver (Book 2)\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n### Step 3: What Gets Generated\n\n```bash\n# parent.sh - Facts become associative arrays\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh - Rules become BFS with memoization\nancestor_all() {\n    declare -A visited\n    # ... BFS traversal using parent_data\n}\n```\n\n### Step 4: Execute\n\n```bash\nsource output/parent.sh\nsource output/ancestor.sh\nancestor abraham jacob  # Finds path!\n```\n\n### Key Transformations\n\n| Prolog (Book 1) | Bash (Book 2) |\n|-----------------|---------------|\n| Facts | Associative arrays |\n| Rules | Functions |\n| Recursion | BFS loops |\n| Unification | Key matching |\n| Backtracking | Streaming output |", "answer_tailored": true}
{"pair_id": "prolog-to-bash-bridge_p3", "cluster_id": "prolog-to-bash-bridge", "question": "What happens during UnifyWeaver compilation?", "question_type": "medium", "answer": "During UnifyWeaver compilation, declarative Prolog logic is transformed into optimized, executable scripts for specific target environments like Bash, Python, or Go. The process converts high-level assertions and relationships into low-level operational code through a series of structured mappings.\n\n### The Compilation Workflow\n\n1.  **Logic Parsing:** The `unifyweaver(core/compiler_driver)` analyzes Prolog source code, identifying facts (basic assertions) and rules (derived relationships).\n2.  **Code Generation:** The compiler generates discrete target scripts. For instance, a recursive `ancestor/2` predicate might result in `parent.sh` and `ancestor.sh` when targeting Bash.\n3.  **Core Transformations:**\n    *   **Facts to Data Structures:** Assertions are converted into efficient lookup tables, such as associative arrays in Bash, where unification is replaced by key matching.\n    *   **Rules to Functions:** Logic rules become callable functions in the target language.\n    *   **Recursion to Iteration:** Recursive Prolog calls are typically refactored into iterative loops using Breadth-First Search (BFS) and memoization to ensure termination and efficiency.\n    *   **Backtracking to Streaming:** The non-deterministic nature of Prolog is handled through streaming outputs or result collections in the target script.\n\n### Resulting Execution\nThe output scripts are native to the target environment. In a Bash context, sourcing the generated files allows you to execute complex logic\u2014like finding a path through a recursive hierarchy\u2014directly from the command line using standard shell syntax.\n\nFor detailed implementation examples and target-specific transformation logic, see the documentation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["compilation", "prolog", "bash", "workflow", "bridge"], "original_answer": "## From Prolog to Bash: The Complete Workflow\n\nThis bridges Book 1 (Prolog fundamentals) with Book 2 (Bash compilation).\n\n### Step 1: Define in Prolog (Book 1)\n\n```prolog\n% Facts - basic assertions\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules - derived relationships\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### Step 2: Compile with UnifyWeaver (Book 2)\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n### Step 3: What Gets Generated\n\n```bash\n# parent.sh - Facts become associative arrays\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh - Rules become BFS with memoization\nancestor_all() {\n    declare -A visited\n    # ... BFS traversal using parent_data\n}\n```\n\n### Step 4: Execute\n\n```bash\nsource output/parent.sh\nsource output/ancestor.sh\nancestor abraham jacob  # Finds path!\n```\n\n### Key Transformations\n\n| Prolog (Book 1) | Bash (Book 2) |\n|-----------------|---------------|\n| Facts | Associative arrays |\n| Rules | Functions |\n| Recursion | BFS loops |\n| Unification | Key matching |\n| Backtracking | Streaming output |", "answer_tailored": true}
