{"pair_id": "prolog-facts-rules_p0", "cluster_id": "prolog-facts-rules", "question": "How do I define facts and rules in Prolog?", "question_type": "medium", "answer": "In Prolog, you define **facts** as basic assertions of truth and **rules** as conditional logic to derive new information.\n\n### Defining Facts\nA fact is a simple statement that ends with a period (`.`):\n\n```prolog\n% Example: defining direct dependencies\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\n```\n\n### Defining Rules\nA rule uses the `:-` operator (read as \"if\") to define a relationship where the **head** is true if the **body** is true:\n\n```prolog\n% Head :- Body.\n\n% Base case: A direct dependency is a transitive dependency\ntransitive_dependency(F, D) :- \n    file_dependency(F, D).\n\n% Recursive case: F depends on D if F depends on I, and I depends on D\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nUnifyWeaver specifically recognizes and optimizes these types of recursive patterns (transitive closures) when compiling to target languages like Python or Go.\n\n### Using Queries\nOnce defined, you can search your knowledge base using the `?-` prompt:\n\n```prolog\n% Does main.o eventually depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% List everything main.o depends on\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nFor more details on Prolog syntax and logic foundations in UnifyWeaver, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
{"pair_id": "prolog-facts-rules_p1", "cluster_id": "prolog-facts-rules", "question": "What is a Prolog fact?", "question_type": "medium", "answer": "A **fact** in Prolog is a fundamental assertion that is unconditionally true within the knowledge base. It consists of a predicate and its arguments, always terminating with a period. In the context of UnifyWeaver, these facts serve as the foundational data that the compiler uses to resolve dependencies and generate target-language logic.\n\nExample of a fact:\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\n```\n\nFacts represent the \"atoms\" of knowledge, whereas rules define how that knowledge can be expanded or inferred. For more details on Prolog syntax and fundamentals, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
{"pair_id": "prolog-facts-rules_p2", "cluster_id": "prolog-facts-rules", "question": "How do rules work in Prolog?", "question_type": "medium", "answer": "In Prolog, rules allow you to define new knowledge and conditional relationships based on existing facts. A rule consists of a **head** and a **body** separated by the `:-` operator, which is read as \"if.\" The head is true only if the goals in the body are satisfied.\n\nRules are frequently used to express recursion and patterns like **transitive closures**. For instance:\n\n```prolog\n% head :- body.\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nWhen UnifyWeaver compiles Prolog, it identifies these recursive rule patterns to optimize the generated code for the target language. For a complete overview of Prolog syntax, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
{"pair_id": "prolog-facts-rules_p3", "cluster_id": "prolog-facts-rules", "question": "How do I write a transitive closure in Prolog?", "question_type": "medium", "answer": "To write a transitive closure in Prolog, you define a recursive relation that handles both direct and indirect connections. This pattern is essential for traversing graphs, such as file dependency trees.\n\nFirst, establish your basic facts:\n```prolog\n% file_dependency(Source, Dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\n```\n\nThen, implement the transitive closure with two rules:\n```prolog\n% Base case: The relationship is direct\ntransitive_dependency(A, B) :- file_dependency(A, B).\n\n% Recursive case: A depends on B if A depends on an intermediate (I), \n% which in turn has a transitive dependency on B.\ntransitive_dependency(A, B) :-\n    file_dependency(A, I),\n    transitive_dependency(I, B).\n```\n\nYou can then query the system to find all reachable dependencies:\n```prolog\n% Find all transitive dependencies for main.o\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nUnifyWeaver automatically optimizes this specific transitive closure pattern during compilation to ensure efficient performance across all supported target languages. For more information on these core concepts, refer to `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
{"pair_id": "prolog-facts-rules_p4", "cluster_id": "prolog-facts-rules", "question": "How do I query Prolog?", "question_type": "medium", "answer": "To query Prolog, you enter questions at the `?-` prompt to see if they can be proven true based on your existing facts and rules.\n\n### Knowledge Base Context\nQueries interact with **facts** (unconditional truths) and **rules** (logic that defines how new knowledge is derived):\n\n```prolog\n% Facts define basic assertions\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Rules define relationships using :- (read as \"if\")\ntransitive_dependency(F, D) :- file_dependency(F, D).\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\n### Asking Questions\nYou can use variables (starting with a capital letter) to search for data, or constants to verify a specific claim:\n\n```prolog\n% Query: What are the direct dependencies of main.o?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Query: Is utils.c an indirect dependency of main.o?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n```\n\nIf there are multiple solutions, pressing `;` will find the next one, while Enter stops the search. UnifyWeaver provides optimized handling for these recursive \"transitive closure\" patterns.\n\nFor a full breakdown of Prolog fundamentals, refer to `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
