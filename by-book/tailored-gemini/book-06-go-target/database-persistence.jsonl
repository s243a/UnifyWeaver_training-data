{"pair_id": "b6-a3-boltdb-schema_p0", "cluster_id": "b6-a3-boltdb-schema", "question": "How does BoltDB store facts in Go target?", "question_type": "medium", "answer": "BoltDB stores facts in the Go target by organizing each predicate into its own specific bucket using the `go.etcd.io/bbolt` library. Inside these buckets, facts are represented as key-value pairs where the keys are byte slices (`[]byte`) and the values are JSON-marshaled `map[string]interface{}` objects.\n\n### Storage Technicals:\n*   **Bucket Organization:** Every predicate is assigned a unique bucket (e.g., `tx.CreateBucketIfNotExists([]byte(\"ancestor\"))`).\n*   **Data Format:** Records are encoded as UTF-8 strings and JSON objects.\n*   **Example Record:** `{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}`\n\nFor comprehensive details on database persistence and Go-specific storage strategies, refer to `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["boltdb", "database-schema", "bucket-organization"], "original_answer": "## BoltDB Schema in Go Target\n\n### Storage Format\n\n| Component | Format |\n|-----------|--------|\n| Keys | `[]byte` (string converted) |\n| Values | JSON-marshaled `map[string]interface{}` |\n| Encoding | UTF-8 strings, JSON objects |\n\n### Bucket Organization\n\nEach predicate gets its own bucket:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n    _, err := tx.CreateBucketIfNotExists([]byte(\"ancestor\"))\n    return err\n})\n```\n\n### Example Stored Record\n\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\n**Library:** `go.etcd.io/bbolt v1.3.8`", "answer_tailored": true}
{"pair_id": "b6-a3-boltdb-schema_p1", "cluster_id": "b6-a3-boltdb-schema", "question": "What is the BoltDB schema?", "question_type": "medium", "answer": "The BoltDB schema in UnifyWeaver's Go target is structured around buckets, where each Prolog predicate is assigned its own dedicated bucket. \n\n### Storage Structure\n*   **Buckets:** Each predicate (e.g., `parent/2`) is mapped to a specific bucket in the database.\n*   **Keys:** Record keys are stored as `[]byte` (converted from strings).\n*   **Values:** Data is persisted as JSON-marshaled objects (`map[string]interface{}`), encoding the relation and its arguments.\n\n### Example Record\nA stored entry for an `ancestor` predicate follows this format:\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\nThe implementation relies on the `go.etcd.io/bbolt v1.3.8` library. For more details on Go persistence and database integration, see `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["boltdb", "database-schema", "bucket-organization"], "original_answer": "## BoltDB Schema in Go Target\n\n### Storage Format\n\n| Component | Format |\n|-----------|--------|\n| Keys | `[]byte` (string converted) |\n| Values | JSON-marshaled `map[string]interface{}` |\n| Encoding | UTF-8 strings, JSON objects |\n\n### Bucket Organization\n\nEach predicate gets its own bucket:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n    _, err := tx.CreateBucketIfNotExists([]byte(\"ancestor\"))\n    return err\n})\n```\n\n### Example Stored Record\n\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\n**Library:** `go.etcd.io/bbolt v1.3.8`", "answer_tailored": true}
{"pair_id": "b6-a3-boltdb-schema_p2", "cluster_id": "b6-a3-boltdb-schema", "question": "How are facts organized in buckets?", "question_type": "medium", "answer": "In the UnifyWeaver Go target, facts are organized using a predicate-per-bucket strategy within BoltDB. Each Prolog predicate is assigned its own dedicated bucket, ensuring that related facts are isolated and easily queryable.\n\nThe internal storage format within these buckets follows these conventions:\n- **Bucket Creation:** Each predicate (e.g., `ancestor`) is initialized as a bucket using `tx.CreateBucketIfNotExists([]byte(\"predicate_name\"))`.\n- **Keys:** Facts are keyed using `[]byte` representations of their string identifiers.\n- **Values:** Data is stored as JSON-marshaled `map[string]interface{}` objects, encoded in UTF-8.\n- **Record Structure:** A typical record includes the relation name and its arguments, for example: `{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}`.\n\nThis persistence mechanism relies on the `go.etcd.io/bbolt` (v1.3.8) library. For more detailed information on database persistence and Go schema organization, see `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["boltdb", "database-schema", "bucket-organization"], "original_answer": "## BoltDB Schema in Go Target\n\n### Storage Format\n\n| Component | Format |\n|-----------|--------|\n| Keys | `[]byte` (string converted) |\n| Values | JSON-marshaled `map[string]interface{}` |\n| Encoding | UTF-8 strings, JSON objects |\n\n### Bucket Organization\n\nEach predicate gets its own bucket:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n    _, err := tx.CreateBucketIfNotExists([]byte(\"ancestor\"))\n    return err\n})\n```\n\n### Example Stored Record\n\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\n**Library:** `go.etcd.io/bbolt v1.3.8`", "answer_tailored": true}
{"pair_id": "b6-a3-key-strategies_p0", "cluster_id": "b6-a3-key-strategies", "question": "What key strategies does Go target support?", "question_type": "medium", "answer": "The Go target supports several key strategies for data persistence via BoltDB, allowing for flexible record identification:\n\n- **Single Field Key**: This is the default approach which uses a single field value (e.g., `name`) directly as the primary key.\n- **Composite Keys**: Merges multiple fields into a single key using a specified delimiter (e.g., `db_key_delimiter(':')`), resulting in keys like `eng:Alice`.\n- **Hash Keys**: Generates a SHA-256 hex digest from a field's content, which is ideal for unique content-based addressing.\n- **Composite with Hash**: Combines literal fields with hash values, such as `filename:sha256_hash`, to create structured yet unique identifiers.\n\nThese strategies are configured in the Prolog source using the `db_key_strategy/1` and `db_key_field/1` options within `compile_predicate_to_go/3`. For more information on database persistence in Go, see `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["key-strategies", "composite-keys", "hash-keys"], "original_answer": "## BoltDB Key Strategies\n\n### Single Field Key (Default)\n\n```prolog\ncompile_predicate_to_go(user/2, [\n    db_backend(bbolt),\n    db_key_field(name)\n], Code).\n```\n\nGenerated key: `\"Alice\"`, `\"Bob\"`\n\n### Composite Keys\n\n```prolog\ndb_key_strategy(composite([field(dept), field(name)])),\ndb_key_delimiter(':')\n```\n\nGenerated keys: `\"eng:Alice\"`, `\"sales:Bob\"`\n\n### Hash Keys\n\n```prolog\ndb_key_strategy(hash(field(content)))\n```\n\nGenerated key: SHA-256 hex digest\n\n### Composite with Hash\n\n```prolog\ndb_key_strategy(composite([field(name), hash(field(content))]))\n```\n\nGenerated key: `\"readme:a3f2b1c9...\"`", "answer_tailored": true}
{"pair_id": "b6-a3-key-strategies_p1", "cluster_id": "b6-a3-key-strategies", "question": "How do I use composite keys in BoltDB?", "question_type": "medium", "answer": "To implement composite keys for BoltDB in UnifyWeaver, you configure the `db_key_strategy` using the `composite` term. This allows you to concatenate multiple fields into a single unique identifier, optionally specifying a separator via `db_key_delimiter`.\n\n### Basic Composite Keys\nSpecify the fields you wish to combine in a list. For example, to create a key from department and name:\n\n```prolog\ncompile_predicate_to_go(user/3, [\n    db_backend(bbolt),\n    db_key_strategy(composite([field(dept), field(name)])),\n    db_key_delimiter(':')\n], Code).\n```\n**Generated keys:** `\"eng:Alice\"`, `\"sales:Bob\"`\n\n### Composite Keys with Hashing\nFor scenarios involving large content blocks, you can mix literal fields with SHA-256 hashes of other fields to maintain key efficiency:\n\n```prolog\ndb_key_strategy(composite([field(name), hash(field(content))]))\n```\n**Generated key:** `\"document_title:a3f2b1c9...\"`\n\nDetailed documentation on Go database persistence and key strategies can be found in `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["key-strategies", "composite-keys", "hash-keys"], "original_answer": "## BoltDB Key Strategies\n\n### Single Field Key (Default)\n\n```prolog\ncompile_predicate_to_go(user/2, [\n    db_backend(bbolt),\n    db_key_field(name)\n], Code).\n```\n\nGenerated key: `\"Alice\"`, `\"Bob\"`\n\n### Composite Keys\n\n```prolog\ndb_key_strategy(composite([field(dept), field(name)])),\ndb_key_delimiter(':')\n```\n\nGenerated keys: `\"eng:Alice\"`, `\"sales:Bob\"`\n\n### Hash Keys\n\n```prolog\ndb_key_strategy(hash(field(content)))\n```\n\nGenerated key: SHA-256 hex digest\n\n### Composite with Hash\n\n```prolog\ndb_key_strategy(composite([field(name), hash(field(content))]))\n```\n\nGenerated key: `\"readme:a3f2b1c9...\"`", "answer_tailored": true}
{"pair_id": "b6-a3-key-strategies_p2", "cluster_id": "b6-a3-key-strategies", "question": "What is db_key_strategy?", "question_type": "medium", "answer": "`db_key_strategy` is a configuration directive used in the UnifyWeaver BoltDB backend to define how primary keys are generated for persistent Go records. It specifies the logic for transforming Prolog predicate arguments into unique database keys.\n\n### Available Strategies\n\n*   **Single Field (Default)**: Maps a single field directly to the key.\n    ```prolog\n    db_key_field(name) % Generated key: \"Alice\"\n    ```\n*   **Composite Keys**: Combines multiple fields using a specified delimiter.\n    ```prolog\n    db_key_strategy(composite([field(dept), field(name)])),\n    db_key_delimiter(':') % Generated key: \"eng:Alice\"\n    ```\n*   **Hash Keys**: Creates a SHA-256 hex digest of a field's content.\n    ```prolog\n    db_key_strategy(hash(field(content))) % Generated key: SHA-256 digest\n    ```\n*   **Composite with Hash**: Mixes literal fields with hashed values.\n    ```prolog\n    db_key_strategy(composite([field(name), hash(field(content))])) % Generated key: \"readme:a3f2b1c9...\"\n    ```\n\nFor further details on Go persistence and BoltDB integration, see `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["key-strategies", "composite-keys", "hash-keys"], "original_answer": "## BoltDB Key Strategies\n\n### Single Field Key (Default)\n\n```prolog\ncompile_predicate_to_go(user/2, [\n    db_backend(bbolt),\n    db_key_field(name)\n], Code).\n```\n\nGenerated key: `\"Alice\"`, `\"Bob\"`\n\n### Composite Keys\n\n```prolog\ndb_key_strategy(composite([field(dept), field(name)])),\ndb_key_delimiter(':')\n```\n\nGenerated keys: `\"eng:Alice\"`, `\"sales:Bob\"`\n\n### Hash Keys\n\n```prolog\ndb_key_strategy(hash(field(content)))\n```\n\nGenerated key: SHA-256 hex digest\n\n### Composite with Hash\n\n```prolog\ndb_key_strategy(composite([field(name), hash(field(content))]))\n```\n\nGenerated key: `\"readme:a3f2b1c9...\"`", "answer_tailored": true}
{"pair_id": "b6-a3-query-outside_p0", "cluster_id": "b6-a3-query-outside", "question": "How do I query BoltDB outside generated programs?", "question_type": "medium", "answer": "To query BoltDB databases outside of their generated UnifyWeaver programs, you can use custom Go code, the internal runtime storage utility, or standard JSON exports.\n\n### Custom Go Implementation\nAccess the `.db` files directly using the `go.etcd.io/bbolt` driver. Opening the database with `ReadOnly: true` is recommended for safe concurrent access:\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    val := bucket.Get([]byte(\"Alice\")) // Returned as JSON bytes\n    return nil\n})\n```\n\n### UnifyWeaver Go Runtime Storage\nThe Go runtime includes a storage package that provides a higher-level API for record retrieval:\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\ndefer store.Close()\n\n// Retrieves record as a map[string]interface{}\nrecord, _ := store.GetObject(\"Alice\") \n```\n\n### JSON Data Export\nFor non-Go environments, you can pipe the output of a generated query program directly to a JSON Lines file:\n\n```bash\n./query_users > all_users.jsonl\n```\n\nFor more information on database schemas and persistence strategies, see `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["query-database", "external-access", "go-api"], "original_answer": "## Querying BoltDB Outside Generated Programs\n\n### Option 1: Custom Go Code\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v is JSON bytes\n    return nil\n})\n```\n\n### Option 2: Runtime Store Wrapper\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // map[string]interface{}\n```\n\n### Option 3: Export to JSON\n\n```bash\n./query_users > all_users.jsonl\n```", "answer_tailored": true}
{"pair_id": "b6-a3-query-outside_p1", "cluster_id": "b6-a3-query-outside", "question": "Can I access the database directly?", "question_type": "medium", "answer": "Yes, you can access the underlying BoltDB storage directly or via integration layers. Since the Go target persists data in bbolt format, you have several ways to interact with it:\n\n### 1. Low-Level Access (Custom Go Code)\nYou can use the standard `bbolt` library to open the database file. If the database is currently in use, ensure you open it in Read-Only mode:\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    b := tx.Bucket([]byte(\"users\"))\n    data := b.Get([]byte(\"Alice\"))\n    // data contains the raw JSON bytes\n    return nil\n})\n```\n\n### 2. High-Level Runtime Wrapper\nFor easier integration, use the UnifyWeaver Go runtime's storage module, which provides a map-based interface:\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\ns, _ := storage.NewStore(\"users.db\")\nrecord, _ := s.GetObject(\"Alice\")  // Returns map[string]interface{}\n```\n\n### 3. CLI Export\nAlternatively, you can extract all records into a standard JSONL file using the generated CLI tool:\n\n```bash\n./query_users > export.jsonl\n```\n\nFor a deeper dive into how persistence is handled, see `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["query-database", "external-access", "go-api"], "original_answer": "## Querying BoltDB Outside Generated Programs\n\n### Option 1: Custom Go Code\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v is JSON bytes\n    return nil\n})\n```\n\n### Option 2: Runtime Store Wrapper\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // map[string]interface{}\n```\n\n### Option 3: Export to JSON\n\n```bash\n./query_users > all_users.jsonl\n```", "answer_tailored": true}
{"pair_id": "b6-a3-query-outside_p2", "cluster_id": "b6-a3-query-outside", "question": "How do I read BoltDB data in custom Go code?", "question_type": "medium", "answer": "To read BoltDB data within custom Go applications, you can either use the raw BoltDB API for low-level access or the UnifyWeaver runtime storage wrapper for a simplified interface.\n\n### Option 1: Direct BoltDB API Access\nUse this method when you need full control over transactions and want to handle raw JSON bytes yourself:\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v is the JSON byte slice\n    return nil\n})\n```\n\n### Option 2: UnifyWeaver Runtime Store Wrapper\nThis approach leverages internal storage utilities to retrieve data directly as decoded maps:\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // Returns data as map[string]interface{}\n```\n\n### Option 3: JSON Stream Processing\nAlternatively, you can consume the output of a generated UnifyWeaver program in your Go code via standard input after exporting to JSONL:\n\n```bash\n./query_users > all_users.jsonl\n```\n\nFor more implementation details regarding database persistence and the Go target, refer to the documentation in `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["query-database", "external-access", "go-api"], "original_answer": "## Querying BoltDB Outside Generated Programs\n\n### Option 1: Custom Go Code\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v is JSON bytes\n    return nil\n})\n```\n\n### Option 2: Runtime Store Wrapper\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // map[string]interface{}\n```\n\n### Option 3: Export to JSON\n\n```bash\n./query_users > all_users.jsonl\n```", "answer_tailored": true}
{"pair_id": "b6-a3-incremental_p0", "cluster_id": "b6-a3-incremental", "question": "How does incremental Datalog work with BoltDB?", "question_type": "medium", "answer": "Incremental Datalog integration with BoltDB allows UnifyWeaver's Go target to maintain a persistent state across independent executions. Instead of re-evaluating the entire logic program from scratch, the system leverages the BoltDB key-value store to manage and update facts incrementally.\n\n### The Incremental Mechanism\nThe process follows a specific execution cycle to ensure data consistency:\n1. **State Loading**: Upon execution, the generated Go binary opens the BoltDB file and loads all previously stored facts into memory.\n2. **Fact Ingestion**: New input facts are read from `stdin` (typically formatted as JSON).\n3. **Fixpoint Computation**: The engine performs Datalog evaluation, deriving new results until no further inferences can be made.\n4. **Persistence**: The updated set of facts is committed back to the database, ensuring the new state is available for the next run.\n\n### Configuration\nTo enable BoltDB persistence, define the backend and database file within the `compile_predicate_to_go/3` directive:\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```\n\n### CLI Workflow\n```bash\n# Initial run: compute and save state\n./ancestor\n\n# Incremental update: add new data to the saved state\necho '{\"relation\":\"parent\", \"args\":[\"node_a\", \"node_b\"]}' | ./ancestor\n\n# Retrieval: query the persisted results\n./query_ancestors\n```\n\nFor a deeper dive into database persistence and Go-specific implementation, refer to `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["incremental-computation", "persistence", "datalog"], "original_answer": "## Incremental Datalog with BoltDB\n\n### Workflow\n\n```bash\n# First run - compute and persist\n./ancestor\n\n# Add new facts - continue from saved state\necho '{\"relation\":\"parent\",...}' | ./ancestor\n\n# Query persisted results\n./query_ancestors\n```\n\n### How It Works\n\n1. Load existing facts from database\n2. Add new input facts from stdin\n3. Run fixpoint until no new derivations\n4. Persist new facts to database\n\n### Configuration\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a3-incremental_p1", "cluster_id": "b6-a3-incremental", "question": "Can I add facts to an existing database?", "question_type": "medium", "answer": "Yes, UnifyWeaver supports adding facts to an existing database through incremental Datalog processing, specifically when using the Go target with the BoltDB backend.\n\n### Workflow for Incremental Updates\nThe system allows you to extend a persisted state by feeding new facts through standard input:\n```bash\n# 1. Initial execution to populate the database\n./ancestor\n\n# 2. Append new facts and update derivations\necho '{\"relation\":\"parent\",\"args\":[\"alice\",\"bob\"]}' | ./ancestor\n\n# 3. Query the updated results\n./query_ancestors\n```\n\n### How It Works\n1. **Loading:** The compiled binary loads existing facts from the specified BoltDB file.\n2. **Ingestion:** New facts are read from stdin (typically in JSON format).\n3. **Fixpoint Calculation:** The engine runs until no new derivations can be made from the combined set of old and new data.\n4. **Persistence:** The updated state is written back to the database.\n\n### Configuration\nEnable database persistence in your Prolog source using the following configuration:\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```\n\nFor a comprehensive guide on database persistence and incremental updates, refer to `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["incremental-computation", "persistence", "datalog"], "original_answer": "## Incremental Datalog with BoltDB\n\n### Workflow\n\n```bash\n# First run - compute and persist\n./ancestor\n\n# Add new facts - continue from saved state\necho '{\"relation\":\"parent\",...}' | ./ancestor\n\n# Query persisted results\n./query_ancestors\n```\n\n### How It Works\n\n1. Load existing facts from database\n2. Add new input facts from stdin\n3. Run fixpoint until no new derivations\n4. Persist new facts to database\n\n### Configuration\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a3-incremental_p2", "cluster_id": "b6-a3-incremental", "question": "How does persistence enable incremental computation?", "question_type": "medium", "answer": "Persistence enables incremental computation by allowing UnifyWeaver to maintain a persistent state between executions, ensuring that previously derived facts are reused rather than recomputed. By utilizing a database backend like BoltDB, the Go target can perform stateful Datalog evaluation across separate process invocations.\n\n### How It Works\n\nThe incremental workflow follows these steps:\n1. **Load:** The engine retrieves existing facts from the persistent store (e.g., `bbolt`).\n2. **Ingest:** New facts are added to the system via standard input or JSON streams.\n3. **Compute:** The fixpoint algorithm runs, generating new derivations based on the union of existing and fresh data.\n4. **Commit:** The updated fact set is persisted back to the database for subsequent runs.\n\n### Configuration\n\nTo enable this behavior, specify the `db_backend` and `db_file` options in the compiler directive:\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```\n\nThis approach allows developers to build systems that \"remember\" their state, enabling scenarios where data is piped into a compiled binary over time to maintain an up-to-date model. For more details on implementing database persistence, see `education/book-06-go-target/A3_database_persistence.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["incremental-computation", "persistence", "datalog"], "original_answer": "## Incremental Datalog with BoltDB\n\n### Workflow\n\n```bash\n# First run - compute and persist\n./ancestor\n\n# Add new facts - continue from saved state\necho '{\"relation\":\"parent\",...}' | ./ancestor\n\n# Query persisted results\n./query_ancestors\n```\n\n### How It Works\n\n1. Load existing facts from database\n2. Add new input facts from stdin\n3. Run fixpoint until no new derivations\n4. Persist new facts to database\n\n### Configuration\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```", "answer_tailored": true}
