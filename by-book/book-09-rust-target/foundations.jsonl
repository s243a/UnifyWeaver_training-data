{"cluster_id": "rust-001", "question": "Why use the Rust target in UnifyWeaver?", "answer": "The Rust target offers three key advantages: (1) Memory safety - Rust's ownership model ensures safety without a garbage collector, suitable for high-performance and resource-constrained environments; (2) Zero-cost abstractions - UnifyWeaver maps Prolog constructs to efficient Rust equivalents (HashSet for facts, iterators for streams); (3) Ecosystem - generated code leverages serde for JSON and regex for pattern matching. Use Rust for high-performance system tools, Go for general-purpose ETL.", "source_file": "book-09-rust-target/01_introduction.md", "prerequisites": ["book-01-foundations"]}
{"cluster_id": "rust-001", "question": "How does the Rust target compare to the Go target?", "answer": "Key differences:\n| Feature | Go Target | Rust Target |\n|---------|-----------|-------------|\n| Compilation | Fast | Slower (optimizing) |\n| Runtime | Garbage collected | Manual/ownership |\n| Safety | Memory safe | Memory & thread safe |\n| Use case | General purpose, ETL | High performance, system tools |\n\nBoth produce single binaries. Choose Go for faster compilation and simpler code, Rust for maximum performance and thread safety.", "source_file": "book-09-rust-target/01_introduction.md", "prerequisites": ["rust-001"]}
{"cluster_id": "rust-002", "question": "What features does the UnifyWeaver Rust target support?", "answer": "Supported features:\n- **Fact Export** (`compile_facts_to_rust/3`) - Export facts as Rust struct Vecs\n- **Recursive Queries** (`compile_recursive/3`) - BFS transitive closure with HashMap/VecDeque\n- **Pipeline Mode** - JSONL streaming with fixpoint evaluation\n- **JSON Processing** - Native serde_json integration\n- **Project Generation** (`write_rust_project/2`) - Full Cargo.toml generation\n- **Tail/Linear/Mutual Recursion** - Optimized patterns with memoization", "source_file": "book-09-rust-target/01_introduction.md", "prerequisites": ["rust-001"]}
