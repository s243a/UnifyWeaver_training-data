{"cluster_id": "sql-cte-001", "question": "How do I use Common Table Expressions (CTEs) in the SQL target?", "answer": "Use `compile_with_cte/4` to create WITH clauses:\n\n```prolog\n% Step 1: Define CTE content\nhigh_earner_data(Id, Name, Salary) :-\n    employees(Id, Name, _, Salary, _),\n    Salary > 100000.\n\n% Step 2: Define main query (references CTE by name)\nhigh_earner_result(Name, Salary) :-\n    high_earners(_, Name, Salary).  % References CTE name\n\n% Step 3: Compile\n?- compile_with_cte(high_earners, high_earner_data/3, high_earner_result/2, SQL).\n```\n\nGenerates: `WITH high_earners AS (SELECT ...) SELECT name, salary FROM high_earners`", "source_file": "book-10-sql-target/07_common_table_expressions.md", "prerequisites": ["sql-subquery-001"]}
{"cluster_id": "sql-cte-001", "question": "Why use CTEs instead of subqueries?", "answer": "CTEs provide several advantages:\n\n**1. Improved readability** - Break complex queries into logical steps:\n```prolog\nrich_depts_cte(DeptName) :-\n    departments(_, DeptName, Budget, _),\n    Budget > 1000000.\n\nemployees_result(Name) :-\n    employees(_, Name, Dept, _, _),\n    rich_depts(Dept).  % Clear reference to CTE\n```\n\n**2. Filter window function results** - CTEs enable WHERE on window results:\n```prolog\nranked_cte(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n\ntop_3_per_dept(Name, Dept, Salary, Rank) :-\n    ranked_employees(Name, Dept, Salary, Rank),\n    Rank =< 3.\n```\n\n**3. Reuse within query** - Reference the same CTE multiple times.", "source_file": "book-10-sql-target/07_common_table_expressions.md", "prerequisites": ["sql-cte-001"]}
{"cluster_id": "sql-cte-002", "question": "How do I use recursive CTEs in the SQL target?", "answer": "Use `compile_recursive_cte/5` for hierarchical data:\n\n```prolog\n% Declare recursive table schema\n:- sql_recursive_table(org_tree, [id-integer, name-text, manager_id-integer]).\n\n% Base case: Top-level employees (no manager)\norg_base(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId).\n\n% Recursive case: Employees whose manager is in org_tree\norg_recursive(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    org_tree(ManagerId, _, _).  % Join to CTE\n\n% Main query\norg_result(Id, Name, ManagerId) :-\n    org_tree(Id, Name, ManagerId).\n\n% Compile\n?- compile_recursive_cte(org_tree, [id, name, manager_id],\n    recursive_cte(org_base/3, org_recursive/3), org_result/3, SQL).\n```\n\nGenerates `WITH RECURSIVE ... UNION ALL ...`", "source_file": "book-10-sql-target/08_recursive_ctes.md", "prerequisites": ["sql-cte-001"]}
{"cluster_id": "sql-cte-002", "question": "What are common recursive CTE patterns?", "answer": "**1. Hierarchical depth tracking:**\n```prolog\nlevel_base(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId),\n    Level = 0.\n\nlevel_recursive(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    org_levels(ManagerId, _, ParentLevel),\n    Level = ParentLevel + 1.\n```\n\n**2. Path accumulation:**\n```prolog\npath_base(Id, Path) :-\n    categories(Id, Name, ParentId),\n    sql_is_null(ParentId),\n    Path = Name.\n\npath_recursive(Id, Path) :-\n    categories(Id, Name, ParentId),\n    paths(ParentId, ParentPath),\n    Path = sql_concat([ParentPath, ' > ', Name]).\n```\n\n**3. Graph reachability:**\n```prolog\nreach_base(Node) :- edges(1, Node, _).\nreach_recursive(Node) :- reachable(From), edges(From, Node, _).\n```", "source_file": "book-10-sql-target/08_recursive_ctes.md", "prerequisites": ["sql-cte-002"]}
