{"cluster_id": "sql-window-001", "question": "How do window functions work in the SQL target?", "answer": "Window functions calculate across related rows without collapsing them like aggregations. Syntax:\n\n```prolog\nsql_window(Function, Args, PartitionBy, OrderBy)\nsql_window(Function, Args, PartitionBy, OrderBy, FrameSpec)\n```\n\nExample - rank employees by salary within department:\n```prolog\nemployees_ranked(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n```\n\nGenerates: `RANK() OVER (PARTITION BY dept ORDER BY salary DESC)`", "source_file": "book-10-sql-target/06_window_functions.md", "prerequisites": ["sql-agg-001"]}
{"cluster_id": "sql-window-001", "question": "What ranking functions does the SQL target support?", "answer": "Three ranking functions with different tie-handling:\n\n```prolog\n% ROW_NUMBER - unique sequential numbers (1, 2, 3, 4...)\nRowNum = sql_window(row_number, [], [Dept], [(Salary, desc)])\n\n% RANK - same rank for ties, with gaps (1, 1, 3, 4...)\nRank = sql_window(rank, [], [Dept], [(Salary, desc)])\n\n% DENSE_RANK - same rank for ties, no gaps (1, 1, 2, 3...)\nDenseRank = sql_window(dense_rank, [], [Dept], [(Salary, desc)])\n```\n\nComparison for [100K, 100K, 90K, 80K]:\n| ROW_NUMBER | RANK | DENSE_RANK |\n|------------|------|------------|\n| 1 | 1 | 1 |\n| 2 | 1 | 1 |\n| 3 | 3 | 2 |\n| 4 | 4 | 3 |", "source_file": "book-10-sql-target/06_window_functions.md", "prerequisites": ["sql-window-001"]}
{"cluster_id": "sql-window-002", "question": "How do I use LAG and LEAD in the SQL target?", "answer": "LAG accesses previous rows, LEAD accesses following rows:\n\n```prolog\n% LAG - previous row's value\nsales_with_previous(Salesperson, Amount, SaleDate, PrevAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    PrevAmount = sql_window(lag, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n\n% LEAD - next row's value\nsales_with_next(Salesperson, Amount, SaleDate, NextAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    NextAmount = sql_window(lead, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n```\n\nThe second argument is the offset (how many rows). Also available: `first_value`, `last_value` for partition extremes.", "source_file": "book-10-sql-target/06_window_functions.md", "prerequisites": ["sql-window-001"]}
{"cluster_id": "sql-window-002", "question": "How do I specify window frames in the SQL target?", "answer": "Control exactly which rows are included using the 5-argument form:\n\n```prolog\nsql_window(Function, Args, PartitionBy, OrderBy, FrameSpec)\n```\n\n**Running total (default frame):**\n```prolog\nrunning_total(Person, Date, Amount, Total) :-\n    sales(_, Person, _, Amount, Date),\n    Total = sql_window(sum, [Amount], [Person], [(Date, asc)],\n                       rows_between(unbounded_preceding, current_row)).\n```\n\n**3-day moving average:**\n```prolog\nmoving_avg_3day(Person, Date, Amount, MovingAvg) :-\n    sales(_, Person, _, Amount, Date),\n    MovingAvg = sql_window(avg, [Amount], [Person], [(Date, asc)],\n                           rows_between(2 preceding, current_row)).\n```\n\nBoundaries: `unbounded_preceding`, `current_row`, `unbounded_following`, `N preceding`, `N following`", "source_file": "book-10-sql-target/06_window_functions.md", "prerequisites": ["sql-window-001"]}
