{"cluster_id": "b4-c4-cost-speed-quality", "seed_level": 2, "source_files": ["education/book-04-workflows/04_economic_decisions.md"], "topics": ["economic-decisions", "trade-offs", "optimization"], "questions": ["How does UnifyWeaver handle cost/speed/quality trade-offs?", "What is economic decision-making in pipelines?", "How do you balance performance vs accuracy?"], "answer": {"text": "## Economic Decision-Making\n\nUnifyWeaver optimizes compilation based on cost, speed, and quality trade-offs.\n\n### Trade-off Dimensions\n\n| Dimension | Optimizes For | Example |\n|-----------|--------------|----------|\n| Cost | Resource usage | Less memory/CPU |\n| Speed | Latency/throughput | Faster execution |\n| Quality | Accuracy | Better results |\n\n### Context-Based Decisions\n\n- **Batch jobs**: Optimize throughput\n- **Interactive**: Optimize latency\n- **Critical data**: Optimize accuracy\n\n### Priority Weights\n\nWorkflows can specify priorities:\n```prolog\nworkflow_options([\n    priority(speed, 3),\n    priority(cost, 2),\n    priority(quality, 1)\n]).\n```\n\n### Parameters Affected\n\n- Parallelism level\n- Caching strategy\n- Target language\n- Optimization flags", "anchor_question_hash": "b4c4001a"}}
{"cluster_id": "b4-c4-decision-heuristics", "seed_level": 3, "source_files": ["education/book-04-workflows/04_economic_decisions.md"], "topics": ["heuristics", "automation", "policy"], "questions": ["What heuristics guide target selection in workflows?", "How do you automate compilation decisions?", "What decision policies can workflows define?"], "answer": {"text": "## Decision Heuristics\n\n### Size-Based Rules\n\n```prolog\ntarget_heuristic(Lines, Target) :-\n    Lines < 1000 -> Target = awk ;\n    Lines < 100000 -> Target = python ;\n    Target = go.\n```\n\n### Characteristic Checks\n\n- **Data size**: Small → AWK, Large → Go\n- **Schema complexity**: Simple → streaming, Complex → batch\n- **Resource limits**: Constrained → lightweight target\n\n### Policies\n\n| Policy | Behavior |\n|--------|----------|\n| Greedy | Pick fastest available |\n| Conservative | Prefer proven paths |\n| Adaptive | Learn from past runs |\n\n### Automation\n\nHeuristics encoded as Prolog rules:\n```prolog\nselect_target(Pred, Options, Target) :-\n    is_recursive(Pred) ->\n        Target = csharp_query ;\n        Target = csharp_stream.\n```", "anchor_question_hash": "b4c4002a"}}
{"cluster_id": "b4-c4-resource-constraints", "seed_level": 3, "source_files": ["education/book-04-workflows/04_economic_decisions.md"], "topics": ["resources", "constraints", "scheduling"], "questions": ["How do workflows handle resource constraints?", "What resource limits can be specified?", "How does UnifyWeaver optimize for limited resources?"], "answer": {"text": "## Resource Constraints\n\n### Constraint Types\n\n| Constraint | Example |\n|------------|----------|\n| Memory | max_memory(4gb) |\n| CPU | max_cores(4) |\n| Time | timeout(5min) |\n| API rate | rate_limit(100/min) |\n| Storage | max_disk(10gb) |\n\n### Orchestrator Response\n\n1. **Light targets**: Bash instead of C#\n2. **Streaming**: Instead of in-memory\n3. **Batching**: API calls under rate limit\n4. **Spilling**: Intermediate results to disk\n\n### Fallback Strategies\n\n```prolog\nconstraint_fallback(memory_exceeded, [\n    switch_to(streaming_mode),\n    reduce_parallelism(2),\n    enable_disk_spill\n]).\n```\n\n### Specification\n\n```prolog\nworkflow_constraints([\n    max_memory(4gb),\n    timeout(10min),\n    rate_limit(api_calls, 100, minute)\n]).\n```", "anchor_question_hash": "b4c4003a"}}
