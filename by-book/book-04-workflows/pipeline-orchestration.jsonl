{"cluster_id": "b4-c3-multi-target-pipelines", "seed_level": 2, "source_files": ["education/book-04-workflows/03_pipeline_orchestration.md"], "topics": ["pipeline-orchestration", "multi-target", "stage-selection"], "questions": ["How do multi-target pipelines work in UnifyWeaver?", "How do you combine different target languages in a pipeline?", "What is cross-target pipeline orchestration?"], "answer": {"text": "## Multi-Target Pipelines\n\nMulti-target pipelines combine stages compiled to different languages:\n\n```\nAWK → Python → Go\n```\n\n### How It Works\n\nEach stage is compiled to its optimal target:\n- **AWK**: Text parsing, field extraction\n- **Python**: Complex transforms, ML integration\n- **Go**: High-performance aggregation\n\n### Pipeline Orchestration\n\n```prolog\npipeline_orchestrator([\n    stage(parse, awk),\n    stage(transform, python),\n    stage(aggregate, go)\n], Options, Output).\n```\n\n### Data Flow\n\n1. Stage outputs → serialized (JSON/CSV)\n2. Orchestrator routes to next stage\n3. Next stage reads, processes, outputs\n4. Continues until final stage\n\n### Benefits\n\n- Leverage each language's strengths\n- Unified Prolog specification\n- Automatic data marshaling", "anchor_question_hash": "b4c3001a"}}
{"cluster_id": "b4-c3-target-selection", "seed_level": 3, "source_files": ["education/book-04-workflows/03_pipeline_orchestration.md"], "topics": ["target-selection", "language-strengths", "optimization"], "questions": ["How do you choose which target language for each pipeline stage?", "When should you use AWK vs Python vs Go in a pipeline?", "What are the criteria for target selection?"], "answer": {"text": "## Target Selection Criteria\n\n### Language Strengths\n\n| Target | Best For | Characteristics |\n|--------|----------|------------------|\n| AWK | Line parsing | Fast, streaming |\n| Python | Complex logic | Flexible, libraries |\n| Go | Aggregation | Fast, compiled |\n| C# | Recursive queries | Fixpoint, .NET |\n| Bash | Glue code | System integration |\n\n### Selection Factors\n\n1. **Input/Output format**: AWK for text, Python for JSON\n2. **Complexity**: Simple → AWK, Complex → Python\n3. **Performance**: Critical → Go/C#\n4. **Libraries**: ML → Python, .NET → C#\n5. **Deployment**: Unix → Bash, Cross-platform → .NET\n\n### Decision Example\n\n```\nParsing CSV? → AWK\nML inference? → Python\n1M+ records? → Go\nRecursive? → C# Query Runtime\n```", "anchor_question_hash": "b4c3002a"}}
{"cluster_id": "b4-c3-pipeline-composition", "seed_level": 3, "source_files": ["education/book-04-workflows/03_pipeline_orchestration.md"], "topics": ["pipeline-composition", "data-flow", "serialization"], "questions": ["How do pipeline stages communicate in UnifyWeaver?", "What data formats are used between pipeline stages?", "How do you handle errors across pipeline stages?"], "answer": {"text": "## Stage Communication\n\n### Data Formats\n\nStages communicate via standard I/O using:\n- **JSON**: Complex nested data\n- **CSV/TSV**: Tabular data\n- **Line-delimited**: Simple records\n\n### Data Flow\n\n```\nStage A (stdout) → | pipe | → Stage B (stdin)\n```\n\nOr via temporary files:\n```\nStage A → /tmp/stage_a.json → Stage B\n```\n\n### Error Handling\n\n1. **Error channel**: stderr or error files\n2. **Retry logic**: Orchestrator retries failed stages\n3. **Fallback**: Alternative stage on failure\n4. **Thresholds**: Stop after N errors\n\n### Orchestrator Role\n\n- Parses stage output\n- Validates formats\n- Routes to next stage\n- Manages error recovery", "anchor_question_hash": "b4c3003a"}}
