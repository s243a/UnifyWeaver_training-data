{"cluster_id": "prolog-case-001", "question": "How do I compile a Prolog predicate to a standalone binary?", "answer": "Complete workflow for factorial example:\n\n**1. Define predicates (factorial.pl):**\n```prolog\nfactorial(0, 1) :- !.\nfactorial(N, R) :- N > 0, N1 is N-1, factorial(N1, R1), R is N*R1.\n\ntest_factorial :- factorial(5, F), format('5! = ~w~n', [F]).\n```\n\n**2. Generate and compile:**\n```prolog\n:- use_module('src/unifyweaver/targets/prolog_target').\n\nmain :-\n    generate_prolog_script([factorial/2, test_factorial/0],\n        [dialect(gnu), compile(true), entry_point(test_factorial)], Code),\n    write_prolog_script(Code, 'factorial_gnu.pl',\n        [dialect(gnu), compile(true)]).\n```\n\n**3. Result:**\n```bash\n$ ./factorial_gnu\n5! = 120\n\n$ time ./factorial_gnu\nreal    0m0.002s  # ~2ms startup (native binary)\n```\n\nKey: UnifyWeaver generates `:- initialization(test_factorial).` for compiled mode.", "source_file": "book-11-prolog-target/15_case_study.md", "prerequisites": ["prolog-dialect-001"]}
{"cluster_id": "prolog-api-001", "question": "What are the key Prolog target API predicates?", "answer": "**Main entry points:**\n\n```prolog\n% Generate script code\ngenerate_prolog_script(+Predicates, +Options, -Code)\n% Options: dialect(D), compile(Bool), entry_point(Goal)\n\n% Write to file (with optional compilation)\nwrite_prolog_script(+Code, +Path)\nwrite_prolog_script(+Code, +Path, +Options)\n% Options: dialect(D), compile(Bool), fail_on_compile_error(Bool)\n\n% Analyze dependencies\nanalyze_dependencies(+Predicates, -Dependencies)\n```\n\n**Dialect predicates:**\n```prolog\nsupported_dialect(?Dialect)           % swi, gnu\ndialect_capabilities(+Dialect, -Caps)\ndialect_shebang(+Dialect, -Shebang)\ndialect_initialization(+Dialect, +Goal, +Opts, -Init)\nvalidate_for_dialect(+Dialect, +Preds, -Issues)\n```\n\n**Compilation:**\n```prolog\ncompile_script(+Dialect, +ScriptPath)      % With error checking\ncompile_script_safe(+Dialect, +Path, +Opts) % Graceful fallback\n```", "source_file": "book-11-prolog-target/appendix_a_api_reference.md", "prerequisites": ["prolog-target-001"]}
{"cluster_id": "prolog-api-001", "question": "What are common Prolog target usage patterns?", "answer": "**Pattern 1: Simple script generation**\n```prolog\ngenerate_prolog_script([my_pred/2], [], Code),\nwrite_prolog_script(Code, 'output.pl').\n```\n\n**Pattern 2: Compiled binary**\n```prolog\ngenerate_prolog_script(Preds, [dialect(gnu), compile(true)], Code),\nwrite_prolog_script(Code, 'app.pl', [dialect(gnu), compile(true)]).\n```\n\n**Pattern 3: Multi-dialect generation**\n```prolog\ngenerate_both(Preds, Base) :-\n    generate_prolog_script(Preds, [dialect(swi)], Swi),\n    atom_concat(Base, '_swi.pl', SwiPath),\n    write_prolog_script(Swi, SwiPath),\n    generate_prolog_script(Preds, [dialect(gnu)], Gnu),\n    atom_concat(Base, '_gnu.pl', GnuPath),\n    write_prolog_script(Gnu, GnuPath).\n```\n\n**Pattern 4: With validation first**\n```prolog\nsafe_generate(Preds, Dialect, Code) :-\n    validate_for_dialect(Dialect, Preds, Issues),\n    Issues = [],  % Fail if incompatible\n    generate_prolog_script(Preds, [dialect(Dialect)], Code).\n```", "source_file": "book-11-prolog-target/appendix_a_api_reference.md", "prerequisites": ["prolog-api-001"]}
