{"pair_id": "sql-func-001_p0", "cluster_id": "sql-func-001", "question": "How do I handle NULL values in the SQL target?", "question_type": "medium", "answer": "The SQL target provides three approaches for NULL handling:\n\n**Testing for NULL values** with `sql_is_null/1` and `sql_is_not_null/1`:\n```prolog\nunshipped_orders(Id) :-\n    orders(Id, _, _, ShipDate, _),\n    sql_is_null(ShipDate).\n\nshipped_orders(Id, ShipDate) :-\n    orders(Id, _, _, ShipDate, _),\n    sql_is_not_null(ShipDate).\n```\n\n**Providing fallback values** using `sql_coalesce/1` to select the first non-NULL:\n```prolog\nemployee_with_dept(Name, Dept) :-\n    employees(_, Name, D, _, _, _),\n    Dept = sql_coalesce([D, 'Unknown']).\n```\n\n**Converting specific values to NULL** with `sql_nullif/2` (returns NULL when arguments match):\n```prolog\nproduct_real_price(Name, Price) :-\n    products(_, Name, _, P, _, _),\n    Price = sql_nullif(P, 0).  % Converts 0 to NULL\n```\n\nFor more SQL target capabilities, see education/book-10-sql-target/10_sql_functions.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/10_sql_functions.md", "topics": [], "original_answer": "**COALESCE** - first non-NULL value:\n```prolog\nemployee_with_dept(Name, Dept) :-\n    employees(_, Name, D, _, _, _),\n    Dept = sql_coalesce([D, 'Unknown']).\n```\n\n**NULLIF** - return NULL if values equal:\n```prolog\nproduct_real_price(Name, Price) :-\n    products(_, Name, _, P, _, _),\n    Price = sql_nullif(P, 0).  % Treat 0 as NULL\n```\n\n**IS NULL / IS NOT NULL** - test for NULL:\n```prolog\nunshipped_orders(Id) :-\n    orders(Id, _, _, ShipDate, _),\n    sql_is_null(ShipDate).\n\nshipped_orders(Id, ShipDate) :-\n    orders(Id, _, _, ShipDate, _),\n    sql_is_not_null(ShipDate).\n```", "answer_tailored": true}
{"pair_id": "sql-func-001_p0", "cluster_id": "sql-func-001", "question": "What string functions does the SQL target support?", "question_type": "medium", "answer": "The SQL target provides several string manipulation functions:\n\n**Concatenation:**\n- `sql_concat([Expr1, Expr2, ...])` - joins multiple values together\n\n**Case Conversion:**\n- `sql_upper(Expr)` - converts to uppercase\n- `sql_lower(Expr)` - converts to lowercase\n\n**Substring Operations:**\n- `sql_substring(Expr, Start, Length)` - extracts portion of a string\n- `sql_trim(Expr)` - removes leading and trailing whitespace\n- `sql_ltrim(Expr)` - removes leading whitespace only\n- `sql_rtrim(Expr)` - removes trailing whitespace only\n\n**String Analysis:**\n- `sql_length(Expr)` - returns the length of a string\n\n**Text Replacement:**\n- `sql_replace(Expr, Pattern, Replacement)` - substitutes text within strings\n\nExample usage:\n```prolog\nFullName = sql_concat([FirstName, ' ', LastName])\nCleanName = sql_upper(sql_trim(UserInput))\nInitialChar = sql_substring(Name, 1, 1)\nSanitizedEmail = sql_replace(Email, '@', ' at ')\n```\n\nThese functions can be freely combined and nested for complex string transformations. For complete documentation on SQL target capabilities, see education/book-10-sql-target/.", "answer_variant": "default", "answer_source": "book-10-sql-target/10_sql_functions.md", "topics": [], "original_answer": "```prolog\n% CONCAT - concatenate values\nInfo = sql_concat([Name, ' - ', Dept])\n\n% UPPER / LOWER - change case\nUpper = sql_upper(Name)\nLower = sql_lower(Name)\n\n% SUBSTRING - extract part of string\nInitials = sql_substring(Name, 1, 1)\n\n% TRIM / LTRIM / RTRIM - remove whitespace\nTrimmed = sql_trim(Name)\nLeftTrimmed = sql_ltrim(Name)\n\n% LENGTH - string length\nLen = sql_length(Name)\n\n% REPLACE - substitute text\nEmail = sql_replace(E, '@', ' at ')\n```\n\nFunctions can be nested:\n```prolog\nResult = sql_upper(sql_trim(Name))\n```", "answer_tailored": true}
{"pair_id": "sql-func-002_p0", "cluster_id": "sql-func-002", "question": "What date functions does the SQL target support?", "question_type": "medium", "answer": "The SQL target provides several date functions for working with temporal data:\n\n**Type Conversion:**\n- `sql_date(OrderDate)` - Convert to DATE type\n- `sql_datetime(OrderDate)` - Convert to DATETIME type\n\n**Date Arithmetic:**\n- `sql_date_add(OrderDate, 7, days)` - Add intervals (supports days, months, years)\n- `sql_date_diff(ShipDate, OrderDate)` - Calculate days between two dates\n\n**Extracting Components:**\n- `sql_extract(year, HireDate)` - Extract specific parts (year, month, day, hour, minute, second)\n\n**Custom Formatting:**\n- `sql_strftime('%Y-%m-%d', OrderDate)` - Format dates using codes like `%Y` (year), `%m` (month), `%d` (day), `%H` (hour), `%M` (minute), `%S` (second)\n\nThese functions enable date manipulation, formatting, and calculations in SQL queries. For complete SQL target documentation, see education/book-10-sql-target/.", "answer_variant": "default", "answer_source": "book-10-sql-target/10_sql_functions.md", "topics": [], "original_answer": "```prolog\n% DATE / DATETIME - extract/convert\nDateOnly = sql_date(OrderDate)\nDT = sql_datetime(OrderDate)\n\n% DATE_ADD - add interval\nDueDate = sql_date_add(OrderDate, 7, days)  % days, months, years\n\n% DATE_DIFF - days between dates\nDays = sql_date_diff(ShipDate, OrderDate)\n\n% EXTRACT - get date parts\nYear = sql_extract(year, HireDate)   % year, month, day, hour, minute, second\nMonth = sql_extract(month, HireDate)\n\n% STRFTIME - custom format\nFormatted = sql_strftime('%Y-%m-%d', OrderDate)\n```\n\nFormat codes: `%Y` (year), `%m` (month), `%d` (day), `%H` (hour), `%M` (minute), `%S` (second)", "answer_tailored": true}
{"pair_id": "sql-func-002_p0", "cluster_id": "sql-func-002", "question": "How do I use pattern matching in the SQL target?", "question_type": "medium", "answer": "The SQL target provides several pattern matching predicates:\n\n**LIKE/NOT LIKE** for wildcard matching:\n```prolog\n% % matches any sequence, _ matches single character\nj_names(Name) :- employees(_, Name, _, _, _, _), sql_like(Name, 'J%').\nson_names(Name) :- employees(_, Name, _, _, _, _), sql_like(Name, '%son%').\nsql_not_like(Name, 'Test%')  % Exclude test entries\n```\n\n**IN/NOT IN** for set membership:\n```prolog\nengineering_depts(Name, Dept) :-\n    employees(_, Name, Dept, _, _, _),\n    sql_in(Dept, [engineering, 'r&d', development]).\n\nsql_not_in(Dept, [admin, hr])  % Exclude departments\n```\n\n**BETWEEN/NOT BETWEEN** for range matching:\n```prolog\nmid_salary(Name, Salary) :-\n    employees(_, Name, _, Salary, _, _),\n    sql_between(Salary, 50000, 100000).\n\nsql_not_between(Salary, 40000, 80000)  % Outside range\n```\n\nSee education/book-10-sql-target/10_sql_functions.md for complete details on SQL pattern matching predicates.", "answer_variant": "default", "answer_source": "book-10-sql-target/10_sql_functions.md", "topics": [], "original_answer": "**BETWEEN** - range test:\n```prolog\nmid_salary(Name, Salary) :-\n    employees(_, Name, _, Salary, _, _),\n    sql_between(Salary, 50000, 100000).\n\n% Also: sql_not_between(Salary, 40000, 80000)\n```\n\n**LIKE** - wildcard matching:\n```prolog\n% % matches any sequence, _ matches single char\nj_names(Name) :- employees(_, Name, _, _, _, _), sql_like(Name, 'J%').\nson_names(Name) :- employees(_, Name, _, _, _, _), sql_like(Name, '%son%').\n\n% Also: sql_not_like(Name, 'Test%')\n```\n\n**IN** - list membership:\n```prolog\nengineering_depts(Name, Dept) :-\n    employees(_, Name, Dept, _, _, _),\n    sql_in(Dept, [engineering, 'r&d', development]).\n\n% Also: sql_not_in(Dept, [admin, hr])\n```", "answer_tailored": true}
