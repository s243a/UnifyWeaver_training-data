{"pair_id": "sql-join-001_p0", "cluster_id": "sql-join-001", "question": "How do JOINs work in the SQL target?", "question_type": "medium", "answer": "In UnifyWeaver's SQL target, JOINs are expressed through Prolog variable unification. When multiple predicates share a variable, the compiler automatically generates an INNER JOIN:\n\n```prolog\ncustomer_orders(CustomerName, Product) :-\n    customers(CustId, CustomerName, _, _),\n    orders(_, CustId, Product, _, _).\n% Compiles to: SELECT ... FROM customers INNER JOIN orders ON orders.customer_id = customers.id\n```\n\nThe shared `CustId` variable triggers the join condition. For outer joins (LEFT, RIGHT, FULL), wrap predicates with explicit join directives:\n\n```prolog\ncustomers_with_orders(Name, Product) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(_, CustId, Product, _, _)).\n```\n\nThis produces a LEFT OUTER JOIN, including customers even when they have no matching orders. For comprehensive details on join strategies and optimization, see education/book-10-sql-target/03_joins.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/03_joins.md", "topics": [], "original_answer": "INNER JOINs happen implicitly via shared variables:\n\n```prolog\ncustomer_orders(CustomerName, Product) :-\n    customers(CustId, CustomerName, _, _),\n    orders(_, CustId, Product, _, _).\n% Generates: SELECT ... FROM customers INNER JOIN orders ON orders.customer_id = customers.id\n```\n\nFor LEFT/RIGHT/FULL OUTER JOINs, use explicit predicates:\n```prolog\ncustomers_with_orders(Name, Product) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(_, CustId, Product, _, _)).\n```", "answer_tailored": true}
{"pair_id": "sql-join-001_p0", "cluster_id": "sql-join-001", "question": "What JOIN types does the SQL target support?", "question_type": "medium", "answer": "The SQL target supports four JOIN types:\n\n**INNER JOIN**: Automatically generated when rules share variables across tables\n**LEFT JOIN**: Explicitly requested using `sql_left_join(table(...))`\n**RIGHT JOIN**: Explicitly requested using `sql_right_join(table(...))`\n**FULL OUTER JOIN**: Explicitly requested using `sql_full_outer_join(table(...))`\n\nYou can identify unmatched rows by combining LEFT JOIN with `sql_is_null/1`. For example, to find customers without orders:\n```prolog\ncustomers_without_orders(Name) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(OrderId, CustId, _, _, _)),\n    sql_is_null(OrderId).\n```\n\nSee education/book-10-sql-target/03_joins.md for complete JOIN documentation.", "answer_variant": "default", "answer_source": "book-10-sql-target/03_joins.md", "topics": [], "original_answer": "Four JOIN types:\n- **INNER JOIN**: Implicit via shared variables\n- **LEFT JOIN**: `sql_left_join(table(...))`\n- **RIGHT JOIN**: `sql_right_join(table(...))`\n- **FULL OUTER JOIN**: `sql_full_outer_join(table(...))`\n\nFind non-matching rows with LEFT JOIN + IS NULL:\n```prolog\ncustomers_without_orders(Name) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(OrderId, CustId, _, _, _)),\n    sql_is_null(OrderId).\n```", "answer_tailored": true}
{"pair_id": "sql-agg-001_p0", "cluster_id": "sql-agg-001", "question": "How do I use aggregations in the SQL target?", "question_type": "medium", "answer": "The SQL target supports aggregations through aggregate functions combined with `sql_group_by/1` for grouping and `sql_having/1` for filtering grouped results:\n\n```prolog\ndept_totals(Dept, Total) :-\n    employees(_, _, Dept, Salary, _),\n    Total = sql_sum(Salary),\n    sql_group_by([Dept]).\n\n% Filter aggregated groups with HAVING\nlarge_depts(Dept, Count) :-\n    employees(_, _, Dept, _, _),\n    Count = sql_count(*),\n    sql_group_by([Dept]),\n    sql_having(Count > 5).\n```\n\nAvailable aggregate functions: `sql_count`, `sql_sum`, `sql_avg`, `sql_min`, `sql_max`.\n\nFor more examples and details, see education/book-10-sql-target/04_aggregations.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/04_aggregations.md", "topics": [], "original_answer": "Use aggregate functions with `sql_group_by/1` and optionally `sql_having/1`:\n\n```prolog\ndept_totals(Dept, Total) :-\n    employees(_, _, Dept, Salary, _),\n    Total = sql_sum(Salary),\n    sql_group_by([Dept]).\n\n% With HAVING\nlarge_depts(Dept, Count) :-\n    employees(_, _, Dept, _, _),\n    Count = sql_count(*),\n    sql_group_by([Dept]),\n    sql_having(Count > 5).\n```\n\nSupported: `sql_count`, `sql_sum`, `sql_avg`, `sql_min`, `sql_max`.", "answer_tailored": true}
