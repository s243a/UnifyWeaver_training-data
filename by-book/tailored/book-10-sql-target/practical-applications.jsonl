{"pair_id": "sql-practical-001_p0", "cluster_id": "sql-practical-001", "question": "How do I build a sales dashboard with the SQL target?", "question_type": "medium", "answer": "To build a sales dashboard with UnifyWeaver's SQL target, you can combine aggregations, window functions, and conditional logic. Here's an example showing revenue summaries and customer segmentation:\n\n```prolog\n% Monthly revenue summary\nmonthly_revenue(Year, Month, Revenue, OrderCount, AvgOrder) :-\n    orders(_, _, _, _, Amount, OrderDate, Status),\n    Status = 'completed',\n    Year = sql_extract(year, OrderDate),\n    Month = sql_extract(month, OrderDate),\n    sql_group_by([Year, Month]),\n    Revenue = sql_as(sql_sum(Amount), total_revenue),\n    OrderCount = sql_as(sql_count(*), order_count),\n    AvgOrder = sql_as(sql_avg(Amount), avg_order_value).\n\n% Customer segments using RFM analysis\ncustomer_segments(CustomerId, CustomerName, Segment, TotalSpent, OrderCount) :-\n    customers(CustomerId, CustomerName, _, _, _),\n    orders(_, CustomerId, _, _, Amount, _, Status),\n    Status = 'completed',\n    sql_group_by([CustomerId, CustomerName]),\n    TotalSpent = sql_sum(Amount),\n    OrderCount = sql_count(*),\n    Segment = sql_case([\n        when((TotalSpent > 10000, OrderCount > 20), 'Platinum'),\n        when((TotalSpent > 5000, OrderCount > 10), 'Gold')\n    ], 'Bronze').\n```\n\nThis approach uses aggregation for totals and counts, CASE WHEN for tier classification, and GROUP BY for summarization. For more dashboard patterns and advanced SQL features, see education/book-10-sql-target/12_practical_applications.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/12_practical_applications.md", "topics": [], "original_answer": "Combine aggregations, window functions, and CASE WHEN:\n\n```prolog\n% Monthly revenue summary\nmonthly_revenue(Year, Month, Revenue, OrderCount, AvgOrder) :-\n    orders(_, _, _, _, Amount, OrderDate, Status),\n    Status = 'completed',\n    Year = sql_extract(year, OrderDate),\n    Month = sql_extract(month, OrderDate),\n    sql_group_by([Year, Month]),\n    Revenue = sql_as(sql_sum(Amount), total_revenue),\n    OrderCount = sql_as(sql_count(*), order_count),\n    AvgOrder = sql_as(sql_avg(Amount), avg_order_value).\n\n% Customer segments with RFM\ncustomer_segments(CustomerId, CustomerName, Segment, TotalSpent, OrderCount) :-\n    customers(CustomerId, CustomerName, _, _, _),\n    orders(_, CustomerId, _, _, Amount, _, Status),\n    Status = 'completed',\n    sql_group_by([CustomerId, CustomerName]),\n    TotalSpent = sql_sum(Amount),\n    OrderCount = sql_count(*),\n    Segment = sql_case([\n        when((TotalSpent > 10000, OrderCount > 20), 'Platinum'),\n        when((TotalSpent > 5000, OrderCount > 10), 'Gold')\n    ], 'Bronze').\n```", "answer_tailored": true}
{"pair_id": "sql-practical-001_p0", "cluster_id": "sql-practical-001", "question": "How do I generate database views from Prolog predicates?", "question_type": "medium", "answer": "To generate database views from Prolog predicates, use `format(view)` and `view_name(Name)` in your compilation options:\n\n```prolog\ngenerate_views :-\n    % Create a revenue summary view\n    compile_predicate_to_sql(monthly_revenue/5,\n        [format(view), view_name(v_monthly_revenue)], SQL1),\n    write_sql_file('views/v_monthly_revenue.sql', SQL1),\n\n    % Create a customer segments view\n    compile_predicate_to_sql(customer_segments/5,\n        [format(view), view_name(v_customer_segments)], SQL2),\n    write_sql_file('views/v_customer_segments.sql', SQL2),\n\n    % Create org chart view using recursive CTE\n    compile_recursive_cte(org_chart, [id, name, manager_id, level],\n        recursive_cte(org_base/4, org_recursive/4),\n        org_result/4,\n        [view_name(v_org_chart)], SQL3),\n    write_sql_file('views/v_org_chart.sql', SQL3).\n```\n\nThis generates SQL statements like `CREATE VIEW IF NOT EXISTS v_monthly_revenue AS SELECT ...` for each predicate. The views can then be queried like regular tables. For more examples, see education/book-10-sql-target/12_practical_applications.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/12_practical_applications.md", "topics": [], "original_answer": "Use the `format(view)` and `view_name(Name)` options:\n\n```prolog\ngenerate_views :-\n    % Revenue summary view\n    compile_predicate_to_sql(monthly_revenue/5,\n        [format(view), view_name(v_monthly_revenue)], SQL1),\n    write_sql_file('views/v_monthly_revenue.sql', SQL1),\n\n    % Customer segments view\n    compile_predicate_to_sql(customer_segments/5,\n        [format(view), view_name(v_customer_segments)], SQL2),\n    write_sql_file('views/v_customer_segments.sql', SQL2),\n\n    % Org chart using recursive CTE\n    compile_recursive_cte(org_chart, [id, name, manager_id, level],\n        recursive_cte(org_base/4, org_recursive/4),\n        org_result/4,\n        [view_name(v_org_chart)], SQL3),\n    write_sql_file('views/v_org_chart.sql', SQL3).\n```\n\nGenerates `CREATE VIEW IF NOT EXISTS v_monthly_revenue AS SELECT ...`", "answer_tailored": true}
{"pair_id": "sql-practical-002_p0", "cluster_id": "sql-practical-002", "question": "How do I create data quality reports with the SQL target?", "question_type": "medium", "answer": "To create data quality reports with UnifyWeaver's SQL target, leverage subqueries, aggregations, and SQL-specific predicates to audit your data:\n\n```prolog\n% Identify duplicate email addresses\nduplicate_emails(Email, Count) :-\n    users(_, Email, _, _),\n    sql_group_by([Email]),\n    Count = sql_count(*),\n    sql_having(Count > 1).\n\n% Detect orphaned order records\norphaned_orders(OrderId) :-\n    orders(OrderId, CustomerId, _, _, _, _, _),\n    sql_not_exists(customers(CustomerId, _, _, _, _)).\n\n% Check data freshness and categorize\ndata_freshness(LastUpdate, DaysOld, Status) :-\n    orders(_, _, _, _, _, OrderDate, _),\n    LastUpdate = sql_max(OrderDate),\n    DaysOld = sql_date_diff(sql_date('now'), LastUpdate),\n    Status = sql_case([\n        when(DaysOld < 1, 'Fresh'),\n        when(DaysOld < 7, 'Recent'),\n        when(DaysOld < 30, 'Stale')\n    ], 'Very Stale').\n```\n\nThese patterns combine Prolog's declarative style with SQL's analytical capabilities to produce comprehensive data quality assessments. For more SQL target features, see education/book-10-sql-target/.", "answer_variant": "default", "answer_source": "book-10-sql-target/12_practical_applications.md", "topics": [], "original_answer": "Use subqueries and aggregations to audit data:\n\n```prolog\n% Find duplicate emails\nduplicate_emails(Email, Count) :-\n    users(_, Email, _, _),\n    sql_group_by([Email]),\n    Count = sql_count(*),\n    sql_having(Count > 1).\n\n% Find orphaned records\norphaned_orders(OrderId) :-\n    orders(OrderId, CustomerId, _, _, _, _, _),\n    sql_not_exists(customers(CustomerId, _, _, _, _)).\n\n% Data freshness check\ndata_freshness(LastUpdate, DaysOld, Status) :-\n    orders(_, _, _, _, _, OrderDate, _),\n    LastUpdate = sql_max(OrderDate),\n    DaysOld = sql_date_diff(sql_date('now'), LastUpdate),\n    Status = sql_case([\n        when(DaysOld < 1, 'Fresh'),\n        when(DaysOld < 7, 'Recent'),\n        when(DaysOld < 30, 'Stale')\n    ], 'Very Stale').\n```", "answer_tailored": true}
