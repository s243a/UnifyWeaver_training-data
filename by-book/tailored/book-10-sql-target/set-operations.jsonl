{"pair_id": "sql-set-001_p0", "cluster_id": "sql-set-001", "question": "How do I use UNION in the SQL target?", "question_type": "medium", "answer": "To combine query results with UNION in the SQL target, use `compile_set_operation/4`:\n\n```prolog\nus_employees(Name, Dept) :- employees_us(_, Name, Dept, _).\nuk_employees(Name, Dept) :- employees_uk(_, Name, Dept, _).\n\n% UNION - removes duplicate rows\n?- compile_set_operation(union, [us_employees/2, uk_employees/2], [], SQL).\n\n% UNION ALL - retains duplicates (better performance)\n?- compile_set_operation(union_all, [us_employees/2, uk_employees/2], [], SQL).\n```\n\nYou can combine more than two predicates:\n```prolog\n?- compile_set_operation(union,\n    [us_employees/2, uk_employees/2, contractor_workers/2], [], SQL).\n```\n\nAll predicates in the operation must have matching column counts and compatible types. For more set operations, see education/book-10-sql-target/09_set_operations.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/09_set_operations.md", "topics": [], "original_answer": "Use `compile_set_operation/4` to combine query results:\n\n```prolog\nus_employees(Name, Dept) :- employees_us(_, Name, Dept, _).\nuk_employees(Name, Dept) :- employees_uk(_, Name, Dept, _).\n\n% UNION (removes duplicates)\n?- compile_set_operation(union, [us_employees/2, uk_employees/2], [], SQL).\n\n% UNION ALL (keeps duplicates, more efficient)\n?- compile_set_operation(union_all, [us_employees/2, uk_employees/2], [], SQL).\n```\n\nMulti-way unions:\n```prolog\n?- compile_set_operation(union,\n    [us_employees/2, uk_employees/2, contractor_workers/2], [], SQL).\n```\n\nAll predicates must have same column count and compatible types.", "answer_tailored": true}
{"pair_id": "sql-set-001_p0", "cluster_id": "sql-set-001", "question": "How do I use INTERSECT and EXCEPT in the SQL target?", "question_type": "medium", "answer": "To use INTERSECT and EXCEPT in UnifyWeaver's SQL target, use `compile_set_operation/4`:\n\n**INTERSECT** finds common rows across all queries:\n```prolog\ncustomers_23(Email) :- customers_2023(_, _, Email).\ncustomers_24(Email) :- customers_2024(_, _, Email).\n\n% Find customers present in both years\n?- compile_set_operation(intersect, [customers_23/1, customers_24/1], [], SQL).\n```\n\n**EXCEPT** returns rows from the first query excluding those in subsequent queries:\n```prolog\n% Customers who joined in 2024 (not in 2023)\n?- compile_set_operation(except, [customers_24/1, customers_23/1], [], SQL).\n\n% Customers who left (in 2023, not in 2024)\n?- compile_set_operation(except, [customers_23/1, customers_24/1], [], SQL).\n```\n\nImportant: EXCEPT is order-dependent\u2014`A EXCEPT B` yields different results than `B EXCEPT A`.\n\nBoth operations support `_all` variants (`intersect_all`, `except_all`) to preserve duplicates. For comprehensive coverage of SQL set operations, see education/book-10-sql-target/09_set_operations.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/09_set_operations.md", "topics": [], "original_answer": "**INTERSECT** - rows in ALL queries:\n```prolog\ncustomers_23(Email) :- customers_2023(_, _, Email).\ncustomers_24(Email) :- customers_2024(_, _, Email).\n\n% Retained customers (in both years)\n?- compile_set_operation(intersect, [customers_23/1, customers_24/1], [], SQL).\n```\n\n**EXCEPT** - rows in first query but not subsequent:\n```prolog\n% New customers (in 2024 but not 2023)\n?- compile_set_operation(except, [customers_24/1, customers_23/1], [], SQL).\n\n% Churned customers (in 2023 but not 2024)\n?- compile_set_operation(except, [customers_23/1, customers_24/1], [], SQL).\n```\n\nNote: Order matters for EXCEPT! `A EXCEPT B` is different from `B EXCEPT A`.\n\nAll variants support `_all` suffix: `intersect_all`, `except_all`.", "answer_tailored": true}
