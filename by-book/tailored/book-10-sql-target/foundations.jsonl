{"pair_id": "sql-001_p0", "cluster_id": "sql-001", "question": "What is the SQL target in UnifyWeaver?", "question_type": "medium", "answer": "The SQL target is one of UnifyWeaver's compilation targets that transforms Prolog predicates into SQL queries for relational databases. It differs from procedural targets like Bash, Go, or Rust by generating declarative database queries rather than standalone executables. To use it, load the module with `use_module('src/unifyweaver/targets/sql_target')` and define your database schemas using `sql_table/2`. For comprehensive guidance on SQL target usage, see education/book-10-sql-target/.", "answer_variant": "default", "answer_source": "book-10-sql-target/01_getting_started.md", "topics": [], "original_answer": "The SQL target compiles Prolog predicates into SQL queries for execution on relational databases. Unlike other targets (Bash, Go, Rust) that produce executable programs, the SQL target generates declarative queries meant for external database execution. Load with `use_module('src/unifyweaver/targets/sql_target')` and declare table schemas with `sql_table/2`.", "answer_tailored": true}
{"pair_id": "sql-001_p0", "cluster_id": "sql-001", "question": "How do I declare SQL table schemas in UnifyWeaver?", "question_type": "medium", "answer": "To declare SQL table schemas in UnifyWeaver, use the `sql_table/2` directive with the table name and column definitions:\n\n```prolog\n:- sql_table(employees, [\n    id-integer,\n    name-text,\n    dept-text,\n    salary-integer\n]).\n```\n\nEach column is specified as `name-type`, where type can be `integer`, `text`, or `real`. The column order in the list determines how they map to predicate arguments in your queries. Define these schema declarations before writing any SQL queries that reference the tables. For comprehensive SQL target documentation, see education/book-10-sql-target/.", "answer_variant": "default", "answer_source": "book-10-sql-target/01_getting_started.md", "topics": [], "original_answer": "Use `sql_table/2` to declare table schemas before writing queries:\n\n```prolog\n:- sql_table(employees, [\n    id-integer,\n    name-text,\n    dept-text,\n    salary-integer\n]).\n```\n\nSupported types: `integer`, `text`, `real`. Column names map to predicate argument positions.", "answer_tailored": true}
{"pair_id": "sql-002_p0", "cluster_id": "sql-002", "question": "How do I compile a Prolog predicate to SQL?", "question_type": "medium", "answer": "To compile a Prolog predicate to SQL, use the `compile_predicate_to_sql/3` predicate. Here's an example:\n\n```prolog\nhigh_earners(Name, Salary) :-\n    employees(_, Name, _, Salary),\n    Salary > 80000.\n\n?- compile_predicate_to_sql(high_earners/2, [], SQL).\n% SQL = 'SELECT name, salary FROM employees WHERE salary > 80000;'\n```\n\nThe first argument is the predicate indicator (Name/Arity), the second is an options list (empty `[]` for basic compilation), and the third unifies with the generated SQL string. You can pass options like `format(view)` with `view_name(ViewName)` to create VIEW definitions instead of standalone queries. For more details on SQL target compilation, see education/book-10-sql-target/.", "answer_variant": "default", "answer_source": "book-10-sql-target/01_getting_started.md", "topics": [], "original_answer": "Use `compile_predicate_to_sql/3`:\n\n```prolog\nhigh_earners(Name, Salary) :-\n    employees(_, Name, _, Salary),\n    Salary > 80000.\n\n?- compile_predicate_to_sql(high_earners/2, [], SQL).\n% SQL = 'SELECT name, salary FROM employees WHERE salary > 80000;'\n```\n\nOptions include `format(view)` with `view_name(Name)` to generate CREATE VIEW statements.", "answer_tailored": true}
