{"pair_id": "rust-001_p0", "cluster_id": "rust-001", "question": "Why use the Rust target in UnifyWeaver?", "question_type": "medium", "answer": "UnifyWeaver's Rust target is ideal when you need memory safety without garbage collection overhead, making it perfect for high-performance or resource-constrained scenarios. The target provides zero-cost abstractions by mapping Prolog primitives to efficient Rust constructs\u2014facts become HashSet operations, streams use iterators\u2014while tapping into Rust's rich ecosystem (serde for serialization, regex for patterns). Choose Rust when building system-level tools or performance-critical applications; for typical ETL pipelines, the Go target may be more appropriate.", "answer_variant": "default", "answer_source": "book-09-rust-target/01_introduction.md", "topics": [], "original_answer": "The Rust target offers three key advantages: (1) Memory safety - Rust's ownership model ensures safety without a garbage collector, suitable for high-performance and resource-constrained environments; (2) Zero-cost abstractions - UnifyWeaver maps Prolog constructs to efficient Rust equivalents (HashSet for facts, iterators for streams); (3) Ecosystem - generated code leverages serde for JSON and regex for pattern matching. Use Rust for high-performance system tools, Go for general-purpose ETL.", "answer_tailored": true}
{"pair_id": "rust-001_p0", "cluster_id": "rust-001", "question": "How does the Rust target compare to the Go target?", "question_type": "medium", "answer": "The Rust and Go targets have distinct trade-offs:\n\n**Compilation Speed**: Go compiles much faster, while Rust takes longer due to aggressive optimizations.\n\n**Memory Model**: Go uses garbage collection for automatic memory management. Rust employs ownership and borrowing, requiring manual memory control but with zero-cost abstractions.\n\n**Safety Guarantees**: Both are memory-safe, but Rust additionally provides compile-time thread safety guarantees through its ownership system.\n\n**Typical Applications**: Go excels at general-purpose tools and ETL pipelines where fast iteration matters. Rust suits high-performance scenarios and systems programming where runtime efficiency is critical.\n\nBoth generate standalone native binaries. Select Go when you prioritize build speed and straightforward code, Rust when you need maximum runtime performance and fearless concurrency.", "answer_variant": "default", "answer_source": "book-09-rust-target/01_introduction.md", "topics": [], "original_answer": "Key differences:\n| Feature | Go Target | Rust Target |\n|---------|-----------|-------------|\n| Compilation | Fast | Slower (optimizing) |\n| Runtime | Garbage collected | Manual/ownership |\n| Safety | Memory safe | Memory & thread safe |\n| Use case | General purpose, ETL | High performance, system tools |\n\nBoth produce single binaries. Choose Go for faster compilation and simpler code, Rust for maximum performance and thread safety.", "answer_tailored": true}
{"pair_id": "rust-002_p0", "cluster_id": "rust-002", "question": "What features does the UnifyWeaver Rust target support?", "question_type": "medium", "answer": "The Rust target in UnifyWeaver provides comprehensive feature support including:\n\n- **Fact Export** - Uses `compile_facts_to_rust/3` to generate Rust struct Vecs from Prolog facts\n- **Recursive Query Compilation** - Implements `compile_recursive/3` with BFS-based transitive closure using HashMap and VecDeque for efficient graph traversal\n- **JSONL Pipeline Mode** - Supports streaming input/output with fixpoint evaluation for incremental processing\n- **JSON Integration** - Native serde_json support for seamless JSON data handling\n- **Project Scaffolding** - `write_rust_project/2` generates complete Cargo projects with proper dependencies\n- **Recursion Optimization** - Handles tail recursion, linear recursion, and mutual recursion with memoization strategies\n\nFor implementation details and examples, see education/book-09-rust-target/.", "answer_variant": "default", "answer_source": "book-09-rust-target/01_introduction.md", "topics": [], "original_answer": "Supported features:\n- **Fact Export** (`compile_facts_to_rust/3`) - Export facts as Rust struct Vecs\n- **Recursive Queries** (`compile_recursive/3`) - BFS transitive closure with HashMap/VecDeque\n- **Pipeline Mode** - JSONL streaming with fixpoint evaluation\n- **JSON Processing** - Native serde_json integration\n- **Project Generation** (`write_rust_project/2`) - Full Cargo.toml generation\n- **Tail/Linear/Mutual Recursion** - Optimized patterns with memoization", "answer_tailored": true}
