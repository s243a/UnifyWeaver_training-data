{"pair_id": "validation-001_p0", "cluster_id": "validation-001", "question": "What validation points does UnifyWeaver have?", "question_type": "medium", "answer": "UnifyWeaver implements validation at three distinct checkpoints: Pre-generation validation ensures predicate compatibility with the target language, verifies feature support, and confirms firewall policy adherence before any code generation occurs. Post-generation validation examines the generated code for correct syntax, scans for dangerous constructs like eval or exec, and assesses code complexity. Finally, deployment validation checks security requirements such as HTTPS for remote connections, validates configuration files, and confirms health check endpoints are properly configured. All three stages return structured issue lists that must be resolved before proceeding. For implementation details, see education/book-08-security-firewall/05_validation_fallback.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/05_validation_fallback.md", "topics": [], "original_answer": "UnifyWeaver validates at three points: (1) Pre-generation - checks predicate compatibility, target feature support, and firewall policy compliance before generating code; (2) Post-generation - verifies syntax, checks for dangerous patterns (eval, exec), and analyzes complexity after code is generated; (3) Deployment - validates security requirements (HTTPS for remote), configuration correctness, and health check setup. Each validation returns a list of issues that must be addressed.", "answer_tailored": true}
{"pair_id": "validation-001_p0", "cluster_id": "validation-001", "question": "How does pre-generation validation work?", "question_type": "medium", "answer": "Pre-generation validation verifies compatibility before generating code by checking features against target capabilities:\n\n```prolog\nvalidate_for_target(Predicates, Target, Issues) :-\n    findall(Issue,\n        (member(Pred, Predicates),\n         incompatible_feature(Pred, Target, Issue)),\n        Issues).\n\n% Detecting incompatibilities\nincompatible_feature(Pred, bash, issue(tabling, Pred)) :-\n    uses_tabling(Pred).\nincompatible_feature(Pred, awk, issue(recursion_depth, Pred)) :-\n    deep_recursion(Pred).\n```\n\nThe validator identifies issues like tabling in Bash targets or deep recursion in AWK, and additionally validates firewall policies using `validate_firewall/3`. See education/book-08-security-firewall/ for complete validation patterns.", "answer_variant": "default", "answer_source": "book-08-security-firewall/05_validation_fallback.md", "topics": [], "original_answer": "Pre-generation validation checks compatibility before code generation:\n\n```prolog\nvalidate_for_target(Predicates, Target, Issues) :-\n    findall(Issue,\n        (member(Pred, Predicates),\n         incompatible_feature(Pred, Target, Issue)),\n        Issues).\n\n% Example incompatibilities\nincompatible_feature(Pred, bash, issue(tabling, Pred)) :-\n    uses_tabling(Pred).\nincompatible_feature(Pred, awk, issue(recursion_depth, Pred)) :-\n    deep_recursion(Pred).\n```\n\nAlso checks firewall policies with `validate_firewall/3`.", "answer_tailored": true}
{"pair_id": "validation-002_p0", "cluster_id": "validation-002", "question": "What fallback mechanisms does UnifyWeaver provide?", "question_type": "medium", "answer": "UnifyWeaver offers four types of fallback mechanisms to ensure robust operation: First, **compilation fallback** automatically switches from native compilation to interpreted mode when native compilation fails. Second, **dialect fallback** attempts alternative Prolog dialects if the primary one fails. Third, **target fallback** tries different compilation targets (e.g., switching from Rust to Python). Fourth, **service fallback** provides graceful degradation when external services fail by using default values, backup services, or cached results:\n\n```prolog\n:- declare_fallback(api_service, [\n    default_value(#{status: 'unavailable'}),\n    fallback_service(backup_api),\n    cache_timeout(300)\n]).\n```\n\nThese mechanisms can be configured per-service with customizable timeout and caching behavior. For implementation details, see education/book-08-security-firewall/05_validation_fallback.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/05_validation_fallback.md", "topics": [], "original_answer": "Four fallback mechanisms: (1) Compilation fallback - native compilation fails, falls back to interpreted; (2) Dialect fallback - tries alternative Prolog dialects if one fails; (3) Target fallback - tries alternative compilation targets; (4) Service fallback - uses default values or backup services when a service fails:\n\n```prolog\n:- declare_fallback(api_service, [\n    default_value(#{status: 'unavailable'}),\n    fallback_service(backup_api),\n    cache_timeout(300)\n]).\n```", "answer_tailored": true}
{"pair_id": "validation-003_p0", "cluster_id": "validation-003", "question": "How do I implement retry policies and circuit breakers?", "question_type": "medium", "answer": "UnifyWeaver provides retry policies and circuit breakers to handle failures gracefully.\n\n**Retry Policies** manage transient failures with configurable backoff:\n\n```prolog\n:- declare_retry_policy(api_service, [\n    max_retries(3),\n    retry_delay(exponential(1000, 2, 10000)),\n    retry_on([connection_error, timeout, server_error])\n]).\n```\n\nThis retries up to 3 times with exponential backoff (1s \u2192 2s \u2192 4s, max 10s) for specific error types.\n\n**Circuit Breakers** prevent cascading failures by stopping requests to failing services:\n\n```prolog\n:- declare_circuit_breaker(api_service, [\n    failure_threshold(5),\n    reset_timeout(60),\n    half_open_requests(3)\n]).\n```\n\nAfter 5 failures, the circuit opens (blocks requests). After 60 seconds, it enters half-open state allowing 3 test requests.\n\nUse `protected_call/4` to layer these protections: circuit breaker \u2192 timeout \u2192 retry \u2192 fallback. See education/book-08-security-firewall/05_validation_fallback.md for complete examples.", "answer_variant": "default", "answer_source": "book-08-security-firewall/05_validation_fallback.md", "topics": [], "original_answer": "Retry policies handle transient failures:\n\n```prolog\n:- declare_retry_policy(api_service, [\n    max_retries(3),\n    retry_delay(exponential(1000, 2, 10000)),\n    retry_on([connection_error, timeout, server_error])\n]).\n```\n\nCircuit breakers prevent cascading failures:\n\n```prolog\n:- declare_circuit_breaker(api_service, [\n    failure_threshold(5),\n    reset_timeout(60),\n    half_open_requests(3)\n]).\n```\n\nCombine with `protected_call/4` for full protection: circuit breaker -> timeout -> retry -> fallback.", "answer_tailored": true}
