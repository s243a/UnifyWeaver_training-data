{"pair_id": "firewall-001_p0", "cluster_id": "firewall-001", "question": "How do I declare a firewall policy in UnifyWeaver?", "question_type": "medium", "answer": "To declare a firewall policy in UnifyWeaver, create a `.firewall` file and use Prolog predicates to define your rules:\n\n```prolog\n% Configure the enforcement mode\n:- firewall_mode(enforce).\n\n% Permit specific compilation targets\n:- allow(target(bash)).\n:- allow(target(go)).\n\n% Block specific targets\n:- deny(target(python)).\n\n% Prohibit native compilation\n:- deny(compile(native)).\n\n% Block module imports\n:- deny(import_module(library(http/_))).\n```\n\nThe key predicates are `allow/1` for permitting actions, `deny/1` for blocking them, and `require/1` for mandatory conditions. For more details on security and firewall configuration, see education/book-08-security-firewall/.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Firewall policies are declared in .firewall files using Prolog predicates:\n\n```prolog\n% Set enforcement mode\n:- firewall_mode(enforce).\n\n% Allow specific targets\n:- allow(target(bash)).\n:- allow(target(go)).\n\n% Deny specific targets\n:- deny(target(python)).\n\n% Deny compilation\n:- deny(compile(native)).\n\n% Deny modules\n:- deny(import_module(library(http/_))).\n```\n\nUse `allow/1` to permit, `deny/1` to block, and `require/1` for mandatory conditions.", "answer_tailored": true}
{"pair_id": "firewall-001_p0", "cluster_id": "firewall-001", "question": "What firewall policy predicates are available?", "question_type": "medium", "answer": "UnifyWeaver provides four core firewall policy predicates: `allow/1` explicitly permits specific operations (e.g., `allow(target(go))`), `deny/1` blocks them (e.g., `deny(compile(native))`), `require/1` enforces mandatory conditions (e.g., `require(validation(passed))`), and `implies/2` creates conditional policies (e.g., `implies(compile(native), code_review(required))`). These predicates support logical composition through AND (multiple conditions in a rule), OR (multiple separate rules), and NOT (using `\\+` for negation). For complete firewall policy implementation details, see education/book-08-security-firewall/02_firewall_policies.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Four main predicates: (1) `allow/1` - explicitly permit operations like `allow(target(go))`; (2) `deny/1` - explicitly deny operations like `deny(compile(native))`; (3) `require/1` - make conditions mandatory like `require(validation(passed))`; (4) `implies/2` - conditional policies like `implies(compile(native), code_review(required))`. Policies can be composed with AND (multiple conditions), OR (multiple rules), and NOT (`\\+` negation).", "answer_tailored": true}
{"pair_id": "firewall-002_p0", "cluster_id": "firewall-002", "question": "How do I create a target whitelist firewall policy?", "question_type": "medium", "answer": "To create a target whitelist firewall policy, use `allow/1` directives for permitted targets followed by a catch-all `deny/1`:\n\n```prolog\n% .firewall - Whitelist configuration\n:- allow(target(bash)).\n:- allow(target(go)).\n:- allow(target(rust)).\n:- deny(target(_)).  % Block everything else\n```\n\nThe wildcard `_` in the final deny rule matches any target not explicitly allowed, establishing a default-deny security posture. See education/book-08-security-firewall/02_firewall_policies.md for additional policy patterns.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Create a whitelist by allowing specific targets then denying all others:\n\n```prolog\n% .firewall - Target whitelist\n:- allow(target(bash)).\n:- allow(target(go)).\n:- allow(target(rust)).\n:- deny(target(_)).  % Deny all others\n```\n\nThe underscore `_` matches any target not previously allowed, creating a secure default-deny policy.", "answer_tailored": true}
{"pair_id": "firewall-002_p0", "cluster_id": "firewall-002", "question": "How do I create environment-specific firewall policies?", "question_type": "medium", "answer": "Create environment-specific firewall policies by using conditional Prolog rules that check the current environment:\n\n```prolog\n% Development environment: allow all targets\n:- allow(target(_)) :- environment(development).\n:- allow(compile(_)) :- environment(development).\n\n% Production environment: restrict to compiled targets only\n:- allow(target(go)) :- environment(production).\n:- allow(target(rust)) :- environment(production).\n:- deny(target(python)) :- environment(production).\n:- require(validation(passed)) :- environment(production).\n```\n\nYou can also maintain separate `.firewall` files for each environment and load the appropriate one based on your deployment context. For more details on firewall configuration, see education/book-08-security-firewall/.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Use conditional rules based on environment:\n\n```prolog\n% Development: permissive\n:- allow(target(_)) :- environment(development).\n:- allow(compile(_)) :- environment(development).\n\n% Production: strict\n:- allow(target(go)) :- environment(production).\n:- allow(target(rust)) :- environment(production).\n:- deny(target(python)) :- environment(production).\n:- require(validation(passed)) :- environment(production).\n```\n\nDifferent .firewall files can be loaded per environment.", "answer_tailored": true}
{"pair_id": "firewall-003_p0", "cluster_id": "firewall-003", "question": "How do I debug firewall policies?", "question_type": "medium", "answer": "UnifyWeaver provides three debugging approaches for firewall policies:\n\n**Trace Mode** - Enable detailed logging to see the decision process in real-time:\n```prolog\n:- set_firewall_flag(trace, true).\n% Output example:\n% [Firewall] Checking: target(python)\n% [Firewall] Rule 3: deny(target(python)) - MATCH\n```\n\n**Policy Inspection** - Query `?- list_firewall_rules.` to view all active firewall rules and their precedence.\n\n**Dry Run Testing** - Test policy behavior without actual execution:\n```prolog\n?- firewall_dry_run([check(target(python)), check(target(go))], Results).\nResults = [denied(target(python)), allowed(target(go))].\n```\n\nFor comprehensive firewall documentation and examples, see education/book-08-security-firewall/02_firewall_policies.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/02_firewall_policies.md", "topics": [], "original_answer": "Three methods: (1) Trace mode shows decision process:\n```prolog\n:- set_firewall_flag(trace, true).\n% Shows: [Firewall] Checking: target(python)\n%        [Firewall] Rule 3: deny(target(python)) - MATCH\n```\n\n(2) List policies: `?- list_firewall_rules.`\n\n(3) Dry run tests policies without executing:\n```prolog\n?- firewall_dry_run([check(target(python)), check(target(go))], Results).\nResults = [denied(target(python)), allowed(target(go))].\n```", "answer_tailored": true}
