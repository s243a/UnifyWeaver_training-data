{"pair_id": "hooks-001_p0", "cluster_id": "hooks-001", "question": "What are lifecycle hooks in UnifyWeaver?", "question_type": "medium", "answer": "Lifecycle hooks are automated actions triggered at specific points in a service's deployment and operational lifecycle. UnifyWeaver's lifecycle follows this sequence: pre_deploy -> Deploy -> post_deploy -> Running -> pre_shutdown -> Shutdown -> post_shutdown. You can configure hooks using declarations like:\n\n```prolog\n:- declare_lifecycle_hook(api_service, pre_deploy, health_check).\n:- declare_lifecycle_hook(api_service, post_deploy, warm_cache).\n:- declare_lifecycle_hook(api_service, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(api_service, on_health_failure, custom('alert.sh')).\n```\n\nThese hooks let you inject custom logic at deployment stages, during runtime events, or when services shut down. For comprehensive coverage of lifecycle management and hook patterns, see education/book-08-security-firewall/03_lifecycle_hooks.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/03_lifecycle_hooks.md", "topics": [], "original_answer": "Lifecycle hooks are actions that execute automatically at specific events during service deployment and operation. The lifecycle flow is: pre_deploy -> Deploy -> post_deploy -> Running -> pre_shutdown -> Shutdown -> post_shutdown. Declare hooks with:\n\n```prolog\n:- declare_lifecycle_hook(api_service, pre_deploy, health_check).\n:- declare_lifecycle_hook(api_service, post_deploy, warm_cache).\n:- declare_lifecycle_hook(api_service, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(api_service, on_health_failure, custom('alert.sh')).\n```", "answer_tailored": true}
{"pair_id": "hooks-001_p0", "cluster_id": "hooks-001", "question": "What lifecycle hook events are available?", "question_type": "medium", "answer": "UnifyWeaver provides five lifecycle hook events: `pre_deploy` runs before deployment for validation and backup tasks; `post_deploy` executes after deployment to perform health checks and cache warming; `pre_shutdown` triggers before service shutdown to drain connections and save state; `post_shutdown` runs after shutdown for cleanup and notifications; and `on_health_failure` activates when health checks fail, enabling alerts and recovery actions. You can register multiple hooks for any event\u2014they'll run in sequence. For implementation details, see education/book-08-security-firewall/03_lifecycle_hooks.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/03_lifecycle_hooks.md", "topics": [], "original_answer": "Five hook events: (1) `pre_deploy` - before deployment for validation/backup; (2) `post_deploy` - after deployment for health checks/cache warming; (3) `pre_shutdown` - before stopping for connection draining/state saving; (4) `post_shutdown` - after stopping for cleanup/notification; (5) `on_health_failure` - when health check fails for alerting/recovery. Multiple hooks can be declared for the same event and execute sequentially.", "answer_tailored": true}
{"pair_id": "hooks-002_p0", "cluster_id": "hooks-002", "question": "What built-in hook actions are available?", "question_type": "medium", "answer": "UnifyWeaver provides five built-in hook actions: `drain_connections` (waits for active connections to finish), `health_check` (verifies service responds via HTTP), `warm_cache` (pre-populates caches), `save_state` (persists service state before shutdown), and `custom(Command)` (executes arbitrary shell commands). Example usage:\n\n```prolog\n:- declare_lifecycle_hook(svc, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(svc, post_deploy, custom('notify.sh deployed')).\n```\n\nFor complete lifecycle hook documentation, see education/book-08-security-firewall/03_lifecycle_hooks.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/03_lifecycle_hooks.md", "topics": [], "original_answer": "Five built-in actions: (1) `drain_connections` - wait for active connections to complete; (2) `health_check` - verify service is responding via HTTP; (3) `warm_cache` - pre-populate caches; (4) `save_state` - persist service state before shutdown; (5) `custom(Command)` - run arbitrary shell command. Example:\n\n```prolog\n:- declare_lifecycle_hook(svc, pre_shutdown, drain_connections).\n:- declare_lifecycle_hook(svc, post_deploy, custom('notify.sh deployed')).\n```", "answer_tailored": true}
{"pair_id": "hooks-002_p0", "cluster_id": "hooks-002", "question": "How does deploy_with_hooks work?", "question_type": "medium", "answer": "The `deploy_with_hooks/2` predicate orchestrates a complete deployment workflow with validation and lifecycle hooks. It takes a service identifier and returns a result after executing four sequential steps: first, it validates all security requirements for the service; second, it runs any registered pre-deployment hooks; third, it performs the actual deployment operation; and fourth, it executes post-deployment hooks. The entire process is atomic\u2014if any step fails, the deployment halts immediately and returns an error. Here's a practical example combining security validation with hooked deployment:\n\n```prolog\ndeploy_secure :-\n    validate_security(api_service, Errors),\n    (Errors == []\n    ->  deploy_with_hooks(api_service, Result)\n    ;   format('Security errors: ~w~n', [Errors]), fail\n    ).\n```\n\nFor graceful shutdowns that also respect hooks, use `graceful_stop/3` instead. Additional lifecycle hook patterns are documented in education/book-08-security-firewall/03_lifecycle_hooks.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/03_lifecycle_hooks.md", "topics": [], "original_answer": "The `deploy_with_hooks/2` predicate executes the full deployment flow: (1) Validate security requirements; (2) Execute pre-deploy hooks; (3) Perform actual deployment; (4) Execute post-deploy hooks. If any step fails, deployment aborts with appropriate error. Use `graceful_stop/3` for shutdown with hooks:\n\n```prolog\ndeploy_secure :-\n    validate_security(api_service, Errors),\n    (Errors == []\n    ->  deploy_with_hooks(api_service, Result)\n    ;   format('Security errors: ~w~n', [Errors]), fail\n    ).\n```", "answer_tailored": true}
