{"pair_id": "target-sec-001_p0", "cluster_id": "target-sec-001", "question": "What are the security characteristics of different compilation targets?", "question_type": "medium", "answer": "Different compilation targets vary significantly in their security characteristics:\n\n**Strongest Security:**\n- **Rust**: Offers guaranteed memory safety and very high compile-time safety with OS-level runtime sandboxing\n- **Go & C#/.NET**: Provide high compile-time safety with managed memory and sandboxing (OS-level for Go, CLR for .NET)\n\n**Moderate Security:**\n- **Python & Prolog (SWI)**: Medium compile-time safety with managed memory but limited runtime sandboxing\n\n**Weakest Security:**\n- **Bash & AWK**: Low compile-time safety with no meaningful runtime sandboxing\n\nFor production deployments, Go and Rust are strongly recommended due to their robust security guarantees. Bash should be restricted to development environments only. See education/book-08-security-firewall/04_target_security.md for the complete security comparison matrix and detailed analysis of each target's security model.", "answer_variant": "default", "answer_source": "book-08-security-firewall/04_target_security.md", "topics": [], "original_answer": "Security comparison matrix:\n| Target | Compile Safety | Runtime Sandbox | Memory Safety |\n|--------|---------------|-----------------|---------------|\n| Bash | Low | None | N/A |\n| AWK | Low | Limited | N/A |\n| Python | Medium | Limited | Managed |\n| Go | High | OS-level | Safe |\n| Rust | Very High | OS-level | Guaranteed |\n| C#/.NET | High | CLR sandbox | Managed |\n| Prolog (SWI) | Medium | Limited | Managed |\n\nGo and Rust are recommended for production, Bash for development only.", "answer_tailored": true}
{"pair_id": "target-sec-001_p0", "cluster_id": "target-sec-001", "question": "What are the security risks with Bash target?", "question_type": "medium", "answer": "Bash targets face four critical security risks in UnifyWeaver:\n\n1. **Command injection**: Unvalidated user input can execute arbitrary commands\n2. **Shell expansion**: Wildcards and variable expansion can cause unintended behavior\n3. **Privilege escalation**: Improper use of sudo or setuid binaries\n4. **Path manipulation**: Attackers can inject malicious executables via PATH\n\nTo mitigate these risks, UnifyWeaver's Bash code generator enforces strict quoting, enables `set -euo pipefail` for error handling, uses absolute paths, and avoids `eval`. For example:\n\n```bash\n#!/bin/bash\nset -euo pipefail\ninput=\"${1:-}\"  # Variables always quoted\nresult=$((input * 2))  # Safe arithmetic\n```\n\nFor comprehensive coverage of Bash security patterns, see education/book-08-security-firewall/04_target_security.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/04_target_security.md", "topics": [], "original_answer": "Bash has four main risks: (1) Command injection - user input in commands; (2) Shell expansion - glob and variable expansion; (3) Privilege escalation - sudo/setuid; (4) Path manipulation - PATH injection. Mitigation: Use strict quoting, `set -euo pipefail`, absolute paths, never use eval. UnifyWeaver generates safe Bash with these protections by default:\n\n```bash\n#!/bin/bash\nset -euo pipefail\ninput=\"${1:-}\"  # Variables always quoted\nresult=$((input * 2))  # Safe arithmetic\n```", "answer_tailored": true}
{"pair_id": "target-sec-002_p0", "cluster_id": "target-sec-002", "question": "How do I configure target-specific firewall policies?", "question_type": "medium", "answer": "To configure firewall policies for specific compilation targets, define allow/deny rules that apply to each target's imports, features, or namespaces:\n\n```prolog\n% For Python: control module imports\n:- deny(python_import(subprocess)).\n:- deny(python_import(pickle)).\n:- allow(python_import(json)).\n\n% For Go: restrict package imports conditionally\n:- deny(go_import(\"os/exec\")) :- \\+ shell_allowed.\n:- allow(go_import(\"encoding/json\")).\n\n% For Rust: control unsafe features and crate usage\n:- deny(rust_feature(unsafe)) :- \\+ unsafe_approved.\n:- allow(rust_crate(\"serde\")).\n\n% For C#: block specific .NET namespaces\n:- deny(dotnet_namespace(\"System.Diagnostics.Process\")).\n```\n\nThese target-specific predicates let you enforce different security boundaries depending on which language you're compiling to. For comprehensive coverage of security models, see education/book-08-security-firewall/.", "answer_variant": "default", "answer_source": "book-08-security-firewall/04_target_security.md", "topics": [], "original_answer": "Each target has specific controls:\n\n```prolog\n% Python restrictions\n:- deny(python_import(subprocess)).\n:- deny(python_import(pickle)).\n:- allow(python_import(json)).\n\n% Go restrictions\n:- deny(go_import(\"os/exec\")) :- \\+ shell_allowed.\n:- allow(go_import(\"encoding/json\")).\n\n% Rust restrictions\n:- deny(rust_feature(unsafe)) :- \\+ unsafe_approved.\n:- allow(rust_crate(\"serde\")).\n\n% C#/.NET restrictions\n:- deny(dotnet_namespace(\"System.Diagnostics.Process\")).\n```", "answer_tailored": true}
{"pair_id": "target-sec-002_p0", "cluster_id": "target-sec-002", "question": "Which target is best for production security?", "question_type": "medium", "answer": "For production security, Go and Rust are the top choices. Go provides strong compile-time safety through static typing, memory-safe operations, and compile-time imports that prevent dependency hijacking, with no dangerous eval capabilities. Rust delivers even stricter guarantees including complete memory safety, elimination of null pointer issues, prevention of data races, and a minimal attack surface. Avoid Bash in production (development only), restrict Python to controlled environments with import limitations, while C#/.NET serves well for enterprise scenarios leveraging CLR sandboxing and Code Access Security. For detailed security characteristics of each target, see education/book-08-security-firewall/04_target_security.md.", "answer_variant": "default", "answer_source": "book-08-security-firewall/04_target_security.md", "topics": [], "original_answer": "Go and Rust are best for production: Go offers high compile-time safety, static typing, no eval, memory safety, and compile-time imports preventing hijacking. Rust provides very high safety with guaranteed memory safety, no null pointers, no data races, and minimal attack surface. Use Bash only for development, Python for controlled environments with import restrictions. C#/.NET is good for enterprise with CLR sandbox and Code Access Security.", "answer_tailored": true}
