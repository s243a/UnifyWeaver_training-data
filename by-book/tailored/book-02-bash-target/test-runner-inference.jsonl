{"pair_id": "test-runner-inference_p0", "cluster_id": "test-runner-inference", "question": "How does UnifyWeaver generate tests automatically?", "question_type": "medium", "answer": "UnifyWeaver generates tests automatically through its **test runner inference system**, which analyzes your compiled Bash code to create complete test suites without manual intervention.\n\n### Automatic Test Generation Process\n\nThe system works in four steps:\n\n1. **Scans** the output directory to find all generated `.sh` files\n2. **Extracts** function signatures including name, arity, and pattern type\n3. **Infers** appropriate test cases based on the function structure\n4. **Generates** a complete executable test runner script\n\n### Quick Start\n\n```prolog\n% Load the test inference module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate test suite with one command\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\nThis single command eliminates the need to manually track scripts, remember function arities, or update tests when adding new predicates.\n\n### Customization Options\n\n```prolog\n% Custom output location\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Compact output format\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan different directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n### Generated Output Formats\n\n- **explicit**: One readable test block per file (default)\n- **concise**: Compact loop-based with arrays\n- **hybrid**: Automatically selects format based on complexity\n\n### Example Generated Test\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n--- Testing list_length.sh ---\nTest 1: Empty list\n[]:0\n\n=== All Tests Complete ===\n```\n\nFor implementation details, see `education/book-02-bash-target/08_test_runner_inference.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["testing", "automatic", "inference", "test-generation"], "original_answer": "## Test Runner Inference\n\nUnifyWeaver can automatically generate test scripts by analyzing compiled Bash code.\n\n### The Problem\n\nManual testing is tedious:\n- Must track all generated scripts\n- Need to know function arities\n- Easy to forget functions\n- Adding predicates requires updating tests\n\n### The Solution: Automatic Discovery\n\n```prolog\n% One command generates complete test suite\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\n### How It Works\n\n1. **Scan** output directory for `.sh` files\n2. **Extract** function signatures (name, arity, pattern type)\n3. **Infer** appropriate test cases\n4. **Generate** complete test runner script\n\n### Usage\n\n```prolog\n% Load module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate with defaults\n?- generate_test_runner_inferred.\n\n% Specify output path\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Use concise mode\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan different directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n### Running Generated Tests\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n--- Testing list_length.sh ---\nTest 1: Empty list\n[]:0\n\n=== All Tests Complete ===\n```\n\n### Output Modes\n\n| Mode | Description |\n|------|-------------|\n| explicit | One test block per file (default, readable) |\n| concise | Loop-based with arrays (compact) |\n| hybrid | Smart selection based on complexity |", "answer_tailored": true}
{"pair_id": "test-runner-inference_p1", "cluster_id": "test-runner-inference", "question": "What is test runner inference?", "question_type": "medium", "answer": "Test runner inference is UnifyWeaver's capability to automatically discover and generate test scripts for compiled Bash code. Instead of manually writing tests for each function, UnifyWeaver scans your output directory, analyzes the function signatures in generated `.sh` files, and creates a complete test suite automatically.\n\nThe system works by:\n1. Scanning the output directory for Bash scripts\n2. Extracting function signatures (names, arities, pattern types)\n3. Inferring appropriate test cases based on the signatures\n4. Generating a comprehensive test runner script\n\nYou can invoke it from Prolog:\n\n```prolog\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\nThis eliminates the tedious process of tracking generated scripts, memorizing function arities, and manually updating tests when adding new predicates. The generated test runner can be executed directly:\n\n```bash\n$ bash output/advanced/test_runner.sh\n```\n\nThe system supports multiple output modes (explicit, concise, hybrid) and allows customization through options like specifying the output path or scanning different directories. For more details on Bash target compilation, see education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["testing", "automatic", "inference", "test-generation"], "original_answer": "## Test Runner Inference\n\nUnifyWeaver can automatically generate test scripts by analyzing compiled Bash code.\n\n### The Problem\n\nManual testing is tedious:\n- Must track all generated scripts\n- Need to know function arities\n- Easy to forget functions\n- Adding predicates requires updating tests\n\n### The Solution: Automatic Discovery\n\n```prolog\n% One command generates complete test suite\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\n### How It Works\n\n1. **Scan** output directory for `.sh` files\n2. **Extract** function signatures (name, arity, pattern type)\n3. **Infer** appropriate test cases\n4. **Generate** complete test runner script\n\n### Usage\n\n```prolog\n% Load module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate with defaults\n?- generate_test_runner_inferred.\n\n% Specify output path\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Use concise mode\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan different directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n### Running Generated Tests\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n--- Testing list_length.sh ---\nTest 1: Empty list\n[]:0\n\n=== All Tests Complete ===\n```\n\n### Output Modes\n\n| Mode | Description |\n|------|-------------|\n| explicit | One test block per file (default, readable) |\n| concise | Loop-based with arrays (compact) |\n| hybrid | Smart selection based on complexity |", "answer_tailored": true}
{"pair_id": "test-runner-inference_p2", "cluster_id": "test-runner-inference", "question": "How do I generate a test script for my compiled code?", "question_type": "medium", "answer": "To generate a test script for your compiled code, use UnifyWeaver's test runner inference system, which automatically creates test suites by scanning your compiled output.\n\n**Quick Start**\n\n```prolog\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\nThis single command analyzes all `.sh` files in your output directory, extracts function signatures, and generates a complete test script.\n\n**Basic Usage**\n\n```prolog\n% Load the module first\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate with default settings\n?- generate_test_runner_inferred.\n\n% Custom output location\n?- generate_test_runner_inferred('my_tests.sh').\n```\n\n**Customization Options**\n\n```prolog\n% Use concise format for compact output\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan a specific directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n**Running Your Tests**\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n=== All Tests Complete ===\n```\n\n**Available Modes**\n\n- **explicit**: One test block per file (most readable, default)\n- **concise**: Array-based loops (minimal lines)\n- **hybrid**: Automatically chooses based on complexity\n\nThe system automatically discovers function names, arities, and pattern types, eliminating manual test maintenance. See education/book-02-bash-target/08_test_runner_inference.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["testing", "automatic", "inference", "test-generation"], "original_answer": "## Test Runner Inference\n\nUnifyWeaver can automatically generate test scripts by analyzing compiled Bash code.\n\n### The Problem\n\nManual testing is tedious:\n- Must track all generated scripts\n- Need to know function arities\n- Easy to forget functions\n- Adding predicates requires updating tests\n\n### The Solution: Automatic Discovery\n\n```prolog\n% One command generates complete test suite\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\n### How It Works\n\n1. **Scan** output directory for `.sh` files\n2. **Extract** function signatures (name, arity, pattern type)\n3. **Infer** appropriate test cases\n4. **Generate** complete test runner script\n\n### Usage\n\n```prolog\n% Load module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate with defaults\n?- generate_test_runner_inferred.\n\n% Specify output path\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Use concise mode\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan different directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n### Running Generated Tests\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n--- Testing list_length.sh ---\nTest 1: Empty list\n[]:0\n\n=== All Tests Complete ===\n```\n\n### Output Modes\n\n| Mode | Description |\n|------|-------------|\n| explicit | One test block per file (default, readable) |\n| concise | Loop-based with arrays (compact) |\n| hybrid | Smart selection based on complexity |", "answer_tailored": true}
{"pair_id": "test-runner-inference_p3", "cluster_id": "test-runner-inference", "question": "What is automatic test discovery?", "question_type": "medium", "answer": "## Automatic Test Discovery\n\nAutomatic test discovery is UnifyWeaver's feature that analyzes your compiled Bash code and automatically generates comprehensive test scripts without manual configuration.\n\nInstead of manually tracking all generated scripts, function arities, and test cases, you can use a single command:\n\n```prolog\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\n### Discovery Process\n\nThe system automatically:\n1. **Scans** the output directory for all `.sh` files\n2. **Extracts** function signatures including name, arity, and pattern type\n3. **Infers** appropriate test cases based on the signatures\n4. **Generates** a complete, ready-to-run test script\n\n### Benefits\n\n- No need to manually track generated scripts\n- Eliminates guesswork about function arities\n- Won't miss any functions\n- Adding new predicates automatically updates tests\n\n### Configuration Options\n\n```prolog\n% Default discovery\n?- generate_test_runner_inferred.\n\n% Custom output path\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Concise output format\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan specific directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\nThe generated test runner executes all discovered tests and reports results. For implementation details, see education/book-02-bash-target/08_test_runner_inference.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["testing", "automatic", "inference", "test-generation"], "original_answer": "## Test Runner Inference\n\nUnifyWeaver can automatically generate test scripts by analyzing compiled Bash code.\n\n### The Problem\n\nManual testing is tedious:\n- Must track all generated scripts\n- Need to know function arities\n- Easy to forget functions\n- Adding predicates requires updating tests\n\n### The Solution: Automatic Discovery\n\n```prolog\n% One command generates complete test suite\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\n### How It Works\n\n1. **Scan** output directory for `.sh` files\n2. **Extract** function signatures (name, arity, pattern type)\n3. **Infer** appropriate test cases\n4. **Generate** complete test runner script\n\n### Usage\n\n```prolog\n% Load module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate with defaults\n?- generate_test_runner_inferred.\n\n% Specify output path\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Use concise mode\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan different directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n### Running Generated Tests\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n--- Testing list_length.sh ---\nTest 1: Empty list\n[]:0\n\n=== All Tests Complete ===\n```\n\n### Output Modes\n\n| Mode | Description |\n|------|-------------|\n| explicit | One test block per file (default, readable) |\n| concise | Loop-based with arrays (compact) |\n| hybrid | Smart selection based on complexity |", "answer_tailored": true}
{"pair_id": "test-inference-heuristics_p0", "cluster_id": "test-inference-heuristics", "question": "How does UnifyWeaver decide what tests to generate?", "question_type": "medium", "answer": "UnifyWeaver determines which tests to generate by combining three complementary heuristics:\n\n**Name-Based Inference**\nThe system analyzes function names for keywords:\n- `length`/`list` \u2192 generates tests with `[]`, `[a]`, `[a,b,c]`\n- `factorial`/`fib`/`power` \u2192 generates numeric tests: `0`, `1`, `5`\n- `sum`/`add` \u2192 generates list tests: `[]`, `[1,2,3]`, `[5,10,15]`\n- `tree`/`binary` \u2192 generates structural tests: `[]`, `[5,[],[]]`, nested trees\n- `is_even`/`even` \u2192 generates `0`, `4`, `3` (including failure case)\n- `is_odd`/`odd` \u2192 generates `3`, `5`, `6` (including failure case)\n\n**Pattern-Based Inference**\nThe recursion pattern guides test structure:\n- `tail_recursive` \u2192 accumulator tests initialized to 0\n- `linear_recursive` \u2192 combines with name analysis\n- `mutual_recursive` \u2192 complementary tests (e.g., even/odd pairs)\n- `tree_recursive` \u2192 structural tests (empty, single node, nested)\n\n**Arity-Based Inference**\nThe number of arguments determines test format:\n- Arity 1 \u2192 single argument tests\n- Arity 2 \u2192 input + output (initialized to empty string)\n- Arity 3 \u2192 input + accumulator(0) + output\n\n**Example:** For a function signature like:\n```prolog\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion'),\n    file_path('factorial.sh')\n))\n```\n\nThe system combines:\n- Name `factorial` \u2192 numeric inputs\n- Pattern `linear_recursive` \u2192 sequential evaluation\n- Arity 2 \u2192 input/output pair format\n\nProducing:\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```\n\nSee education/book-02-bash-target/08_test_runner_inference.md for the complete heuristic tables and additional examples.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["heuristics", "test-cases", "inference-rules"], "original_answer": "## Test Inference Heuristics\n\nUnifyWeaver uses multiple heuristics to generate appropriate tests.\n\n### Heuristic 1: Name-Based\n\n| Function Name Contains | Inferred Tests |\n|------------------------|----------------|\n| `length`, `list` | `[]`, `[a]`, `[a,b,c]` |\n| `factorial`, `fib`, `power` | `0`, `1`, `5` |\n| `sum`, `add` | `[]`, `[1,2,3]`, `[5,10,15]` |\n| `tree`, `binary` | `[]`, `[5,[],[]]`, nested tree |\n| `is_even`, `even` | `0`, `4`, `3` (should fail) |\n| `is_odd`, `odd` | `3`, `5`, `6` (should fail) |\n\n### Heuristic 2: Pattern-Based\n\n| Pattern Type | Inferred Tests |\n|--------------|----------------|\n| `tail_recursive` | Accumulator tests with initial 0 |\n| `linear_recursive` | Check name for specific patterns |\n| `mutual_recursive` | Complementary tests (even/odd) |\n| `tree_recursive` | Structural tests (empty, single, nested) |\n\n### Heuristic 3: Arity-Based\n\n| Arity | Typical Pattern | Test Structure |\n|-------|-----------------|----------------|\n| 1 | Unary predicates | Single argument |\n| 2 | Binary relations | Input + output (empty string) |\n| 3 | Accumulators | Input + acc(0) + output |\n\n### Example Inference\n\n```prolog\n% Signature extracted from factorial.sh\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion'),\n    file_path('factorial.sh')\n))\n```\n\n**Inferred tests:**\n- Name contains `factorial` -> numeric tests\n- Pattern is `linear_recursive` -> check name\n- Arity is 2 -> input + output\n\n**Result:**\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```", "answer_tailored": true}
{"pair_id": "test-inference-heuristics_p1", "cluster_id": "test-inference-heuristics", "question": "What heuristics are used for test inference?", "question_type": "medium", "answer": "UnifyWeaver infers tests using three complementary heuristics:\n\n**Name-Based Heuristics**\n\nThe system analyzes function names to determine appropriate test inputs:\n- List operations (`length`, `list`): Empty list, single element, multiple elements\n- Mathematical functions (`factorial`, `fib`, `power`): Edge cases like 0, 1, and typical values like 5\n- Aggregations (`sum`, `add`): Empty and populated numeric lists\n- Tree operations (`tree`, `binary`): Empty, leaf nodes, and nested structures\n- Predicates (`is_even`, `is_odd`): True cases and expected failures\n\n**Pattern-Based Heuristics**\n\nDifferent recursion patterns suggest specific test strategies:\n- `tail_recursive`: Tests with accumulator initialized to 0\n- `linear_recursive`: Pattern-specific tests based on function name\n- `mutual_recursive`: Complementary test pairs (e.g., even/odd numbers)\n- `tree_recursive`: Structural variations (empty, single node, nested)\n\n**Arity-Based Heuristics**\n\nArgument count determines test structure:\n- Arity 1: Single argument tests for unary predicates\n- Arity 2: Input paired with empty output string for binary relations\n- Arity 3: Input + accumulator (typically 0) + output placeholder\n\nFor example, given `factorial/2` with `linear_recursive` pattern, the system combines name-based numeric tests (0, 1, 5) with the arity-2 structure (input + output), generating test calls like `factorial \"0\" \"\"` and `factorial \"5\" \"\"`.\n\nSee education/book-02-bash-target/08_test_runner_inference.md for complete inference rules and examples.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["heuristics", "test-cases", "inference-rules"], "original_answer": "## Test Inference Heuristics\n\nUnifyWeaver uses multiple heuristics to generate appropriate tests.\n\n### Heuristic 1: Name-Based\n\n| Function Name Contains | Inferred Tests |\n|------------------------|----------------|\n| `length`, `list` | `[]`, `[a]`, `[a,b,c]` |\n| `factorial`, `fib`, `power` | `0`, `1`, `5` |\n| `sum`, `add` | `[]`, `[1,2,3]`, `[5,10,15]` |\n| `tree`, `binary` | `[]`, `[5,[],[]]`, nested tree |\n| `is_even`, `even` | `0`, `4`, `3` (should fail) |\n| `is_odd`, `odd` | `3`, `5`, `6` (should fail) |\n\n### Heuristic 2: Pattern-Based\n\n| Pattern Type | Inferred Tests |\n|--------------|----------------|\n| `tail_recursive` | Accumulator tests with initial 0 |\n| `linear_recursive` | Check name for specific patterns |\n| `mutual_recursive` | Complementary tests (even/odd) |\n| `tree_recursive` | Structural tests (empty, single, nested) |\n\n### Heuristic 3: Arity-Based\n\n| Arity | Typical Pattern | Test Structure |\n|-------|-----------------|----------------|\n| 1 | Unary predicates | Single argument |\n| 2 | Binary relations | Input + output (empty string) |\n| 3 | Accumulators | Input + acc(0) + output |\n\n### Example Inference\n\n```prolog\n% Signature extracted from factorial.sh\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion'),\n    file_path('factorial.sh')\n))\n```\n\n**Inferred tests:**\n- Name contains `factorial` -> numeric tests\n- Pattern is `linear_recursive` -> check name\n- Arity is 2 -> input + output\n\n**Result:**\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```", "answer_tailored": true}
{"pair_id": "test-inference-heuristics_p2", "cluster_id": "test-inference-heuristics", "question": "How are test cases inferred from function signatures?", "question_type": "medium", "answer": "UnifyWeaver infers test cases from function signatures using three main heuristics:\n\n**Name-Based Inference**: The function name suggests appropriate test inputs. For example, functions containing \"factorial\", \"fib\", or \"power\" receive numeric tests like `0`, `1`, `5`. Functions with \"length\" or \"list\" get list-based tests such as `[]`, `[a]`, `[a,b,c]`. Boolean predicates like \"is_even\" include both passing cases (`0`, `4`) and expected failures (`3`).\n\n**Pattern-Based Inference**: The recursion pattern determines test structure. Tail-recursive functions get accumulator tests initialized with 0. Tree-recursive predicates receive structural tests covering empty, single-node, and nested cases. Mutually-recursive functions get complementary test pairs (like even/odd).\n\n**Arity-Based Inference**: The number of parameters shapes the test format. Unary predicates (arity 1) take a single argument. Binary relations (arity 2) pair an input with an empty output string. Three-parameter functions typically follow the input + accumulator(0) + output pattern.\n\nThese heuristics combine to generate tests automatically. For instance, given:\n```prolog\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion')\n))\n```\n\nThe inference process recognizes \"factorial\" in the name (numeric tests), linear recursion pattern (check name), and arity 2 (input + output format), producing:\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```\n\nSee education/book-02-bash-target/08_test_runner_inference.md for complete heuristic tables and additional examples.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["heuristics", "test-cases", "inference-rules"], "original_answer": "## Test Inference Heuristics\n\nUnifyWeaver uses multiple heuristics to generate appropriate tests.\n\n### Heuristic 1: Name-Based\n\n| Function Name Contains | Inferred Tests |\n|------------------------|----------------|\n| `length`, `list` | `[]`, `[a]`, `[a,b,c]` |\n| `factorial`, `fib`, `power` | `0`, `1`, `5` |\n| `sum`, `add` | `[]`, `[1,2,3]`, `[5,10,15]` |\n| `tree`, `binary` | `[]`, `[5,[],[]]`, nested tree |\n| `is_even`, `even` | `0`, `4`, `3` (should fail) |\n| `is_odd`, `odd` | `3`, `5`, `6` (should fail) |\n\n### Heuristic 2: Pattern-Based\n\n| Pattern Type | Inferred Tests |\n|--------------|----------------|\n| `tail_recursive` | Accumulator tests with initial 0 |\n| `linear_recursive` | Check name for specific patterns |\n| `mutual_recursive` | Complementary tests (even/odd) |\n| `tree_recursive` | Structural tests (empty, single, nested) |\n\n### Heuristic 3: Arity-Based\n\n| Arity | Typical Pattern | Test Structure |\n|-------|-----------------|----------------|\n| 1 | Unary predicates | Single argument |\n| 2 | Binary relations | Input + output (empty string) |\n| 3 | Accumulators | Input + acc(0) + output |\n\n### Example Inference\n\n```prolog\n% Signature extracted from factorial.sh\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion'),\n    file_path('factorial.sh')\n))\n```\n\n**Inferred tests:**\n- Name contains `factorial` -> numeric tests\n- Pattern is `linear_recursive` -> check name\n- Arity is 2 -> input + output\n\n**Result:**\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```", "answer_tailored": true}
{"pair_id": "test-inference-heuristics_p3", "cluster_id": "test-inference-heuristics", "question": "What test patterns does UnifyWeaver recognize?", "question_type": "medium", "answer": "UnifyWeaver recognizes test patterns through three main heuristics:\n\n**Name-Based Recognition:**\nFunctions containing `length` or `list` get tested with `[]`, `[a]`, `[a,b,c]`. Names with `factorial`, `fib`, or `power` receive numeric tests: `0`, `1`, `5`. Functions with `sum` or `add` get list tests. Tree-related names (`tree`, `binary`) receive structural tests from empty to nested. Boolean predicates like `is_even`/`even` get `0`, `4`, `3` (expect fail), while `is_odd`/`odd` get `3`, `5`, `6` (expect fail).\n\n**Pattern-Based Recognition:**\n- `tail_recursive`: Accumulator tests initialized with 0\n- `linear_recursive`: Name-specific pattern tests\n- `mutual_recursive`: Complementary tests (e.g., even/odd pairs)\n- `tree_recursive`: Structural tests (empty, single node, nested)\n\n**Arity-Based Recognition:**\n- Arity 1: Single argument tests for unary predicates\n- Arity 2: Input + output pair (output starts as empty string)\n- Arity 3: Input + accumulator(0) + output\n\nFor example, `factorial/2` with `linear_recursive` pattern triggers numeric tests (`0`, `1`, `5`) formatted as `factorial \"0\" \"\"`, `factorial \"1\" \"\"`, `factorial \"5\" \"\"`.\n\nSee education/book-02-bash-target/08_test_runner_inference.md for complete heuristic details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["heuristics", "test-cases", "inference-rules"], "original_answer": "## Test Inference Heuristics\n\nUnifyWeaver uses multiple heuristics to generate appropriate tests.\n\n### Heuristic 1: Name-Based\n\n| Function Name Contains | Inferred Tests |\n|------------------------|----------------|\n| `length`, `list` | `[]`, `[a]`, `[a,b,c]` |\n| `factorial`, `fib`, `power` | `0`, `1`, `5` |\n| `sum`, `add` | `[]`, `[1,2,3]`, `[5,10,15]` |\n| `tree`, `binary` | `[]`, `[5,[],[]]`, nested tree |\n| `is_even`, `even` | `0`, `4`, `3` (should fail) |\n| `is_odd`, `odd` | `3`, `5`, `6` (should fail) |\n\n### Heuristic 2: Pattern-Based\n\n| Pattern Type | Inferred Tests |\n|--------------|----------------|\n| `tail_recursive` | Accumulator tests with initial 0 |\n| `linear_recursive` | Check name for specific patterns |\n| `mutual_recursive` | Complementary tests (even/odd) |\n| `tree_recursive` | Structural tests (empty, single, nested) |\n\n### Heuristic 3: Arity-Based\n\n| Arity | Typical Pattern | Test Structure |\n|-------|-----------------|----------------|\n| 1 | Unary predicates | Single argument |\n| 2 | Binary relations | Input + output (empty string) |\n| 3 | Accumulators | Input + acc(0) + output |\n\n### Example Inference\n\n```prolog\n% Signature extracted from factorial.sh\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion'),\n    file_path('factorial.sh')\n))\n```\n\n**Inferred tests:**\n- Name contains `factorial` -> numeric tests\n- Pattern is `linear_recursive` -> check name\n- Arity is 2 -> input + output\n\n**Result:**\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```", "answer_tailored": true}
