{"pair_id": "first-bash-program_p0", "cluster_id": "first-bash-program", "question": "How do I compile my first Prolog program to Bash?", "question_type": "medium", "answer": "To compile your first Prolog program to Bash in UnifyWeaver, follow this workflow:\n\n**1. Launch SWI-Prolog in the project directory:**\n```bash\ncd UnifyWeaver\nswipl\n```\n\n**2. Load the educational environment:**\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n**3. Load the recursive compiler module:**\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n**4. Load your Prolog program:**\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n**5. Compile your facts to Bash:**\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n**6. Compile your recursive rules:**\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n**7. Execute the generated Bash scripts:**\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Query all matches\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Test specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n**Important notes:**\n- Facts and rules are compiled separately\n- Source dependencies in order (`parent.sh` must be loaded before `ancestor.sh`)\n- Generated Bash functions support both streaming output and boolean lookup modes\n\nFor more details, see education/book-02-bash-target/01_your_first_program.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["tutorial", "compilation", "bash", "ancestor", "family-tree"], "original_answer": "## Your First UnifyWeaver Program\n\nHere's the complete step-by-step workflow:\n\n### Step 1: Start SWI-Prolog\n\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### Step 2: Initialize Environment\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n### Step 3: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Step 4: Load Your Program\n\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n### Step 5: Compile Facts First\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 6: Compile Recursive Rule\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 7: Run the Scripts\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Find all descendants of abraham\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n### Key Points\n\n- Facts and rules compile separately\n- Dependencies must be sourced first (`parent.sh` before `ancestor.sh`)\n- Generated functions support both streaming and lookup modes", "answer_tailored": true}
{"pair_id": "first-bash-program_p1", "cluster_id": "first-bash-program", "question": "What is the step-by-step process to use UnifyWeaver?", "question_type": "medium", "answer": "The step-by-step process to use UnifyWeaver follows this workflow:\n\n**1. Launch SWI-Prolog in the project directory:**\n```bash\ncd UnifyWeaver\nswipl\n```\n\n**2. Initialize the educational environment:**\n```prolog\n?- ['education/init'].\n```\n\n**3. Load the recursive compiler module:**\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n**4. Load your Prolog program:**\n```prolog\n?- ['education/family_tree'].\n```\n\n**5. Compile base facts using the stream compiler:**\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n**6. Compile recursive rules:**\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n**7. Execute the generated scripts:**\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Query all descendants\nancestor abraham\n\n# Test specific relationships\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n```\n\n**Important notes:** Facts and rules compile as separate modules. Always source dependencies first (base facts before rules that depend on them). The generated Bash functions work in both streaming mode (all results) and boolean mode (relationship testing).\n\nFor a detailed walkthrough, see education/book-02-bash-target/01_your_first_program.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["tutorial", "compilation", "bash", "ancestor", "family-tree"], "original_answer": "## Your First UnifyWeaver Program\n\nHere's the complete step-by-step workflow:\n\n### Step 1: Start SWI-Prolog\n\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### Step 2: Initialize Environment\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n### Step 3: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Step 4: Load Your Program\n\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n### Step 5: Compile Facts First\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 6: Compile Recursive Rule\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 7: Run the Scripts\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Find all descendants of abraham\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n### Key Points\n\n- Facts and rules compile separately\n- Dependencies must be sourced first (`parent.sh` before `ancestor.sh`)\n- Generated functions support both streaming and lookup modes", "answer_tailored": true}
{"pair_id": "first-bash-program_p2", "cluster_id": "first-bash-program", "question": "How do I compile ancestor/2 to Bash?", "question_type": "medium", "answer": "To compile `ancestor/2` to Bash, follow these steps in SWI-Prolog:\n\n### Prerequisites\n\nFirst, ensure you have the facts that `ancestor/2` depends on. The `ancestor/2` rule typically relies on a `parent/2` fact base, which must be compiled first:\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], ParentCode),\n   open('education/output/parent.sh', write, S),\n   write(S, ParentCode), close(S).\n```\n\n### Compiling ancestor/2\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Using the Compiled Code\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Query all ancestors/descendants\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n```\n\n### Important Notes\n\n- Compile dependencies (`parent/2`) before compiling recursive rules that use them\n- Source the dependency scripts in order when executing\n- The generated Bash functions support both streaming output (no args) and boolean checks (with args)\n\nFor a complete walkthrough of this process, see education/book-02-bash-target/01_your_first_program.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["tutorial", "compilation", "bash", "ancestor", "family-tree"], "original_answer": "## Your First UnifyWeaver Program\n\nHere's the complete step-by-step workflow:\n\n### Step 1: Start SWI-Prolog\n\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### Step 2: Initialize Environment\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n### Step 3: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Step 4: Load Your Program\n\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n### Step 5: Compile Facts First\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 6: Compile Recursive Rule\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 7: Run the Scripts\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Find all descendants of abraham\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n### Key Points\n\n- Facts and rules compile separately\n- Dependencies must be sourced first (`parent.sh` before `ancestor.sh`)\n- Generated functions support both streaming and lookup modes", "answer_tailored": true}
{"pair_id": "first-bash-program_p3", "cluster_id": "first-bash-program", "question": "How do I run generated Bash scripts?", "question_type": "medium", "answer": "To run generated Bash scripts from UnifyWeaver, follow these steps:\n\n### Execution Process\n\nAfter compiling your Prolog code to Bash (using `compile_facts` or `compile_recursive`), you need to source the generated scripts:\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n```\n\n**Important**: Source dependencies first. If `ancestor.sh` relies on `parent.sh`, load `parent.sh` before `ancestor.sh`.\n\n### Usage Modes\n\nGenerated Bash functions support two modes:\n\n**1. Streaming mode** - Find all matches:\n```bash\nancestor abraham\n# Outputs: abraham:isaac, abraham:jacob, ...\n```\n\n**2. Lookup mode** - Check specific relationship:\n```bash\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Outputs: Yes\n```\n\n### Complete Example\n\nStarting from compiled output:\n\n```bash\n# Source the generated scripts\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Query for all descendants\nancestor abraham\n\n# Test a specific relationship\nancestor isaac judah && echo \"Match found\" || echo \"No match\"\n```\n\nFor the full compilation workflow from Prolog source to executable Bash, see education/book-02-bash-target/01_your_first_program.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["tutorial", "compilation", "bash", "ancestor", "family-tree"], "original_answer": "## Your First UnifyWeaver Program\n\nHere's the complete step-by-step workflow:\n\n### Step 1: Start SWI-Prolog\n\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### Step 2: Initialize Environment\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n### Step 3: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Step 4: Load Your Program\n\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n### Step 5: Compile Facts First\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 6: Compile Recursive Rule\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 7: Run the Scripts\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Find all descendants of abraham\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n### Key Points\n\n- Facts and rules compile separately\n- Dependencies must be sourced first (`parent.sh` before `ancestor.sh`)\n- Generated functions support both streaming and lookup modes", "answer_tailored": true}
{"pair_id": "compile-workflow_p0", "cluster_id": "compile-workflow", "question": "What's the difference between compile_recursive and compile_stream?", "question_type": "medium", "answer": "## Key Differences Between compile_recursive and compile_stream\n\n**compile_stream/3** is designed for **non-recursive predicates** like joins and filters. It generates pipeline-style code that processes data in a single pass without loops or iteration tracking.\n\n**compile_recursive/3** is designed for **recursive predicates** like transitive closures. It generates iterative code with visited tracking and breadth-first search to handle recursive relationships.\n\n### When to Use Each\n\nUse **compile_stream** for:\n- Simple rules that reference other predicates but don't call themselves\n- Joins, filters, and data transformations\n- Example: `grandparent(GP, GC) :- parent(GP, P), parent(P, GC).`\n\nUse **compile_recursive** for:\n- Rules that call themselves directly or indirectly\n- Transitive closures and accumulator patterns\n- Example: `ancestor(A, D) :- parent(A, D). ancestor(A, D) :- parent(A, P), ancestor(P, D).`\n\n### Auto-Detection Alternative\n\nInstead of choosing manually, use **compile_predicate/3** which analyzes your predicate structure and automatically selects the appropriate compiler:\n\n```prolog\n?- compile_predicate(grandparent/2, [], Code).  % \u2192 stream compiler\n?- compile_predicate(ancestor/2, [], Code).     % \u2192 recursive compiler\n```\n\nFor more details on compilation strategies, see education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["compile_recursive", "compile_stream", "compile_predicate", "workflow"], "original_answer": "## UnifyWeaver Compilation Predicates\n\n### Three Main Entry Points\n\n| Predicate | Purpose | When to Use |\n|-----------|---------|-------------|\n| `compile_predicate/3` | Auto-selects compiler | Recommended default |\n| `compile_recursive/3` | Recursive predicates | Transitive closures, accumulators |\n| `compile_stream/3` | Non-recursive predicates | Simple joins, filters |\n\n### How Auto-Selection Works\n\n```prolog\n% compile_predicate analyzes your predicate and routes accordingly\n?- compile_predicate(grandparent/2, [], Code).  % Uses stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Uses recursive_compiler\n```\n\n### Manual Selection\n\n```prolog\n% For non-recursive rules (joins, filters)\n?- compile_stream(grandparent/2, [], BashCode).\n\n% For recursive rules (transitive closures)\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% For facts only\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Example: grandparent/2 (Non-Recursive)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nCompiles to a stream join pipeline.\n\n### Example: ancestor/2 (Recursive)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nCompiles to BFS with visited tracking.", "answer_tailored": true}
{"pair_id": "compile-workflow_p1", "cluster_id": "compile-workflow", "question": "When should I use compile_predicate vs compile_recursive?", "question_type": "medium", "answer": "## Choosing Between compile_predicate and compile_recursive\n\n**Quick Answer**: Use `compile_predicate/3` as your default\u2014it automatically detects recursion and selects the right compiler. Only use `compile_recursive/3` when you need to explicitly force recursive compilation.\n\n### When to Use compile_predicate/3\n\nThis is the recommended entry point for most use cases. It analyzes your predicate's structure and automatically routes to either the stream compiler or recursive compiler:\n\n```prolog\n?- compile_predicate(grandparent/2, [], Code).  % Auto-detects: non-recursive\n?- compile_predicate(ancestor/2, [], Code).     % Auto-detects: recursive\n```\n\n### When to Use compile_recursive/3\n\nUse this when you know your predicate is recursive and want to bypass auto-detection:\n\n- Transitive closures (e.g., ancestor, reachability)\n- Predicates with accumulators\n- Any predicate where a rule references itself\n\n```prolog\n% Explicit recursive compilation\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n### Example: Non-Recursive (Stream Compilation)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nBoth `compile_predicate/3` and `compile_stream/3` generate a join pipeline.\n\n### Example: Recursive (BFS Compilation)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nBoth `compile_predicate/3` and `compile_recursive/3` generate BFS with cycle detection.\n\n**Best Practice**: Start with `compile_predicate/3` and only switch to explicit `compile_recursive/3` or `compile_stream/3` if you have specific compilation requirements.\n\nFor more details on compilation strategies, see `education/book-02-bash-target/01_your_first_program.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["compile_recursive", "compile_stream", "compile_predicate", "workflow"], "original_answer": "## UnifyWeaver Compilation Predicates\n\n### Three Main Entry Points\n\n| Predicate | Purpose | When to Use |\n|-----------|---------|-------------|\n| `compile_predicate/3` | Auto-selects compiler | Recommended default |\n| `compile_recursive/3` | Recursive predicates | Transitive closures, accumulators |\n| `compile_stream/3` | Non-recursive predicates | Simple joins, filters |\n\n### How Auto-Selection Works\n\n```prolog\n% compile_predicate analyzes your predicate and routes accordingly\n?- compile_predicate(grandparent/2, [], Code).  % Uses stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Uses recursive_compiler\n```\n\n### Manual Selection\n\n```prolog\n% For non-recursive rules (joins, filters)\n?- compile_stream(grandparent/2, [], BashCode).\n\n% For recursive rules (transitive closures)\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% For facts only\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Example: grandparent/2 (Non-Recursive)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nCompiles to a stream join pipeline.\n\n### Example: ancestor/2 (Recursive)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nCompiles to BFS with visited tracking.", "answer_tailored": true}
{"pair_id": "compile-workflow_p2", "cluster_id": "compile-workflow", "question": "How does UnifyWeaver decide which compiler to use?", "question_type": "medium", "answer": "## Compiler Selection in UnifyWeaver\n\nUnifyWeaver determines which compiler to use by analyzing your predicate's structure:\n\n### Automatic Selection with compile_predicate/3\n\nThe `compile_predicate/3` entry point (recommended) automatically chooses the appropriate compiler:\n\n```prolog\n?- compile_predicate(grandparent/2, [], Code).  % Routes to stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Routes to recursive_compiler\n```\n\nIt inspects whether your predicate contains recursive calls:\n- **Non-recursive predicates** \u2192 `stream_compiler` (for joins, filters, projections)\n- **Recursive predicates** \u2192 `recursive_compiler` (for transitive closures, accumulator patterns)\n\n### Manual Compiler Selection\n\nYou can explicitly choose a compiler when needed:\n\n```prolog\n% Direct use of stream compiler\n?- compile_stream(grandparent/2, [], BashCode).\n\n% Direct use of recursive compiler\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% Facts-only compilation\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Decision Criteria\n\n**Stream compiler** handles predicates like:\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Recursive compiler** handles predicates like:\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nThe recursive compiler generates BFS traversal with cycle detection, while the stream compiler generates pipeline joins.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["compile_recursive", "compile_stream", "compile_predicate", "workflow"], "original_answer": "## UnifyWeaver Compilation Predicates\n\n### Three Main Entry Points\n\n| Predicate | Purpose | When to Use |\n|-----------|---------|-------------|\n| `compile_predicate/3` | Auto-selects compiler | Recommended default |\n| `compile_recursive/3` | Recursive predicates | Transitive closures, accumulators |\n| `compile_stream/3` | Non-recursive predicates | Simple joins, filters |\n\n### How Auto-Selection Works\n\n```prolog\n% compile_predicate analyzes your predicate and routes accordingly\n?- compile_predicate(grandparent/2, [], Code).  % Uses stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Uses recursive_compiler\n```\n\n### Manual Selection\n\n```prolog\n% For non-recursive rules (joins, filters)\n?- compile_stream(grandparent/2, [], BashCode).\n\n% For recursive rules (transitive closures)\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% For facts only\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Example: grandparent/2 (Non-Recursive)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nCompiles to a stream join pipeline.\n\n### Example: ancestor/2 (Recursive)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nCompiles to BFS with visited tracking.", "answer_tailored": true}
{"pair_id": "compile-workflow_p3", "cluster_id": "compile-workflow", "question": "What are the main compilation predicates?", "question_type": "medium", "answer": "UnifyWeaver provides three main compilation predicates for converting Prolog to target languages:\n\n**Primary Predicates:**\n\n1. **`compile_predicate/3`** - The recommended entry point that automatically analyzes your predicate and selects the appropriate compiler (recursive or stream-based)\n\n2. **`compile_recursive/3`** - Explicitly compiles recursive predicates using BFS with visited tracking, ideal for transitive closures and accumulator-based logic\n\n3. **`compile_stream/3`** - Explicitly compiles non-recursive predicates as streaming pipelines, optimal for joins and filters\n\n**Auto-Selection Example:**\n```prolog\n?- compile_predicate(grandparent/2, [], Code).  % Routes to stream compiler\n?- compile_predicate(ancestor/2, [], Code).     % Routes to recursive compiler\n```\n\n**When to Choose Manually:**\n- Use `compile_stream/3` for simple relational joins (e.g., grandparent as parent-parent join)\n- Use `compile_recursive/3` for transitive relationships (e.g., ancestor with recursive descent)\n- Use `stream_compiler:compile_facts/4` for fact-only predicates\n\nThe compiler automatically detects recursion patterns, but manual selection gives you explicit control over the compilation strategy. See education/book-02-bash-target/ for detailed examples of each approach.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["compile_recursive", "compile_stream", "compile_predicate", "workflow"], "original_answer": "## UnifyWeaver Compilation Predicates\n\n### Three Main Entry Points\n\n| Predicate | Purpose | When to Use |\n|-----------|---------|-------------|\n| `compile_predicate/3` | Auto-selects compiler | Recommended default |\n| `compile_recursive/3` | Recursive predicates | Transitive closures, accumulators |\n| `compile_stream/3` | Non-recursive predicates | Simple joins, filters |\n\n### How Auto-Selection Works\n\n```prolog\n% compile_predicate analyzes your predicate and routes accordingly\n?- compile_predicate(grandparent/2, [], Code).  % Uses stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Uses recursive_compiler\n```\n\n### Manual Selection\n\n```prolog\n% For non-recursive rules (joins, filters)\n?- compile_stream(grandparent/2, [], BashCode).\n\n% For recursive rules (transitive closures)\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% For facts only\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Example: grandparent/2 (Non-Recursive)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nCompiles to a stream join pipeline.\n\n### Example: ancestor/2 (Recursive)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nCompiles to BFS with visited tracking.", "answer_tailored": true}
