{"pair_id": "accumulator-pattern_p0", "cluster_id": "accumulator-pattern", "question": "What is an accumulator in recursion?", "question_type": "medium", "answer": "An accumulator is an extra parameter used in recursive functions to carry intermediate results as you move through recursive calls, rather than building the result on the return path.\n\n## How It Works\n\nIn traditional recursion, work happens *after* each recursive call returns, building the result backward. With an accumulator, you do the work *before* making the recursive call, passing the updated result forward.\n\n### Example: Factorial Without Accumulator\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.        % Computation happens AFTER recursion\n```\n\nThis creates a call stack where each level waits for the next to return:\n```\nfactorial(4, F) -> waiting...\n  factorial(3, F) -> waiting...\n    factorial(2, F) -> waiting...\n      factorial(1, F) -> waiting...\n        factorial(0, 1) -> returns 1\n      F = 1 * 1 = 1\n    F = 2 * 1 = 2\n  F = 3 * 2 = 6\nF = 4 * 6 = 24\n```\n\n### Example: Factorial With Accumulator\n\n```prolog\nfactorial_acc(0, Acc, Acc).     % When done, return the accumulator\nfactorial_acc(N, Acc, F) :-\n    N > 0,\n    Acc1 is Acc * N,            % Update accumulator BEFORE recursing\n    N1 is N - 1,\n    factorial_acc(N1, Acc1, F). % No work after this call\n```\n\nExecution of `factorial_acc(4, 1, F)`:\n```\nfactorial_acc(4, 1, F)   -> Acc = 1*4 = 4\nfactorial_acc(3, 4, F)   -> Acc = 4*3 = 12\nfactorial_acc(2, 12, F)  -> Acc = 12*2 = 24\nfactorial_acc(1, 24, F)  -> Acc = 24*1 = 24\nfactorial_acc(0, 24, 24) -> Returns 24\n```\n\n## Benefits\n\n| Feature | Without Accumulator | With Accumulator |\n|---------|---------------------|------------------|\n| Stack depth | O(n) | O(1) with tail-call optimization |\n| Stack overflow risk | Yes for large inputs | No |\n| Loop conversion | Not possible | Yes |\n\nUnifyWeaver recognizes accumulator-based recursion and compiles it to efficient iterative loops in target languages like Bash, avoiding recursive function calls entirely. For more on optimization techniques, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["accumulator", "tail-recursion", "intermediate-result", "optimization"], "original_answer": "## The Accumulator Pattern\n\nAn accumulator is an extra parameter that carries intermediate results through recursive calls.\n\n### Without Accumulator (Stack-based)\n\n```prolog\n% Result builds on return path\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.        % Work AFTER recursive call\n```\n\nCall stack for `factorial(4, F)`:\n```\nfactorial(4, F) -> waiting for factorial(3)\n  factorial(3, F) -> waiting for factorial(2)\n    factorial(2, F) -> waiting for factorial(1)\n      factorial(1, F) -> waiting for factorial(0)\n        factorial(0, 1) -> returns 1\n      F = 1 * 1 = 1\n    F = 2 * 1 = 2\n  F = 3 * 2 = 6\nF = 4 * 6 = 24\n```\n\n### With Accumulator (Tail-recursive)\n\n```prolog\n% Result builds on forward path\nfactorial_acc(0, Acc, Acc).     % Base: return accumulator\nfactorial_acc(N, Acc, F) :-\n    N > 0,\n    Acc1 is Acc * N,\n    N1 is N - 1,\n    factorial_acc(N1, Acc1, F). % Tail call - no work after\n```\n\nExecution for `factorial_acc(4, 1, F)`:\n```\nfactorial_acc(4, 1, F)   -> Acc = 1*4 = 4\nfactorial_acc(3, 4, F)   -> Acc = 4*3 = 12\nfactorial_acc(2, 12, F)  -> Acc = 12*2 = 24\nfactorial_acc(1, 24, F)  -> Acc = 24*1 = 24\nfactorial_acc(0, 24, 24) -> F = 24\n```\n\n### Why Accumulators Are Efficient\n\n| Aspect | Without Acc | With Acc |\n|--------|-------------|----------|\n| Stack depth | O(n) | O(1)* |\n| Can overflow | Yes | No |\n| Compilable to loop | No | Yes |\n\n*With tail-call optimization\n\n### UnifyWeaver's Optimization\n\nUnifyWeaver detects accumulator patterns and generates iterative loops:\n\n```bash\n# Instead of recursive calls:\nwhile [[ \"$current_list\" != \"[]\" ]]; do\n    acc=$((acc + 1))\n    # advance to next element\ndone\n```", "answer_tailored": true}
{"pair_id": "accumulator-pattern_p1", "cluster_id": "accumulator-pattern", "question": "How does an accumulator enable tail recursion?", "question_type": "medium", "answer": "An accumulator enables tail recursion by carrying the intermediate computation forward through each recursive call, eliminating the need to perform work after the recursion returns.\n\n### How It Works\n\nIn standard recursion, calculations happen on the return path\u2014each call must wait for its recursive subcall to complete before performing its own computation:\n\n```prolog\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.        % Computation AFTER recursion\n```\n\nThis builds a call stack because each frame must remain active to complete its pending multiplication.\n\nWith an accumulator, all computation happens before the recursive call:\n\n```prolog\nfactorial_acc(0, Acc, Acc).     % Base case returns the accumulator\nfactorial_acc(N, Acc, F) :-\n    N > 0,\n    Acc1 is Acc * N,            % Computation BEFORE recursion\n    N1 is N - 1,\n    factorial_acc(N1, Acc1, F). % Nothing left to do\u2014tail position\n```\n\n### Stack Comparison\n\nStandard recursion for `factorial(4, F)`:\n```\nfactorial(4) waits for factorial(3)\n  factorial(3) waits for factorial(2)\n    factorial(2) waits for factorial(1)\n      factorial(1) waits for factorial(0)\n        returns 1\n      computes 1*1=1\n    computes 2*1=2\n  computes 3*2=6\ncomputes 4*6=24\n```\n\nAccumulator version for `factorial_acc(4, 1, F)`:\n```\nfactorial_acc(4, 1, F)   -> compute 1*4=4,  call factorial_acc(3, 4, F)\nfactorial_acc(3, 4, F)   -> compute 4*3=12, call factorial_acc(2, 12, F)\nfactorial_acc(2, 12, F)  -> compute 12*2=24, call factorial_acc(1, 24, F)\nfactorial_acc(1, 24, F)  -> compute 24*1=24, call factorial_acc(0, 24, F)\nfactorial_acc(0, 24, 24) -> return 24\n```\n\nNo stack frames need to be preserved\u2014each call can reuse the same stack space.\n\n### Key Benefits\n\n- **Constant stack depth**: O(1) instead of O(n)\n- **Loop conversion**: Tail calls can be compiled to iterative loops\n- **No overflow risk**: Stack won't grow with input size\n\nUnifyWeaver recognizes this pattern and generates efficient while-loops in target languages like Bash instead of simulating recursive calls. For more details on recursive compilation strategies, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["accumulator", "tail-recursion", "intermediate-result", "optimization"], "original_answer": "## The Accumulator Pattern\n\nAn accumulator is an extra parameter that carries intermediate results through recursive calls.\n\n### Without Accumulator (Stack-based)\n\n```prolog\n% Result builds on return path\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.        % Work AFTER recursive call\n```\n\nCall stack for `factorial(4, F)`:\n```\nfactorial(4, F) -> waiting for factorial(3)\n  factorial(3, F) -> waiting for factorial(2)\n    factorial(2, F) -> waiting for factorial(1)\n      factorial(1, F) -> waiting for factorial(0)\n        factorial(0, 1) -> returns 1\n      F = 1 * 1 = 1\n    F = 2 * 1 = 2\n  F = 3 * 2 = 6\nF = 4 * 6 = 24\n```\n\n### With Accumulator (Tail-recursive)\n\n```prolog\n% Result builds on forward path\nfactorial_acc(0, Acc, Acc).     % Base: return accumulator\nfactorial_acc(N, Acc, F) :-\n    N > 0,\n    Acc1 is Acc * N,\n    N1 is N - 1,\n    factorial_acc(N1, Acc1, F). % Tail call - no work after\n```\n\nExecution for `factorial_acc(4, 1, F)`:\n```\nfactorial_acc(4, 1, F)   -> Acc = 1*4 = 4\nfactorial_acc(3, 4, F)   -> Acc = 4*3 = 12\nfactorial_acc(2, 12, F)  -> Acc = 12*2 = 24\nfactorial_acc(1, 24, F)  -> Acc = 24*1 = 24\nfactorial_acc(0, 24, 24) -> F = 24\n```\n\n### Why Accumulators Are Efficient\n\n| Aspect | Without Acc | With Acc |\n|--------|-------------|----------|\n| Stack depth | O(n) | O(1)* |\n| Can overflow | Yes | No |\n| Compilable to loop | No | Yes |\n\n*With tail-call optimization\n\n### UnifyWeaver's Optimization\n\nUnifyWeaver detects accumulator patterns and generates iterative loops:\n\n```bash\n# Instead of recursive calls:\nwhile [[ \"$current_list\" != \"[]\" ]]; do\n    acc=$((acc + 1))\n    # advance to next element\ndone\n```", "answer_tailored": true}
{"pair_id": "accumulator-pattern_p2", "cluster_id": "accumulator-pattern", "question": "What's the difference between accumulator and non-accumulator recursion?", "question_type": "medium", "answer": "The key difference is **when the work happens** and **how results build up**:\n\n**Non-accumulator recursion** does work **after** each recursive call returns. The result builds on the way back up the call stack:\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.        % Computation happens AFTER the call\n```\n\nThis creates a deep call stack that must be unwound:\n```\nfactorial(4) waits for factorial(3)\n  factorial(3) waits for factorial(2)\n    factorial(2) waits for factorial(1)\n      factorial(1) waits for factorial(0)\n        factorial(0) returns 1\n      1 * 1 = 1 (return)\n    2 * 1 = 2 (return)\n  3 * 2 = 6 (return)\n4 * 6 = 24 (final result)\n```\n\n**Accumulator recursion** does work **before** each recursive call. An extra parameter carries the running result forward:\n\n```prolog\nfactorial_acc(0, Acc, Acc).     % Base case returns the accumulator\nfactorial_acc(N, Acc, F) :-\n    N > 0,\n    Acc1 is Acc * N,            % Computation happens BEFORE the call\n    N1 is N - 1,\n    factorial_acc(N1, Acc1, F). % Tail call - nothing after this\n```\n\nExecution flows forward without building up stack frames:\n```\nfactorial_acc(4, 1, F)   -> compute 1*4=4, continue\nfactorial_acc(3, 4, F)   -> compute 4*3=12, continue\nfactorial_acc(2, 12, F)  -> compute 12*2=24, continue\nfactorial_acc(1, 24, F)  -> compute 24*1=24, continue\nfactorial_acc(0, 24, 24) -> done, F=24\n```\n\n**Performance implications:**\n\n- Non-accumulator: O(n) stack space, can overflow, compiles to actual recursion\n- Accumulator: O(1) stack space with tail-call optimization, can't overflow, UnifyWeaver compiles to iterative loops\n\nFor more on optimization strategies, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["accumulator", "tail-recursion", "intermediate-result", "optimization"], "original_answer": "## The Accumulator Pattern\n\nAn accumulator is an extra parameter that carries intermediate results through recursive calls.\n\n### Without Accumulator (Stack-based)\n\n```prolog\n% Result builds on return path\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.        % Work AFTER recursive call\n```\n\nCall stack for `factorial(4, F)`:\n```\nfactorial(4, F) -> waiting for factorial(3)\n  factorial(3, F) -> waiting for factorial(2)\n    factorial(2, F) -> waiting for factorial(1)\n      factorial(1, F) -> waiting for factorial(0)\n        factorial(0, 1) -> returns 1\n      F = 1 * 1 = 1\n    F = 2 * 1 = 2\n  F = 3 * 2 = 6\nF = 4 * 6 = 24\n```\n\n### With Accumulator (Tail-recursive)\n\n```prolog\n% Result builds on forward path\nfactorial_acc(0, Acc, Acc).     % Base: return accumulator\nfactorial_acc(N, Acc, F) :-\n    N > 0,\n    Acc1 is Acc * N,\n    N1 is N - 1,\n    factorial_acc(N1, Acc1, F). % Tail call - no work after\n```\n\nExecution for `factorial_acc(4, 1, F)`:\n```\nfactorial_acc(4, 1, F)   -> Acc = 1*4 = 4\nfactorial_acc(3, 4, F)   -> Acc = 4*3 = 12\nfactorial_acc(2, 12, F)  -> Acc = 12*2 = 24\nfactorial_acc(1, 24, F)  -> Acc = 24*1 = 24\nfactorial_acc(0, 24, 24) -> F = 24\n```\n\n### Why Accumulators Are Efficient\n\n| Aspect | Without Acc | With Acc |\n|--------|-------------|----------|\n| Stack depth | O(n) | O(1)* |\n| Can overflow | Yes | No |\n| Compilable to loop | No | Yes |\n\n*With tail-call optimization\n\n### UnifyWeaver's Optimization\n\nUnifyWeaver detects accumulator patterns and generates iterative loops:\n\n```bash\n# Instead of recursive calls:\nwhile [[ \"$current_list\" != \"[]\" ]]; do\n    acc=$((acc + 1))\n    # advance to next element\ndone\n```", "answer_tailored": true}
{"pair_id": "accumulator-pattern_p3", "cluster_id": "accumulator-pattern", "question": "Why are accumulators more efficient?", "question_type": "medium", "answer": "## The Accumulator Pattern\n\nAn accumulator is an extra parameter that carries intermediate results through recursive calls.\n\n### Without Accumulator (Stack-based)\n\n```prolog\n% Result builds on return path\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.        % Work AFTER recursive call\n```\n\nCall stack for `factorial(4, F)`:\n```\nfactorial(4, F) -> waiting for factorial(3)\n  factorial(3, F) -> waiting for factorial(2)\n    factorial(2, F) -> waiting for factorial(1)\n      factorial(1, F) -> waiting for factorial(0)\n        factorial(0, 1) -> returns 1\n      F = 1 * 1 = 1\n    F = 2 * 1 = 2\n  F = 3 * 2 = 6\nF = 4 * 6 = 24\n```\n\n### With Accumulator (Tail-recursive)\n\n```prolog\n% Result builds on forward path\nfactorial_acc(0, Acc, Acc).     % Base: return accumulator\nfactorial_acc(N, Acc, F) :-\n    N > 0,\n    Acc1 is Acc * N,\n    N1 is N - 1,\n    factorial_acc(N1, Acc1, F). % Tail call - no work after\n```\n\nExecution for `factorial_acc(4, 1, F)`:\n```\nfactorial_acc(4, 1, F)   -> Acc = 1*4 = 4\nfactorial_acc(3, 4, F)   -> Acc = 4*3 = 12\nfactorial_acc(2, 12, F)  -> Acc = 12*2 = 24\nfactorial_acc(1, 24, F)  -> Acc = 24*1 = 24\nfactorial_acc(0, 24, 24) -> F = 24\n```\n\n### Why Accumulators Are Efficient\n\n| Aspect | Without Acc | With Acc |\n|--------|-------------|----------|\n| Stack depth | O(n) | O(1)* |\n| Can overflow | Yes | No |\n| Compilable to loop | No | Yes |\n\n*With tail-call optimization\n\n### UnifyWeaver's Optimization\n\nUnifyWeaver detects accumulator patterns and generates iterative loops:\n\n```bash\n# Instead of recursive calls:\nwhile [[ \"$current_list\" != \"[]\" ]]; do\n    acc=$((acc + 1))\n    # advance to next element\ndone\n```", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["accumulator", "tail-recursion", "intermediate-result", "optimization"], "answer_tailored": false}
{"pair_id": "fold-pattern_p0", "cluster_id": "fold-pattern", "question": "What is a fold and why use it for compilation?", "question_type": "medium", "answer": "## The Fold Pattern\n\nA fold (also called reduce) accumulates a result by iterating over a sequence.\n\n### Basic Concept\n\n```\nfold(operation, initial, [a, b, c])\n\nSteps:\n  acc = initial\n  acc = operation(a, acc)\n  acc = operation(b, acc)\n  acc = operation(c, acc)\n  return acc\n```\n\n### Example: Sum with Fold\n\n```bash\n# sum([1, 2, 3]) using fold\nfold_left 0 add 1 2 3\n\n# Steps:\n# acc = 0\n# acc = add(1, 0) = 1\n# acc = add(2, 1) = 3\n# acc = add(3, 3) = 6\n# Result: 6\n```\n\n### Left vs Right Fold\n\n```\nfold_left:  ((initial op a) op b) op c\nfold_right: a op (b op (c op initial))\n```\n\nFor associative operations (like +, *), both give same result.\n\n### Why Use Fold for Compilation?\n\n**1. Separation of Concerns**\n- Structure building: generate the sequence\n- Computation: apply the operation\n\n**2. Reusability**\n```bash\n# Same fold_left for many predicates\nfactorial: fold_left 1 multiply [n..1]\nsum_list:  fold_left 0 add [elements]\nlength:    fold_left 0 increment [elements]\n```\n\n### UnifyWeaver's Fold Implementation\n\n```bash\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Usage for factorial\nbuild_range_down() {\n    seq \"$1\" -1 1\n}\n\nfactorial_op() {\n    echo $(($1 * $2))\n}\n\nfactorial() {\n    local range=$(build_range_down \"$1\")\n    fold_left 1 factorial_op $range\n}\n```\n\n### Benefits\n\n- Clear, readable generated code\n- Easy to debug (inspect sequence, operation)\n- Natural fit for linear recursion patterns", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["fold", "reduce", "functional-programming", "compilation-strategy"], "answer_tailored": false}
{"pair_id": "fold-pattern_p1", "cluster_id": "fold-pattern", "question": "What's the difference between fold_left and fold_right?", "question_type": "medium", "answer": "The key difference is in the order of operations:\n\n**fold_left** processes left-to-right, associating operations from the left:\n```\nfold_left(initial, op, [a, b, c])\n\u2192 ((initial op a) op b) op c\n```\n\n**fold_right** processes right-to-left, associating operations from the right:\n```\nfold_right(op, [a, b, c], initial)\n\u2192 a op (b op (c op initial))\n```\n\n**Example: Subtraction (non-associative)**\n```bash\n# fold_left with subtract on [1, 2, 3], initial 10\n# ((10 - 1) - 2) - 3 = 4\n\n# fold_right with subtract on [1, 2, 3], initial 10\n# 1 - (2 - (3 - 10)) = 1 - (2 - (-7)) = 1 - 9 = -8\n```\n\nFor **associative operations** (addition, multiplication), both produce identical results:\n```bash\n# sum([1, 2, 3]) with either fold\nfold_left:  ((0 + 1) + 2) + 3 = 6\nfold_right: 1 + (2 + (3 + 0)) = 6\n```\n\n**In UnifyWeaver's Bash target**, fold_left is typically used because it:\n- Matches the natural iteration order in loops\n- Works well with tail-recursive patterns\n- Is more efficient for sequential processing\n\n```bash\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n```\n\nFor more on how folds compile recursive predicates, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["fold", "reduce", "functional-programming", "compilation-strategy"], "original_answer": "## The Fold Pattern\n\nA fold (also called reduce) accumulates a result by iterating over a sequence.\n\n### Basic Concept\n\n```\nfold(operation, initial, [a, b, c])\n\nSteps:\n  acc = initial\n  acc = operation(a, acc)\n  acc = operation(b, acc)\n  acc = operation(c, acc)\n  return acc\n```\n\n### Example: Sum with Fold\n\n```bash\n# sum([1, 2, 3]) using fold\nfold_left 0 add 1 2 3\n\n# Steps:\n# acc = 0\n# acc = add(1, 0) = 1\n# acc = add(2, 1) = 3\n# acc = add(3, 3) = 6\n# Result: 6\n```\n\n### Left vs Right Fold\n\n```\nfold_left:  ((initial op a) op b) op c\nfold_right: a op (b op (c op initial))\n```\n\nFor associative operations (like +, *), both give same result.\n\n### Why Use Fold for Compilation?\n\n**1. Separation of Concerns**\n- Structure building: generate the sequence\n- Computation: apply the operation\n\n**2. Reusability**\n```bash\n# Same fold_left for many predicates\nfactorial: fold_left 1 multiply [n..1]\nsum_list:  fold_left 0 add [elements]\nlength:    fold_left 0 increment [elements]\n```\n\n### UnifyWeaver's Fold Implementation\n\n```bash\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Usage for factorial\nbuild_range_down() {\n    seq \"$1\" -1 1\n}\n\nfactorial_op() {\n    echo $(($1 * $2))\n}\n\nfactorial() {\n    local range=$(build_range_down \"$1\")\n    fold_left 1 factorial_op $range\n}\n```\n\n### Benefits\n\n- Clear, readable generated code\n- Easy to debug (inspect sequence, operation)\n- Natural fit for linear recursion patterns", "answer_tailored": true}
{"pair_id": "fold-pattern_p2", "cluster_id": "fold-pattern", "question": "How does fold-based compilation work?", "question_type": "medium", "answer": "Fold-based compilation transforms recursive predicates into iterative fold operations. The compiler recognizes linear recursion patterns and generates code that builds a sequence, then applies a fold operation to compute the result.\n\n## How It Works\n\nThe compilation has two phases:\n\n**1. Generate the sequence** - Extract the recursive structure into a list\n**2. Apply the fold** - Accumulate results using an operation\n\nFor example, compiling `factorial(N)`:\n- Sequence: `[N, N-1, ..., 1]` (generated by `build_range_down`)\n- Operation: multiply\n- Fold: `fold_left 1 multiply N N-1 ... 1`\n\n## Generated Code Structure\n\n```bash\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\nfactorial() {\n    local range=$(build_range_down \"$1\")\n    fold_left 1 factorial_op $range\n}\n```\n\n## Why This Compilation Strategy?\n\n**Separation**: The compiler separates structure (what to iterate) from computation (what to do)\n\n**Reusability**: One `fold_left` implementation works for many predicates:\n- `factorial` \u2192 fold with multiply\n- `sum_list` \u2192 fold with add\n- `length` \u2192 fold with increment\n\n**Clarity**: Generated code is readable and debuggable - you can inspect the sequence and operation independently\n\nThe compiler chooses between `fold_left` and `fold_right` based on the recursion pattern, though for associative operations the choice doesn't affect correctness.\n\nSee education/book-02-bash-target/06_advanced_recursion.md for complete examples and implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["fold", "reduce", "functional-programming", "compilation-strategy"], "original_answer": "## The Fold Pattern\n\nA fold (also called reduce) accumulates a result by iterating over a sequence.\n\n### Basic Concept\n\n```\nfold(operation, initial, [a, b, c])\n\nSteps:\n  acc = initial\n  acc = operation(a, acc)\n  acc = operation(b, acc)\n  acc = operation(c, acc)\n  return acc\n```\n\n### Example: Sum with Fold\n\n```bash\n# sum([1, 2, 3]) using fold\nfold_left 0 add 1 2 3\n\n# Steps:\n# acc = 0\n# acc = add(1, 0) = 1\n# acc = add(2, 1) = 3\n# acc = add(3, 3) = 6\n# Result: 6\n```\n\n### Left vs Right Fold\n\n```\nfold_left:  ((initial op a) op b) op c\nfold_right: a op (b op (c op initial))\n```\n\nFor associative operations (like +, *), both give same result.\n\n### Why Use Fold for Compilation?\n\n**1. Separation of Concerns**\n- Structure building: generate the sequence\n- Computation: apply the operation\n\n**2. Reusability**\n```bash\n# Same fold_left for many predicates\nfactorial: fold_left 1 multiply [n..1]\nsum_list:  fold_left 0 add [elements]\nlength:    fold_left 0 increment [elements]\n```\n\n### UnifyWeaver's Fold Implementation\n\n```bash\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Usage for factorial\nbuild_range_down() {\n    seq \"$1\" -1 1\n}\n\nfactorial_op() {\n    echo $(($1 * $2))\n}\n\nfactorial() {\n    local range=$(build_range_down \"$1\")\n    fold_left 1 factorial_op $range\n}\n```\n\n### Benefits\n\n- Clear, readable generated code\n- Easy to debug (inspect sequence, operation)\n- Natural fit for linear recursion patterns", "answer_tailored": true}
{"pair_id": "fold-pattern_p3", "cluster_id": "fold-pattern", "question": "Why does UnifyWeaver use fold for linear recursion?", "question_type": "medium", "answer": "UnifyWeaver uses fold for linear recursion because it cleanly separates the iteration structure from the actual computation, making the generated code more maintainable and reusable.\n\n## Key Advantages\n\n**Separation of Concerns**\nThe fold pattern divides linear recursion into two parts:\n- Building the sequence to iterate over\n- Applying the operation to accumulate results\n\nThis separation makes each part easier to understand and debug independently.\n\n**Code Reusability**\nThe same `fold_left` implementation works for many different predicates:\n\n```bash\nfactorial: fold_left 1 multiply [n..1]\nsum_list:  fold_left 0 add [elements]\nlength:    fold_left 0 increment [elements]\n```\n\n**Natural Accumulator Pattern**\nLinear recursive predicates with accumulators map directly to folds:\n\n```bash\n# Prolog accumulator pattern\nfactorial(N, Acc, Result) :- ...\n\n# Compiles to fold\nfold_left 1 multiply_op $(seq $N -1 1)\n```\n\n## Implementation Example\n\n```bash\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\nfactorial() {\n    fold_left 1 factorial_op $(seq \"$1\" -1 1)\n}\n```\n\nThis produces clear, debuggable Bash code where you can easily inspect the sequence being processed and the operation being applied. For more details on recursion compilation strategies, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["fold", "reduce", "functional-programming", "compilation-strategy"], "original_answer": "## The Fold Pattern\n\nA fold (also called reduce) accumulates a result by iterating over a sequence.\n\n### Basic Concept\n\n```\nfold(operation, initial, [a, b, c])\n\nSteps:\n  acc = initial\n  acc = operation(a, acc)\n  acc = operation(b, acc)\n  acc = operation(c, acc)\n  return acc\n```\n\n### Example: Sum with Fold\n\n```bash\n# sum([1, 2, 3]) using fold\nfold_left 0 add 1 2 3\n\n# Steps:\n# acc = 0\n# acc = add(1, 0) = 1\n# acc = add(2, 1) = 3\n# acc = add(3, 3) = 6\n# Result: 6\n```\n\n### Left vs Right Fold\n\n```\nfold_left:  ((initial op a) op b) op c\nfold_right: a op (b op (c op initial))\n```\n\nFor associative operations (like +, *), both give same result.\n\n### Why Use Fold for Compilation?\n\n**1. Separation of Concerns**\n- Structure building: generate the sequence\n- Computation: apply the operation\n\n**2. Reusability**\n```bash\n# Same fold_left for many predicates\nfactorial: fold_left 1 multiply [n..1]\nsum_list:  fold_left 0 add [elements]\nlength:    fold_left 0 increment [elements]\n```\n\n### UnifyWeaver's Fold Implementation\n\n```bash\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Usage for factorial\nbuild_range_down() {\n    seq \"$1\" -1 1\n}\n\nfactorial_op() {\n    echo $(($1 * $2))\n}\n\nfactorial() {\n    local range=$(build_range_down \"$1\")\n    fold_left 1 factorial_op $range\n}\n```\n\n### Benefits\n\n- Clear, readable generated code\n- Easy to debug (inspect sequence, operation)\n- Natural fit for linear recursion patterns", "answer_tailored": true}
{"pair_id": "scc-tarjan_p0", "cluster_id": "scc-tarjan", "question": "What is a Strongly Connected Component (SCC)?", "question_type": "medium", "answer": "A Strongly Connected Component (SCC) is a maximal group of nodes in a graph where every node can reach every other node through some path.\n\n### Simple Example\n\n```\n    A \u2192 B \u2192 C\n    \u2191       \u2193\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nHere, nodes A, B, and C form an SCC because there's a cycle: A can reach B, B can reach C, and C can reach A.\n\n### SCCs in UnifyWeaver's Recursion Analysis\n\nSCCs are crucial for identifying mutual recursion in Prolog predicates. Consider:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nThe call graph shows:\n```\nis_even \u2192 is_odd\n   \u2191         \u2193\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nSince `is_even` and `is_odd` call each other, they form an SCC. This tells UnifyWeaver these predicates are mutually recursive and must be compiled together with shared memoization.\n\n### Detection with Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm to find SCCs:\n\n1. Perform depth-first search through the call graph\n2. Track when each node is discovered (discovery time)\n3. Compute the lowest reachable ancestor (low-link value)\n4. Use a stack to identify complete SCCs\n\nWhen a node's discovery time equals its low-link value, an SCC is found.\n\nSee education/book-02-bash-target/06_advanced_recursion.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithm"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn SCC is a maximal group of nodes where every node can reach every other node.\n\n### Visual Example\n\n```\n    A \u2192 B \u2192 C\n    \u2191       \u2193\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nA, B, C form an SCC: A\u2192B\u2192C\u2192A (cycle)\n```\n\n### Why SCCs Matter for Mutual Recursion\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even \u2192 is_odd\n   \u2191         \u2193\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThese form an SCC - they're mutually recursive and must be compiled together.\n\n### Tarjan's Algorithm (Simplified)\n\n1. **DFS traversal** - visit each node\n2. **Track discovery time** - when node was first seen\n3. **Track low-link** - lowest reachable node\n4. **Stack-based detection** - nodes in current path\n\n```\nVisit A (disc=1, low=1)\n  Visit B (disc=2, low=2)\n    Visit C (disc=3, low=3)\n      C can reach A (disc=1)\n      Update C.low = 1\n    Update B.low = 1\n  Update A.low = 1\nA.disc == A.low \u2192 SCC found: {A, B, C}\n```\n\n### UnifyWeaver's SCC Detection\n\n```prolog\n% Build call graph from clauses\nbuild_call_graph(Predicates, Graph),\n\n% Find SCCs using Tarjan\nfind_sccs(Graph, SCCs),\n\n% Non-trivial SCCs = mutual recursion\ninclude(non_trivial_scc, SCCs, MutualGroups).\n```\n\n### Why Shared Memoization?\n\nWithout shared memo:\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n              ^ if is_odd has separate memo, \n                is_even's results aren't cached\n```\n\nWith shared memo:\n```\nis_even_is_odd_memo[\"is_even:4\"] = true\nis_even_is_odd_memo[\"is_odd:3\"] = true\n... all results cached in one table\n```", "answer_tailored": true}
{"pair_id": "scc-tarjan_p1", "cluster_id": "scc-tarjan", "question": "Why does SCC detection matter for mutual recursion?", "question_type": "medium", "answer": "SCC detection identifies groups of predicates that form mutual recursion cycles. When predicates like `is_even` and `is_odd` call each other, they create a strongly connected component in the call graph - a cycle where each predicate can reach the others.\n\nThis matters because mutually recursive predicates must be compiled together and share a single memoization table. Without SCC detection, the compiler might try to compile them separately, leading to:\n\n1. **Compilation order issues** - can't compile `is_even` before `is_odd` when they reference each other\n2. **Separate memo tables** - each predicate would have its own cache, missing optimization opportunities\n3. **Incorrect semantics** - the predicates wouldn't see each other's cached results\n\nUnifyWeaver detects SCCs using Tarjan's algorithm during the compilation phase:\n\n```prolog\nbuild_call_graph(Predicates, Graph),\nfind_sccs(Graph, SCCs),\ninclude(non_trivial_scc, SCCs, MutualGroups).\n```\n\nOnce identified, all predicates in an SCC share a unified memo table (e.g., `is_even_is_odd_memo`) where results like `\"is_even:4\"` and `\"is_odd:3\"` are stored together. This ensures efficient caching across the entire mutually recursive group.\n\nFor implementation details, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithm"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn SCC is a maximal group of nodes where every node can reach every other node.\n\n### Visual Example\n\n```\n    A \u2192 B \u2192 C\n    \u2191       \u2193\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nA, B, C form an SCC: A\u2192B\u2192C\u2192A (cycle)\n```\n\n### Why SCCs Matter for Mutual Recursion\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even \u2192 is_odd\n   \u2191         \u2193\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThese form an SCC - they're mutually recursive and must be compiled together.\n\n### Tarjan's Algorithm (Simplified)\n\n1. **DFS traversal** - visit each node\n2. **Track discovery time** - when node was first seen\n3. **Track low-link** - lowest reachable node\n4. **Stack-based detection** - nodes in current path\n\n```\nVisit A (disc=1, low=1)\n  Visit B (disc=2, low=2)\n    Visit C (disc=3, low=3)\n      C can reach A (disc=1)\n      Update C.low = 1\n    Update B.low = 1\n  Update A.low = 1\nA.disc == A.low \u2192 SCC found: {A, B, C}\n```\n\n### UnifyWeaver's SCC Detection\n\n```prolog\n% Build call graph from clauses\nbuild_call_graph(Predicates, Graph),\n\n% Find SCCs using Tarjan\nfind_sccs(Graph, SCCs),\n\n% Non-trivial SCCs = mutual recursion\ninclude(non_trivial_scc, SCCs, MutualGroups).\n```\n\n### Why Shared Memoization?\n\nWithout shared memo:\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n              ^ if is_odd has separate memo, \n                is_even's results aren't cached\n```\n\nWith shared memo:\n```\nis_even_is_odd_memo[\"is_even:4\"] = true\nis_even_is_odd_memo[\"is_odd:3\"] = true\n... all results cached in one table\n```", "answer_tailored": true}
{"pair_id": "scc-tarjan_p2", "cluster_id": "scc-tarjan", "question": "How does Tarjan's algorithm work?", "question_type": "medium", "answer": "Tarjan's algorithm detects strongly connected components (SCCs) in a directed graph using depth-first search with stack-based tracking. Here's how it works:\n\n**Core Mechanism:**\n\n1. **DFS traversal** - Visit each node in depth-first order\n2. **Discovery time tracking** - Assign each node a timestamp when first visited\n3. **Low-link tracking** - Track the lowest discovery time reachable from each node\n4. **Stack maintenance** - Keep nodes on a stack representing the current DFS path\n\n**Step-by-Step Example:**\n\n```\nVisit A (disc=1, low=1)\n  Visit B (disc=2, low=2)\n    Visit C (disc=3, low=3)\n      C can reach A (disc=1)\n      Update C.low = 1\n    Update B.low = 1\n  Update A.low = 1\nA.disc == A.low \u2192 SCC found: {A, B, C}\n```\n\n**Key Insight:** When a node's discovery time equals its low-link value, it's the root of an SCC. All nodes on the stack above it form that component.\n\n**UnifyWeaver Application:**\n\n```prolog\n% Build call graph from clauses\nbuild_call_graph(Predicates, Graph),\n\n% Find SCCs using Tarjan\nfind_sccs(Graph, SCCs),\n\n% Non-trivial SCCs = mutual recursion\ninclude(non_trivial_scc, SCCs, MutualGroups).\n```\n\nThis identifies mutually recursive predicates (like `is_even/1` and `is_odd/1`) that must share memoization tables and be compiled together as a single unit.\n\nFor implementation details, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithm"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn SCC is a maximal group of nodes where every node can reach every other node.\n\n### Visual Example\n\n```\n    A \u2192 B \u2192 C\n    \u2191       \u2193\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nA, B, C form an SCC: A\u2192B\u2192C\u2192A (cycle)\n```\n\n### Why SCCs Matter for Mutual Recursion\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even \u2192 is_odd\n   \u2191         \u2193\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThese form an SCC - they're mutually recursive and must be compiled together.\n\n### Tarjan's Algorithm (Simplified)\n\n1. **DFS traversal** - visit each node\n2. **Track discovery time** - when node was first seen\n3. **Track low-link** - lowest reachable node\n4. **Stack-based detection** - nodes in current path\n\n```\nVisit A (disc=1, low=1)\n  Visit B (disc=2, low=2)\n    Visit C (disc=3, low=3)\n      C can reach A (disc=1)\n      Update C.low = 1\n    Update B.low = 1\n  Update A.low = 1\nA.disc == A.low \u2192 SCC found: {A, B, C}\n```\n\n### UnifyWeaver's SCC Detection\n\n```prolog\n% Build call graph from clauses\nbuild_call_graph(Predicates, Graph),\n\n% Find SCCs using Tarjan\nfind_sccs(Graph, SCCs),\n\n% Non-trivial SCCs = mutual recursion\ninclude(non_trivial_scc, SCCs, MutualGroups).\n```\n\n### Why Shared Memoization?\n\nWithout shared memo:\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n              ^ if is_odd has separate memo, \n                is_even's results aren't cached\n```\n\nWith shared memo:\n```\nis_even_is_odd_memo[\"is_even:4\"] = true\nis_even_is_odd_memo[\"is_odd:3\"] = true\n... all results cached in one table\n```", "answer_tailored": true}
{"pair_id": "scc-tarjan_p3", "cluster_id": "scc-tarjan", "question": "How does UnifyWeaver detect mutual recursion?", "question_type": "medium", "answer": "UnifyWeaver detects mutual recursion by finding **Strongly Connected Components (SCCs)** in the predicate call graph using **Tarjan's algorithm**.\n\n## Detection Process\n\n```prolog\n% Build call graph from clauses\nbuild_call_graph(Predicates, Graph),\n\n% Find SCCs using Tarjan\nfind_sccs(Graph, SCCs),\n\n% Non-trivial SCCs = mutual recursion\ninclude(non_trivial_scc, SCCs, MutualGroups).\n```\n\n## What is an SCC?\n\nAn SCC is a maximal group of predicates where every predicate can reach every other predicate through the call graph. This forms a cycle.\n\n**Example with mutually recursive predicates:**\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph shows the cycle:\n```\nis_even \u2192 is_odd\n   \u2191         \u2193\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nSince `is_even` and `is_odd` form an SCC (they call each other), they're mutually recursive and must be compiled together with shared memoization.\n\n## Tarjan's Algorithm (Core Steps)\n\n1. **DFS traversal** - visit each predicate node\n2. **Track discovery time** - when node was first encountered\n3. **Track low-link value** - lowest node reachable from this node\n4. **Stack-based detection** - maintain nodes in current path\n5. **Identify components** - when `disc == low`, an SCC is complete\n\nThis approach ensures all mutually recursive predicate groups are identified before compilation begins. For implementation details, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithm"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn SCC is a maximal group of nodes where every node can reach every other node.\n\n### Visual Example\n\n```\n    A \u2192 B \u2192 C\n    \u2191       \u2193\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nA, B, C form an SCC: A\u2192B\u2192C\u2192A (cycle)\n```\n\n### Why SCCs Matter for Mutual Recursion\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even \u2192 is_odd\n   \u2191         \u2193\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThese form an SCC - they're mutually recursive and must be compiled together.\n\n### Tarjan's Algorithm (Simplified)\n\n1. **DFS traversal** - visit each node\n2. **Track discovery time** - when node was first seen\n3. **Track low-link** - lowest reachable node\n4. **Stack-based detection** - nodes in current path\n\n```\nVisit A (disc=1, low=1)\n  Visit B (disc=2, low=2)\n    Visit C (disc=3, low=3)\n      C can reach A (disc=1)\n      Update C.low = 1\n    Update B.low = 1\n  Update A.low = 1\nA.disc == A.low \u2192 SCC found: {A, B, C}\n```\n\n### UnifyWeaver's SCC Detection\n\n```prolog\n% Build call graph from clauses\nbuild_call_graph(Predicates, Graph),\n\n% Find SCCs using Tarjan\nfind_sccs(Graph, SCCs),\n\n% Non-trivial SCCs = mutual recursion\ninclude(non_trivial_scc, SCCs, MutualGroups).\n```\n\n### Why Shared Memoization?\n\nWithout shared memo:\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n              ^ if is_odd has separate memo, \n                is_even's results aren't cached\n```\n\nWith shared memo:\n```\nis_even_is_odd_memo[\"is_even:4\"] = true\nis_even_is_odd_memo[\"is_odd:3\"] = true\n... all results cached in one table\n```", "answer_tailored": true}
{"pair_id": "recursion-types_p0", "cluster_id": "recursion-types", "question": "How do I know if my code is tail/linear/tree recursive?", "question_type": "medium", "answer": "To classify your code's recursion pattern, follow this quick decision tree:\n\n**Count the recursive calls in each clause:**\n- If you see **one recursive call** that's the **very last thing** in the clause (nothing happens after it returns), that's **tail recursion**\n- If you see **one recursive call** but then you do work **after it returns** (like arithmetic or building structures), that's **linear recursion**\n- If you see **multiple recursive calls** (typically on different parts of a data structure), that's **tree recursion**\n\n**Examples to guide you:**\n\nTail recursion - the recursive call is the final action:\n```prolog\ncount([], Acc, Acc).\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).    % Last line, nothing after\n```\n\nLinear recursion - work happens after the recursive call:\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.          % Computation AFTER the call\n```\n\nTree recursion - multiple recursive calls:\n```prolog\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),      % First recursive call\n    tree_sum(R, RS),      % Second recursive call\n    Sum is V + LS + RS.\n```\n\nUnifyWeaver optimizes tail recursion into iterative loops (most efficient), converts linear recursion to folds with memoization, and handles tree recursion with structural parsing. See education/book-02-bash-target/06_advanced_recursion.md for compilation strategies for each pattern.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "linear-recursion", "tree-recursion", "classification"], "original_answer": "## Recursion Pattern Classification\n\n### Quick Reference\n\n| Pattern | Recursive Calls | Work After Call? | Example |\n|---------|-----------------|------------------|--------|\n| Tail | 1 | No | count_items |\n| Linear | 1 | Yes | factorial |\n| Tree | 2+ | Yes | tree_sum |\n| Mutual | 1+ (to different pred) | Varies | is_even/is_odd |\n\n### Tail Recursion\n\nThe recursive call is the **last action** - no computation after it returns.\n\n```prolog\n% TAIL: recursive call is last\ncount([], Acc, Acc).\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).    % Nothing after this\n```\n\n### Linear Recursion\n\nExactly **one recursive call**, but work happens **after** it returns.\n\n```prolog\n% LINEAR: work after recursive call\nfactorial(0, 1).\nfactorial(N, F) :-\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.          % Multiplication AFTER return\n```\n\n### Tree Recursion\n\n**Multiple recursive calls** on structural parts.\n\n```prolog\n% TREE: two recursive calls\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),      % Call 1\n    tree_sum(R, RS),      % Call 2\n    Sum is V + LS + RS.\n```\n\n### How to Identify\n\n**Step 1:** Count recursive calls per clause\n- 0 = base case\n- 1 = tail or linear\n- 2+ = tree\n\n**Step 2:** If 1 call, check if it's last\n- Last action \u2192 tail\n- Work after \u2192 linear\n\n**Step 3:** Check if calls are to same predicate\n- Different predicate \u2192 possibly mutual\n\n### UnifyWeaver's Priority\n\n1. **Tail** (most efficient \u2192 iterative loop)\n2. **Linear** (fold-based with memoization)\n3. **Tree** (recursive with structure parsing)\n4. **Mutual** (SCC detection, shared memo)\n5. **Basic** (fallback BFS)", "answer_tailored": true}
{"pair_id": "recursion-types_p1", "cluster_id": "recursion-types", "question": "What's the difference between tail and linear recursion?", "question_type": "medium", "answer": "The key difference is what happens **after the recursive call**:\n\n**Tail Recursion**: The recursive call is the **final action** in the clause - nothing happens after it returns. All work is done before making the call, typically using an accumulator:\n\n```prolog\n% TAIL: recursive call is last, no work after\ncount([], Acc, Acc).\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).    % Nothing follows this call\n```\n\n**Linear Recursion**: There's exactly **one recursive call**, but computation happens **after it returns**. The predicate waits for the result, then performs additional work:\n\n```prolog\n% LINEAR: work happens after the call returns\nfactorial(0, 1).\nfactorial(N, F) :-\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.          % Multiplication AFTER return\n```\n\n**Performance Impact**: Tail recursion is more efficient because UnifyWeaver can compile it to an iterative loop. Linear recursion requires fold-based compilation with potential memoization since results must propagate back up the call stack.\n\nTo identify which pattern you have: if the recursive call is the last thing in the clause, it's tail recursion. If there's any computation using the recursive result afterward, it's linear recursion.\n\nSee education/book-02-bash-target/06_advanced_recursion.md for detailed pattern classification and UnifyWeaver's compilation strategies for each type.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "linear-recursion", "tree-recursion", "classification"], "original_answer": "## Recursion Pattern Classification\n\n### Quick Reference\n\n| Pattern | Recursive Calls | Work After Call? | Example |\n|---------|-----------------|------------------|--------|\n| Tail | 1 | No | count_items |\n| Linear | 1 | Yes | factorial |\n| Tree | 2+ | Yes | tree_sum |\n| Mutual | 1+ (to different pred) | Varies | is_even/is_odd |\n\n### Tail Recursion\n\nThe recursive call is the **last action** - no computation after it returns.\n\n```prolog\n% TAIL: recursive call is last\ncount([], Acc, Acc).\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).    % Nothing after this\n```\n\n### Linear Recursion\n\nExactly **one recursive call**, but work happens **after** it returns.\n\n```prolog\n% LINEAR: work after recursive call\nfactorial(0, 1).\nfactorial(N, F) :-\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.          % Multiplication AFTER return\n```\n\n### Tree Recursion\n\n**Multiple recursive calls** on structural parts.\n\n```prolog\n% TREE: two recursive calls\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),      % Call 1\n    tree_sum(R, RS),      % Call 2\n    Sum is V + LS + RS.\n```\n\n### How to Identify\n\n**Step 1:** Count recursive calls per clause\n- 0 = base case\n- 1 = tail or linear\n- 2+ = tree\n\n**Step 2:** If 1 call, check if it's last\n- Last action \u2192 tail\n- Work after \u2192 linear\n\n**Step 3:** Check if calls are to same predicate\n- Different predicate \u2192 possibly mutual\n\n### UnifyWeaver's Priority\n\n1. **Tail** (most efficient \u2192 iterative loop)\n2. **Linear** (fold-based with memoization)\n3. **Tree** (recursive with structure parsing)\n4. **Mutual** (SCC detection, shared memo)\n5. **Basic** (fallback BFS)", "answer_tailored": true}
{"pair_id": "recursion-types_p2", "cluster_id": "recursion-types", "question": "What makes recursion 'tree' recursion?", "question_type": "medium", "answer": "Tree recursion occurs when a predicate makes **multiple recursive calls** (2 or more) within the same clause, typically on different structural parts of the input.\n\n```prolog\n% TREE: two recursive calls on left and right subtrees\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),      % First recursive call\n    tree_sum(R, RS),      % Second recursive call\n    Sum is V + LS + RS.\n```\n\nThe key characteristic is that each invocation branches into multiple recursive paths, creating a tree-like call structure. This contrasts with:\n- **Tail recursion**: 1 call, last action (no work after)\n- **Linear recursion**: 1 call, with work after it returns\n\nTo identify tree recursion, count the recursive calls per clause - if there are 2 or more calls to the same predicate on different parts of the structure, it's tree recursion.\n\nUnifyWeaver handles tree recursion with recursive compilation and structure parsing, ranking it third in efficiency priority after tail and linear patterns (see education/book-02-bash-target/06_advanced_recursion.md for the full classification system).", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "linear-recursion", "tree-recursion", "classification"], "original_answer": "## Recursion Pattern Classification\n\n### Quick Reference\n\n| Pattern | Recursive Calls | Work After Call? | Example |\n|---------|-----------------|------------------|--------|\n| Tail | 1 | No | count_items |\n| Linear | 1 | Yes | factorial |\n| Tree | 2+ | Yes | tree_sum |\n| Mutual | 1+ (to different pred) | Varies | is_even/is_odd |\n\n### Tail Recursion\n\nThe recursive call is the **last action** - no computation after it returns.\n\n```prolog\n% TAIL: recursive call is last\ncount([], Acc, Acc).\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).    % Nothing after this\n```\n\n### Linear Recursion\n\nExactly **one recursive call**, but work happens **after** it returns.\n\n```prolog\n% LINEAR: work after recursive call\nfactorial(0, 1).\nfactorial(N, F) :-\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.          % Multiplication AFTER return\n```\n\n### Tree Recursion\n\n**Multiple recursive calls** on structural parts.\n\n```prolog\n% TREE: two recursive calls\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),      % Call 1\n    tree_sum(R, RS),      % Call 2\n    Sum is V + LS + RS.\n```\n\n### How to Identify\n\n**Step 1:** Count recursive calls per clause\n- 0 = base case\n- 1 = tail or linear\n- 2+ = tree\n\n**Step 2:** If 1 call, check if it's last\n- Last action \u2192 tail\n- Work after \u2192 linear\n\n**Step 3:** Check if calls are to same predicate\n- Different predicate \u2192 possibly mutual\n\n### UnifyWeaver's Priority\n\n1. **Tail** (most efficient \u2192 iterative loop)\n2. **Linear** (fold-based with memoization)\n3. **Tree** (recursive with structure parsing)\n4. **Mutual** (SCC detection, shared memo)\n5. **Basic** (fallback BFS)", "answer_tailored": true}
{"pair_id": "recursion-types_p3", "cluster_id": "recursion-types", "question": "How does UnifyWeaver classify recursion patterns?", "question_type": "medium", "answer": "UnifyWeaver categorizes recursion into four main patterns based on the number and position of recursive calls:\n\n**Tail Recursion**: Single recursive call that occurs as the final action\u2014no computation happens after the call returns. Example: `count(T, Acc1, N)` where nothing follows the recursive step.\n\n**Linear Recursion**: Exactly one recursive call, but additional work is performed after it completes. Example: `factorial` computes `F is N * F1` after the recursive call returns.\n\n**Tree Recursion**: Multiple recursive calls operating on different structural components. Example: binary tree traversal with separate calls for left and right subtrees.\n\n**Mutual Recursion**: Predicates that call different predicates in a cyclic dependency (e.g., `is_even` calling `is_odd` and vice versa).\n\n**Classification Process**:\n1. Count recursive calls per clause (0 = base case, 1 = tail/linear, 2+ = tree)\n2. For single calls, determine if it's the last operation (tail) or has subsequent work (linear)\n3. Check whether calls target the same predicate or form mutual dependencies\n\nUnifyWeaver prioritizes these patterns for compilation efficiency: tail recursion converts to iterative loops, linear uses fold-based approaches with memoization, tree requires structural parsing, mutual recursion uses strongly-connected component (SCC) detection with shared memoization, and a basic BFS serves as the fallback.\n\nFor implementation details, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "linear-recursion", "tree-recursion", "classification"], "original_answer": "## Recursion Pattern Classification\n\n### Quick Reference\n\n| Pattern | Recursive Calls | Work After Call? | Example |\n|---------|-----------------|------------------|--------|\n| Tail | 1 | No | count_items |\n| Linear | 1 | Yes | factorial |\n| Tree | 2+ | Yes | tree_sum |\n| Mutual | 1+ (to different pred) | Varies | is_even/is_odd |\n\n### Tail Recursion\n\nThe recursive call is the **last action** - no computation after it returns.\n\n```prolog\n% TAIL: recursive call is last\ncount([], Acc, Acc).\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).    % Nothing after this\n```\n\n### Linear Recursion\n\nExactly **one recursive call**, but work happens **after** it returns.\n\n```prolog\n% LINEAR: work after recursive call\nfactorial(0, 1).\nfactorial(N, F) :-\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.          % Multiplication AFTER return\n```\n\n### Tree Recursion\n\n**Multiple recursive calls** on structural parts.\n\n```prolog\n% TREE: two recursive calls\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),      % Call 1\n    tree_sum(R, RS),      % Call 2\n    Sum is V + LS + RS.\n```\n\n### How to Identify\n\n**Step 1:** Count recursive calls per clause\n- 0 = base case\n- 1 = tail or linear\n- 2+ = tree\n\n**Step 2:** If 1 call, check if it's last\n- Last action \u2192 tail\n- Work after \u2192 linear\n\n**Step 3:** Check if calls are to same predicate\n- Different predicate \u2192 possibly mutual\n\n### UnifyWeaver's Priority\n\n1. **Tail** (most efficient \u2192 iterative loop)\n2. **Linear** (fold-based with memoization)\n3. **Tree** (recursive with structure parsing)\n4. **Mutual** (SCC detection, shared memo)\n5. **Basic** (fallback BFS)", "answer_tailored": true}
{"pair_id": "memoization-strategy_p0", "cluster_id": "memoization-strategy", "question": "What is memoization and why use it?", "question_type": "medium", "answer": "Memoization is a technique that caches function results to avoid redundant computation. When a function is called with the same arguments, instead of recalculating, it returns the cached result.\n\n**Why use it?**\n\nWithout memoization, recursive functions can wastefully recompute the same values multiple times. For example, `fib(5)` would calculate `fib(3)` twice:\n\n```\nfib(5)\n\u251c\u2500\u2500 fib(4)\n\u2502   \u251c\u2500\u2500 fib(3)  \u2190 computed\n\u2502   \u2514\u2500\u2500 fib(2)\n\u2514\u2500\u2500 fib(3)      \u2190 computed AGAIN\n```\n\nWith memoization, `fib(3)` is computed once and cached, so subsequent calls retrieve it instantly from the cache.\n\n**Basic implementation:**\n\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check cache first\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Compute and cache result\n    local result=$(compute_factorial \"$n\")\n    factorial_memo[$n]=\"$result\"\n    echo \"$result\"\n}\n```\n\nFor mutually recursive functions, shared memoization tables are crucial to avoid infinite loops and enable cross-function caching. See education/book-02-bash-target/06_advanced_recursion.md for UnifyWeaver's implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["memoization", "caching", "performance", "mutual-recursion"], "original_answer": "## Memoization Strategy\n\nMemoization caches function results to avoid redundant computation.\n\n### Basic Concept\n\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check cache first\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Compute result\n    local result=$(compute_factorial \"$n\")\n    \n    # Cache it\n    factorial_memo[$n]=\"$result\"\n    echo \"$result\"\n}\n```\n\n### Why Memoization Helps\n\n```\nWithout memo: fib(5) computes fib(3) twice\n  fib(5)\n  \u251c\u2500\u2500 fib(4)\n  \u2502   \u251c\u2500\u2500 fib(3)  \u2190 computed\n  \u2502   \u2514\u2500\u2500 fib(2)\n  \u2514\u2500\u2500 fib(3)      \u2190 computed AGAIN\n\nWith memo: fib(3) computed once, cached\n  fib(5)\n  \u251c\u2500\u2500 fib(4)\n  \u2502   \u251c\u2500\u2500 fib(3)  \u2190 computed, cached\n  \u2502   \u2514\u2500\u2500 fib(2)\n  \u2514\u2500\u2500 fib(3)      \u2190 cache hit!\n```\n\n### Why Mutual Recursion Needs Shared Memo\n\nSeparate tables would miss cross-function caching:\n\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n\nSeparate memos:\n  is_even_memo: {4: ?, 2: ?}  \u2190 waiting for is_odd\n  is_odd_memo: {3: ?, 1: true}\n  \nShared memo:\n  shared_memo: {\n    \"is_even:4\": true,\n    \"is_odd:3\": true,\n    \"is_even:2\": true,\n    \"is_odd:1\": true\n  }\n```\n\n### Without Shared Memo: Infinite Loop Risk\n\n```prolog\na(X) :- b(X).\nb(X) :- a(X).  % Circular!\n```\n\nShared memo detects the cycle:\n```bash\na(5):  Check memo[\"a:5\"] - not found, mark as computing\nb(5):  Check memo[\"b:5\"] - not found, mark as computing  \na(5):  Check memo[\"a:5\"] - FOUND (computing) \u2192 cycle detected!\n```\n\n### UnifyWeaver's Implementation\n\n```bash\n# Shared memo for SCC group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local key=\"is_even:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n\nis_odd() {\n    local key=\"is_odd:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n```", "answer_tailored": true}
{"pair_id": "memoization-strategy_p1", "cluster_id": "memoization-strategy", "question": "Why must mutual recursive functions share a memo table?", "question_type": "medium", "answer": "Mutual recursive functions need a shared memo table because they call each other, and each function needs visibility into the other's cached results to avoid redundant computation and infinite loops.\n\n## The Cross-Function Caching Problem\n\nWhen functions call each other mutually, separate memo tables miss opportunities to reuse work:\n\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n\nWith separate tables:\n  is_even_memo: {4: ?, 2: ?}  \u2190 can't see is_odd's results\n  is_odd_memo: {3: ?, 1: true} \u2190 can't see is_even's results\n  \nWith shared table:\n  shared_memo: {\n    \"is_even:4\": true,\n    \"is_odd:3\": true,\n    \"is_even:2\": true,\n    \"is_odd:1\": true\n  }\n```\n\n## Cycle Detection\n\nA shared memo table is critical for detecting infinite recursion in circular call chains:\n\n```prolog\na(X) :- b(X).\nb(X) :- a(X).  % Circular dependency!\n```\n\nThe shared table tracks which computations are in-progress:\n\n```bash\na(5):  Check memo[\"a:5\"] \u2192 not found, mark as \"computing\"\nb(5):  Check memo[\"b:5\"] \u2192 not found, mark as \"computing\"  \na(5):  Check memo[\"a:5\"] \u2192 FOUND \"computing\" \u2192 cycle detected!\n```\n\n## UnifyWeaver's Approach\n\nFunctions in the same Strongly Connected Component (SCC) share one memo table:\n\n```bash\n# Single shared table for mutually recursive group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local key=\"is_even:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && echo \"${is_even_is_odd_memo[$key]}\" && return\n    # ... computation\n}\n\nis_odd() {\n    local key=\"is_odd:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && echo \"${is_even_is_odd_memo[$key]}\" && return\n    # ... computation\n}\n```\n\nSee education/book-02-bash-target/06_advanced_recursion.md for complete memoization strategies.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["memoization", "caching", "performance", "mutual-recursion"], "original_answer": "## Memoization Strategy\n\nMemoization caches function results to avoid redundant computation.\n\n### Basic Concept\n\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check cache first\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Compute result\n    local result=$(compute_factorial \"$n\")\n    \n    # Cache it\n    factorial_memo[$n]=\"$result\"\n    echo \"$result\"\n}\n```\n\n### Why Memoization Helps\n\n```\nWithout memo: fib(5) computes fib(3) twice\n  fib(5)\n  \u251c\u2500\u2500 fib(4)\n  \u2502   \u251c\u2500\u2500 fib(3)  \u2190 computed\n  \u2502   \u2514\u2500\u2500 fib(2)\n  \u2514\u2500\u2500 fib(3)      \u2190 computed AGAIN\n\nWith memo: fib(3) computed once, cached\n  fib(5)\n  \u251c\u2500\u2500 fib(4)\n  \u2502   \u251c\u2500\u2500 fib(3)  \u2190 computed, cached\n  \u2502   \u2514\u2500\u2500 fib(2)\n  \u2514\u2500\u2500 fib(3)      \u2190 cache hit!\n```\n\n### Why Mutual Recursion Needs Shared Memo\n\nSeparate tables would miss cross-function caching:\n\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n\nSeparate memos:\n  is_even_memo: {4: ?, 2: ?}  \u2190 waiting for is_odd\n  is_odd_memo: {3: ?, 1: true}\n  \nShared memo:\n  shared_memo: {\n    \"is_even:4\": true,\n    \"is_odd:3\": true,\n    \"is_even:2\": true,\n    \"is_odd:1\": true\n  }\n```\n\n### Without Shared Memo: Infinite Loop Risk\n\n```prolog\na(X) :- b(X).\nb(X) :- a(X).  % Circular!\n```\n\nShared memo detects the cycle:\n```bash\na(5):  Check memo[\"a:5\"] - not found, mark as computing\nb(5):  Check memo[\"b:5\"] - not found, mark as computing  \na(5):  Check memo[\"a:5\"] - FOUND (computing) \u2192 cycle detected!\n```\n\n### UnifyWeaver's Implementation\n\n```bash\n# Shared memo for SCC group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local key=\"is_even:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n\nis_odd() {\n    local key=\"is_odd:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n```", "answer_tailored": true}
{"pair_id": "memoization-strategy_p2", "cluster_id": "memoization-strategy", "question": "How does UnifyWeaver implement memoization?", "question_type": "medium", "answer": "UnifyWeaver implements memoization by caching function results in associative arrays to avoid redundant computation. The approach varies based on whether functions are mutually recursive:\n\n**For Simple Recursion:**\nIndividual functions use dedicated cache tables:\n\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check cache first\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Compute and cache\n    local result=$(compute_factorial \"$n\")\n    factorial_memo[$n]=\"$result\"\n    echo \"$result\"\n}\n```\n\n**For Mutually Recursive Functions:**\nUnifyWeaver uses shared memoization tables for strongly connected components (SCCs). This is critical because functions in mutual recursion call each other, and separate caches would miss cross-function lookups.\n\nExample with `is_even` and `is_odd`:\n\n```bash\n# Shared memo for the SCC group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local key=\"is_even:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n\nis_odd() {\n    local key=\"is_odd:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n```\n\nThe shared cache also enables cycle detection. When a function is already being computed (marked in the memo), re-encountering it indicates a circular dependency, preventing infinite loops.\n\nThis strategy dramatically reduces redundant computation\u2014for example, `fib(5)` without memoization computes `fib(3)` multiple times, while with memoization it's computed once and cached for subsequent calls.\n\nSee education/book-02-bash-target/06_advanced_recursion.md for detailed examples and diagrams.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["memoization", "caching", "performance", "mutual-recursion"], "original_answer": "## Memoization Strategy\n\nMemoization caches function results to avoid redundant computation.\n\n### Basic Concept\n\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check cache first\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Compute result\n    local result=$(compute_factorial \"$n\")\n    \n    # Cache it\n    factorial_memo[$n]=\"$result\"\n    echo \"$result\"\n}\n```\n\n### Why Memoization Helps\n\n```\nWithout memo: fib(5) computes fib(3) twice\n  fib(5)\n  \u251c\u2500\u2500 fib(4)\n  \u2502   \u251c\u2500\u2500 fib(3)  \u2190 computed\n  \u2502   \u2514\u2500\u2500 fib(2)\n  \u2514\u2500\u2500 fib(3)      \u2190 computed AGAIN\n\nWith memo: fib(3) computed once, cached\n  fib(5)\n  \u251c\u2500\u2500 fib(4)\n  \u2502   \u251c\u2500\u2500 fib(3)  \u2190 computed, cached\n  \u2502   \u2514\u2500\u2500 fib(2)\n  \u2514\u2500\u2500 fib(3)      \u2190 cache hit!\n```\n\n### Why Mutual Recursion Needs Shared Memo\n\nSeparate tables would miss cross-function caching:\n\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n\nSeparate memos:\n  is_even_memo: {4: ?, 2: ?}  \u2190 waiting for is_odd\n  is_odd_memo: {3: ?, 1: true}\n  \nShared memo:\n  shared_memo: {\n    \"is_even:4\": true,\n    \"is_odd:3\": true,\n    \"is_even:2\": true,\n    \"is_odd:1\": true\n  }\n```\n\n### Without Shared Memo: Infinite Loop Risk\n\n```prolog\na(X) :- b(X).\nb(X) :- a(X).  % Circular!\n```\n\nShared memo detects the cycle:\n```bash\na(5):  Check memo[\"a:5\"] - not found, mark as computing\nb(5):  Check memo[\"b:5\"] - not found, mark as computing  \na(5):  Check memo[\"a:5\"] - FOUND (computing) \u2192 cycle detected!\n```\n\n### UnifyWeaver's Implementation\n\n```bash\n# Shared memo for SCC group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local key=\"is_even:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n\nis_odd() {\n    local key=\"is_odd:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n```", "answer_tailored": true}
{"pair_id": "memoization-strategy_p3", "cluster_id": "memoization-strategy", "question": "What would happen without shared memoization?", "question_type": "medium", "answer": "Without shared memoization, mutual recursion can lead to redundant computation and infinite loops. Here's what would go wrong:\n\n**Missed Cross-Function Caching**\n\nWhen `is_even` and `is_odd` use separate memo tables, they can't benefit from each other's cached results:\n\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n\nSeparate tables miss opportunities:\n  is_even_memo: {4: ?, 2: ?}  # waiting for is_odd results\n  is_odd_memo: {3: ?, 1: true}  # can't help is_even\n```\n\n**Infinite Loop Risk**\n\nThe critical problem is cycle detection. Without a shared memo, circular dependencies cause infinite recursion:\n\n```prolog\na(X) :- b(X).\nb(X) :- a(X).  % Circular dependency!\n```\n\nWith separate memos, each function doesn't know the other is computing:\n```bash\na(5): Check a_memo[\"5\"] - not found, start computing\nb(5): Check b_memo[\"5\"] - not found, start computing\na(5): Check a_memo[\"5\"] - not found, start computing again\n# Infinite loop!\n```\n\nShared memoization solves this by tracking all in-progress computations:\n```bash\na(5): Check memo[\"a:5\"] - not found, mark as \"computing\"\nb(5): Check memo[\"b:5\"] - not found, mark as \"computing\"\na(5): Check memo[\"a:5\"] - FOUND \"computing\" \u2192 cycle detected!\n```\n\nUnifyWeaver generates shared memo tables for each SCC (strongly connected component) group to prevent these issues. See `education/book-02-bash-target/06_advanced_recursion.md` for implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["memoization", "caching", "performance", "mutual-recursion"], "original_answer": "## Memoization Strategy\n\nMemoization caches function results to avoid redundant computation.\n\n### Basic Concept\n\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check cache first\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Compute result\n    local result=$(compute_factorial \"$n\")\n    \n    # Cache it\n    factorial_memo[$n]=\"$result\"\n    echo \"$result\"\n}\n```\n\n### Why Memoization Helps\n\n```\nWithout memo: fib(5) computes fib(3) twice\n  fib(5)\n  \u251c\u2500\u2500 fib(4)\n  \u2502   \u251c\u2500\u2500 fib(3)  \u2190 computed\n  \u2502   \u2514\u2500\u2500 fib(2)\n  \u2514\u2500\u2500 fib(3)      \u2190 computed AGAIN\n\nWith memo: fib(3) computed once, cached\n  fib(5)\n  \u251c\u2500\u2500 fib(4)\n  \u2502   \u251c\u2500\u2500 fib(3)  \u2190 computed, cached\n  \u2502   \u2514\u2500\u2500 fib(2)\n  \u2514\u2500\u2500 fib(3)      \u2190 cache hit!\n```\n\n### Why Mutual Recursion Needs Shared Memo\n\nSeparate tables would miss cross-function caching:\n\n```\nis_even(4) \u2192 is_odd(3) \u2192 is_even(2) \u2192 is_odd(1) \u2192 true\n\nSeparate memos:\n  is_even_memo: {4: ?, 2: ?}  \u2190 waiting for is_odd\n  is_odd_memo: {3: ?, 1: true}\n  \nShared memo:\n  shared_memo: {\n    \"is_even:4\": true,\n    \"is_odd:3\": true,\n    \"is_even:2\": true,\n    \"is_odd:1\": true\n  }\n```\n\n### Without Shared Memo: Infinite Loop Risk\n\n```prolog\na(X) :- b(X).\nb(X) :- a(X).  % Circular!\n```\n\nShared memo detects the cycle:\n```bash\na(5):  Check memo[\"a:5\"] - not found, mark as computing\nb(5):  Check memo[\"b:5\"] - not found, mark as computing  \na(5):  Check memo[\"a:5\"] - FOUND (computing) \u2192 cycle detected!\n```\n\n### UnifyWeaver's Implementation\n\n```bash\n# Shared memo for SCC group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local key=\"is_even:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n\nis_odd() {\n    local key=\"is_odd:$*\"\n    [[ -n \"${is_even_is_odd_memo[$key]}\" ]] && ...\n}\n```", "answer_tailored": true}
