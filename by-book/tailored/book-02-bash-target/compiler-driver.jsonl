{"pair_id": "compiler-driver_p0", "cluster_id": "compiler-driver", "question": "What is the UnifyWeaver compiler driver?", "question_type": "medium", "answer": "The UnifyWeaver compiler driver is a module (`compiler_driver.pl`) that provides **one-click compilation with automatic dependency resolution**. Instead of manually compiling each predicate and its dependencies separately, you can compile everything with a single call.\n\n**Key predicate: `compile/3`**\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- ['education/family_tree'].\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**How the compiler driver works:**\n\n1. **Dependency Analysis**: Analyzes the target predicate to discover all dependencies\n2. **Recursive Compilation**: Compiles dependencies first, then the target\n3. **Duplicate Prevention**: Tracks what's already compiled to avoid redundant work and infinite loops\n4. **Script Collection**: Returns a list of all generated script paths\n\nThis eliminates the tedious, error-prone process of manually tracking and compiling dependencies in the correct order. For complex projects with multiple interdependent predicates, the compiler driver handles the entire compilation workflow automatically.\n\nYou can also use the compiled script list to generate test runners that source all necessary files:\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n```\n\nSee education/book-02-bash-target/09_recursive_compilation.md for complete details on recursive compilation and dependency resolution.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compiler-driver", "one-click-compilation", "dependency-resolution"], "original_answer": "## The Compiler Driver\n\nThe `compiler_driver.pl` module provides **one-click compilation** with automatic dependency resolution.\n\n### The Problem\n\nManual compilation requires:\n1. Compile `parent/2` facts \u2192 `parent.sh`\n2. Compile `ancestor/2` rule \u2192 `ancestor.sh`\n\nThis is tedious and error-prone for complex projects.\n\n### The Solution: compile/3\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n?- ['education/family_tree'].\n\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One call compiles everything!**\n\n### How It Works\n\n1. **Dependency Analysis**: Scans predicate to find dependencies\n2. **Recursive Compilation**: Compiles each dependency first\n3. **Tracks Compiled**: Avoids redundant work and infinite loops\n4. **Compiles Target**: Finally compiles requested predicate\n5. **Returns List**: All generated script paths\n\n### Generating Test Runners\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nThe `Scripts` variable gives the exact files to source.", "answer_tailored": true}
{"pair_id": "compiler-driver_p1", "cluster_id": "compiler-driver", "question": "How do I compile with automatic dependency resolution?", "question_type": "medium", "answer": "UnifyWeaver's `compiler_driver.pl` module provides automatic dependency resolution through the `compile/3` predicate.\n\n**Basic Usage:**\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- ['education/family_tree'].\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\nA single call to `compile/3` automatically:\n1. Analyzes the predicate to discover all dependencies\n2. Recursively compiles each dependency in the correct order\n3. Tracks what's been compiled to prevent redundant work and infinite loops\n4. Compiles the target predicate\n5. Returns the complete list of generated scripts\n\n**Example: Generating Test Runners**\n\nThe returned script list makes it easy to create test runners:\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n```\n\nThis eliminates the manual process of tracking dependencies\u2014instead of separately compiling `parent/2` facts and then `ancestor/2` rules, one call handles everything.\n\nSee education/book-02-bash-target/09_recursive_compilation.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compiler-driver", "one-click-compilation", "dependency-resolution"], "original_answer": "## The Compiler Driver\n\nThe `compiler_driver.pl` module provides **one-click compilation** with automatic dependency resolution.\n\n### The Problem\n\nManual compilation requires:\n1. Compile `parent/2` facts \u2192 `parent.sh`\n2. Compile `ancestor/2` rule \u2192 `ancestor.sh`\n\nThis is tedious and error-prone for complex projects.\n\n### The Solution: compile/3\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n?- ['education/family_tree'].\n\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One call compiles everything!**\n\n### How It Works\n\n1. **Dependency Analysis**: Scans predicate to find dependencies\n2. **Recursive Compilation**: Compiles each dependency first\n3. **Tracks Compiled**: Avoids redundant work and infinite loops\n4. **Compiles Target**: Finally compiles requested predicate\n5. **Returns List**: All generated script paths\n\n### Generating Test Runners\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nThe `Scripts` variable gives the exact files to source.", "answer_tailored": true}
{"pair_id": "compiler-driver_p2", "cluster_id": "compiler-driver", "question": "What does compile/3 do?", "question_type": "medium", "answer": "The `compile/3` predicate provides one-click compilation with automatic dependency resolution. It takes three arguments:\n\n1. **Predicate specifier** (e.g., `ancestor/2`) - what to compile\n2. **Options list** (e.g., `[output_dir('output')]`) - compilation settings\n3. **Scripts variable** - unified with list of generated script paths\n\n**Example:**\n```prolog\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**What it does:**\n1. Analyzes the predicate to identify all dependencies\n2. Recursively compiles each dependency first\n3. Tracks already-compiled predicates to avoid duplication and infinite loops\n4. Compiles the target predicate itself\n5. Returns a list of all generated script paths\n\nThis eliminates manual compilation of each dependency. Instead of separately compiling `parent/2` then `ancestor/2`, one call handles the entire dependency chain.\n\nThe returned `Scripts` list is particularly useful for generating test runners that need to source all required scripts in the correct order.\n\nSee education/book-02-bash-target/09_recursive_compilation.md for implementation details and the compiler_driver.pl module for the full API.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compiler-driver", "one-click-compilation", "dependency-resolution"], "original_answer": "## The Compiler Driver\n\nThe `compiler_driver.pl` module provides **one-click compilation** with automatic dependency resolution.\n\n### The Problem\n\nManual compilation requires:\n1. Compile `parent/2` facts \u2192 `parent.sh`\n2. Compile `ancestor/2` rule \u2192 `ancestor.sh`\n\nThis is tedious and error-prone for complex projects.\n\n### The Solution: compile/3\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n?- ['education/family_tree'].\n\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One call compiles everything!**\n\n### How It Works\n\n1. **Dependency Analysis**: Scans predicate to find dependencies\n2. **Recursive Compilation**: Compiles each dependency first\n3. **Tracks Compiled**: Avoids redundant work and infinite loops\n4. **Compiles Target**: Finally compiles requested predicate\n5. **Returns List**: All generated script paths\n\n### Generating Test Runners\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nThe `Scripts` variable gives the exact files to source.", "answer_tailored": true}
{"pair_id": "compiler-driver_p3", "cluster_id": "compiler-driver", "question": "How is one-click compilation achieved?", "question_type": "medium", "answer": "UnifyWeaver achieves one-click compilation through the `compiler_driver.pl` module's `compile/3` predicate, which automatically handles dependency resolution and recursive compilation.\n\n### The Challenge\n\nWithout automation, you'd need to manually compile each dependency in order:\n1. First compile `parent/2` facts \u2192 `parent.sh`\n2. Then compile `ancestor/2` rule \u2192 `ancestor.sh`\n\nThis becomes unmanageable for projects with complex dependency chains.\n\n### Single-Command Compilation\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- ['education/family_tree'].\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One `compile/3` call generates all required scripts!**\n\n### Automation Process\n\nThe compiler driver:\n1. **Analyzes Dependencies**: Examines the predicate to identify what it depends on\n2. **Compiles Recursively**: Processes each dependency before the target\n3. **Tracks Progress**: Prevents duplicate compilation and circular dependency issues\n4. **Compiles Target**: Generates the requested predicate's script\n5. **Returns Paths**: Provides a list of all generated script files\n\n### Practical Application\n\nYou can use the returned script list to generate test runners:\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nSee education/book-02-bash-target/09_recursive_compilation.md for complete details on the compilation driver.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compiler-driver", "one-click-compilation", "dependency-resolution"], "original_answer": "## The Compiler Driver\n\nThe `compiler_driver.pl` module provides **one-click compilation** with automatic dependency resolution.\n\n### The Problem\n\nManual compilation requires:\n1. Compile `parent/2` facts \u2192 `parent.sh`\n2. Compile `ancestor/2` rule \u2192 `ancestor.sh`\n\nThis is tedious and error-prone for complex projects.\n\n### The Solution: compile/3\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n?- ['education/family_tree'].\n\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One call compiles everything!**\n\n### How It Works\n\n1. **Dependency Analysis**: Scans predicate to find dependencies\n2. **Recursive Compilation**: Compiles each dependency first\n3. **Tracks Compiled**: Avoids redundant work and infinite loops\n4. **Compiles Target**: Finally compiles requested predicate\n5. **Returns List**: All generated script paths\n\n### Generating Test Runners\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nThe `Scripts` variable gives the exact files to source.", "answer_tailored": true}
{"pair_id": "compile-api-reference_p0", "cluster_id": "compile-api-reference", "question": "What is the difference between compile/3 and compile_recursive/3?", "question_type": "medium", "answer": "The key difference is in dependency handling:\n\n**compile/3** (high-level, recommended):\n- Automatically detects and compiles all dependencies\n- When you compile `ancestor/2`, it also compiles `parent/2` if needed\n- Returns a list of all generated script paths\n- Handles the entire compilation workflow\n\n**compile_recursive/3** (low-level):\n- Compiles only the single predicate you specify\n- Does NOT resolve or compile dependencies\n- You must manually compile dependencies first\n- Gives you fine-grained control over the compilation order\n\n**Example showing the difference:**\n\n```prolog\n% compile/3 - compiles ancestor/2 AND parent/2 automatically\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% compile_recursive/3 - compiles ONLY ancestor/2\n?- compile_recursive(ancestor/2, [], AncestorCode).\n% parent/2 is NOT compiled - you'd need a separate call\n```\n\nUse `compile/3` for normal compilation tasks. Only use `compile_recursive/3` when you need manual control over which predicates are compiled and in what order.\n\nFor more details, see `education/book-02-bash-target/09_recursive_compilation.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compile/3", "compile_recursive/3", "api", "options"], "original_answer": "## Compile API Reference\n\n### compile/3 (Recommended)\n\nThe high-level interface with automatic dependency resolution:\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Parameters:**\n- `Predicate`: `name/arity` (e.g., `ancestor/2`)\n- `Options`: List of options\n- `GeneratedScripts`: Output - list of generated file paths\n\n**Common Options:**\n\n| Option | Description |\n|--------|-------------|\n| `output_dir(Dir)` | Where to save generated scripts |\n| `target(bash)` | Target language (default: bash) |\n| `unique(true/false)` | Constraint for deduplication |\n\n### compile_recursive/3 (Low-level)\n\nCompiles a single predicate without dependency resolution:\n\n```prolog\n% Compiles ONLY ancestor/2, not its dependencies\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n**When to use each:**\n\n| Function | Use When |\n|----------|----------|\n| `compile/3` | Normal compilation - handles everything |\n| `compile_recursive/3` | Manual control, dependencies already compiled |\n\n### Example\n\n```prolog\n% Automatic (recommended)\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% Manual (advanced)\n?- compile_recursive(parent/2, [], ParentCode),\n   compile_recursive(ancestor/2, [], AncestorCode).\n```", "answer_tailored": true}
{"pair_id": "compile-api-reference_p1", "cluster_id": "compile-api-reference", "question": "What options does compile/3 accept?", "question_type": "medium", "answer": "The `compile/3` predicate accepts the following options:\n\n**Common Options:**\n\n- `output_dir(Dir)` - Specifies the directory where generated scripts should be saved\n- `target(bash)` - Sets the target language (bash is the default; other targets include python, go, rust, csharp, powershell, sql)\n- `unique(true/false)` - Enables or disables constraint-based deduplication\n\n**Usage Example:**\n\n```prolog\n?- compile(ancestor/2, [output_dir('out'), target(bash), unique(true)], Scripts).\n```\n\nThe options parameter is a list that can contain any combination of these settings. If no options are needed, you can pass an empty list `[]`.\n\nFor complete details on the compilation API and recursive compilation strategies, see education/book-02-bash-target/09_recursive_compilation.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compile/3", "compile_recursive/3", "api", "options"], "original_answer": "## Compile API Reference\n\n### compile/3 (Recommended)\n\nThe high-level interface with automatic dependency resolution:\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Parameters:**\n- `Predicate`: `name/arity` (e.g., `ancestor/2`)\n- `Options`: List of options\n- `GeneratedScripts`: Output - list of generated file paths\n\n**Common Options:**\n\n| Option | Description |\n|--------|-------------|\n| `output_dir(Dir)` | Where to save generated scripts |\n| `target(bash)` | Target language (default: bash) |\n| `unique(true/false)` | Constraint for deduplication |\n\n### compile_recursive/3 (Low-level)\n\nCompiles a single predicate without dependency resolution:\n\n```prolog\n% Compiles ONLY ancestor/2, not its dependencies\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n**When to use each:**\n\n| Function | Use When |\n|----------|----------|\n| `compile/3` | Normal compilation - handles everything |\n| `compile_recursive/3` | Manual control, dependencies already compiled |\n\n### Example\n\n```prolog\n% Automatic (recommended)\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% Manual (advanced)\n?- compile_recursive(parent/2, [], ParentCode),\n   compile_recursive(ancestor/2, [], AncestorCode).\n```", "answer_tailored": true}
{"pair_id": "compile-api-reference_p2", "cluster_id": "compile-api-reference", "question": "How do I specify the output directory?", "question_type": "medium", "answer": "The `output_dir(Dir)` option controls where generated scripts are saved:\n\n```prolog\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n```\n\nSimply include `output_dir('your/path')` in the options list when calling `compile/3`. The compiler will write all generated scripts (including dependencies) to that directory.\n\n**Other useful options:**\n- `target(bash)` - Set target language (default: bash)\n- `unique(true/false)` - Enable constraint-based deduplication\n\nFor manual compilation using `compile_recursive/3`, you'll need to handle output paths yourself, as this low-level interface returns code as text rather than writing files directly.\n\nSee education/book-02-bash-target/09_recursive_compilation.md for complete details on the compilation API.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compile/3", "compile_recursive/3", "api", "options"], "original_answer": "## Compile API Reference\n\n### compile/3 (Recommended)\n\nThe high-level interface with automatic dependency resolution:\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Parameters:**\n- `Predicate`: `name/arity` (e.g., `ancestor/2`)\n- `Options`: List of options\n- `GeneratedScripts`: Output - list of generated file paths\n\n**Common Options:**\n\n| Option | Description |\n|--------|-------------|\n| `output_dir(Dir)` | Where to save generated scripts |\n| `target(bash)` | Target language (default: bash) |\n| `unique(true/false)` | Constraint for deduplication |\n\n### compile_recursive/3 (Low-level)\n\nCompiles a single predicate without dependency resolution:\n\n```prolog\n% Compiles ONLY ancestor/2, not its dependencies\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n**When to use each:**\n\n| Function | Use When |\n|----------|----------|\n| `compile/3` | Normal compilation - handles everything |\n| `compile_recursive/3` | Manual control, dependencies already compiled |\n\n### Example\n\n```prolog\n% Automatic (recommended)\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% Manual (advanced)\n?- compile_recursive(parent/2, [], ParentCode),\n   compile_recursive(ancestor/2, [], AncestorCode).\n```", "answer_tailored": true}
{"pair_id": "compile-api-reference_p3", "cluster_id": "compile-api-reference", "question": "Which compile function should I use?", "question_type": "medium", "answer": "For most cases, use **`compile/3`** - it's the recommended high-level interface that automatically handles dependency resolution for you.\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Example:**\n```prolog\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n```\n\nThis compiles `ancestor/2` along with any predicates it depends on (like `parent/2`).\n\n**Common options:**\n- `output_dir(Dir)` - Where to save generated scripts\n- `target(bash)` - Target language (default: bash)\n- `unique(true/false)` - Constraint for deduplication\n\n**When to use `compile_recursive/3` instead:**\n\nOnly use the low-level `compile_recursive/3` if you need manual control and are managing dependencies yourself:\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\nThis compiles only the specified predicate without resolving dependencies.\n\nFor details on the compilation process, see education/book-02-bash-target/09_recursive_compilation.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/09_recursive_compilation.md", "topics": ["compile/3", "compile_recursive/3", "api", "options"], "original_answer": "## Compile API Reference\n\n### compile/3 (Recommended)\n\nThe high-level interface with automatic dependency resolution:\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Parameters:**\n- `Predicate`: `name/arity` (e.g., `ancestor/2`)\n- `Options`: List of options\n- `GeneratedScripts`: Output - list of generated file paths\n\n**Common Options:**\n\n| Option | Description |\n|--------|-------------|\n| `output_dir(Dir)` | Where to save generated scripts |\n| `target(bash)` | Target language (default: bash) |\n| `unique(true/false)` | Constraint for deduplication |\n\n### compile_recursive/3 (Low-level)\n\nCompiles a single predicate without dependency resolution:\n\n```prolog\n% Compiles ONLY ancestor/2, not its dependencies\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n**When to use each:**\n\n| Function | Use When |\n|----------|----------|\n| `compile/3` | Normal compilation - handles everything |\n| `compile_recursive/3` | Manual control, dependencies already compiled |\n\n### Example\n\n```prolog\n% Automatic (recommended)\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% Manual (advanced)\n?- compile_recursive(parent/2, [], ParentCode),\n   compile_recursive(ancestor/2, [], AncestorCode).\n```", "answer_tailored": true}
