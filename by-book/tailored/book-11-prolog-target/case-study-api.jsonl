{"pair_id": "prolog-case-001_p0", "cluster_id": "prolog-case-001", "question": "How do I compile a Prolog predicate to a standalone binary?", "question_type": "medium", "answer": "To compile a Prolog predicate to a standalone binary using UnifyWeaver:\n\n**1. Write your predicates (factorial.pl):**\n```prolog\nfactorial(0, 1) :- !.\nfactorial(N, R) :- N > 0, N1 is N-1, factorial(N1, R1), R is N*R1.\n\ntest_factorial :- factorial(5, F), format('5! = ~w~n', [F]).\n```\n\n**2. Use UnifyWeaver's Prolog target to generate compiled output:**\n```prolog\n:- use_module('src/unifyweaver/targets/prolog_target').\n\nmain :-\n    generate_prolog_script([factorial/2, test_factorial/0],\n        [dialect(gnu), compile(true), entry_point(test_factorial)], Code),\n    write_prolog_script(Code, 'factorial_gnu.pl',\n        [dialect(gnu), compile(true)]).\n```\n\n**3. Execute the binary:**\n```bash\n$ ./factorial_gnu\n5! = 120\n\n$ time ./factorial_gnu\nreal    0m0.002s  # Native binary startup (~2ms)\n```\n\nUnifyWeaver automatically generates the `:- initialization(test_factorial).` directive to enable compiled binary execution. The `compile(true)` option produces a native executable instead of an interpreted script.\n\nSee education/book-11-prolog-target/15_case_study.md for complete workflow examples.", "answer_variant": "default", "answer_source": "book-11-prolog-target/15_case_study.md", "topics": [], "original_answer": "Complete workflow for factorial example:\n\n**1. Define predicates (factorial.pl):**\n```prolog\nfactorial(0, 1) :- !.\nfactorial(N, R) :- N > 0, N1 is N-1, factorial(N1, R1), R is N*R1.\n\ntest_factorial :- factorial(5, F), format('5! = ~w~n', [F]).\n```\n\n**2. Generate and compile:**\n```prolog\n:- use_module('src/unifyweaver/targets/prolog_target').\n\nmain :-\n    generate_prolog_script([factorial/2, test_factorial/0],\n        [dialect(gnu), compile(true), entry_point(test_factorial)], Code),\n    write_prolog_script(Code, 'factorial_gnu.pl',\n        [dialect(gnu), compile(true)]).\n```\n\n**3. Result:**\n```bash\n$ ./factorial_gnu\n5! = 120\n\n$ time ./factorial_gnu\nreal    0m0.002s  # ~2ms startup (native binary)\n```\n\nKey: UnifyWeaver generates `:- initialization(test_factorial).` for compiled mode.", "answer_tailored": true}
{"pair_id": "prolog-api-001_p0", "cluster_id": "prolog-api-001", "question": "What are the key Prolog target API predicates?", "question_type": "medium", "answer": "The Prolog target provides several categories of API predicates:\n\n**Script Generation & Output:**\n- `generate_prolog_script(+Predicates, +Options, -Code)` - Core predicate for generating Prolog script code with options like `dialect(D)`, `compile(Bool)`, and `entry_point(Goal)`\n- `write_prolog_script(+Code, +Path)` and `write_prolog_script(+Code, +Path, +Options)` - Write generated code to files, optionally compiling with options such as `fail_on_compile_error(Bool)`\n\n**Dialect Management:**\n- `supported_dialect(?Dialect)` - Query or check supported dialects (swi, gnu)\n- `dialect_capabilities(+Dialect, -Caps)` - Retrieve capability information for a dialect\n- `dialect_shebang(+Dialect, -Shebang)` - Get appropriate shebang line\n- `dialect_initialization(+Dialect, +Goal, +Opts, -Init)` - Generate dialect-specific initialization code\n- `validate_for_dialect(+Dialect, +Preds, -Issues)` - Check predicate compatibility with target dialect\n\n**Compilation & Analysis:**\n- `compile_script(+Dialect, +ScriptPath)` - Compile with error checking\n- `compile_script_safe(+Dialect, +Path, +Opts)` - Compile with graceful error handling\n- `analyze_dependencies(+Predicates, -Dependencies)` - Extract dependency information\n\nFor complete details and usage examples, see education/book-11-prolog-target/appendix_a_api_reference.md.", "answer_variant": "default", "answer_source": "book-11-prolog-target/appendix_a_api_reference.md", "topics": [], "original_answer": "**Main entry points:**\n\n```prolog\n% Generate script code\ngenerate_prolog_script(+Predicates, +Options, -Code)\n% Options: dialect(D), compile(Bool), entry_point(Goal)\n\n% Write to file (with optional compilation)\nwrite_prolog_script(+Code, +Path)\nwrite_prolog_script(+Code, +Path, +Options)\n% Options: dialect(D), compile(Bool), fail_on_compile_error(Bool)\n\n% Analyze dependencies\nanalyze_dependencies(+Predicates, -Dependencies)\n```\n\n**Dialect predicates:**\n```prolog\nsupported_dialect(?Dialect)           % swi, gnu\ndialect_capabilities(+Dialect, -Caps)\ndialect_shebang(+Dialect, -Shebang)\ndialect_initialization(+Dialect, +Goal, +Opts, -Init)\nvalidate_for_dialect(+Dialect, +Preds, -Issues)\n```\n\n**Compilation:**\n```prolog\ncompile_script(+Dialect, +ScriptPath)      % With error checking\ncompile_script_safe(+Dialect, +Path, +Opts) % Graceful fallback\n```", "answer_tailored": true}
{"pair_id": "prolog-api-001_p0", "cluster_id": "prolog-api-001", "question": "What are common Prolog target usage patterns?", "question_type": "medium", "answer": "Common usage patterns for the Prolog target include:\n\n**1. Basic script generation** - Generate a simple Prolog script from predicates:\n```prolog\ngenerate_prolog_script([my_pred/2], [], Code),\nwrite_prolog_script(Code, 'output.pl').\n```\n\n**2. Compiled executable** - Create a compiled binary (e.g., for GNU Prolog):\n```prolog\ngenerate_prolog_script(Preds, [dialect(gnu), compile(true)], Code),\nwrite_prolog_script(Code, 'app.pl', [dialect(gnu), compile(true)]).\n```\n\n**3. Cross-dialect output** - Generate scripts for multiple Prolog implementations:\n```prolog\ngenerate_both(Preds, Base) :-\n    generate_prolog_script(Preds, [dialect(swi)], Swi),\n    atom_concat(Base, '_swi.pl', SwiPath),\n    write_prolog_script(Swi, SwiPath),\n    generate_prolog_script(Preds, [dialect(gnu)], Gnu),\n    atom_concat(Base, '_gnu.pl', GnuPath),\n    write_prolog_script(Gnu, GnuPath).\n```\n\n**4. Validated generation** - Check dialect compatibility before generating:\n```prolog\nsafe_generate(Preds, Dialect, Code) :-\n    validate_for_dialect(Dialect, Preds, Issues),\n    Issues = [],  % Fail if incompatible\n    generate_prolog_script(Preds, [dialect(Dialect)], Code).\n```\n\nFor more details on Prolog target implementation, see education/book-11-prolog-target/.", "answer_variant": "default", "answer_source": "book-11-prolog-target/appendix_a_api_reference.md", "topics": [], "original_answer": "**Pattern 1: Simple script generation**\n```prolog\ngenerate_prolog_script([my_pred/2], [], Code),\nwrite_prolog_script(Code, 'output.pl').\n```\n\n**Pattern 2: Compiled binary**\n```prolog\ngenerate_prolog_script(Preds, [dialect(gnu), compile(true)], Code),\nwrite_prolog_script(Code, 'app.pl', [dialect(gnu), compile(true)]).\n```\n\n**Pattern 3: Multi-dialect generation**\n```prolog\ngenerate_both(Preds, Base) :-\n    generate_prolog_script(Preds, [dialect(swi)], Swi),\n    atom_concat(Base, '_swi.pl', SwiPath),\n    write_prolog_script(Swi, SwiPath),\n    generate_prolog_script(Preds, [dialect(gnu)], Gnu),\n    atom_concat(Base, '_gnu.pl', GnuPath),\n    write_prolog_script(Gnu, GnuPath).\n```\n\n**Pattern 4: With validation first**\n```prolog\nsafe_generate(Preds, Dialect, Code) :-\n    validate_for_dialect(Dialect, Preds, Issues),\n    Issues = [],  % Fail if incompatible\n    generate_prolog_script(Preds, [dialect(Dialect)], Code).\n```", "answer_tailored": true}
