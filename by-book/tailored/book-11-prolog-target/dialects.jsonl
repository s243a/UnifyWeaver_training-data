{"pair_id": "prolog-dialect-001_p0", "cluster_id": "prolog-dialect-001", "question": "What are the differences between SWI-Prolog and GNU Prolog dialects?", "question_type": "medium", "answer": "SWI-Prolog and GNU Prolog differ primarily in their execution models and capabilities. SWI-Prolog uses an interpreted approach with approximately 150ms startup time, while GNU Prolog compiles to native code with roughly 2ms startup. \n\nFor modularity, SWI-Prolog provides a complete module system with `use_module`, whereas GNU Prolog offers only basic `include` functionality. SWI-Prolog ships with extensive libraries including HTTP and database support, compared to GNU Prolog's minimal library set. Debugging tools are more sophisticated in SWI-Prolog with graphical interfaces, while GNU Prolog provides basic debugging capabilities.\n\nDeployment differs significantly: SWI-Prolog applications require the runtime environment, but GNU Prolog can produce standalone executables with minimal dependencies.\n\n**When to choose each:**\n- SWI-Prolog: Development environments, web applications, projects needing rich module systems\n- GNU Prolog: Standalone binaries, performance-critical startup, minimal deployment footprint\n\n```prolog\n?- dialect_capabilities(swi, Caps).\n% Caps = [name('SWI-Prolog'), compilation(interpreted), constraint_solver(clpfd), module_system(full)]\n\n?- dialect_capabilities(gnu, Caps).\n% Caps = [name('GNU Prolog'), compilation(compiled), constraint_solver(fd), module_system(basic)]\n```\n\nFor comprehensive dialect coverage, see education/book-11-prolog-target/03_dialects.md.", "answer_variant": "default", "answer_source": "book-11-prolog-target/03_dialects.md", "topics": [], "original_answer": "| Feature | SWI-Prolog | GNU Prolog |\n|---------|------------|------------|\n| Execution | Interpreted | Compiled native |\n| Startup | ~150ms | ~2ms |\n| Module System | Full (use_module) | Basic (include) |\n| Libraries | HTTP, DB, extensive | Minimal |\n| Debugging | Rich graphical | Basic |\n| Deployment | Requires runtime | Single executable |\n\n**SWI-Prolog strengths**: Development, web apps, complex modules\n**GNU Prolog strengths**: Standalone binaries, fast startup, minimal deps\n\n```prolog\n?- dialect_capabilities(swi, Caps).\n% Caps = [name('SWI-Prolog'), compilation(interpreted), constraint_solver(clpfd), module_system(full)]\n\n?- dialect_capabilities(gnu, Caps).\n% Caps = [name('GNU Prolog'), compilation(compiled), constraint_solver(fd), module_system(basic)]\n```", "answer_tailored": true}
{"pair_id": "prolog-dialect-001_p0", "cluster_id": "prolog-dialect-001", "question": "How do initialization directives differ between Prolog dialects?", "question_type": "medium", "answer": "Initialization directives vary significantly across Prolog dialects and execution modes:\n\n**SWI-Prolog** uses a two-argument initialization directive:\n```prolog\n:- initialization(main, main).\n```\n\n**GNU Prolog** requires different forms depending on whether you're compiling or interpreting:\n- Compiled binaries (gplc): Single-argument form `:-\u200b initialization(main).`\n- Interactive/interpreted: Direct goal `:-\u200b main.`\n\nUnifyWeaver addresses these differences through `dialect_initialization/4`, which generates the appropriate form based on dialect and compilation mode:\n```prolog\n?- dialect_initialization(gnu, test, [compile(true)], Init).\n% Init = ':- initialization(test).'\n\n?- dialect_initialization(gnu, test, [compile(false)], Init).\n% Init = ':- test.'\n```\n\nMismatching the initialization form to your target dialect and mode will result in \"no initial goal\" errors when executing compiled binaries. For comprehensive coverage of dialect-specific features, see education/book-11-prolog-target/03_dialects.md.", "answer_variant": "default", "answer_source": "book-11-prolog-target/03_dialects.md", "topics": [], "original_answer": "Critical difference - initialization is dialect and mode specific:\n\n**SWI-Prolog:**\n```prolog\n:- initialization(main, main).  % 2-arg form\n```\n\n**GNU Prolog (Compiled binary):**\n```prolog\n:- initialization(main).  % 1-arg form for gplc\n```\n\n**GNU Prolog (Interpreted):**\n```prolog\n:- main.  % Direct goal execution\n```\n\nUnifyWeaver's `dialect_initialization/4` handles this:\n```prolog\n?- dialect_initialization(gnu, test, [compile(true)], Init).\n% Init = ':- initialization(test).'\n\n?- dialect_initialization(gnu, test, [compile(false)], Init).\n% Init = ':- test.'\n```\n\nUsing wrong form causes \"no initial goal\" errors in compiled binaries.", "answer_tailored": true}
{"pair_id": "prolog-dialect-002_p0", "cluster_id": "prolog-dialect-002", "question": "When should I use SWI-Prolog vs GNU Prolog?", "question_type": "medium", "answer": "**Choose SWI-Prolog for:**\n- Active development and rapid prototyping\n- Projects requiring HTTP servers or database connectivity\n- Complex module structures and dependencies\n- Access to comprehensive debugging facilities\n- Interactive development with the REPL\n\n**Choose GNU Prolog for:**\n- Creating standalone executable binaries\n- Performance-critical applications needing fast startup\n- Deployments with minimal runtime dependencies\n- Distribution to end users without Prolog installed\n- Embedded or resource-limited environments\n\n**Recommended workflow: Develop in SWI-Prolog, compile for GNU Prolog deployment**\n```prolog\n% Development phase\nswipl my_app.pl\n\n% Production deployment\n?- generate_prolog_script([my_app/0],\n                         [dialect(gnu), compile(true)],\n                         Code),\n   write_prolog_script(Code, 'my_app_gnu.pl',\n                      [dialect(gnu), compile(true)]).\n\n% Produces: my_app_gnu (native executable)\n```\n\nFor more on Prolog dialect compatibility in UnifyWeaver, see education/book-11-prolog-target/03_dialects.md.", "answer_variant": "default", "answer_source": "book-11-prolog-target/03_dialects.md", "topics": [], "original_answer": "**Use SWI-Prolog when:**\n- Development and prototyping\n- Need HTTP server, database integration\n- Complex module hierarchies\n- Rich debugging tools\n- Interactive REPL work\n\n**Use GNU Prolog when:**\n- Standalone executables required\n- Fast startup time critical\n- Minimal dependencies needed\n- Deploying to end users\n- Resource-constrained systems\n\n**Common pattern: Develop with SWI, deploy with GNU**\n```prolog\n% Development\nswipl my_app.pl\n\n% Deploy as standalone binary\n?- generate_prolog_script([my_app/0],\n                         [dialect(gnu), compile(true)],\n                         Code),\n   write_prolog_script(Code, 'my_app_gnu.pl',\n                      [dialect(gnu), compile(true)]).\n\n% Result: my_app_gnu (native binary)\n```", "answer_tailored": true}
