{"pair_id": "b5-c1-python-overview_p0", "cluster_id": "b5-c1-python-overview", "question": "Why compile Prolog to Python?", "question_type": "medium", "answer": "Compiling Prolog to Python offers several key advantages:\n\n**Immediate Benefits:**\n- **Maximum portability** - Python 3.7+ runs everywhere without platform-specific builds\n- **No external dependencies** - Generated scripts use only Python's standard library\n- **Easy integration** - Seamlessly combine with existing Python ecosystems like pandas, numpy, and ML libraries\n- **Human-readable output** - The compiled code is clear and maintainable\n\n**Technical Capabilities:**\nUnifyWeaver's Python target supports two evaluation strategies:\n- *Procedural mode* - Uses generator functions for arithmetic and shallow recursion\n- *Generator mode* - Employs fixpoint iteration for transitive closure and graph queries\n\n**Ideal Use Cases:**\nChoose Python compilation when you need rapid prototyping, want to leverage Python's rich library ecosystem, require cross-platform deployment without compilation overhead, or are building semantic AI features with embeddings and search capabilities.\n\nFor implementation details and examples, see education/book-05-python-target/.", "answer_variant": "default", "answer_source": "education/book-05-python-target/01_introduction.md", "topics": ["python-target", "evaluation-modes", "portability"], "original_answer": "## Python Target Overview\n\nThe Python target compiles Prolog predicates to standalone, dependency-free Python scripts.\n\n### Benefits\n\n- **Portability** - Python 3.7+ runs on virtually any platform\n- **Zero dependencies** - Uses only standard library\n- **Ecosystem integration** - Easy to combine with pandas, numpy\n- **Readability** - Generated code is human-readable\n\n### Two Evaluation Modes\n\n| Mode | Best For | Mechanism |\n|------|----------|----------|\n| Procedural | Arithmetic, shallow recursion | Generator functions |\n| Generator | Transitive closure, graphs | Fixpoint iteration |\n\n### When to Choose Python\n\n- Rapid prototyping\n- Integration with Python libraries\n- Cross-platform without compilation\n- Semantic AI features (embeddings, search)", "answer_tailored": true}
{"pair_id": "b5-c1-python-overview_p1", "cluster_id": "b5-c1-python-overview", "question": "What are the two evaluation modes in the Python target?", "question_type": "medium", "answer": "The Python target supports two evaluation modes:\n\n1. **Procedural Mode** - Uses generator functions and is best suited for arithmetic operations and shallow recursion\n2. **Generator Mode** - Uses fixpoint iteration and is optimized for transitive closure and graph operations\n\nBoth modes compile to standalone Python scripts with zero dependencies (Python 3.7+ standard library only). The choice depends on your query patterns: use procedural for computational tasks, generator for recursive graph traversals.\n\nFor complete details on implementation and usage, see education/book-05-python-target/01_introduction.md.", "answer_variant": "default", "answer_source": "education/book-05-python-target/01_introduction.md", "topics": ["python-target", "evaluation-modes", "portability"], "original_answer": "## Python Target Overview\n\nThe Python target compiles Prolog predicates to standalone, dependency-free Python scripts.\n\n### Benefits\n\n- **Portability** - Python 3.7+ runs on virtually any platform\n- **Zero dependencies** - Uses only standard library\n- **Ecosystem integration** - Easy to combine with pandas, numpy\n- **Readability** - Generated code is human-readable\n\n### Two Evaluation Modes\n\n| Mode | Best For | Mechanism |\n|------|----------|----------|\n| Procedural | Arithmetic, shallow recursion | Generator functions |\n| Generator | Transitive closure, graphs | Fixpoint iteration |\n\n### When to Choose Python\n\n- Rapid prototyping\n- Integration with Python libraries\n- Cross-platform without compilation\n- Semantic AI features (embeddings, search)", "answer_tailored": true}
{"pair_id": "b5-c1-python-overview_p2", "cluster_id": "b5-c1-python-overview", "question": "When should I use Python vs other targets?", "question_type": "medium", "answer": "## Choosing Python Over Other Targets\n\nPython is ideal when you prioritize **portability and ecosystem access** over raw performance.\n\n### Use Python When You Need:\n\n- **Cross-platform deployment** - Python 3.7+ works everywhere without recompilation (unlike Go/Rust/C#)\n- **Library integration** - Seamlessly combine with pandas, numpy, scikit-learn, or ML frameworks\n- **Quick iterations** - No build step means faster development cycles than compiled targets\n- **AI/ML workflows** - Natural fit for embeddings, semantic search, and data science tasks\n- **Readable output** - Generated code is inspectable and debuggable (vs. Bash complexity)\n\n### Python's Trade-offs\n\n- Slower than Go/Rust/C# for compute-heavy tasks\n- No static typing like C#/Go (though generated code is type-consistent)\n- Less systems-level control than Rust\n\n### Evaluation Modes\n\nPython supports two execution strategies:\n- **Procedural mode** - Uses generator functions for arithmetic and shallow recursion\n- **Generator mode** - Employs fixpoint iteration for graph traversal and transitive closure\n\nFor performance-critical workflows, consider Go or Rust. For shell automation, use Bash. For Windows environments, PowerShell may be more appropriate.\n\nSee education/book-05-python-target/ for implementation details.", "answer_variant": "default", "answer_source": "education/book-05-python-target/01_introduction.md", "topics": ["python-target", "evaluation-modes", "portability"], "original_answer": "## Python Target Overview\n\nThe Python target compiles Prolog predicates to standalone, dependency-free Python scripts.\n\n### Benefits\n\n- **Portability** - Python 3.7+ runs on virtually any platform\n- **Zero dependencies** - Uses only standard library\n- **Ecosystem integration** - Easy to combine with pandas, numpy\n- **Readability** - Generated code is human-readable\n\n### Two Evaluation Modes\n\n| Mode | Best For | Mechanism |\n|------|----------|----------|\n| Procedural | Arithmetic, shallow recursion | Generator functions |\n| Generator | Transitive closure, graphs | Fixpoint iteration |\n\n### When to Choose Python\n\n- Rapid prototyping\n- Integration with Python libraries\n- Cross-platform without compilation\n- Semantic AI features (embeddings, search)", "answer_tailored": true}
{"pair_id": "b5-c1-target-comparison_p0", "cluster_id": "b5-c1-target-comparison", "question": "How does Python target compare to Bash and Go?", "question_type": "medium", "answer": "Python target offers a middle ground between Bash and Go in several aspects:\n\n**Startup Time**: Python has medium startup time, faster than Go's slow binary initialization but not as instant as Bash scripts.\n\n**Runtime Performance**: Python provides good execution speed, matching Bash for most tasks but falling short of Go's excellent performance for compute-intensive operations.\n\n**Deployment**: Like Bash, Python deploys as a simple file copy (no compilation needed), while Go requires building and distributing a binary. This makes Python and Bash more convenient for rapid iteration.\n\n**Advanced Features**: Python supports fixpoint iteration (important for recursive queries), which Bash lacks. Both Python and Go handle streaming data and have minimal dependencies\u2014Python is self-contained except for optional libraries like lxml (XML processing) or onnxruntime (ML embeddings).\n\n**Use Cases**: Choose Python when you need fixpoint support with easier deployment than Go, or when integrating machine learning capabilities. Use Bash for simple Unix text processing where fixpoint isn't needed, and Go when maximum performance justifies the compilation overhead.\n\nSee education/book-05-python-target/ for complete Python implementation details and education/book-02-bash-target/ or education/book-09-go-target/ for target-specific comparisons.", "answer_variant": "default", "answer_source": "education/book-05-python-target/01_introduction.md", "topics": ["target-comparison", "python", "bash", "go", "csharp"], "original_answer": "## Target Comparison\n\n| Feature | Python | Bash | Go | C# |\n|---------|--------|------|----|----||\n| Startup | Medium | Fast | Slow | Slow |\n| Speed | Good | Good | Excellent | Excellent |\n| Dependencies | None* | None | None | .NET Runtime |\n| Streaming | Yes | Yes | Yes | Yes |\n| Fixpoint | Yes | No | Yes | Yes |\n| Deploy | Copy file | Copy file | Binary | Build project |\n\n*Optional: lxml for XML, onnxruntime for embeddings\n\n### Decision Guide\n\n- **Max performance** \u2192 Go or C#\n- **Unix text processing** \u2192 Bash\n- **Quick prototyping** \u2192 Python\n- **ML integration** \u2192 Python\n- **.NET ecosystem** \u2192 C#", "answer_tailored": true}
{"pair_id": "b5-c1-target-comparison_p1", "cluster_id": "b5-c1-target-comparison", "question": "What are the trade-offs between Python and C# targets?", "question_type": "medium", "answer": "When comparing Python and C# targets in UnifyWeaver:\n\n**Startup Performance**: Both have similar startup times (medium-to-slow), unlike Bash which starts instantly.\n\n**Runtime Speed**: C# offers excellent performance, matching Go's speed. Python provides good performance but doesn't reach the same level.\n\n**Dependencies**: Python is nearly dependency-free (only optional packages like lxml for XML or onnxruntime for embeddings). C# requires the .NET Runtime.\n\n**Deployment**: Python deploys as a simple file copy. C# requires building a project, adding deployment complexity.\n\n**Feature Parity**: Both support streaming execution and fixpoint iteration (recursive queries with convergence).\n\n**Choose Python when**: You need quick prototyping, minimal dependencies, ML/AI integration, or simpler deployment.\n\n**Choose C# when**: You need maximum performance, are working within the .NET ecosystem, or require excellent runtime speed for complex queries.\n\nFor complete target comparisons, see education/book-05-python-target/01_introduction.md and education/book-11-csharp-target/.", "answer_variant": "default", "answer_source": "education/book-05-python-target/01_introduction.md", "topics": ["target-comparison", "python", "bash", "go", "csharp"], "original_answer": "## Target Comparison\n\n| Feature | Python | Bash | Go | C# |\n|---------|--------|------|----|----||\n| Startup | Medium | Fast | Slow | Slow |\n| Speed | Good | Good | Excellent | Excellent |\n| Dependencies | None* | None | None | .NET Runtime |\n| Streaming | Yes | Yes | Yes | Yes |\n| Fixpoint | Yes | No | Yes | Yes |\n| Deploy | Copy file | Copy file | Binary | Build project |\n\n*Optional: lxml for XML, onnxruntime for embeddings\n\n### Decision Guide\n\n- **Max performance** \u2192 Go or C#\n- **Unix text processing** \u2192 Bash\n- **Quick prototyping** \u2192 Python\n- **ML integration** \u2192 Python\n- **.NET ecosystem** \u2192 C#", "answer_tailored": true}
{"pair_id": "b5-c1-target-comparison_p2", "cluster_id": "b5-c1-target-comparison", "question": "Which target should I use for maximum performance?", "question_type": "medium", "answer": "For maximum performance, choose either **Go** or **C#** as your target language. Both offer excellent execution speed, though they have different trade-offs:\n\n**Go** provides:\n- Excellent runtime performance\n- Single binary deployment (no dependencies)\n- Support for streaming and fixpoint queries\n- Slower startup time compared to interpreted languages\n\n**C#** provides:\n- Excellent runtime performance (equivalent to Go)\n- Full .NET ecosystem integration\n- Support for streaming and fixpoint queries\n- Requires .NET Runtime dependency\n- Slower startup time\n\nThe choice between them depends on your deployment context: Go if you need standalone binaries with no runtime dependencies, C# if you're already in a .NET environment.\n\nFor comparison, Python and Bash offer faster startup but slower execution speed, making them better suited for quick prototyping or Unix text processing respectively. See education/book-05-python-target/01_introduction.md for detailed target comparisons.", "answer_variant": "default", "answer_source": "education/book-05-python-target/01_introduction.md", "topics": ["target-comparison", "python", "bash", "go", "csharp"], "original_answer": "## Target Comparison\n\n| Feature | Python | Bash | Go | C# |\n|---------|--------|------|----|----||\n| Startup | Medium | Fast | Slow | Slow |\n| Speed | Good | Good | Excellent | Excellent |\n| Dependencies | None* | None | None | .NET Runtime |\n| Streaming | Yes | Yes | Yes | Yes |\n| Fixpoint | Yes | No | Yes | Yes |\n| Deploy | Copy file | Copy file | Binary | Build project |\n\n*Optional: lxml for XML, onnxruntime for embeddings\n\n### Decision Guide\n\n- **Max performance** \u2192 Go or C#\n- **Unix text processing** \u2192 Bash\n- **Quick prototyping** \u2192 Python\n- **ML integration** \u2192 Python\n- **.NET ecosystem** \u2192 C#", "answer_tailored": true}
