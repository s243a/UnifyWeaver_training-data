{"pair_id": "b5-c2-procedural-mode_p0", "cluster_id": "b5-c2-procedural-mode", "question": "What is procedural mode in the Python target?", "question_type": "medium", "answer": "Procedural mode is the default translation approach in UnifyWeaver's Python target, where Prolog predicates become Python generator functions that yield results in a streaming fashion.\n\nIn this mode, Prolog facts map to constant yields, rules become nested generator loops, constraints translate to `if` conditions, and recursive predicates are optimized using memoization or converted to iterative loops.\n\nThe generated Python code uses a streaming architecture that processes records incrementally. Results flow through nested generators, with automatic deduplication handled by a `seen` set that tracks unique results (using JSON serialization as keys). This ensures each distinct result is yielded exactly once, preserving Prolog's set-based semantics.\n\nFor a complete walkthrough of procedural mode patterns and examples, see education/book-05-python-target/02_procedural_mode.md.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["procedural-mode", "streaming", "generator-functions"], "original_answer": "## Procedural Mode\n\nProcedural mode (default) translates Prolog predicates into Python generator functions with streaming semantics.\n\n### Translation Pattern\n\n- **Facts** \u2192 constant yields\n- **Rules** \u2192 nested generator loops\n- **Constraints** \u2192 `if` conditions\n- **Recursion** \u2192 memoization or loop optimization\n\n### Streaming Architecture\n\n```python\ndef process_stream(records):\n    seen = set()\n    for record in records:\n        for result in _clause_0(record):\n            key = json.dumps(result, sort_keys=True)\n            if key not in seen:\n                seen.add(key)\n                yield result\n```\n\n### Automatic Deduplication\n\nGenerated scripts use a `seen` set to ensure each unique result is yielded exactly once, matching Prolog's set semantics.", "answer_tailored": true}
{"pair_id": "b5-c2-procedural-mode_p1", "cluster_id": "b5-c2-procedural-mode", "question": "How does procedural mode handle streaming?", "question_type": "medium", "answer": "Procedural mode handles streaming through Python generator functions that yield results incrementally rather than building complete result sets in memory.\n\nThe streaming architecture uses nested generator loops where each Prolog clause becomes a generator that yields solutions one at a time:\n\n```python\ndef process_stream(records):\n    seen = set()\n    for record in records:\n        for result in _clause_0(record):\n            key = json.dumps(result, sort_keys=True)\n            if key not in seen:\n                seen.add(key)\n                yield result\n```\n\nThis approach allows UnifyWeaver to process large datasets efficiently by:\n- **Lazy evaluation** - Results are generated on-demand as consumers iterate\n- **Memory efficiency** - Only active computation state is held in memory, not entire result sets\n- **Automatic deduplication** - A `seen` set tracks yielded results to ensure each unique solution appears exactly once, matching Prolog's set semantics\n\nFacts translate to constant yields, rules become nested generator loops, and constraints add `if` conditions that filter the stream. For more details on procedural mode translation patterns, see education/book-05-python-target/02_procedural_mode.md.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["procedural-mode", "streaming", "generator-functions"], "original_answer": "## Procedural Mode\n\nProcedural mode (default) translates Prolog predicates into Python generator functions with streaming semantics.\n\n### Translation Pattern\n\n- **Facts** \u2192 constant yields\n- **Rules** \u2192 nested generator loops\n- **Constraints** \u2192 `if` conditions\n- **Recursion** \u2192 memoization or loop optimization\n\n### Streaming Architecture\n\n```python\ndef process_stream(records):\n    seen = set()\n    for record in records:\n        for result in _clause_0(record):\n            key = json.dumps(result, sort_keys=True)\n            if key not in seen:\n                seen.add(key)\n                yield result\n```\n\n### Automatic Deduplication\n\nGenerated scripts use a `seen` set to ensure each unique result is yielded exactly once, matching Prolog's set semantics.", "answer_tailored": true}
{"pair_id": "b5-c2-procedural-mode_p2", "cluster_id": "b5-c2-procedural-mode", "question": "How are Prolog facts translated to Python?", "question_type": "medium", "answer": "In UnifyWeaver's Python target, Prolog facts are translated into constant yields within generator functions. When you write a fact like `parent(john, mary).` in Prolog, the compiler generates a Python function that immediately yields that fact as a dictionary result.\n\nThe translation follows this pattern:\n- Each fact becomes a generator function that yields a constant value\n- Multiple facts for the same predicate yield their results sequentially\n- The yielded values are typically dictionaries mapping variable names to their bindings\n\nFor example, a simple fact gets translated to something like:\n\n```python\ndef parent(X, Y):\n    yield {\"X\": \"john\", \"Y\": \"mary\"}\n```\n\nThis constant-yield approach is part of procedural mode's streaming architecture, where facts, rules, and queries all operate through Python's generator protocol. The system automatically deduplicates results using a `seen` set to match Prolog's set semantics.\n\nFor more details on procedural mode translation patterns, see education/book-05-python-target/02_procedural_mode.md.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["procedural-mode", "streaming", "generator-functions"], "original_answer": "## Procedural Mode\n\nProcedural mode (default) translates Prolog predicates into Python generator functions with streaming semantics.\n\n### Translation Pattern\n\n- **Facts** \u2192 constant yields\n- **Rules** \u2192 nested generator loops\n- **Constraints** \u2192 `if` conditions\n- **Recursion** \u2192 memoization or loop optimization\n\n### Streaming Architecture\n\n```python\ndef process_stream(records):\n    seen = set()\n    for record in records:\n        for result in _clause_0(record):\n            key = json.dumps(result, sort_keys=True)\n            if key not in seen:\n                seen.add(key)\n                yield result\n```\n\n### Automatic Deduplication\n\nGenerated scripts use a `seen` set to ensure each unique result is yielded exactly once, matching Prolog's set semantics.", "answer_tailored": true}
{"pair_id": "b5-c2-constraints-arithmetic_p0", "cluster_id": "b5-c2-constraints-arithmetic", "question": "How does Python target handle arithmetic expressions?", "question_type": "medium", "answer": "The Python target compiles Prolog arithmetic expressions from `is/2` predicates into native Python arithmetic operations. For example, `Y is X * 2` becomes `y = x * 2` within the generated clause function.\n\nAll standard arithmetic operators are supported with direct mappings: addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), modulo (`mod` \u2192 `%`), and exponentiation (`**`). These expressions are evaluated and assigned to variables in the Python output.\n\nComparison constraints from Prolog are translated into Python `if` conditions that guard the execution flow within clause functions. The compiler ensures arithmetic evaluation happens before yielding results in the generator-based execution model.\n\nFor complete details on procedural compilation patterns, see education/book-05-python-target/02_procedural_mode.md.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["constraints", "arithmetic", "compilation"], "original_answer": "## Arithmetic and Constraints\n\n### Arithmetic Compilation\n\nProlog `is/2` expressions translate directly to Python:\n\n```prolog\ndouble(X, Y) :- Y is X * 2.\n```\n\n```python\ndef _clause_0(record):\n    x = record.get('arg0')\n    if x is not None:\n        y = x * 2\n        yield {'arg0': x, 'arg1': y}\n```\n\n### Supported Operations\n\n| Prolog | Python | Description |\n|--------|--------|-------------|\n| `X + Y` | `x + y` | Addition |\n| `X - Y` | `x - y` | Subtraction |\n| `X * Y` | `x * y` | Multiplication |\n| `X / Y` | `x / y` | Division |\n| `X mod Y` | `x % y` | Modulo |\n| `X ** Y` | `x ** y` | Exponentiation |\n\n### Comparison Constraints\n\nConstraints become `if` conditions in Python.", "answer_tailored": true}
{"pair_id": "b5-c2-constraints-arithmetic_p1", "cluster_id": "b5-c2-constraints-arithmetic", "question": "How are Prolog constraints compiled to Python?", "question_type": "medium", "answer": "Prolog constraints compile to Python conditional checks and arithmetic operations. When UnifyWeaver encounters `is/2` for arithmetic evaluation, it generates direct Python expressions:\n\n```prolog\ndouble(X, Y) :- Y is X * 2.\n```\n\nBecomes:\n\n```python\ndef _clause_0(record):\n    x = record.get('arg0')\n    if x is not None:\n        y = x * 2\n        yield {'arg0': x, 'arg1': y}\n```\n\nThe compiler supports standard arithmetic operators:\n\n| Prolog Operator | Python Equivalent | Operation |\n|-----------------|-------------------|-----------|\n| `X + Y` | `x + y` | Addition |\n| `X - Y` | `x - y` | Subtraction |\n| `X * Y` | `x * y` | Multiplication |\n| `X / Y` | `x / y` | Division |\n| `X mod Y` | `x % y` | Modulo |\n| `X ** Y` | `x ** y` | Exponentiation |\n\nComparison constraints (like `X > Y`, `X =< Y`) translate to Python `if` conditions that filter results. For comprehensive details on Python target compilation, see education/book-05-python-target/.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["constraints", "arithmetic", "compilation"], "original_answer": "## Arithmetic and Constraints\n\n### Arithmetic Compilation\n\nProlog `is/2` expressions translate directly to Python:\n\n```prolog\ndouble(X, Y) :- Y is X * 2.\n```\n\n```python\ndef _clause_0(record):\n    x = record.get('arg0')\n    if x is not None:\n        y = x * 2\n        yield {'arg0': x, 'arg1': y}\n```\n\n### Supported Operations\n\n| Prolog | Python | Description |\n|--------|--------|-------------|\n| `X + Y` | `x + y` | Addition |\n| `X - Y` | `x - y` | Subtraction |\n| `X * Y` | `x * y` | Multiplication |\n| `X / Y` | `x / y` | Division |\n| `X mod Y` | `x % y` | Modulo |\n| `X ** Y` | `x ** y` | Exponentiation |\n\n### Comparison Constraints\n\nConstraints become `if` conditions in Python.", "answer_tailored": true}
{"pair_id": "b5-c2-constraints-arithmetic_p2", "cluster_id": "b5-c2-constraints-arithmetic", "question": "What arithmetic operations are supported?", "question_type": "medium", "answer": "UnifyWeaver supports standard arithmetic operations in Prolog that compile to Python equivalents:\n\n- **Addition** (`X + Y` \u2192 `x + y`)\n- **Subtraction** (`X - Y` \u2192 `x - y`)\n- **Multiplication** (`X * Y` \u2192 `x * y`)\n- **Division** (`X / Y` \u2192 `x / y`)\n- **Modulo** (`X mod Y` \u2192 `x % y`)\n- **Exponentiation** (`X ** Y` \u2192 `x ** y`)\n\nThese operations work within Prolog's `is/2` expressions. For example, `Y is X * 2` compiles to a Python clause that computes `y = x * 2`. Comparison constraints (like `X > Y`) translate to conditional statements in the generated Python code.\n\nFor complete details on arithmetic compilation and constraints in the Python target, see `education/book-05-python-target/02_procedural_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["constraints", "arithmetic", "compilation"], "original_answer": "## Arithmetic and Constraints\n\n### Arithmetic Compilation\n\nProlog `is/2` expressions translate directly to Python:\n\n```prolog\ndouble(X, Y) :- Y is X * 2.\n```\n\n```python\ndef _clause_0(record):\n    x = record.get('arg0')\n    if x is not None:\n        y = x * 2\n        yield {'arg0': x, 'arg1': y}\n```\n\n### Supported Operations\n\n| Prolog | Python | Description |\n|--------|--------|-------------|\n| `X + Y` | `x + y` | Addition |\n| `X - Y` | `x - y` | Subtraction |\n| `X * Y` | `x * y` | Multiplication |\n| `X / Y` | `x / y` | Division |\n| `X mod Y` | `x % y` | Modulo |\n| `X ** Y` | `x ** y` | Exponentiation |\n\n### Comparison Constraints\n\nConstraints become `if` conditions in Python.", "answer_tailored": true}
{"pair_id": "b5-c2-io-formats_p0", "cluster_id": "b5-c2-io-formats", "question": "What input/output formats does the Python target support?", "question_type": "medium", "answer": "The Python target supports three I/O formats:\n\n**JSONL (JSON Lines)** - The default format, with one JSON object per line. Records are processed individually as they're read from stdin.\n\n**NUL-delimited JSON** - For binary-safe streaming when data contains embedded NUL bytes. Enable with `record_format(nul_json)` in compiler options.\n\n**Native XML** - Direct XML processing using lxml's streaming parser. Specify with `input_source(xml('data.xml', ['product']))` to efficiently handle large XML files via `lxml.etree.iterparse`.\n\nFor more details on Python target features, see education/book-05-python-target/02_procedural_mode.md.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["jsonl", "nul-json", "xml", "io-formats"], "original_answer": "## Input/Output Formats\n\n### JSONL (Default)\n\nJSON Lines - one JSON object per line:\n\n```bash\necho '{\"x\": 5}\n{\"x\": 10}' | python3 script.py\n```\n\n### NUL-Delimited JSON\n\nBinary-safe streaming for embedded NULs:\n\n```prolog\ncompile_predicate_to_python(pred/2, [record_format(nul_json)], Code).\n```\n\n### Native XML Input\n\nDirect XML processing with lxml:\n\n```prolog\ncompile_predicate_to_python(process_products/1, [\n    input_source(xml('data.xml', ['product']))\n], Code).\n```\n\nUses `lxml.etree.iterparse` for memory-efficient streaming of large XML files.", "answer_tailored": true}
{"pair_id": "b5-c2-io-formats_p1", "cluster_id": "b5-c2-io-formats", "question": "How do I process XML files with Python target?", "question_type": "medium", "answer": "To process XML files with the Python target, use the `input_source(xml(...))` option in `compile_predicate_to_python/3`:\n\n```prolog\ncompile_predicate_to_python(process_products/1, [\n    input_source(xml('data.xml', ['product']))\n], Code).\n```\n\nThis generates Python code that uses `lxml.etree.iterparse` for streaming XML processing, which is memory-efficient for large files. The second argument to `xml()` specifies which XML elements to extract as records.\n\nFor other input formats supported by the Python target, including JSONL (default) and NUL-delimited JSON for binary-safe streaming, see education/book-05-python-target/02_procedural_mode.md.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["jsonl", "nul-json", "xml", "io-formats"], "original_answer": "## Input/Output Formats\n\n### JSONL (Default)\n\nJSON Lines - one JSON object per line:\n\n```bash\necho '{\"x\": 5}\n{\"x\": 10}' | python3 script.py\n```\n\n### NUL-Delimited JSON\n\nBinary-safe streaming for embedded NULs:\n\n```prolog\ncompile_predicate_to_python(pred/2, [record_format(nul_json)], Code).\n```\n\n### Native XML Input\n\nDirect XML processing with lxml:\n\n```prolog\ncompile_predicate_to_python(process_products/1, [\n    input_source(xml('data.xml', ['product']))\n], Code).\n```\n\nUses `lxml.etree.iterparse` for memory-efficient streaming of large XML files.", "answer_tailored": true}
{"pair_id": "b5-c2-io-formats_p2", "cluster_id": "b5-c2-io-formats", "question": "What is NUL-delimited JSON?", "question_type": "medium", "answer": "NUL-delimited JSON is a binary-safe streaming format that uses the NUL character (ASCII 0) as a delimiter between JSON objects, rather than newlines. This format is particularly useful when you need to handle JSON data that contains embedded NUL bytes, which would break standard JSONL (newline-delimited) parsing.\n\nIn UnifyWeaver's Python target, you can enable NUL-delimited JSON output by specifying the `record_format(nul_json)` option:\n\n```prolog\ncompile_predicate_to_python(pred/2, [record_format(nul_json)], Code).\n```\n\nThis is one of several I/O formats supported by the Python target, alongside JSONL (the default, using one JSON object per line) and native XML input with lxml for memory-efficient streaming. See education/book-05-python-target/02_procedural_mode.md for complete details on all available input/output formats.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["jsonl", "nul-json", "xml", "io-formats"], "original_answer": "## Input/Output Formats\n\n### JSONL (Default)\n\nJSON Lines - one JSON object per line:\n\n```bash\necho '{\"x\": 5}\n{\"x\": 10}' | python3 script.py\n```\n\n### NUL-Delimited JSON\n\nBinary-safe streaming for embedded NULs:\n\n```prolog\ncompile_predicate_to_python(pred/2, [record_format(nul_json)], Code).\n```\n\n### Native XML Input\n\nDirect XML processing with lxml:\n\n```prolog\ncompile_predicate_to_python(process_products/1, [\n    input_source(xml('data.xml', ['product']))\n], Code).\n```\n\nUses `lxml.etree.iterparse` for memory-efficient streaming of large XML files.", "answer_tailored": true}
