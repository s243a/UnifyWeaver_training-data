{"pair_id": "constraint-usage_p0", "cluster_id": "constraint-usage", "question": "What are constraints in UnifyWeaver and how do I use them?", "question_type": "medium", "answer": "Constraints in UnifyWeaver are declarations that inform the compiler about properties of your predicates, allowing it to generate more efficient code. Here's how to use them:\n\n### Basic Usage\n\nDeclare constraints using pragma-style syntax (preferred):\n\n```prolog\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n```\n\nOr programmatically:\n\n```prolog\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### Understanding Constraint Types\n\n**`unique(true/false)`** - Controls whether the predicate can return duplicate results\n- `true` (default): Guarantees no duplicates, compiler adds deduplication\n- `false`: Duplicates allowed, no deduplication performed\n\n**`unordered(true/false)`** - Controls whether result order matters\n- `true` (default): Order irrelevant, enables `sort -u` optimization\n- `false`: Order must be preserved, uses hash-based deduplication\n\n### Impact on Generated Code\n\nThe constraint combination determines the deduplication strategy:\n\n- **`unique(true), unordered(true)`**: Uses `sort -u` for efficiency\n- **`unique(true), unordered(false)`**: Hash table preserves insertion order\n- **`unique(false)`**: No deduplication, returns raw results\n\n### Common Use Cases\n\n```prolog\n% Temporal/sequential data - preserve order\n:- constraint(event_log/2, [unordered(false)]).\n\n% Aggregation queries - allow duplicates\n:- constraint(word_count/2, [unique(false)]).\n\n% Set operations - defaults work well\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\nQuery active constraints with `get_constraints/2`. The constraint analyzer (src/unifyweaver/core/constraint_analyzer.pl) processes these declarations during compilation.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/constraint_analyzer.pl", "topics": ["constraints", "unique", "ordered", "deduplication", "optimization"], "original_answer": "## Constraints in UnifyWeaver\n\nConstraints tell the compiler about properties of your predicates, enabling optimizations.\n\n### Available Constraints\n\n| Constraint | Meaning | Default |\n|------------|---------|--------|\n| `unique(true)` | Predicate never returns duplicates | true |\n| `unique(false)` | May return duplicates | false |\n| `unordered(true)` | Order doesn't matter | true |\n| `unordered(false)` | Order must be preserved | false |\n\n### Declaring Constraints\n\n```prolog\n% Pragma-style (recommended)\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n\n% Or programmatically\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### How Constraints Affect Code Generation\n\n**With `unique(true), unordered(true)` (default):**\n```bash\n# Uses sort -u for deduplication\nresults | sort -u\n```\n\n**With `unique(true), unordered(false)`:**\n```bash\n# Uses hash table to preserve order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**With `unique(false)`:**\n```bash\n# No deduplication - raw output\nresults\n```\n\n### When to Override Defaults\n\n```prolog\n% Temporal data - order matters!\n:- constraint(event_log/2, [unordered(false)]).\n\n% May have duplicates (counting queries)\n:- constraint(word_count/2, [unique(false)]).\n\n% Set-like operations (default is fine)\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\n### Checking Active Constraints\n\n```prolog\n?- get_constraints(my_pred/2, C).\nC = [unique(true), unordered(true)].\n```", "answer_tailored": true}
{"pair_id": "constraint-usage_p1", "cluster_id": "constraint-usage", "question": "What does unique(true) mean in UnifyWeaver?", "question_type": "medium", "answer": "In UnifyWeaver, `unique(true)` is a constraint that tells the compiler your predicate never returns duplicate results. This is the default setting for most predicates.\n\nWhen `unique(true)` is declared, the compiler can safely apply deduplication during code generation:\n\n```prolog\n:- constraint(grandparent/2, [unique(true)]).\n```\n\n**Impact on Generated Code:**\n\nCombined with `unordered(true)` (also default):\n```bash\n# Bash: uses sort -u\nresults | sort -u\n```\n\nCombined with `unordered(false)`:\n```bash\n# Bash: hash table preserves order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**When to use `unique(false)` instead:**\n\nUse `unique(false)` when duplicates are meaningful:\n```prolog\n% Counting queries need duplicates\n:- constraint(word_count/2, [unique(false)]).\n```\n\n**Checking constraints:**\n```prolog\n?- get_constraints(my_pred/2, C).\nC = [unique(true), unordered(true)].\n```\n\nSee src/unifyweaver/core/constraint_analyzer.pl for implementation details.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/constraint_analyzer.pl", "topics": ["constraints", "unique", "ordered", "deduplication", "optimization"], "original_answer": "## Constraints in UnifyWeaver\n\nConstraints tell the compiler about properties of your predicates, enabling optimizations.\n\n### Available Constraints\n\n| Constraint | Meaning | Default |\n|------------|---------|--------|\n| `unique(true)` | Predicate never returns duplicates | true |\n| `unique(false)` | May return duplicates | false |\n| `unordered(true)` | Order doesn't matter | true |\n| `unordered(false)` | Order must be preserved | false |\n\n### Declaring Constraints\n\n```prolog\n% Pragma-style (recommended)\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n\n% Or programmatically\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### How Constraints Affect Code Generation\n\n**With `unique(true), unordered(true)` (default):**\n```bash\n# Uses sort -u for deduplication\nresults | sort -u\n```\n\n**With `unique(true), unordered(false)`:**\n```bash\n# Uses hash table to preserve order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**With `unique(false)`:**\n```bash\n# No deduplication - raw output\nresults\n```\n\n### When to Override Defaults\n\n```prolog\n% Temporal data - order matters!\n:- constraint(event_log/2, [unordered(false)]).\n\n% May have duplicates (counting queries)\n:- constraint(word_count/2, [unique(false)]).\n\n% Set-like operations (default is fine)\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\n### Checking Active Constraints\n\n```prolog\n?- get_constraints(my_pred/2, C).\nC = [unique(true), unordered(true)].\n```", "answer_tailored": true}
{"pair_id": "constraint-usage_p2", "cluster_id": "constraint-usage", "question": "How do constraints affect generated code?", "question_type": "medium", "answer": "## Impact of Constraints on Generated Code\n\nConstraints directly influence how UnifyWeaver generates target code, particularly for deduplication and ordering operations.\n\n### Code Generation Based on Constraints\n\n**Default behavior (`unique(true), unordered(true)`):**\nThe compiler generates deduplication logic without ordering guarantees:\n```bash\n# Bash: efficient sorting with dedup\nresults | sort -u\n```\n\n**Order-preserving deduplication (`unique(true), unordered(false)`):**\nWhen order matters, the compiler emits hash-based tracking:\n```bash\n# Bash: maintains insertion order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**No deduplication (`unique(false)`):**\nRaw output with potential duplicates:\n```bash\n# Bash: direct passthrough\nresults\n```\n\n### Constraint Declaration Syntax\n\n```prolog\n% Via pragma (preferred)\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n\n% Programmatic declaration\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### Available Constraint Options\n\n- `unique(true)` - Compiler adds deduplication logic\n- `unique(false)` - Allows duplicate results\n- `unordered(true)` - Permits reordering (enables optimizations)\n- `unordered(false)` - Forces order preservation\n\n### Practical Examples\n\n```prolog\n% Temporal data requires ordered output\n:- constraint(event_log/2, [unordered(false)]).\n\n% Counting queries need duplicates\n:- constraint(word_count/2, [unique(false)]).\n\n% Set operations use defaults\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\nImplementation details in `src/unifyweaver/core/constraint_analyzer.pl`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/constraint_analyzer.pl", "topics": ["constraints", "unique", "ordered", "deduplication", "optimization"], "original_answer": "## Constraints in UnifyWeaver\n\nConstraints tell the compiler about properties of your predicates, enabling optimizations.\n\n### Available Constraints\n\n| Constraint | Meaning | Default |\n|------------|---------|--------|\n| `unique(true)` | Predicate never returns duplicates | true |\n| `unique(false)` | May return duplicates | false |\n| `unordered(true)` | Order doesn't matter | true |\n| `unordered(false)` | Order must be preserved | false |\n\n### Declaring Constraints\n\n```prolog\n% Pragma-style (recommended)\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n\n% Or programmatically\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### How Constraints Affect Code Generation\n\n**With `unique(true), unordered(true)` (default):**\n```bash\n# Uses sort -u for deduplication\nresults | sort -u\n```\n\n**With `unique(true), unordered(false)`:**\n```bash\n# Uses hash table to preserve order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**With `unique(false)`:**\n```bash\n# No deduplication - raw output\nresults\n```\n\n### When to Override Defaults\n\n```prolog\n% Temporal data - order matters!\n:- constraint(event_log/2, [unordered(false)]).\n\n% May have duplicates (counting queries)\n:- constraint(word_count/2, [unique(false)]).\n\n% Set-like operations (default is fine)\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\n### Checking Active Constraints\n\n```prolog\n?- get_constraints(my_pred/2, C).\nC = [unique(true), unordered(true)].\n```", "answer_tailored": true}
{"pair_id": "constraint-usage_p3", "cluster_id": "constraint-usage", "question": "What deduplication strategies does UnifyWeaver support?", "question_type": "medium", "answer": "UnifyWeaver supports three primary deduplication strategies, controlled by the `unique` and `unordered` constraints:\n\n### 1. Sort-Based Deduplication (`unique(true), unordered(true)`)\nThis is the **default strategy**. When both constraints are set, the compiler generates code using `sort -u` to remove duplicates:\n\n```bash\nresults | sort -u\n```\n\nThis is most efficient for set-like operations where order doesn't matter.\n\n### 2. Order-Preserving Deduplication (`unique(true), unordered(false)`)\nWhen you need to eliminate duplicates but preserve the original order, the compiler uses a hash table approach:\n\n```bash\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\nUse this for temporal data or when result order is semantically important.\n\n### 3. No Deduplication (`unique(false)`)\nWhen duplicates are meaningful (e.g., counting queries, aggregations), set `unique(false)` to output raw results without any deduplication:\n\n```bash\nresults  # No filtering\n```\n\n### Configuring Deduplication Strategy\n\nDeclare constraints using pragma syntax:\n\n```prolog\n% Order-preserving deduplication for event logs\n:- constraint(event_log/2, [unique(true), unordered(false)]).\n\n% No deduplication for counting\n:- constraint(word_count/2, [unique(false)]).\n\n% Default: sort-based deduplication\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\nSee `src/unifyweaver/core/constraint_analyzer.pl` for implementation details and `education/book-02-bash-target/` for target-specific code generation examples.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/constraint_analyzer.pl", "topics": ["constraints", "unique", "ordered", "deduplication", "optimization"], "original_answer": "## Constraints in UnifyWeaver\n\nConstraints tell the compiler about properties of your predicates, enabling optimizations.\n\n### Available Constraints\n\n| Constraint | Meaning | Default |\n|------------|---------|--------|\n| `unique(true)` | Predicate never returns duplicates | true |\n| `unique(false)` | May return duplicates | false |\n| `unordered(true)` | Order doesn't matter | true |\n| `unordered(false)` | Order must be preserved | false |\n\n### Declaring Constraints\n\n```prolog\n% Pragma-style (recommended)\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n\n% Or programmatically\n?- declare_constraint(my_pred/2, [unique(false)]).\n```\n\n### How Constraints Affect Code Generation\n\n**With `unique(true), unordered(true)` (default):**\n```bash\n# Uses sort -u for deduplication\nresults | sort -u\n```\n\n**With `unique(true), unordered(false)`:**\n```bash\n# Uses hash table to preserve order\ndeclare -A seen\nwhile read line; do\n    [[ -z \"${seen[$line]}\" ]] && { seen[$line]=1; echo \"$line\"; }\ndone\n```\n\n**With `unique(false)`:**\n```bash\n# No deduplication - raw output\nresults\n```\n\n### When to Override Defaults\n\n```prolog\n% Temporal data - order matters!\n:- constraint(event_log/2, [unordered(false)]).\n\n% May have duplicates (counting queries)\n:- constraint(word_count/2, [unique(false)]).\n\n% Set-like operations (default is fine)\n:- constraint(ancestors/2, [unique(true), unordered(true)]).\n```\n\n### Checking Active Constraints\n\n```prolog\n?- get_constraints(my_pred/2, C).\nC = [unique(true), unordered(true)].\n```", "answer_tailored": true}
{"pair_id": "troubleshooting-compilation_p0", "cluster_id": "troubleshooting-compilation", "question": "How do I debug compilation errors in UnifyWeaver?", "question_type": "medium", "answer": "## Debugging UnifyWeaver Compilation Errors\n\nWhen compilation fails or produces unexpected results, follow this systematic debugging approach:\n\n### \"Procedure Not Found\" Errors\n\nIf you see `ERROR: Unknown procedure: my_pred/2`:\n\n**Check if the predicate is loaded:**\n```prolog\n?- listing(my_pred).\n```\n\n**Load the source file:**\n```prolog\n?- ['my_predicates.pl'].\n```\n\n**Or define it directly for testing:**\n```prolog\n?- assertz(my_pred(a, b)).\n```\n\nCommon cause: Wrong arity (e.g., calling `my_pred/2` when you defined `my_pred/3`).\n\n### Enable Compiler Diagnostics\n\nTurn on verbose output to see what the compiler is doing:\n\n```prolog\n?- set_prolog_flag(verbose, normal).\n?- compile(reaches/2, [target(bash), debug(true)], S).\n```\n\nThis shows the query classification and transformation steps:\n```\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf the classification looks wrong, your predicate may not match a known pattern\u2014try simplifying the rules.\n\n### Verify Prolog Logic Before Compilation\n\nAlways test your predicate in Prolog first:\n\n```prolog\n?- my_pred(X, Y).\n% Check that results are correct\n```\n\nIf it doesn't work in Prolog, it won't compile correctly either.\n\n### Inspect Generated Code\n\nExamine the output to find structural issues:\n\n```bash\ncat output/my_pred.sh\n```\n\nLook for:\n- Correct key format (e.g., `arg1:arg2` for binary predicates)\n- Proper array initialization\n- Cycle detection (visited tracking) for recursive queries\n\n### Debug Target Code Execution\n\nFor Bash targets, use shell tracing:\n\n```bash\nsource my_pred.sh\nset -x  # Enable execution trace\nmy_pred_stream\nset +x\n```\n\nFor Python, Go, or other targets, check `playbooks/` for target-specific debugging examples.\n\n### Common Error Patterns\n\n| Problem | Likely Cause | Solution |\n|---------|--------------|----------|\n| Empty output | Facts not loaded | Run `listing(pred)` to verify |\n| Infinite loop | Missing cycle detection | Add `unique(true)` constraint |\n| Duplicate results | No deduplication | Check query constraints |\n| Key errors | Arity mismatch | Ensure `pred/N` matches definition |\n\n### Firewall Info Messages\n\nIf you see `INFO: No firewall rules defined. Using implicit allow.`, the security system isn't configured. This is fine for development but should be addressed for production (see `src/unifyweaver/core/firewall.pl` for configuration options).\n\nFor more debugging techniques, refer to `education/book-02-bash-target/` and the troubleshooting sections in `docs/proposals/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/firewall.pl", "topics": ["troubleshooting", "errors", "debugging", "firewall", "compilation-errors"], "original_answer": "## Troubleshooting UnifyWeaver Compilation\n\n### Error: \"procedure not found\"\n\n**Cause:** The predicate isn't loaded or has wrong arity.\n\n```prolog\n?- compile(my_pred/2, [target(bash)], S).\nERROR: Unknown procedure: my_pred/2\n```\n\n**Fix:**\n```prolog\n% Check what's loaded\n?- listing(my_pred).\n\n% Load your file\n?- ['my_predicates.pl'].\n\n% Or assert directly\n?- assertz(my_pred(a, b)).\n```\n\n### Info: \"No firewall rules defined\"\n\n```\nINFO: No firewall rules defined. Using implicit allow.\n```\n\n**Meaning:** The firewall security system isn't configured. This is OK for development.\n\n**To configure:**\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### Wrong Results in Generated Bash\n\n**Step 1: Test Prolog logic first**\n```prolog\n?- my_pred(X, Y).\n% Verify results are correct in Prolog\n```\n\n**Step 2: Check generated code structure**\n```bash\ncat output/my_pred.sh\n# Look for:\n# - Correct key format (arg1:arg2)\n# - Proper array initialization\n# - Visited tracking for recursion\n```\n\n**Step 3: Debug with traces**\n```bash\nsource my_pred.sh\nset -x  # Enable bash tracing\nmy_pred_stream\nset +x\n```\n\n### Common Issues\n\n| Symptom | Cause | Fix |\n|---------|-------|-----|\n| Empty output | Facts not loaded | Check `listing(pred)` |\n| Infinite loop | No cycle detection | Add `unique(true)` constraint |\n| Duplicates | Wrong dedup strategy | Check constraints |\n| Key not found | Wrong arity | Verify `pred/N` matches facts |\n\n### Debugging Recursive Predicates\n\n```prolog\n% Enable compiler tracing\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debug info\n?- compile(reaches/2, [target(bash), debug(true)], S).\n\n% Check classification\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf classification is wrong, simplify your rules to match known patterns.", "answer_tailored": true}
{"pair_id": "troubleshooting-compilation_p1", "cluster_id": "troubleshooting-compilation", "question": "What does 'procedure not found' mean during compilation?", "question_type": "medium", "answer": "## Understanding \"procedure not found\" Compilation Errors\n\nWhen you see \"procedure not found\" during UnifyWeaver compilation, it means the compiler cannot locate the predicate you're trying to compile\u2014either because it hasn't been loaded into Prolog or because the arity (number of arguments) doesn't match.\n\n**Example Error:**\n```prolog\n?- compile(my_pred/2, [target(bash)], S).\nERROR: Unknown procedure: my_pred/2\n```\n\n**Resolution Steps:**\n\n1. **Verify the predicate exists:**\n```prolog\n?- listing(my_pred).\n% If nothing shows, the predicate isn't loaded\n```\n\n2. **Load your source file:**\n```prolog\n?- ['my_predicates.pl'].\n```\n\n3. **Or define it directly:**\n```prolog\n?- assertz(my_pred(a, b)).\n```\n\n**Common Causes:**\n- File containing the predicate wasn't consulted\n- Typo in predicate name\n- Wrong arity (e.g., calling `my_pred/2` when only `my_pred/1` exists)\n- Module visibility issues\n\n**Quick Check:**\n```prolog\n% List all predicates matching a pattern\n?- current_predicate(my_pred/_).\n\n% Verify exact arity\n?- current_predicate(my_pred/2).\n```\n\nOnce the predicate is properly loaded and accessible, compilation should proceed normally. For more on setting up UnifyWeaver projects, see education/book-01-foundations/ and playbooks/ for working examples.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/firewall.pl", "topics": ["troubleshooting", "errors", "debugging", "firewall", "compilation-errors"], "original_answer": "## Troubleshooting UnifyWeaver Compilation\n\n### Error: \"procedure not found\"\n\n**Cause:** The predicate isn't loaded or has wrong arity.\n\n```prolog\n?- compile(my_pred/2, [target(bash)], S).\nERROR: Unknown procedure: my_pred/2\n```\n\n**Fix:**\n```prolog\n% Check what's loaded\n?- listing(my_pred).\n\n% Load your file\n?- ['my_predicates.pl'].\n\n% Or assert directly\n?- assertz(my_pred(a, b)).\n```\n\n### Info: \"No firewall rules defined\"\n\n```\nINFO: No firewall rules defined. Using implicit allow.\n```\n\n**Meaning:** The firewall security system isn't configured. This is OK for development.\n\n**To configure:**\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### Wrong Results in Generated Bash\n\n**Step 1: Test Prolog logic first**\n```prolog\n?- my_pred(X, Y).\n% Verify results are correct in Prolog\n```\n\n**Step 2: Check generated code structure**\n```bash\ncat output/my_pred.sh\n# Look for:\n# - Correct key format (arg1:arg2)\n# - Proper array initialization\n# - Visited tracking for recursion\n```\n\n**Step 3: Debug with traces**\n```bash\nsource my_pred.sh\nset -x  # Enable bash tracing\nmy_pred_stream\nset +x\n```\n\n### Common Issues\n\n| Symptom | Cause | Fix |\n|---------|-------|-----|\n| Empty output | Facts not loaded | Check `listing(pred)` |\n| Infinite loop | No cycle detection | Add `unique(true)` constraint |\n| Duplicates | Wrong dedup strategy | Check constraints |\n| Key not found | Wrong arity | Verify `pred/N` matches facts |\n\n### Debugging Recursive Predicates\n\n```prolog\n% Enable compiler tracing\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debug info\n?- compile(reaches/2, [target(bash), debug(true)], S).\n\n% Check classification\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf classification is wrong, simplify your rules to match known patterns.", "answer_tailored": true}
{"pair_id": "troubleshooting-compilation_p2", "cluster_id": "troubleshooting-compilation", "question": "What is the firewall and how does it affect compilation?", "question_type": "medium", "answer": "## The Firewall System in UnifyWeaver\n\nThe firewall is a security mechanism that controls what operations and targets are permitted during compilation. It acts as a policy enforcement layer between your Prolog code and the generated target language output.\n\n### How It Works\n\nWhen compiling predicates, the firewall checks each operation against configured rules. If no rules are defined, it defaults to \"implicit allow\" mode - meaning all operations are permitted. This is typical for development environments.\n\n### Impact on Compilation\n\nThe firewall can:\n- **Block unsafe targets**: Prevent compilation to specific languages (e.g., deny bash output)\n- **Restrict operations**: Disallow dangerous operations like `shell_exec` even if the target is allowed\n- **Enforce security policies**: Apply organization-wide compilation constraints\n\nIf compilation is blocked, you'll see an error indicating which firewall rule was violated.\n\n### Configuration\n\nLoad and configure the firewall in `src/unifyweaver/core/firewall.pl`:\n\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\nThis example allows Bash compilation but blocks shell execution operations.\n\n### Development vs Production\n\nDuring development, you'll typically see:\n```\nINFO: No firewall rules defined. Using implicit allow.\n```\n\nIn production deployments, configure explicit policies to prevent unauthorized code generation or unsafe operations.\n\nSee `docs/proposals/` for security architecture details and `src/unifyweaver/core/` for firewall implementation.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/firewall.pl", "topics": ["troubleshooting", "errors", "debugging", "firewall", "compilation-errors"], "original_answer": "## Troubleshooting UnifyWeaver Compilation\n\n### Error: \"procedure not found\"\n\n**Cause:** The predicate isn't loaded or has wrong arity.\n\n```prolog\n?- compile(my_pred/2, [target(bash)], S).\nERROR: Unknown procedure: my_pred/2\n```\n\n**Fix:**\n```prolog\n% Check what's loaded\n?- listing(my_pred).\n\n% Load your file\n?- ['my_predicates.pl'].\n\n% Or assert directly\n?- assertz(my_pred(a, b)).\n```\n\n### Info: \"No firewall rules defined\"\n\n```\nINFO: No firewall rules defined. Using implicit allow.\n```\n\n**Meaning:** The firewall security system isn't configured. This is OK for development.\n\n**To configure:**\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### Wrong Results in Generated Bash\n\n**Step 1: Test Prolog logic first**\n```prolog\n?- my_pred(X, Y).\n% Verify results are correct in Prolog\n```\n\n**Step 2: Check generated code structure**\n```bash\ncat output/my_pred.sh\n# Look for:\n# - Correct key format (arg1:arg2)\n# - Proper array initialization\n# - Visited tracking for recursion\n```\n\n**Step 3: Debug with traces**\n```bash\nsource my_pred.sh\nset -x  # Enable bash tracing\nmy_pred_stream\nset +x\n```\n\n### Common Issues\n\n| Symptom | Cause | Fix |\n|---------|-------|-----|\n| Empty output | Facts not loaded | Check `listing(pred)` |\n| Infinite loop | No cycle detection | Add `unique(true)` constraint |\n| Duplicates | Wrong dedup strategy | Check constraints |\n| Key not found | Wrong arity | Verify `pred/N` matches facts |\n\n### Debugging Recursive Predicates\n\n```prolog\n% Enable compiler tracing\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debug info\n?- compile(reaches/2, [target(bash), debug(true)], S).\n\n% Check classification\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf classification is wrong, simplify your rules to match known patterns.", "answer_tailored": true}
{"pair_id": "troubleshooting-compilation_p3", "cluster_id": "troubleshooting-compilation", "question": "My generated Bash code gives wrong results - how do I debug?", "question_type": "medium", "answer": "## Debugging Wrong Results in Generated Bash Code\n\nWhen your generated Bash code produces incorrect output, follow this debugging workflow:\n\n**1. Verify Prolog Logic First**\n```prolog\n?- my_pred(X, Y).\n% Confirm the results are correct in Prolog before debugging Bash\n```\n\n**2. Inspect the Generated Code**\n```bash\ncat output/my_pred.sh\n# Check for:\n# - Correct key format (arg1:arg2)\n# - Proper array initialization\n# - Visited tracking for recursive predicates\n```\n\n**3. Enable Bash Tracing**\n```bash\nsource my_pred.sh\nset -x  # Turn on execution tracing\nmy_pred_stream\nset +x\n```\n\n**Common Problems and Solutions:**\n\n| Issue | Likely Cause | Solution |\n|-------|--------------|----------|\n| Empty output | Facts not loaded | Run `listing(pred)` to verify |\n| Infinite loop | Missing cycle detection | Add `unique(true)` constraint |\n| Duplicate results | Incorrect deduplication | Review constraints |\n| Key not found errors | Arity mismatch | Ensure `pred/N` matches facts |\n\n**For Recursive Predicates:**\n\n```prolog\n% Enable detailed compiler output\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debugging enabled\n?- compile(reaches/2, [target(bash), debug(true)], S).\n\n% Verify the pattern classification\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf the classification looks incorrect, simplify your rules to match recognized patterns.\n\nSee education/book-02-bash-target/ for detailed examples of Bash code generation and education/book-10-security/ for firewall configuration if you encounter security-related issues.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/firewall.pl", "topics": ["troubleshooting", "errors", "debugging", "firewall", "compilation-errors"], "original_answer": "## Troubleshooting UnifyWeaver Compilation\n\n### Error: \"procedure not found\"\n\n**Cause:** The predicate isn't loaded or has wrong arity.\n\n```prolog\n?- compile(my_pred/2, [target(bash)], S).\nERROR: Unknown procedure: my_pred/2\n```\n\n**Fix:**\n```prolog\n% Check what's loaded\n?- listing(my_pred).\n\n% Load your file\n?- ['my_predicates.pl'].\n\n% Or assert directly\n?- assertz(my_pred(a, b)).\n```\n\n### Info: \"No firewall rules defined\"\n\n```\nINFO: No firewall rules defined. Using implicit allow.\n```\n\n**Meaning:** The firewall security system isn't configured. This is OK for development.\n\n**To configure:**\n```prolog\n?- use_module(unifyweaver(core/firewall)).\n?- set_firewall_policy([allow(bash), deny(shell_exec)]).\n```\n\n### Wrong Results in Generated Bash\n\n**Step 1: Test Prolog logic first**\n```prolog\n?- my_pred(X, Y).\n% Verify results are correct in Prolog\n```\n\n**Step 2: Check generated code structure**\n```bash\ncat output/my_pred.sh\n# Look for:\n# - Correct key format (arg1:arg2)\n# - Proper array initialization\n# - Visited tracking for recursion\n```\n\n**Step 3: Debug with traces**\n```bash\nsource my_pred.sh\nset -x  # Enable bash tracing\nmy_pred_stream\nset +x\n```\n\n### Common Issues\n\n| Symptom | Cause | Fix |\n|---------|-------|-----|\n| Empty output | Facts not loaded | Check `listing(pred)` |\n| Infinite loop | No cycle detection | Add `unique(true)` constraint |\n| Duplicates | Wrong dedup strategy | Check constraints |\n| Key not found | Wrong arity | Verify `pred/N` matches facts |\n\n### Debugging Recursive Predicates\n\n```prolog\n% Enable compiler tracing\n?- set_prolog_flag(verbose, normal).\n\n% Compile with debug info\n?- compile(reaches/2, [target(bash), debug(true)], S).\n\n% Check classification\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\n```\n\nIf classification is wrong, simplify your rules to match known patterns.", "answer_tailored": true}
