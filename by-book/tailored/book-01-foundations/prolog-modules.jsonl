{"pair_id": "prolog-modules_p0", "cluster_id": "prolog-modules", "question": "What are Prolog modules and why does UnifyWeaver need them?", "question_type": "medium", "answer": "Prolog modules provide namespacing to organize code and prevent naming conflicts - essential for a multi-component system like UnifyWeaver.\n\n## Why UnifyWeaver Needs Modules\n\nUnifyWeaver has multiple compilers (recursive, streaming), target backends (Bash, Python, Go, etc.), and utility components. Without modules, all predicates would share a global namespace. If the Bash compiler and Python compiler both define `compile/3`, they'd conflict. Modules solve this by creating separate namespaces:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n## Module Basics\n\nEach module declares its name and exported predicates:\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported - visible to other modules\n    predicate2/3\n]).\n\n% Predicates not in the export list are private\n```\n\n## Loading UnifyWeaver Modules\n\n```prolog\n% Standard library module\n?- use_module(library(lists)).\n\n% UnifyWeaver module using the unifyweaver(...) alias\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\nThe `unifyweaver(...)` syntax is defined in init.pl as a file search path alias:\n\n```prolog\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n```\n\nThis lets you write `unifyweaver(core/recursive_compiler)` instead of the full path `'src/unifyweaver/core/recursive_compiler'`.\n\n## Using Module Predicates\n\n```prolog\n% Exported predicates are available directly after loading\n?- compile_recursive(ancestor/2, [], Code).\n\n% Module-qualified calls work for any predicate (exported or not)\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\nFor more on UnifyWeaver's module organization, see src/unifyweaver/ and education/book-01-foundations/02_prolog_fundamentals.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["modules", "use_module", "library", "namespaces"], "original_answer": "## Prolog Modules\n\nModules organize Prolog code into namespaces, preventing naming conflicts.\n\n### Why Modules?\n\nWithout modules, all predicates share a global namespace. If two files define `compile/3`, they conflict. Modules solve this:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Loading Modules\n\n```prolog\n% Load a module\n?- use_module(library(lists)).\n\n% Load UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The unifyweaver(...) Syntax\n\nThe `unifyweaver(...)` syntax is a library alias:\n\n```prolog\n% Defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% So this:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Becomes:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### Accessing Module Predicates\n\n```prolog\n% Exported predicates are available directly\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified syntax\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Module Declaration\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported predicates\n    predicate2/3\n]).\n\n% Private predicates (not in export list)\n% are only visible inside the module\n```", "answer_tailored": true}
{"pair_id": "prolog-modules_p1", "cluster_id": "prolog-modules", "question": "How do I use use_module in Prolog?", "question_type": "medium", "answer": "To use `use_module/1` in Prolog, call it with the module path:\n\n```prolog\n% Load a standard library module\n?- use_module(library(lists)).\n\n% Load a UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\nThe `use_module/1` directive loads a module and makes its exported predicates available in your code.\n\n### UnifyWeaver Module Loading\n\nUnifyWeaver uses the `unifyweaver(...)` library alias for loading project modules:\n\n```prolog\n% The alias is defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% This means:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Resolves to:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### After Loading\n\nOnce loaded, you can call exported predicates directly:\n\n```prolog\n?- compile_recursive(ancestor/2, [], Code).\n```\n\nOr use module-qualified calls:\n\n```prolog\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Why use_module?\n\nModules prevent naming conflicts by organizing predicates into namespaces. Without them, all predicates exist in a global namespace where duplicate names cause conflicts.\n\nFor more on Prolog fundamentals, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["modules", "use_module", "library", "namespaces"], "original_answer": "## Prolog Modules\n\nModules organize Prolog code into namespaces, preventing naming conflicts.\n\n### Why Modules?\n\nWithout modules, all predicates share a global namespace. If two files define `compile/3`, they conflict. Modules solve this:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Loading Modules\n\n```prolog\n% Load a module\n?- use_module(library(lists)).\n\n% Load UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The unifyweaver(...) Syntax\n\nThe `unifyweaver(...)` syntax is a library alias:\n\n```prolog\n% Defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% So this:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Becomes:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### Accessing Module Predicates\n\n```prolog\n% Exported predicates are available directly\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified syntax\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Module Declaration\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported predicates\n    predicate2/3\n]).\n\n% Private predicates (not in export list)\n% are only visible inside the module\n```", "answer_tailored": true}
{"pair_id": "prolog-modules_p2", "cluster_id": "prolog-modules", "question": "What does unifyweaver(core/...) syntax mean?", "question_type": "medium", "answer": "The `unifyweaver(core/...)` syntax is a **library alias** that provides a shorthand for loading UnifyWeaver modules.\n\n**How It Works:**\n\nUnifyWeaver defines a file search path in `init.pl`:\n\n```prolog\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n```\n\nThis alias maps `unifyweaver(...)` to the actual source directory:\n\n```prolog\n% Using the alias:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Expands to:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n**Why Use It?**\n\nThe alias provides location independence\u2014you can reference UnifyWeaver modules without hardcoding paths. Whether you're in the project root, a playbook, or a test file, `unifyweaver(core/recursive_compiler)` always resolves correctly.\n\n**Common Usage:**\n\n```prolog\n% Load core compilation modules\n?- use_module(unifyweaver(core/recursive_compiler)).\n?- use_module(unifyweaver(core/stream_compiler)).\n\n% Load target-specific modules\n?- use_module(unifyweaver(targets/bash/bash_emitter)).\n?- use_module(unifyweaver(targets/python/python_emitter)).\n```\n\nFor more details on Prolog modules and namespacing, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["modules", "use_module", "library", "namespaces"], "original_answer": "## Prolog Modules\n\nModules organize Prolog code into namespaces, preventing naming conflicts.\n\n### Why Modules?\n\nWithout modules, all predicates share a global namespace. If two files define `compile/3`, they conflict. Modules solve this:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Loading Modules\n\n```prolog\n% Load a module\n?- use_module(library(lists)).\n\n% Load UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The unifyweaver(...) Syntax\n\nThe `unifyweaver(...)` syntax is a library alias:\n\n```prolog\n% Defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% So this:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Becomes:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### Accessing Module Predicates\n\n```prolog\n% Exported predicates are available directly\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified syntax\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Module Declaration\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported predicates\n    predicate2/3\n]).\n\n% Private predicates (not in export list)\n% are only visible inside the module\n```", "answer_tailored": true}
{"pair_id": "prolog-modules_p3", "cluster_id": "prolog-modules", "question": "How do modules prevent naming conflicts?", "question_type": "medium", "answer": "Modules prevent naming conflicts by creating separate namespaces for predicates. Without modules, all predicates exist in a global scope where name collisions can occur. When two files define predicates with the same name and arity (like `compile/3`), they conflict.\n\nBy wrapping code in module declarations, each module gets its own namespace:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\nNow `recursive_compiler` and `stream_compiler` can each define their own predicates without interfering with each other. Only predicates listed in the export list (the second argument to `:- module/2`) are visible outside the module.\n\nTo access predicates from different modules:\n\n```prolog\n% Use exported predicates directly after loading\n?- use_module(unifyweaver(core/recursive_compiler)).\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified calls\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\nPrivate predicates (not in the export list) remain isolated within their module, preventing any external conflicts. This modular organization is essential in UnifyWeaver, where multiple compiler targets and components need to coexist without naming collisions.\n\nFor more on organizing UnifyWeaver code, see education/book-01-foundations/02_prolog_fundamentals.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["modules", "use_module", "library", "namespaces"], "original_answer": "## Prolog Modules\n\nModules organize Prolog code into namespaces, preventing naming conflicts.\n\n### Why Modules?\n\nWithout modules, all predicates share a global namespace. If two files define `compile/3`, they conflict. Modules solve this:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Loading Modules\n\n```prolog\n% Load a module\n?- use_module(library(lists)).\n\n% Load UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The unifyweaver(...) Syntax\n\nThe `unifyweaver(...)` syntax is a library alias:\n\n```prolog\n% Defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% So this:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Becomes:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### Accessing Module Predicates\n\n```prolog\n% Exported predicates are available directly\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified syntax\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Module Declaration\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported predicates\n    predicate2/3\n]).\n\n% Private predicates (not in export list)\n% are only visible inside the module\n```", "answer_tailored": true}
{"pair_id": "prolog-directives_p0", "cluster_id": "prolog-directives", "question": "What is a Prolog directive or pragma?", "question_type": "medium", "answer": "A Prolog directive (also called a pragma) is an instruction that starts with `:-` and executes during file loading, rather than defining facts or rules. Directives control the Prolog environment and trigger actions when a file is loaded.\n\n**Key Differences from Queries:**\n- A query at the prompt (`?- parent(alice, bob).`) asks Prolog to prove something interactively\n- A directive in a file (`:- use_module(library(lists)).`) executes automatically when the file loads\n\n**Common Directive Types:**\n\n```prolog\n% Module loading\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Module declaration\n:- module(my_module, [my_pred/2]).\n\n% Runtime-modifiable predicates\n:- dynamic(my_fact/2).\n\n% Post-load initialization\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragmas\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n**Execution Order:**\nWhen Prolog processes a source file, it first adds facts and rules to the knowledge base, then executes directives immediately in order, and finally runs any initialization goals.\n\n**UnifyWeaver's constraint Pragma:**\nUnifyWeaver extends standard Prolog with constraint directives that guide cross-language compilation:\n\n```prolog\n:- constraint(event_log/3, [unique(false), ordered]).\n```\n\nThe compiler intercepts these directives to extract metadata (predicate name, arity, options) and uses them to optimize target code generation. For more on UnifyWeaver-specific directives, see education/book-01-foundations/ and the core compiler documentation in src/unifyweaver/core/.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["directives", "pragmas", ":-", "initialization"], "original_answer": "## Prolog Directives\n\nA directive (starting with `:-`) is an instruction to Prolog, not a fact or rule.\n\n### Directive vs Query\n\n```prolog\n% Query (interactive prompt) - asks Prolog to prove something\n?- parent(alice, bob).\n\n% Directive (in file) - executes when file loads\n:- use_module(library(lists)).\n```\n\n### Common Directives\n\n```prolog\n% Load a module\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Declare a module\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicate (can be modified at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization (runs after file loads)\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragma\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n### How Directives Execute\n\nWhen Prolog loads a file:\n1. Facts and rules are added to the knowledge base\n2. Directives are executed immediately\n3. Initialization goals run after everything loads\n\n### UnifyWeaver's constraint Directive\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nUnifyWeaver intercepts this during compilation:\n1. Extracts predicate name and arity\n2. Stores constraint options\n3. Uses them to guide code generation\n\n```prolog\n% Example: preserve order, allow duplicates\n:- constraint(event_log/3, [unique(false), ordered]).\n```", "answer_tailored": true}
{"pair_id": "prolog-directives_p1", "cluster_id": "prolog-directives", "question": "What does :- mean at the start of a line?", "question_type": "medium", "answer": "The `:-` symbol at the start of a line indicates a **directive** - an instruction that executes immediately when Prolog loads the file, rather than defining a fact or rule.\n\nCommon examples:\n\n```prolog\n% Load a module\n:- use_module(library(lists)).\n\n% Declare dynamic predicates (modifiable at runtime)\n:- dynamic(my_fact/2).\n\n% Module declaration\n:- module(my_module, [exported_pred/2]).\n\n% Run initialization code after file loads\n:- initialization(setup_defaults).\n\n% UnifyWeaver-specific: declare constraints for compilation\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n**Execution flow**: When a `.pl` file loads, Prolog adds facts/rules to the knowledge base, then immediately executes any directives (in order), and finally runs any initialization goals.\n\n**Contrast with queries**: In the interactive prompt, you'd write `?- goal.` to query Prolog. In a file, `:-` serves a similar purpose but executes automatically during loading rather than requiring interactive input.\n\nFor UnifyWeaver projects, the `constraint/2` directive is particularly important - it tells the compiler how to optimize code generation for specific predicates (see education/book-01-foundations/ for constraint examples).", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["directives", "pragmas", ":-", "initialization"], "original_answer": "## Prolog Directives\n\nA directive (starting with `:-`) is an instruction to Prolog, not a fact or rule.\n\n### Directive vs Query\n\n```prolog\n% Query (interactive prompt) - asks Prolog to prove something\n?- parent(alice, bob).\n\n% Directive (in file) - executes when file loads\n:- use_module(library(lists)).\n```\n\n### Common Directives\n\n```prolog\n% Load a module\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Declare a module\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicate (can be modified at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization (runs after file loads)\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragma\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n### How Directives Execute\n\nWhen Prolog loads a file:\n1. Facts and rules are added to the knowledge base\n2. Directives are executed immediately\n3. Initialization goals run after everything loads\n\n### UnifyWeaver's constraint Directive\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nUnifyWeaver intercepts this during compilation:\n1. Extracts predicate name and arity\n2. Stores constraint options\n3. Uses them to guide code generation\n\n```prolog\n% Example: preserve order, allow duplicates\n:- constraint(event_log/3, [unique(false), ordered]).\n```", "answer_tailored": true}
{"pair_id": "prolog-directives_p2", "cluster_id": "prolog-directives", "question": "How does UnifyWeaver process the constraint directive?", "question_type": "medium", "answer": "UnifyWeaver intercepts the `constraint` directive during the compilation phase. When it encounters:\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nThe compiler performs these steps:\n\n1. **Extracts** the predicate name and arity from the directive\n2. **Stores** the constraint options (like `unique(true)`, `ordered`, etc.) in its internal metadata\n3. **Uses** these stored constraints to guide code generation for the target language\n\nFor example, with this directive:\n\n```prolog\n:- constraint(event_log/3, [unique(false), ordered]).\n```\n\nUnifyWeaver will generate target code that preserves insertion order and allows duplicate entries when compiling predicates that reference `event_log/3`.\n\nThe `constraint` directive is a **compile-time instruction** specific to UnifyWeaver (not standard Prolog). It executes when the source file is being compiled, before any runtime code generation occurs. This allows UnifyWeaver to customize how it translates logical predicates into efficient data structures in the target language (Bash, Python, Go, Rust, C#, PowerShell, or SQL).\n\nSee education/book-01-foundations/02_prolog_fundamentals.md for more on Prolog directives, and docs/proposals/ for UnifyWeaver's constraint system design.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["directives", "pragmas", ":-", "initialization"], "original_answer": "## Prolog Directives\n\nA directive (starting with `:-`) is an instruction to Prolog, not a fact or rule.\n\n### Directive vs Query\n\n```prolog\n% Query (interactive prompt) - asks Prolog to prove something\n?- parent(alice, bob).\n\n% Directive (in file) - executes when file loads\n:- use_module(library(lists)).\n```\n\n### Common Directives\n\n```prolog\n% Load a module\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Declare a module\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicate (can be modified at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization (runs after file loads)\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragma\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n### How Directives Execute\n\nWhen Prolog loads a file:\n1. Facts and rules are added to the knowledge base\n2. Directives are executed immediately\n3. Initialization goals run after everything loads\n\n### UnifyWeaver's constraint Directive\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nUnifyWeaver intercepts this during compilation:\n1. Extracts predicate name and arity\n2. Stores constraint options\n3. Uses them to guide code generation\n\n```prolog\n% Example: preserve order, allow duplicates\n:- constraint(event_log/3, [unique(false), ordered]).\n```", "answer_tailored": true}
{"pair_id": "prolog-directives_p3", "cluster_id": "prolog-directives", "question": "What's the difference between a directive and a query?", "question_type": "medium", "answer": "A directive (starting with `:-`) executes an instruction when a file loads, while a query (starting with `?-`) is asked at the interactive prompt to prove something.\n\n**Directive Example:**\n```prolog\n:- use_module(library(lists)).  % Runs when file loads\n```\n\n**Query Example:**\n```prolog\n?- parent(alice, bob).  % Asked interactively\n```\n\n**Common Directive Uses:**\n\n```prolog\n% Module loading\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Module declaration\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicates (modifiable at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization code\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraints\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n**Execution Flow:**\n\nWhen loading a file:\n1. Facts/rules populate the knowledge base\n2. Directives execute immediately\n3. Initialization goals run last\n\n**UnifyWeaver's Constraint Directive:**\n\nUnifyWeaver uses `constraint/2` directives to control code generation:\n\n```prolog\n:- constraint(event_log/3, [unique(false), ordered]).\n```\n\nThis tells the compiler to preserve order and allow duplicates when generating target code for `event_log/3`.\n\nSee education/book-01-foundations/02_prolog_fundamentals.md for more on Prolog basics.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["directives", "pragmas", ":-", "initialization"], "original_answer": "## Prolog Directives\n\nA directive (starting with `:-`) is an instruction to Prolog, not a fact or rule.\n\n### Directive vs Query\n\n```prolog\n% Query (interactive prompt) - asks Prolog to prove something\n?- parent(alice, bob).\n\n% Directive (in file) - executes when file loads\n:- use_module(library(lists)).\n```\n\n### Common Directives\n\n```prolog\n% Load a module\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Declare a module\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicate (can be modified at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization (runs after file loads)\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragma\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n### How Directives Execute\n\nWhen Prolog loads a file:\n1. Facts and rules are added to the knowledge base\n2. Directives are executed immediately\n3. Initialization goals run after everything loads\n\n### UnifyWeaver's constraint Directive\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nUnifyWeaver intercepts this during compilation:\n1. Extracts predicate name and arity\n2. Stores constraint options\n3. Uses them to guide code generation\n\n```prolog\n% Example: preserve order, allow duplicates\n:- constraint(event_log/3, [unique(false), ordered]).\n```", "answer_tailored": true}
{"pair_id": "prolog-file-io_p0", "cluster_id": "prolog-file-io", "question": "How do I write to a file in Prolog?", "question_type": "medium", "answer": "To write to a file in Prolog, you use stream-based file operations. Here's the basic approach:\n\n### Simple Write Pattern\n\n```prolog\n% Open file, write content, then close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\nThe `open/3` predicate takes three arguments: the filename, the mode (use `write` to create or overwrite a file), and a variable that will be unified with the stream handle.\n\n### Writing Different Content Types\n\n```prolog\n% Write without newline\nwrite(Stream, 'Hello').\n\n% Write with automatic newline\nwriteln(Stream, 'Hello').\n\n% Formatted output with placeholders\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Recommended Safe Pattern\n\nFor production code, use `setup_call_cleanup/3` to ensure the file closes even if an error occurs:\n\n```prolog\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Other File Modes\n\nBesides `write`, you can use:\n- `read` - Open existing file for reading\n- `append` - Add content to the end of an existing file\n\n### Creating Output Directories\n\nIf your output path doesn't exist yet:\n\n```prolog\n?- make_directory_path('education/output').\n```\n\nFor more details on Prolog fundamentals and file operations, see education/book-01-foundations/02_prolog_fundamentals.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["file-io", "open", "write", "close", "streams"], "original_answer": "## Prolog File I/O\n\nProlog uses streams for file operations.\n\n### Basic Pattern\n\n```prolog\n% Open file, write, close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### open/3 Parameters\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\n| Mode | Purpose |\n|------|--------|\n| `read` | Read from existing file |\n| `write` | Create/overwrite file |\n| `append` | Add to end of file |\n\n### Writing Content\n\n```prolog\n% Write term (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Reading Content\n\n```prolog\n% Read a term\nread(Stream, Term).\n\n% Read a line as string\nread_line_to_string(Stream, Line).\n\n% Read entire file\nread_file_to_string(FileName, Content, []).\n```\n\n### Safe Pattern with setup_call_cleanup\n\n```prolog\n% Ensures file is closed even on error\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Creating Directories\n\n```prolog\n% Create directory (including parents)\n?- make_directory_path('education/output').\n```", "answer_tailored": true}
{"pair_id": "prolog-file-io_p1", "cluster_id": "prolog-file-io", "question": "What do open, write, and close do in Prolog?", "question_type": "medium", "answer": "In Prolog file I/O, these three predicates work together to handle file operations:\n\n**`open/3`** - Opens a file and creates a stream handle\n```prolog\nopen('output/script.sh', write, Stream)\n```\n- First argument: filename\n- Second argument: mode (`read`, `write`, or `append`)\n- Third argument: stream variable to bind\n\n**`write/2`** - Outputs content to a stream\n```prolog\nwrite(Stream, BashCode)\n```\n- First argument: the stream from `open/3`\n- Second argument: the term/content to write\n- Note: doesn't add a newline (use `writeln/2` for that)\n\n**`close/1`** - Closes the stream and flushes any buffered data\n```prolog\nclose(Stream)\n```\n- Argument: the stream to close\n- Important: always close streams to prevent resource leaks\n\n### Complete Example\n\n```prolog\n% Generate a bash script\nopen('output/script.sh', write, Stream),\nwrite(Stream, '#!/bin/bash\\n'),\nwrite(Stream, 'echo \"Hello from UnifyWeaver\"\\n'),\nclose(Stream).\n```\n\n### Safer Alternative\n\nUse `setup_call_cleanup/3` to guarantee the file closes even if errors occur:\n\n```prolog\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\nFor additional I/O operations like `format/3` and file reading, see education/book-01-foundations/02_prolog_fundamentals.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["file-io", "open", "write", "close", "streams"], "original_answer": "## Prolog File I/O\n\nProlog uses streams for file operations.\n\n### Basic Pattern\n\n```prolog\n% Open file, write, close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### open/3 Parameters\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\n| Mode | Purpose |\n|------|--------|\n| `read` | Read from existing file |\n| `write` | Create/overwrite file |\n| `append` | Add to end of file |\n\n### Writing Content\n\n```prolog\n% Write term (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Reading Content\n\n```prolog\n% Read a term\nread(Stream, Term).\n\n% Read a line as string\nread_line_to_string(Stream, Line).\n\n% Read entire file\nread_file_to_string(FileName, Content, []).\n```\n\n### Safe Pattern with setup_call_cleanup\n\n```prolog\n% Ensures file is closed even on error\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Creating Directories\n\n```prolog\n% Create directory (including parents)\n?- make_directory_path('education/output').\n```", "answer_tailored": true}
{"pair_id": "prolog-file-io_p2", "cluster_id": "prolog-file-io", "question": "How does Prolog file I/O work?", "question_type": "medium", "answer": "Prolog handles file I/O through a stream-based model. Here's how it works:\n\n**Opening and Closing Files**\n\nThe fundamental operation uses `open/3` to establish a stream connection:\n\n```prolog\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\nThe `open/3` predicate takes three arguments: the file path, an access mode (`read` for existing files, `write` to create or overwrite, `append` to add content), and a variable that gets unified with the stream handle.\n\n**Writing to Streams**\n\nOnce you have a stream, several predicates let you output data:\n\n```prolog\n% Output without newline\nwrite(Stream, 'Hello').\n\n% Output with newline appended\nwriteln(Stream, 'Hello').\n\n% Formatted output with placeholders\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n**Reading from Streams**\n\nFor input operations:\n\n```prolog\n% Parse a Prolog term\nread(Stream, Term).\n\n% Get a line as a string\nread_line_to_string(Stream, Line).\n\n% Load entire file contents\nread_file_to_string(FileName, Content, []).\n```\n\n**Exception-Safe Pattern**\n\nTo guarantee proper resource cleanup even when errors occur, use `setup_call_cleanup/3`:\n\n```prolog\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\nThis ensures the stream is closed regardless of whether the write succeeds or fails.\n\n**Directory Operations**\n\n```prolog\n% Create directory hierarchy if needed\n?- make_directory_path('education/output').\n```\n\nFor more on Prolog fundamentals including file operations, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["file-io", "open", "write", "close", "streams"], "original_answer": "## Prolog File I/O\n\nProlog uses streams for file operations.\n\n### Basic Pattern\n\n```prolog\n% Open file, write, close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### open/3 Parameters\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\n| Mode | Purpose |\n|------|--------|\n| `read` | Read from existing file |\n| `write` | Create/overwrite file |\n| `append` | Add to end of file |\n\n### Writing Content\n\n```prolog\n% Write term (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Reading Content\n\n```prolog\n% Read a term\nread(Stream, Term).\n\n% Read a line as string\nread_line_to_string(Stream, Line).\n\n% Read entire file\nread_file_to_string(FileName, Content, []).\n```\n\n### Safe Pattern with setup_call_cleanup\n\n```prolog\n% Ensures file is closed even on error\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Creating Directories\n\n```prolog\n% Create directory (including parents)\n?- make_directory_path('education/output').\n```", "answer_tailored": true}
{"pair_id": "prolog-file-io_p3", "cluster_id": "prolog-file-io", "question": "What are Prolog streams?", "question_type": "medium", "answer": "Prolog streams are I/O channels that handle file operations and data flow. A stream is obtained when you open a file and serves as the connection point for reading or writing data.\n\n### Opening Streams\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\nThe `open/3` predicate creates a stream:\n- `read` - Opens existing file for input\n- `write` - Creates new file or overwrites existing\n- `append` - Adds to end of existing file\n\n### Stream Operations\n\nOnce you have a stream, you can perform operations on it:\n\n```prolog\n% Write to stream (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n\n% Read term from stream\nread(Stream, Term).\n\n% Read line as string\nread_line_to_string(Stream, Line).\n```\n\n### Complete Example\n\n```prolog\n% Open stream, write content, close stream\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### Safe Stream Handling\n\nAlways close streams when done. Use `setup_call_cleanup/3` to ensure closure even on errors:\n\n```prolog\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\nFor more details on Prolog fundamentals including streams, see education/book-01-foundations/02_prolog_fundamentals.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["file-io", "open", "write", "close", "streams"], "original_answer": "## Prolog File I/O\n\nProlog uses streams for file operations.\n\n### Basic Pattern\n\n```prolog\n% Open file, write, close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### open/3 Parameters\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\n| Mode | Purpose |\n|------|--------|\n| `read` | Read from existing file |\n| `write` | Create/overwrite file |\n| `append` | Add to end of file |\n\n### Writing Content\n\n```prolog\n% Write term (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Reading Content\n\n```prolog\n% Read a term\nread(Stream, Term).\n\n% Read a line as string\nread_line_to_string(Stream, Line).\n\n% Read entire file\nread_file_to_string(FileName, Content, []).\n```\n\n### Safe Pattern with setup_call_cleanup\n\n```prolog\n% Ensures file is closed even on error\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Creating Directories\n\n```prolog\n% Create directory (including parents)\n?- make_directory_path('education/output').\n```", "answer_tailored": true}
{"pair_id": "init-pl-explained_p0", "cluster_id": "init-pl-explained", "question": "What does education/init.pl do?", "question_type": "medium", "answer": "The `education/init.pl` file configures the Prolog environment for working with UnifyWeaver educational materials.\n\n### Core Functionality\n\nIt performs three essential tasks:\n\n```prolog\n% 1. Establishes library search paths\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Loads core compiler modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Confirms initialization\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### The Problem It Solves\n\nProlog needs to know where UnifyWeaver modules are located. Without `init.pl`, attempting to load modules fails:\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nAfter loading `init.pl`, the `unifyweaver` alias resolves correctly:\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### How Library Aliases Work\n\nThe `file_search_path/2` predicate maps aliases to actual directories:\n\n```prolog\n% Define the mapping\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% These become equivalent:\nuse_module(unifyweaver(core/foo))  % Using alias\nuse_module('src/unifyweaver/core/foo')  % Direct path\n```\n\n### Usage Options\n\nYou can load it interactively or via command-line flag:\n\n```bash\n# Auto-load on startup\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["init.pl", "initialization", "setup", "library-paths"], "original_answer": "## Understanding init.pl\n\nThe `init.pl` file sets up the UnifyWeaver environment.\n\n### What It Does\n\n```prolog\n% education/init.pl typically contains:\n\n% 1. Set library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Print confirmation\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Why It's Necessary\n\nWithout init.pl:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nWith init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Library Search Paths\n\nProlog uses `file_search_path/2` to resolve library aliases:\n\n```prolog\n% Define alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Alternative: Using -f Flag\n\n```bash\n# Load init.pl automatically\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "answer_tailored": true}
{"pair_id": "init-pl-explained_p1", "cluster_id": "init-pl-explained", "question": "Why do I need to load init.pl first?", "question_type": "medium", "answer": "## Why Load init.pl First?\n\nThe `init.pl` file configures the Prolog environment so it knows where to find UnifyWeaver modules. Without it, Prolog cannot resolve the `unifyweaver(...)` library paths.\n\n### The Problem Without init.pl\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nProlog doesn't know what `unifyweaver` refers to, so module loading fails.\n\n### What init.pl Does\n\n```prolog\n% education/init.pl sets up the environment:\n\n% 1. Register the library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Confirm initialization\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\nThe critical part is `file_search_path/2`, which tells Prolog that `unifyweaver` is an alias for `src/unifyweaver`.\n\n### After Loading init.pl\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\nNow Prolog can resolve the library alias and load modules successfully.\n\n### How file_search_path Works\n\n```prolog\n% Define the alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% These become equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Automatically Loading init.pl\n\nYou can use the `-f` flag to load it on startup:\n\n```bash\n# From education directory\nswipl -f education/init.pl\n\n# From project root\nswipl -f init.pl\n```\n\nFor more on the educational setup, see education/book-01-foundations/.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["init.pl", "initialization", "setup", "library-paths"], "original_answer": "## Understanding init.pl\n\nThe `init.pl` file sets up the UnifyWeaver environment.\n\n### What It Does\n\n```prolog\n% education/init.pl typically contains:\n\n% 1. Set library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Print confirmation\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Why It's Necessary\n\nWithout init.pl:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nWith init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Library Search Paths\n\nProlog uses `file_search_path/2` to resolve library aliases:\n\n```prolog\n% Define alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Alternative: Using -f Flag\n\n```bash\n# Load init.pl automatically\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "answer_tailored": true}
{"pair_id": "init-pl-explained_p2", "cluster_id": "init-pl-explained", "question": "What does init.pl set up?", "question_type": "medium", "answer": "The `init.pl` file establishes the UnifyWeaver environment by configuring essential paths and loading core modules.\n\n### Core Setup Tasks\n\n`init.pl` performs three main operations:\n\n```prolog\n% education/init.pl structure:\n\n% 1. Configure library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Import common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Display confirmation message\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Purpose of Library Path Configuration\n\nThe file search path setup allows Prolog to resolve `unifyweaver` aliases to actual file locations:\n\n```prolog\n% After init.pl defines:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% These become equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Impact on Module Loading\n\nWithout init.pl loaded:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nAfter loading init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Loading Options\n\nYou can load init.pl interactively or via command-line flag:\n\n```bash\n# Automatic loading on startup\nswipl -f education/init.pl\n\n# From project root\nswipl -f init.pl\n```", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["init.pl", "initialization", "setup", "library-paths"], "original_answer": "## Understanding init.pl\n\nThe `init.pl` file sets up the UnifyWeaver environment.\n\n### What It Does\n\n```prolog\n% education/init.pl typically contains:\n\n% 1. Set library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Print confirmation\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Why It's Necessary\n\nWithout init.pl:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nWith init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Library Search Paths\n\nProlog uses `file_search_path/2` to resolve library aliases:\n\n```prolog\n% Define alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Alternative: Using -f Flag\n\n```bash\n# Load init.pl automatically\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "answer_tailored": true}
{"pair_id": "init-pl-explained_p3", "cluster_id": "init-pl-explained", "question": "How do library search paths work in Prolog?", "question_type": "medium", "answer": "Prolog's library search paths use the `file_search_path/2` predicate to map aliases to actual directories. This allows you to reference modules using short, portable names instead of full paths.\n\n### How It Works\n\nThe `file_search_path/2` predicate defines an alias mapping:\n\n```prolog\n% Define the alias 'unifyweaver' to point to the actual directory\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these two are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Setting Up Search Paths\n\nIn UnifyWeaver, the `init.pl` file configures the search path dynamically:\n\n```prolog\n% education/init.pl sets up the path relative to its location\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n```\n\n### Why This Matters\n\nWithout a proper search path configured:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nAfter loading init.pl with the search path defined:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\nThis mechanism makes module loading location-independent and more maintainable. See education/book-01-foundations/01_introduction.md for setup details.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["init.pl", "initialization", "setup", "library-paths"], "original_answer": "## Understanding init.pl\n\nThe `init.pl` file sets up the UnifyWeaver environment.\n\n### What It Does\n\n```prolog\n% education/init.pl typically contains:\n\n% 1. Set library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Print confirmation\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Why It's Necessary\n\nWithout init.pl:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nWith init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Library Search Paths\n\nProlog uses `file_search_path/2` to resolve library aliases:\n\n```prolog\n% Define alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Alternative: Using -f Flag\n\n```bash\n# Load init.pl automatically\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "answer_tailored": true}
