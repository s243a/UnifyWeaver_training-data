{"pair_id": "practical-compilation_p0", "cluster_id": "practical-compilation", "question": "How do I compile a Prolog predicate to Bash with UnifyWeaver?", "question_type": "medium", "answer": "To compile a Prolog predicate to Bash using UnifyWeaver, follow these steps:\n\n**1. Launch SWI-Prolog with UnifyWeaver:**\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n**2. Load the compiler module:**\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n**3. Define your predicate (example using facts):**\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n**4. Invoke the compiler with the Bash target:**\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n**5. Examine the generated Bash script:**\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nThis produces:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n**6. Run the generated script:**\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```\n\nFor more details on Bash compilation patterns, see education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "docs/targets/bash.md", "topics": ["compilation", "bash", "how-to", "compile", "generated-code"], "original_answer": "## Compiling Prolog to Bash\n\nHere's the complete step-by-step process:\n\n### Step 1: Start SWI-Prolog with UnifyWeaver\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### Step 2: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n### Step 3: Define Your Predicates\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n### Step 4: Compile to Bash\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n### Step 5: View Generated Code\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nOutput:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Step 6: Test the Generated Code\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```", "answer_tailored": true}
{"pair_id": "practical-compilation_p1", "cluster_id": "practical-compilation", "question": "What is the step-by-step process to compile Prolog to Bash?", "question_type": "medium", "answer": "## Step-by-Step Prolog to Bash Compilation Process\n\nHere's how to compile Prolog predicates to Bash using UnifyWeaver:\n\n**Step 1: Initialize UnifyWeaver**\n\nLaunch SWI-Prolog with the UnifyWeaver initialization file:\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n**Step 2: Load the Compiler Module**\n\nImport the compiler driver module:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n**Step 3: Define Prolog Predicates**\n\nAssert your Prolog facts or rules:\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n**Step 4: Invoke the Compiler**\n\nCall `compile/3` with the target set to `bash`:\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n**Step 5: Examine Generated Bash Script**\n\nView the compiled output:\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nThe compiler generates a Bash script with associative arrays and lookup functions:\n\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n**Step 6: Execute and Verify**\n\nSource the script and test the generated functions:\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```\n\nFor more details on Bash target compilation, see education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "docs/targets/bash.md", "topics": ["compilation", "bash", "how-to", "compile", "generated-code"], "original_answer": "## Compiling Prolog to Bash\n\nHere's the complete step-by-step process:\n\n### Step 1: Start SWI-Prolog with UnifyWeaver\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### Step 2: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n### Step 3: Define Your Predicates\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n### Step 4: Compile to Bash\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n### Step 5: View Generated Code\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nOutput:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Step 6: Test the Generated Code\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```", "answer_tailored": true}
{"pair_id": "practical-compilation_p2", "cluster_id": "practical-compilation", "question": "How do I use the UnifyWeaver compiler?", "question_type": "medium", "answer": "To use the UnifyWeaver compiler, follow these steps:\n\n**1. Launch SWI-Prolog with UnifyWeaver:**\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n**2. Load the compiler module:**\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n**3. Define your Prolog predicates:**\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n**4. Compile to your target language (e.g., Bash):**\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n**5. Examine the generated output:**\n```bash\ncat education/output/advanced/edge.sh\n```\n\nThe compiler produces executable code in your target language:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n**6. Execute the generated code:**\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```\n\nThe compiler supports multiple targets including Bash, Python, Go, Rust, C#, PowerShell, and SQL. For target-specific details, see education/book-02-bash-target/ and other target-specific books.", "answer_variant": "default", "answer_source": "docs/targets/bash.md", "topics": ["compilation", "bash", "how-to", "compile", "generated-code"], "original_answer": "## Compiling Prolog to Bash\n\nHere's the complete step-by-step process:\n\n### Step 1: Start SWI-Prolog with UnifyWeaver\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### Step 2: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n### Step 3: Define Your Predicates\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n### Step 4: Compile to Bash\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n### Step 5: View Generated Code\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nOutput:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Step 6: Test the Generated Code\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```", "answer_tailored": true}
{"pair_id": "practical-compilation_p3", "cluster_id": "practical-compilation", "question": "What command compiles a predicate?", "question_type": "medium", "answer": "To compile a predicate to Bash, use the `compile/3` directive in SWI-Prolog:\n\n```prolog\n?- compile(predicate_name/arity, [target(bash)], Scripts).\n```\n\nFor example, to compile an `edge/2` predicate:\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\nThe `compile/3` predicate takes three arguments:\n- **Predicate indicator** (e.g., `edge/2`)\n- **Options list** containing `target(bash)` and optional settings\n- **Output variable** that unifies with the list of generated script paths\n\nBefore compiling, ensure you've loaded the compiler module:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n```\n\nThe generated Bash script will be written to the output directory (typically `education/output/advanced/`). You can then source and execute the script:\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream  # Lists all facts\nedge a b     # Queries specific fact\n```\n\nSee docs/targets/bash.md for complete compilation examples and generated code patterns.", "answer_variant": "default", "answer_source": "docs/targets/bash.md", "topics": ["compilation", "bash", "how-to", "compile", "generated-code"], "original_answer": "## Compiling Prolog to Bash\n\nHere's the complete step-by-step process:\n\n### Step 1: Start SWI-Prolog with UnifyWeaver\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### Step 2: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n### Step 3: Define Your Predicates\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n### Step 4: Compile to Bash\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n### Step 5: View Generated Code\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nOutput:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Step 6: Test the Generated Code\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```", "answer_tailored": true}
{"pair_id": "generated-code-facts_p0", "cluster_id": "generated-code-facts", "question": "What does generated Bash code look like for Prolog facts?", "question_type": "medium", "answer": "## Bash Code Generation for Prolog Facts\n\nWhen UnifyWeaver compiles Prolog facts to Bash, it generates associative arrays with O(1) lookup functions:\n\n### Example: Parent Facts\n\n**Prolog input:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n**Generated Bash output:**\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Key Design Decisions\n\nThe generated code uses **Bash associative arrays** because they provide:\n\n- **Constant-time lookup** via hash table implementation\n- **Automatic deduplication** (keys are inherently unique)\n- **Efficient memory usage** in Bash 4+\n- **Native iteration** over keys with `${!array[@]}`\n\n### Running the Generated Code\n\n```bash\nsource parent.sh\n\n# Query specific relationship\nparent alice bob\n# \u2192 alice:bob\n\n# Enumerate all relationships  \nparent_stream\n# \u2192 alice:bob\n# \u2192 bob:charlie\n# \u2192 charlie:david\n```\n\nThe compiler generates three functions per fact predicate: direct lookup, forward streaming, and reverse streaming. See src/unifyweaver/core/stream_compiler.pl for the compilation logic.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/stream_compiler.pl", "topics": ["facts", "associative-arrays", "bash", "generated-code", "declare"], "original_answer": "## Generated Code for Facts\n\nProlog facts compile to Bash associative arrays for O(1) lookup:\n\n### Input: Prolog Facts\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n### Output: Generated Bash\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Associative Arrays?\n\n1. **O(1) lookup** - `[[ -n \"${parent_data[$key]}\" ]]` is constant time\n2. **Deduplication** - Keys are unique by definition\n3. **Memory efficient** - Bash 4+ handles large arrays well\n4. **Streaming** - `${!array[@]}` iterates all keys\n\n### Usage\n\n```bash\nsource parent.sh\n\n# Check if alice is parent of bob\nparent alice bob\n# Output: alice:bob\n\n# List all parent relationships  \nparent_stream\n# Output:\n# alice:bob\n# bob:charlie\n# charlie:david\n```", "answer_tailored": true}
{"pair_id": "generated-code-facts_p1", "cluster_id": "generated-code-facts", "question": "How are Prolog facts compiled to Bash?", "question_type": "medium", "answer": "## Bash Compilation of Prolog Facts\n\nProlog facts compile to Bash associative arrays, providing efficient O(1) lookup operations.\n\n### Example Transformation\n\nGiven these Prolog facts:\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\nThe compiler generates this Bash code:\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Compilation Strategy\n\nEach fact becomes an entry in a Bash associative array where:\n- **Keys**: Colon-separated argument values (e.g., `alice:bob`)\n- **Values**: Simple presence marker (`1`)\n- **Functions**: Generated for lookup, streaming, and reverse streaming\n\n### Performance Benefits\n\n1. **Constant-time lookups** - Associative array checks are O(1)\n2. **Automatic deduplication** - Hash keys prevent duplicates\n3. **Efficient iteration** - `${!array[@]}` provides all keys\n4. **Bash 4+ optimization** - Native support for large arrays\n\n### Using the Generated Code\n\n```bash\nsource parent.sh\n\n# Query specific fact\nparent alice bob\n# Returns: alice:bob\n\n# List all facts\nparent_stream\n# Returns:\n# alice:bob\n# bob:charlie\n# charlie:david\n```\n\nFor more details on Bash target compilation, see `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/stream_compiler.pl", "topics": ["facts", "associative-arrays", "bash", "generated-code", "declare"], "original_answer": "## Generated Code for Facts\n\nProlog facts compile to Bash associative arrays for O(1) lookup:\n\n### Input: Prolog Facts\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n### Output: Generated Bash\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Associative Arrays?\n\n1. **O(1) lookup** - `[[ -n \"${parent_data[$key]}\" ]]` is constant time\n2. **Deduplication** - Keys are unique by definition\n3. **Memory efficient** - Bash 4+ handles large arrays well\n4. **Streaming** - `${!array[@]}` iterates all keys\n\n### Usage\n\n```bash\nsource parent.sh\n\n# Check if alice is parent of bob\nparent alice bob\n# Output: alice:bob\n\n# List all parent relationships  \nparent_stream\n# Output:\n# alice:bob\n# bob:charlie\n# charlie:david\n```", "answer_tailored": true}
{"pair_id": "generated-code-facts_p2", "cluster_id": "generated-code-facts", "question": "Why does UnifyWeaver use associative arrays?", "question_type": "medium", "answer": "UnifyWeaver uses associative arrays in Bash (and similar data structures in other target languages) to achieve efficient O(1) lookup performance when compiling Prolog facts. This design choice directly addresses the need for fast fact checking in logic programs.\n\nWhen you define facts like `parent(alice, bob).`, the compiler generates a Bash associative array where the key is the concatenated arguments (e.g., `alice:bob`) and the value is `1`:\n\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n```\n\nThe lookup function then performs constant-time checks:\n\n```bash\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n```\n\n**Key advantages of this approach:**\n\n1. **O(1) lookup time** - Checking if a fact exists is instantaneous regardless of dataset size\n2. **Automatic deduplication** - Array keys are inherently unique, preventing duplicate facts\n3. **Memory efficiency** - Bash 4+ handles large associative arrays effectively\n4. **Streaming support** - `${!array[@]}` enables iteration over all facts, and reverse lookups are simple to implement\n\nThis pattern extends to other target languages: Python uses dictionaries, Go uses maps, and C# uses Dictionary types\u2014all providing the same O(1) lookup guarantees that make compiled Prolog queries efficient.\n\nFor implementation details, see `src/unifyweaver/core/stream_compiler.pl` and examples in `playbooks/`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/stream_compiler.pl", "topics": ["facts", "associative-arrays", "bash", "generated-code", "declare"], "original_answer": "## Generated Code for Facts\n\nProlog facts compile to Bash associative arrays for O(1) lookup:\n\n### Input: Prolog Facts\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n### Output: Generated Bash\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Associative Arrays?\n\n1. **O(1) lookup** - `[[ -n \"${parent_data[$key]}\" ]]` is constant time\n2. **Deduplication** - Keys are unique by definition\n3. **Memory efficient** - Bash 4+ handles large arrays well\n4. **Streaming** - `${!array[@]}` iterates all keys\n\n### Usage\n\n```bash\nsource parent.sh\n\n# Check if alice is parent of bob\nparent alice bob\n# Output: alice:bob\n\n# List all parent relationships  \nparent_stream\n# Output:\n# alice:bob\n# bob:charlie\n# charlie:david\n```", "answer_tailored": true}
{"pair_id": "generated-code-facts_p3", "cluster_id": "generated-code-facts", "question": "What is the structure of generated fact lookup code?", "question_type": "medium", "answer": "## Fact Lookup Code Structure\n\nGenerated Bash code for Prolog facts uses three main components:\n\n### 1. Associative Array Storage\n\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n```\n\nArguments are concatenated with `:` as the key, value is always `1` (presence marker).\n\n### 2. Point Lookup Function\n\n```bash\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n```\n\nConstructs the key from arguments and tests for presence in the array. Returns the key if found, nothing otherwise.\n\n### 3. Streaming Functions\n\n**Forward stream** - enumerate all facts:\n```bash\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n**Reverse stream** - swap argument positions:\n```bash\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\nThis structure provides O(1) lookups via hash table access while supporting both point queries and full table scans. The key format allows argument binding at different positions through string manipulation.\n\nFor implementation details, see `src/unifyweaver/core/stream_compiler.pl`.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/stream_compiler.pl", "topics": ["facts", "associative-arrays", "bash", "generated-code", "declare"], "original_answer": "## Generated Code for Facts\n\nProlog facts compile to Bash associative arrays for O(1) lookup:\n\n### Input: Prolog Facts\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n### Output: Generated Bash\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Associative Arrays?\n\n1. **O(1) lookup** - `[[ -n \"${parent_data[$key]}\" ]]` is constant time\n2. **Deduplication** - Keys are unique by definition\n3. **Memory efficient** - Bash 4+ handles large arrays well\n4. **Streaming** - `${!array[@]}` iterates all keys\n\n### Usage\n\n```bash\nsource parent.sh\n\n# Check if alice is parent of bob\nparent alice bob\n# Output: alice:bob\n\n# List all parent relationships  \nparent_stream\n# Output:\n# alice:bob\n# bob:charlie\n# charlie:david\n```", "answer_tailored": true}
{"pair_id": "generated-code-transitive_p0", "cluster_id": "generated-code-transitive", "question": "How does UnifyWeaver compile a transitive closure to Bash?", "question_type": "medium", "answer": "UnifyWeaver compiles transitive closure patterns to Bash by generating breadth-first search (BFS) code with visited tracking, avoiding recursion which would hit Bash's stack limits.\n\nWhen you define a transitive closure in Prolog:\n\n```prolog\nreaches(X, Y) :- edge(X, Y).\nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\nThe compiler detects the pattern and generates optimized Bash:\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n**Key compilation strategies:**\n\n- **BFS iteration** replaces recursive calls to avoid stack overflow\n- **Associative array** (`declare -A visited`) prevents infinite loops on cycles\n- **Temporary queue files** handle large graphs efficiently\n- **Stream processing** with `sort -u` deduplicates results\n\nThis approach is detailed in `src/unifyweaver/core/advanced/linear_recursion.pl` and `education/book-02-bash-target/` covers Bash-specific compilation techniques.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/advanced/linear_recursion.pl", "topics": ["transitive-closure", "recursion", "bfs", "generated-code", "reaches"], "original_answer": "## Transitive Closure Compilation\n\nUnifyWeaver detects transitive closure patterns and generates optimized BFS code:\n\n### Input: Prolog Rules\n\n```prolog\n% Base case\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case  \nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Detection\n\n```prolog\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n### Output: BFS with Visited Tracking\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Optimizations\n\n1. **BFS not recursion** - Avoids Bash stack limits\n2. **Visited tracking** - `declare -A visited` prevents cycles\n3. **Deduplication** - `sort -u` removes duplicates\n4. **Temp files** - Queue stored in `/tmp` for large graphs\n\n### Usage\n\n```bash\nsource edge.sh reaches.sh\n\n# Find all nodes reachable from 'a'\nreaches a\n# Output: a:b  a:c  a:d\n\n# Check if 'd' is reachable from 'a'\nreaches a d && echo \"yes\" || echo \"no\"\n# Output: yes\n```", "answer_tailored": true}
{"pair_id": "generated-code-transitive_p1", "cluster_id": "generated-code-transitive", "question": "What does generated code for recursive predicates look like?", "question_type": "medium", "answer": "## Generated Code for Recursive Predicates\n\nWhen compiling recursive predicates, UnifyWeaver transforms Prolog recursion into iterative algorithms optimized for each target language. Here's what the generated code looks like:\n\n### Source Prolog\n\n```prolog\n% Direct recursion\nreaches(X, Y) :- edge(X, Y).\nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Generated Bash Code\n\n```bash\n#!/bin/bash\n# Iterative BFS implementation\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # Breadth-first traversal instead of recursion\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand to adjacent nodes\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Code Structure\n\nThe generated code replaces recursive calls with:\n\n1. **Work queue** - Temporary file `/tmp/reaches_queue_$$` manages pending nodes\n2. **Visited set** - Associative array `visited[]` prevents infinite loops\n3. **Iterative loops** - `while` loops replace recursive function calls\n4. **Streaming output** - Results produced incrementally with deduplication via `sort -u`\n\nThis compilation strategy avoids stack overflow issues in target languages and provides better performance for graph traversal workloads. See `src/unifyweaver/core/advanced/linear_recursion.pl` for the detection and transformation logic.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/advanced/linear_recursion.pl", "topics": ["transitive-closure", "recursion", "bfs", "generated-code", "reaches"], "original_answer": "## Transitive Closure Compilation\n\nUnifyWeaver detects transitive closure patterns and generates optimized BFS code:\n\n### Input: Prolog Rules\n\n```prolog\n% Base case\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case  \nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Detection\n\n```prolog\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n### Output: BFS with Visited Tracking\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Optimizations\n\n1. **BFS not recursion** - Avoids Bash stack limits\n2. **Visited tracking** - `declare -A visited` prevents cycles\n3. **Deduplication** - `sort -u` removes duplicates\n4. **Temp files** - Queue stored in `/tmp` for large graphs\n\n### Usage\n\n```bash\nsource edge.sh reaches.sh\n\n# Find all nodes reachable from 'a'\nreaches a\n# Output: a:b  a:c  a:d\n\n# Check if 'd' is reachable from 'a'\nreaches a d && echo \"yes\" || echo \"no\"\n# Output: yes\n```", "answer_tailored": true}
{"pair_id": "generated-code-transitive_p2", "cluster_id": "generated-code-transitive", "question": "How is ancestor/2 compiled to Bash?", "question_type": "medium", "answer": "## Ancestor/2 Compilation to Bash\n\nUnifyWeaver compiles `ancestor/2` by detecting it as a transitive closure pattern and generating BFS-based Bash code:\n\n### Prolog Source\n\n```prolog\n% Base case\nancestor(X, Y) :- parent(X, Y).\n\n% Recursive case  \nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### Compilation Process\n\n```prolog\n?- compile(ancestor/2, [target(bash)], Scripts).\n=== Analyzing ancestor/2 ===\nClassification: transitive_closure(parent)\nDetected transitive closure over parent\n```\n\n### Generated Bash Code\n\n```bash\n#!/bin/bash\n# ancestor - transitive closure of parent\n\nancestor_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/ancestor_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(parent_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nancestor() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        ancestor_all \"$start\" | sort -u\n    else\n        ancestor_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Implementation Features\n\n1. **Breadth-first search** - Prevents Bash recursion stack overflow\n2. **Cycle prevention** - `declare -A visited` hash table tracks seen nodes\n3. **Streaming expansion** - Uses `parent_stream` to query base relation\n4. **Deduplication** - `sort -u` eliminates duplicate paths\n5. **Queue management** - Temporary files handle large ancestry trees\n\n### Example Usage\n\n```bash\nsource parent.sh ancestor.sh\n\n# Find all ancestors of 'john'\nancestor john\n# Output: john:mary  john:robert  john:elizabeth\n\n# Check if 'elizabeth' is ancestor of 'john'\nancestor john elizabeth && echo \"yes\" || echo \"no\"\n# Output: yes\n```\n\nSee education/book-02-bash-target/ for more details on transitive closure compilation strategies.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/advanced/linear_recursion.pl", "topics": ["transitive-closure", "recursion", "bfs", "generated-code", "reaches"], "original_answer": "## Transitive Closure Compilation\n\nUnifyWeaver detects transitive closure patterns and generates optimized BFS code:\n\n### Input: Prolog Rules\n\n```prolog\n% Base case\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case  \nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Detection\n\n```prolog\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n### Output: BFS with Visited Tracking\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Optimizations\n\n1. **BFS not recursion** - Avoids Bash stack limits\n2. **Visited tracking** - `declare -A visited` prevents cycles\n3. **Deduplication** - `sort -u` removes duplicates\n4. **Temp files** - Queue stored in `/tmp` for large graphs\n\n### Usage\n\n```bash\nsource edge.sh reaches.sh\n\n# Find all nodes reachable from 'a'\nreaches a\n# Output: a:b  a:c  a:d\n\n# Check if 'd' is reachable from 'a'\nreaches a d && echo \"yes\" || echo \"no\"\n# Output: yes\n```", "answer_tailored": true}
{"pair_id": "generated-code-transitive_p3", "cluster_id": "generated-code-transitive", "question": "What optimization does UnifyWeaver use for transitive closures?", "question_type": "medium", "answer": "UnifyWeaver applies **breadth-first search (BFS) compilation** when it detects transitive closure patterns in recursive Prolog rules.\n\n## How It Works\n\nWhen you define transitive closure rules like:\n\n```prolog\nreaches(X, Y) :- edge(X, Y).\nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\nThe compiler recognizes this as a transitive closure pattern and generates optimized iterative code instead of naive recursion.\n\n## Key Optimizations\n\n1. **BFS traversal instead of recursion** - Eliminates stack overflow issues in target languages like Bash\n2. **Visited set tracking** - Uses hash maps (`declare -A visited` in Bash) to prevent infinite cycles\n3. **Queue-based expansion** - Processes nodes level-by-level using temporary files or data structures\n4. **Deduplication** - Automatically removes duplicate paths with `sort -u` or equivalent\n\n## Generated Code Example (Bash)\n\n```bash\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n```\n\nThis approach scales to large graphs without hitting recursion limits. See src/unifyweaver/core/advanced/linear_recursion.pl for the detection and compilation logic.", "answer_variant": "default", "answer_source": "src/unifyweaver/core/advanced/linear_recursion.pl", "topics": ["transitive-closure", "recursion", "bfs", "generated-code", "reaches"], "original_answer": "## Transitive Closure Compilation\n\nUnifyWeaver detects transitive closure patterns and generates optimized BFS code:\n\n### Input: Prolog Rules\n\n```prolog\n% Base case\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case  \nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Detection\n\n```prolog\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n### Output: BFS with Visited Tracking\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Optimizations\n\n1. **BFS not recursion** - Avoids Bash stack limits\n2. **Visited tracking** - `declare -A visited` prevents cycles\n3. **Deduplication** - `sort -u` removes duplicates\n4. **Temp files** - Queue stored in `/tmp` for large graphs\n\n### Usage\n\n```bash\nsource edge.sh reaches.sh\n\n# Find all nodes reachable from 'a'\nreaches a\n# Output: a:b  a:c  a:d\n\n# Check if 'd' is reachable from 'a'\nreaches a d && echo \"yes\" || echo \"no\"\n# Output: yes\n```", "answer_tailored": true}
