{"pair_id": "bash-target-design_p0", "cluster_id": "bash-target-design", "question": "How does UnifyWeaver generate Bash code?", "question_type": "medium", "answer": "UnifyWeaver's Bash code generation uses a template-driven approach that transforms Prolog constructs into shell scripts operating over text streams.\n\n**Facts become associative arrays**: Prolog facts compile to `declare -A` hash maps for O(1) lookup. For example, `parent(alice, bob)` becomes `declare -A parent_data=([alice:bob]=1)`. The compiler generates helper functions for forward lookup, streaming all facts, and reverse streaming.\n\n**Rules translate to functions**: Simple queries become bash functions that check the associative array. More complex patterns generate streaming functions that output colon-delimited results to stdout, enabling composition via pipes.\n\n**Recursive queries use BFS with memoization**: Transitive closures like `ancestor(X, Y)` compile to breadth-first search loops. The generated code maintains a `visited` associative array to prevent cycles and a queue for frontier expansion. Base facts from `parent_stream` initialize the queue, then each iteration expands relationships and tracks visited nodes.\n\n**Core design principles**:\n- Deduplication through hash-based storage\n- Stream-oriented output for Unix-style composition  \n- Cycle detection via visited tracking in recursive queries\n\nThe implementation details are documented in `education/book-02-bash-target/`, which covers the full compilation pipeline from Prolog AST to executable shell scripts.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["bash", "code-generation", "associative-arrays", "streaming", "templates"], "original_answer": "## Bash Target Design\n\nThe Bash target uses template-driven code generation to create shell scripts that operate over textual streams.\n\n## Facts \u2192 Associative Arrays\n\nProlog facts compile to `declare -A` associative arrays:\n\n```prolog\n% Prolog facts\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nGenerated Bash:\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n\nparent_reverse_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        IFS=\":\" read -r a b <<< \"$key\"\n        echo \"$b:$a\"\n    done\n}\n```\n\n## Recursion \u2192 BFS with Memoization\n\nTransitive closures use BFS loops with visited tracking:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Initialize with base cases\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS traversal\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\n## Key Features\n\n- **Deduplication**: `declare -A` provides O(1) lookup\n- **Streaming**: Functions output to stdout for piping\n- **Cycle detection**: `visited` array prevents infinite loops", "answer_tailored": true}
{"pair_id": "bash-target-design_p1", "cluster_id": "bash-target-design", "question": "How are Prolog facts compiled to Bash?", "question_type": "medium", "answer": "Prolog facts compile to Bash associative arrays using `declare -A`. Each fact becomes a key-value entry where the arguments are joined with colons.\n\nFor example, these Prolog facts:\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nGenerate this Bash code:\n\n```bash\n#!/bin/bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n```\n\nThe compiler generates three functions per fact:\n- **Lookup function** (`parent`): Checks if a specific fact exists using O(1) array lookup\n- **Stream function** (`parent_stream`): Outputs all facts to stdout for pipeline processing\n- **Reverse stream** (optional): Inverts argument order for bidirectional queries\n\nFor recursive queries like transitive closure, the Bash target uses BFS loops with memoization to prevent infinite cycles:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Seed with direct parent relationships\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS expansion\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\nThis template-driven approach ensures deduplication through associative arrays and enables streaming composition via stdout. See education/book-02-bash-target/ for complete implementation details.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["bash", "code-generation", "associative-arrays", "streaming", "templates"], "original_answer": "## Bash Target Design\n\nThe Bash target uses template-driven code generation to create shell scripts that operate over textual streams.\n\n## Facts \u2192 Associative Arrays\n\nProlog facts compile to `declare -A` associative arrays:\n\n```prolog\n% Prolog facts\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nGenerated Bash:\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n\nparent_reverse_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        IFS=\":\" read -r a b <<< \"$key\"\n        echo \"$b:$a\"\n    done\n}\n```\n\n## Recursion \u2192 BFS with Memoization\n\nTransitive closures use BFS loops with visited tracking:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Initialize with base cases\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS traversal\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\n## Key Features\n\n- **Deduplication**: `declare -A` provides O(1) lookup\n- **Streaming**: Functions output to stdout for piping\n- **Cycle detection**: `visited` array prevents infinite loops", "answer_tailored": true}
{"pair_id": "bash-target-design_p2", "cluster_id": "bash-target-design", "question": "What does generated Bash code look like?", "question_type": "medium", "answer": "UnifyWeaver generates Bash scripts that use associative arrays and stream-based processing to implement Prolog semantics.\n\n## Facts Become Associative Arrays\n\nProlog facts compile to `declare -A` hash maps with colon-separated keys:\n\n```bash\n#!/bin/bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n```\n\nFor facts like `parent(alice, bob)`, the generated code creates lookup functions that check hash membership and streaming functions that emit all facts.\n\n## Recursive Rules Use BFS\n\nTransitive queries compile to breadth-first search with memoization:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Seed with direct parents\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS expansion\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Add children to frontier\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\nThe generated code prevents infinite loops with a `visited` array and processes relationships level-by-level through a queue.\n\n## Design Principles\n\n- Template-driven generation produces idiomatic Bash\n- Stream-oriented functions enable Unix-style piping\n- O(1) lookups via associative arrays for efficiency\n\nSee education/book-02-bash-target/ for complete implementation details and more examples.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["bash", "code-generation", "associative-arrays", "streaming", "templates"], "original_answer": "## Bash Target Design\n\nThe Bash target uses template-driven code generation to create shell scripts that operate over textual streams.\n\n## Facts \u2192 Associative Arrays\n\nProlog facts compile to `declare -A` associative arrays:\n\n```prolog\n% Prolog facts\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nGenerated Bash:\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n\nparent_reverse_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        IFS=\":\" read -r a b <<< \"$key\"\n        echo \"$b:$a\"\n    done\n}\n```\n\n## Recursion \u2192 BFS with Memoization\n\nTransitive closures use BFS loops with visited tracking:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Initialize with base cases\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS traversal\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\n## Key Features\n\n- **Deduplication**: `declare -A` provides O(1) lookup\n- **Streaming**: Functions output to stdout for piping\n- **Cycle detection**: `visited` array prevents infinite loops", "answer_tailored": true}
{"pair_id": "bash-target-design_p3", "cluster_id": "bash-target-design", "question": "How does Bash target handle recursion?", "question_type": "medium", "answer": "The Bash target transforms Prolog recursion into iterative BFS (breadth-first search) loops with memoization to prevent infinite loops and ensure termination.\n\n## Recursive Rules \u2192 BFS Loops\n\nWhen compiling recursive Prolog rules (like transitive closures), UnifyWeaver generates Bash functions that:\n\n1. **Initialize a queue** with base facts from the underlying data stream\n2. **Track visited states** using associative arrays (`declare -A visited`)\n3. **Process iteratively** rather than recursively to avoid stack limits\n\nExample for ancestor relationships:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Seed queue with direct parent facts\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS traversal with cycle detection\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier by joining with parent facts\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\n## Key Mechanisms\n\n- **Cycle detection**: The `visited` associative array prevents processing the same relationship twice\n- **O(1) deduplication**: Bash's `declare -A` provides constant-time membership checks\n- **Stream-based output**: Results are emitted to stdout as they're discovered\n\nSee education/book-02-bash-target/ for complete recursion compilation patterns.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["bash", "code-generation", "associative-arrays", "streaming", "templates"], "original_answer": "## Bash Target Design\n\nThe Bash target uses template-driven code generation to create shell scripts that operate over textual streams.\n\n## Facts \u2192 Associative Arrays\n\nProlog facts compile to `declare -A` associative arrays:\n\n```prolog\n% Prolog facts\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nGenerated Bash:\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n\nparent() {\n    local key=\"$1:$2\"\n    [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\nparent_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n\nparent_reverse_stream() {\n    for key in \"${!parent_data[@]}\"; do\n        IFS=\":\" read -r a b <<< \"$key\"\n        echo \"$b:$a\"\n    done\n}\n```\n\n## Recursion \u2192 BFS with Memoization\n\nTransitive closures use BFS loops with visited tracking:\n\n```bash\nancestor_all() {\n    declare -A visited\n    local queue=()\n    \n    # Initialize with base cases\n    while IFS=: read -r a b; do\n        queue+=(\"$a:$b\")\n    done < <(parent_stream)\n    \n    # BFS traversal\n    while [[ ${#queue[@]} -gt 0 ]]; do\n        local current=\"${queue[0]}\"\n        queue=(\"${queue[@]:1}\")\n        \n        [[ -n \"${visited[$current]}\" ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        \n        # Expand frontier\n        IFS=: read -r _ child <<< \"$current\"\n        while IFS=: read -r a b; do\n            [[ \"$a\" == \"$child\" ]] && queue+=(\"${current%%:*}:$b\")\n        done < <(parent_stream)\n    done\n}\n```\n\n## Key Features\n\n- **Deduplication**: `declare -A` provides O(1) lookup\n- **Streaming**: Functions output to stdout for piping\n- **Cycle detection**: `visited` array prevents infinite loops", "answer_tailored": true}
