{"pair_id": "prolog-unification_p0", "cluster_id": "prolog-unification", "question": "How does unification work in Prolog?", "question_type": "medium", "answer": "Unification in Prolog is the pattern-matching mechanism that determines whether two terms can be made identical. When unification succeeds, any variables involved are instantiated (bound to values) to make the terms match.\n\n## Core Unification Rules\n\n```prolog\n% Atoms unify with identical atoms only\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with anything\nX = alice.            % binds X to 'alice'\nX = foo(1, 2).        % binds X to the structure 'foo(1, 2)'\n\n% Compound terms unify when functor, arity, and arguments all unify\npoint(1, Y) = point(X, 2).  % succeeds: X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails: arity mismatch\n```\n\n## How Queries Use Unification\n\nDuring query execution, Prolog attempts to unify your goal with facts and rule heads in the knowledge base:\n\n```prolog\n% Facts in database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Your query\n?- file_dependency('main.o', Dep).\n\n% Prolog unifies your query pattern\n%   file_dependency('main.o', Dep)\n% against the first matching fact\n%   file_dependency('main.o', 'main.c')\n%\n% Outcome: Dep = 'main.c'\n```\n\nThis unification-based approach is fundamental to how UnifyWeaver processes declarative specifications and transforms them into target languages. The project name itself reflects this: **unification** (Prolog's matching engine) combined with **weaving** (connecting data patterns across systems). For deeper exploration of how UnifyWeaver leverages unification during compilation, see education/book-01-foundations/ and education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "unification", "pattern-matching", "variable-binding"], "original_answer": "## Unification: The Engine of Prolog\n\n**Unification** is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n\n## Unification Rules\n\n```prolog\n% Atoms unify only with themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with any term\nX = alice.            % X is now 'alice'\nX = foo(1, 2).        % X is now 'foo(1, 2)'\n\n% Structures unify if functor, arity, and all args unify\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\n## Unification in Queries\n\nWhen you query, Prolog unifies your query with facts/rules:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog tries to unify:\n%   file_dependency('main.o', Dep)\n% with\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\n## Why \"UnifyWeaver\"?\n\nThe name comes from **unification** (Prolog's core operation) + **weaving** (interconnecting data threads). UnifyWeaver unifies your declarative specifications and weaves them into executable code:\n\n```prolog\n% Your specification (unified pattern)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Woven into optimized Bash/Python/Go/etc.\n```", "answer_tailored": true}
{"pair_id": "prolog-unification_p1", "cluster_id": "prolog-unification", "question": "What is pattern matching in Prolog?", "question_type": "medium", "answer": "Pattern matching in Prolog is accomplished through **unification**, which matches two terms and instantiates any variables to make them identical.\n\n## Basic Pattern Matching Rules\n\n```prolog\n% Atoms match only themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables match anything\nX = alice.            % X becomes 'alice'\nX = foo(1, 2).        % X becomes 'foo(1, 2)'\n\n% Compound terms match if functor, arity, and arguments all match\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (arity mismatch)\n```\n\n## Pattern Matching in Queries\n\nProlog matches your query pattern against facts and rules in the database:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query with pattern\n?- file_dependency('main.o', Dep).\n\n% Prolog matches the pattern:\n%   file_dependency('main.o', Dep)\n% against the fact:\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\nThis pattern matching mechanism is central to how Prolog executes programs - it continuously attempts to match query patterns with available facts and rule heads, instantiating variables as matches are found.\n\nFor more on Prolog fundamentals, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "unification", "pattern-matching", "variable-binding"], "original_answer": "## Unification: The Engine of Prolog\n\n**Unification** is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n\n## Unification Rules\n\n```prolog\n% Atoms unify only with themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with any term\nX = alice.            % X is now 'alice'\nX = foo(1, 2).        % X is now 'foo(1, 2)'\n\n% Structures unify if functor, arity, and all args unify\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\n## Unification in Queries\n\nWhen you query, Prolog unifies your query with facts/rules:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog tries to unify:\n%   file_dependency('main.o', Dep)\n% with\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\n## Why \"UnifyWeaver\"?\n\nThe name comes from **unification** (Prolog's core operation) + **weaving** (interconnecting data threads). UnifyWeaver unifies your declarative specifications and weaves them into executable code:\n\n```prolog\n% Your specification (unified pattern)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Woven into optimized Bash/Python/Go/etc.\n```", "answer_tailored": true}
{"pair_id": "prolog-unification_p2", "cluster_id": "prolog-unification", "question": "How do Prolog variables get their values?", "question_type": "medium", "answer": "Prolog variables get their values through **unification** - the process of matching terms and instantiating variables to make them identical.\n\n## How Variables Get Bound\n\nWhen Prolog unifies two terms, any variables are given values (instantiated) to make the terms match:\n\n```prolog\n% A variable unifies with any term and takes its value\nX = alice.            % X becomes 'alice'\nX = foo(1, 2).        % X becomes 'foo(1, 2)'\n\n% Multiple variables can be bound in one unification\npoint(1, Y) = point(X, 2).  % X gets value 1, Y gets value 2\n```\n\n## Variables in Queries\n\nWhen you query facts or rules, Prolog unifies your query variables with matching database entries:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog unifies your query with the first fact:\n%   file_dependency('main.o', Dep)  matches\n%   file_dependency('main.o', 'main.c')\n%\n% This binds: Dep = 'main.c'\n```\n\n## Unification Rules\n\nVariables bind according to these rules:\n\n```prolog\n% Atoms only match themselves\nalice = alice.        % succeeds\nalice = bob.          % fails - no variable to bind\n\n% Structures must have same functor, arity, and matching arguments\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\nThis unification mechanism is why the project is called \"UnifyWeaver\" - it unifies your declarative Prolog patterns and weaves them into target language code. For more on Prolog fundamentals, see education/book-01-foundations/02_prolog_fundamentals.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "unification", "pattern-matching", "variable-binding"], "original_answer": "## Unification: The Engine of Prolog\n\n**Unification** is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n\n## Unification Rules\n\n```prolog\n% Atoms unify only with themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with any term\nX = alice.            % X is now 'alice'\nX = foo(1, 2).        % X is now 'foo(1, 2)'\n\n% Structures unify if functor, arity, and all args unify\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\n## Unification in Queries\n\nWhen you query, Prolog unifies your query with facts/rules:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog tries to unify:\n%   file_dependency('main.o', Dep)\n% with\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\n## Why \"UnifyWeaver\"?\n\nThe name comes from **unification** (Prolog's core operation) + **weaving** (interconnecting data threads). UnifyWeaver unifies your declarative specifications and weaves them into executable code:\n\n```prolog\n% Your specification (unified pattern)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Woven into optimized Bash/Python/Go/etc.\n```", "answer_tailored": true}
{"pair_id": "prolog-unification_p3", "cluster_id": "prolog-unification", "question": "Why is it called UnifyWeaver?", "question_type": "medium", "answer": "The name \"UnifyWeaver\" combines two concepts:\n\n1. **Unification** - Prolog's fundamental operation for pattern matching and variable binding. When you write a query, Prolog unifies it with facts and rules in your knowledge base, instantiating variables to make terms match.\n\n2. **Weaving** - The process of interconnecting data threads and transforming declarative specifications into executable code across multiple target languages.\n\nUnifyWeaver takes your Prolog specifications (unified patterns) and weaves them into optimized implementations in Bash, Python, Go, Rust, C#, PowerShell, or SQL. For example:\n\n```prolog\n% Your declarative specification\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Gets woven into optimized target code\n```\n\nThe name reflects how the compiler unifies your high-level logic with target-specific implementations, weaving together the declarative and imperative worlds. See education/book-01-foundations/02_prolog_fundamentals.md for details on how unification works in Prolog.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "unification", "pattern-matching", "variable-binding"], "original_answer": "## Unification: The Engine of Prolog\n\n**Unification** is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n\n## Unification Rules\n\n```prolog\n% Atoms unify only with themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with any term\nX = alice.            % X is now 'alice'\nX = foo(1, 2).        % X is now 'foo(1, 2)'\n\n% Structures unify if functor, arity, and all args unify\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\n## Unification in Queries\n\nWhen you query, Prolog unifies your query with facts/rules:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog tries to unify:\n%   file_dependency('main.o', Dep)\n% with\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\n## Why \"UnifyWeaver\"?\n\nThe name comes from **unification** (Prolog's core operation) + **weaving** (interconnecting data threads). UnifyWeaver unifies your declarative specifications and weaves them into executable code:\n\n```prolog\n% Your specification (unified pattern)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Woven into optimized Bash/Python/Go/etc.\n```", "answer_tailored": true}
