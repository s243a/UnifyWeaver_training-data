{"pair_id": "ps-facts-001_p0", "cluster_id": "ps-facts-001", "question": "How are Prolog facts compiled to PowerShell?", "question_type": "medium", "answer": "When compiling Prolog facts to PowerShell, UnifyWeaver transforms them into PowerShell arrays containing PSCustomObject instances:\n\nFor simple unary facts like `color(red). color(green). color(blue).`, the compiler generates a straightforward array: `$facts = @('red', 'green', 'blue')`.\n\nFor binary or multi-argument facts such as `parent(anne, bob). parent(bob, charles).`, each fact becomes a PSCustomObject with named properties:\n```powershell\n$facts = @(\n    [PSCustomObject]@{ X='anne'; Y='bob' },\n    [PSCustomObject]@{ X='bob'; Y='charles' }\n)\n```\n\nThis compilation strategy leverages PSCustomObject's advantages: direct property access using dot notation (`.X`, `.Y`), seamless integration with PowerShell's pipeline cmdlets (`Where-Object`, `Select-Object`), and built-in JSON serialization via `ConvertTo-Json`.\n\nFor more details on PowerShell target compilation, see education/book-12-powershell-target/.", "answer_variant": "default", "answer_source": "book-12-powershell-target/02_facts_rules.md", "topics": [], "original_answer": "Facts become PowerShell arrays with PSCustomObject entries:\n\n**Unary facts:**\n```prolog\ncolor(red). color(green). color(blue).\n```\n\u2192\n```powershell\n$facts = @('red', 'green', 'blue')\n```\n\n**Binary facts:**\n```prolog\nparent(anne, bob). parent(bob, charles).\n```\n\u2192\n```powershell\n$facts = @(\n    [PSCustomObject]@{ X='anne'; Y='bob' },\n    [PSCustomObject]@{ X='bob'; Y='charles' }\n)\n```\n\nPSCustomObject provides:\n- Named property access (`.X`, `.Y`)\n- Pipeline-friendly (`Where-Object`, `Select-Object`)\n- JSON serialization (`ConvertTo-Json`)", "answer_tailored": true}
{"pair_id": "ps-facts-001_p0", "cluster_id": "ps-facts-001", "question": "How are Prolog rules compiled to PowerShell functions?", "question_type": "medium", "answer": "UnifyWeaver compiles Prolog rules into PowerShell functions that implement relational logic through nested foreach loops. Each goal in the rule body becomes a loop level, with join conditions checked via if statements.\n\nFor example, the rule `grandparent(X, Z) :- parent(X, Y), parent(Y, Z).` generates a PowerShell function where:\n- The outer loop iterates over the first `parent` relation\n- The inner loop iterates over the second `parent` relation  \n- An if condition matches `$r1.Y -eq $r2.X` to join the intermediate variable\n- Matching tuples are emitted as `[PSCustomObject]` instances with bound variables X and Z\n\n**Example compilation:**\n```powershell\nfunction grandparent {\n    param([string]$X, [string]$Z)\n    \n    $rel1 = parent\n    $rel2 = parent\n    \n    $results = foreach ($r1 in $rel1) {\n        foreach ($r2 in $rel2) {\n            if ($r1.Y -eq $r2.X) {\n                [PSCustomObject]@{ X = $r1.X; Z = $r2.Y }\n            }\n        }\n    }\n    # Filtering applies parameter constraints\n}\n```\n\nNegation operators (`\\+`) are optimized using PowerShell hashtables for constant-time membership testing rather than linear scans. See education/book-12-powershell-target/02_facts_rules.md for the complete compilation pattern.", "answer_variant": "default", "answer_source": "book-12-powershell-target/02_facts_rules.md", "topics": [], "original_answer": "Rules become functions with nested loop joins:\n\n**Prolog:**\n```prolog\ngrandparent(X, Z) :- parent(X, Y), parent(Y, Z).\n```\n\n**Generated PowerShell:**\n```powershell\nfunction grandparent {\n    param([string]$X, [string]$Z)\n    \n    $rel1 = parent\n    $rel2 = parent\n    \n    $results = foreach ($r1 in $rel1) {\n        foreach ($r2 in $rel2) {\n            if ($r1.Y -eq $r2.X) {  # Join condition\n                [PSCustomObject]@{ X = $r1.X; Z = $r2.Y }\n            }\n        }\n    }\n    # ... filtering logic\n}\n```\n\nNegation (`\\+`) uses hashtable-based exclusion for O(1) lookups.", "answer_tailored": true}
{"pair_id": "ps-facts-002_p0", "cluster_id": "ps-facts-002", "question": "How do I use compile_facts_to_powershell/3?", "question_type": "medium", "answer": "To use `compile_facts_to_powershell/3`, call it with your predicate name, arity, and a variable for the generated code:\n\n```prolog\n?- powershell_target:compile_facts_to_powershell(parent, 2, Code).\n```\n\nThis produces a PowerShell class with static fact storage:\n\n```powershell\nclass PARENT {\n    static [string[][]] $FACTS = @(\n        @(\"anne\", \"bob\"),\n        @(\"bob\", \"charles\")\n    )\n    \n    static [string[][]] GetAll() {\n        return [PARENT]::FACTS\n    }\n    \n    static [bool] Contains([string[]]$target) {\n        # ... membership check\n    }\n}\n```\n\nThe predicate generates a complete, self-contained class with `GetAll()`, `Stream()`, and `Contains()` methods, compatible with PowerShell 5.1+ class syntax. This approach encapsulates your Prolog facts as structured PowerShell data that's easy to query and validate.", "answer_variant": "default", "answer_source": "book-12-powershell-target/02_facts_rules.md", "topics": [], "original_answer": "For class-based fact export with static methods:\n\n```prolog\n?- powershell_target:compile_facts_to_powershell(parent, 2, Code).\n```\n\n**Generated:**\n```powershell\nclass PARENT {\n    static [string[][]] $FACTS = @(\n        @(\"anne\", \"bob\"),\n        @(\"bob\", \"charles\")\n    )\n    \n    static [string[][]] GetAll() {\n        return [PARENT]::FACTS\n    }\n    \n    static [bool] Contains([string[]]$target) {\n        # ... membership check\n    }\n}\n```\n\n**Benefits:**\n- Self-contained PowerShell class\n- `GetAll()`, `Stream()`, `Contains()` methods\n- Works with PowerShell 5.1+ class syntax", "answer_tailored": true}
