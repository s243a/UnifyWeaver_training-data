{"pair_id": "ps-cmdlet-001_p0", "cluster_id": "ps-cmdlet-001", "question": "How do I generate PowerShell cmdlets with CmdletBinding?", "question_type": "medium", "answer": "To generate PowerShell cmdlets with CmdletBinding, set `cmdlet_binding(true)` in your compilation options:\n\n```prolog\n?- compile_to_powershell(parent/2, [\n       cmdlet_name('Get-Parent'),\n       cmdlet_binding(true),\n       verbose_output(true)\n   ], Code).\n```\n\n**This produces:**\n```powershell\nfunction Get-Parent {\n    [CmdletBinding()]\n    param(\n        [Parameter(Position=0)]\n        [ValidateNotNullOrEmpty()]\n        [string]$Parent,\n        \n        [Parameter(Position=1, ValueFromPipeline=$true)]\n        [string]$Child\n    )\n    \n    begin { Write-Verbose \"Loading facts...\" }\n    process { # ... implementation }\n    end { Write-Verbose \"Query complete\" }\n}\n```\n\nThe `[CmdletBinding()]` attribute automatically adds common parameters like `-Verbose`, `-Debug`, `-ErrorAction`, and `-WhatIf` to your function, making it behave like native PowerShell cmdlets. See education/book-12-powershell-target/03_cmdlet_generation.md for more details on cmdlet generation options.", "answer_variant": "default", "answer_source": "book-12-powershell-target/03_cmdlet_generation.md", "topics": [], "original_answer": "Use `cmdlet_binding(true)` to generate advanced functions:\n\n```prolog\n?- compile_to_powershell(parent/2, [\n       cmdlet_name('Get-Parent'),\n       cmdlet_binding(true),\n       verbose_output(true)\n   ], Code).\n```\n\n**Generated:**\n```powershell\nfunction Get-Parent {\n    [CmdletBinding()]\n    param(\n        [Parameter(Position=0)]\n        [ValidateNotNullOrEmpty()]\n        [string]$Parent,\n        \n        [Parameter(Position=1, ValueFromPipeline=$true)]\n        [string]$Child\n    )\n    \n    begin { Write-Verbose \"Loading facts...\" }\n    process { # ... implementation }\n    end { Write-Verbose \"Query complete\" }\n}\n```\n\nCmdletBinding enables `-Verbose`, `-Debug`, `-ErrorAction` and other common parameters.", "answer_tailored": true}
{"pair_id": "ps-cmdlet-001_p0", "cluster_id": "ps-cmdlet-001", "question": "What parameter attributes can I use in generated cmdlets?", "question_type": "medium", "answer": "Generated PowerShell cmdlets support several parameter attributes for validation and configuration:\n\n**Validation Attributes:**\n\n| Attribute | Purpose |\n|-----------|---------|\n| `[ValidateNotNullOrEmpty()]` | Reject null/empty |\n| `[ValidateRange(1, 100)]` | Numeric bounds |\n| `[ValidateSet('a','b','c')]` | Allowed values |\n| `[ValidatePattern('^[A-Z]')]` | Regex match |\n| `[ValidateScript({...})]` | Custom validation |\n\n**Parameter Configuration:**\n```powershell\n[Parameter(\n    Mandatory=$true,\n    Position=0,\n    ValueFromPipeline=$true,\n    ValueFromPipelineByPropertyName=$true,\n    HelpMessage='Enter a name'\n)]\n[Alias('N', 'PersonName')]\n[string]$Name\n```\n\nUnifyWeaver automatically maps Prolog constraints to the appropriate PowerShell attributes during compilation. For more details on cmdlet generation, see education/book-12-powershell-target/03_cmdlet_generation.md.", "answer_variant": "default", "answer_source": "book-12-powershell-target/03_cmdlet_generation.md", "topics": [], "original_answer": "Common validation attributes:\n\n| Attribute | Purpose |\n|-----------|---------|\n| `[ValidateNotNullOrEmpty()]` | Reject null/empty |\n| `[ValidateRange(1, 100)]` | Numeric bounds |\n| `[ValidateSet('a','b','c')]` | Allowed values |\n| `[ValidatePattern('^[A-Z]')]` | Regex match |\n| `[ValidateScript({...})]` | Custom validation |\n\n**Parameter options:**\n```powershell\n[Parameter(\n    Mandatory=$true,\n    Position=0,\n    ValueFromPipeline=$true,\n    ValueFromPipelineByPropertyName=$true,\n    HelpMessage='Enter a name'\n)]\n[Alias('N', 'PersonName')]\n[string]$Name\n```\n\nThe compiler maps Prolog constraints to these attributes.", "answer_tailored": true}
{"pair_id": "ps-cmdlet-002_p0", "cluster_id": "ps-cmdlet-002", "question": "How do Begin/Process/End blocks work in generated cmdlets?", "question_type": "medium", "answer": "PowerShell cmdlets use a three-phase execution model for pipeline processing:\n\n**Begin block** - Executes once at the start, before any pipeline input:\n```powershell\nbegin {\n    Write-Verbose \"Initializing...\"\n    $script:facts = Load-Facts  # One-time fact loading\n    $script:index = @{}  # Initialize data structures\n}\n```\n\n**Process block** - Runs once for each item coming through the pipeline:\n```powershell\nprocess {\n    Write-Verbose \"Processing: $_\"\n    if ($script:index.ContainsKey($_)) {\n        $script:index[$_]\n    }\n}\n```\n\n**End block** - Executes once after all pipeline items are processed:\n```powershell\nend {\n    Write-Verbose \"Cleanup...\"\n    # Output aggregated results, perform cleanup\n}\n```\n\nThis structure allows UnifyWeaver-generated cmdlets to efficiently handle pipeline data: initialize resources once in Begin, process each input item in Process, and finalize/cleanup in End. For more details on PowerShell target generation, see education/book-12-powershell-target/.", "answer_variant": "default", "answer_source": "book-12-powershell-target/03_cmdlet_generation.md", "topics": [], "original_answer": "Three execution phases for pipeline processing:\n\n**Begin** - Runs once before processing:\n```powershell\nbegin {\n    Write-Verbose \"Initializing...\"\n    $script:facts = Load-Facts  # Load once\n    $script:index = @{}  # Build indexes\n}\n```\n\n**Process** - Runs once per pipeline item:\n```powershell\nprocess {\n    Write-Verbose \"Processing: $_\"\n    if ($script:index.ContainsKey($_)) {\n        $script:index[$_]\n    }\n}\n```\n\n**End** - Runs after all input processed:\n```powershell\nend {\n    Write-Verbose \"Cleanup...\"\n    # Emit aggregated results, clean up\n}\n```\n\nThis pattern enables efficient batch processing: load facts once, process many items.", "answer_tailored": true}
