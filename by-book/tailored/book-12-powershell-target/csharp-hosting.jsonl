{"pair_id": "ps-hosting-001_p0", "cluster_id": "ps-hosting-001", "question": "How does in-process C# hosting work with PowerShell?", "question_type": "medium", "answer": "In-process C# hosting allows PowerShell code to run directly within a C# application through `compile_with_csharp_host/4`. This predicate generates both PowerShell functions and a C# wrapper class that manages a PowerShell runspace:\n\n```prolog\n?- compile_with_csharp_host(\n       [filter_users/2, transform_data/2],\n       [namespace('MyApp.Generated'), class('DataProcessor')],\n       PSCode,    % PowerShell functions\n       CSharpCode % C# wrapper class\n   ).\n```\n\nThe generated C# host creates a PowerShell environment and exposes Prolog predicates as C# methods:\n\n```csharp\npublic class PowerShellHost {\n    public PowerShellHost(string scriptBlock) { /* init runspace */ }\n    \n    public IEnumerable<dynamic> filter_users(string arg1, string arg2) {\n        var script = \"filter_users $arg1 $arg2\";\n        return PowerShellBridge.Invoke<object, dynamic>(script, null);\n    }\n}\n```\n\nFrom C#, you call the hosted PowerShell code like native methods:\n\n```csharp\nvar host = new PowerShellHost(psScript);\nforeach (var user in host.filter_users(\"\", \"\")) {\n    Console.WriteLine($\"ID: {user.X}\");\n}\n```\n\nThis approach eliminates serialization overhead by passing objects directly between PowerShell and C# within the same process. For more details, see education/book-12-powershell-target/06_csharp_hosting.md.", "answer_variant": "default", "answer_source": "book-12-powershell-target/06_csharp_hosting.md", "topics": [], "original_answer": "Generate dual outputs with `compile_with_csharp_host/4`:\n\n```prolog\n?- compile_with_csharp_host(\n       [filter_users/2, transform_data/2],\n       [namespace('MyApp.Generated'), class('DataProcessor')],\n       PSCode,    % PowerShell functions\n       CSharpCode % C# wrapper class\n   ).\n```\n\n**Generated C# host:**\n```csharp\npublic class PowerShellHost {\n    public PowerShellHost(string scriptBlock) { /* init runspace */ }\n    \n    public IEnumerable<dynamic> filter_users(string arg1, string arg2) {\n        var script = \"filter_users $arg1 $arg2\";\n        return PowerShellBridge.Invoke<object, dynamic>(script, null);\n    }\n}\n```\n\n**Usage:**\n```csharp\nvar host = new PowerShellHost(psScript);\nforeach (var user in host.filter_users(\"\", \"\")) {\n    Console.WriteLine($\"ID: {user.X}\");\n}\n```\n\nAdvantage: Zero serialization overhead - objects pass directly.", "answer_tailored": true}
{"pair_id": "ps-hosting-001_p0", "cluster_id": "ps-hosting-001", "question": "What bridges does UnifyWeaver support for .NET interop?", "question_type": "medium", "answer": "UnifyWeaver provides three bridge types for .NET interoperability:\n\n**PowerShell Bridge** - Enables C# to host and execute PowerShell scripts directly within the same process, useful for Windows automation and system management tasks.\n\n**IronPython Bridge** - Allows C# to host Python code in-process without subprocess overhead, ideal for pure-Python libraries and scripting logic that doesn't require C extensions.\n\n**CPython Fallback Bridge** - Uses pipe-based communication for libraries with native C extensions (like numpy or pandas), handling cross-process serialization when in-process hosting isn't possible.\n\nGenerate these bridges using:\n```prolog\n?- generate_csharp_bridge(powershell, [namespace('MyApp')], Code).\n?- generate_csharp_bridge(ironpython, [namespace('MyApp')], Code).\n?- generate_csharp_bridge(cpython, [], Code).\n```\n\nThe system automatically selects the appropriate runtime based on library requirements:\n```prolog\n?- dotnet_glue:python_runtime_choice([json, re], Runtime).\nRuntime = ironpython.  % Pure Python modules\n\n?- dotnet_glue:python_runtime_choice([numpy], Runtime).\nRuntime = cpython_pipe.  % Native extensions\n```\n\nPerformance varies: in-process bridges have ~0ms overhead, while pipe-based bridges incur ~5-10ms latency due to JSON serialization. See education/book-12-powershell-target/06_csharp_hosting.md for implementation details.", "answer_variant": "default", "answer_source": "book-12-powershell-target/06_csharp_hosting.md", "topics": [], "original_answer": "Three bridge types:\n\n```prolog\n% PowerShell bridge (C# hosts PowerShell)\n?- generate_csharp_bridge(powershell, [namespace('MyApp')], Code).\n\n% IronPython bridge (C# hosts Python - no subprocess)\n?- generate_csharp_bridge(ironpython, [namespace('MyApp')], Code).\n\n% CPython fallback (pipe-based - for numpy, pandas)\n?- generate_csharp_bridge(cpython, [], Code).\n```\n\n**Performance comparison:**\n| Pattern | Latency | Use Case |\n|---------|---------|----------|\n| In-Process | ~0ms | Same AppDomain, direct objects |\n| Pipe-Based | ~5-10ms | Cross-process, JSON serialization |\n\n**Runtime detection:**\n```prolog\n?- dotnet_glue:python_runtime_choice([json, re], Runtime).\nRuntime = ironpython.  % All IronPython-compatible\n\n?- dotnet_glue:python_runtime_choice([numpy], Runtime).\nRuntime = cpython_pipe.  % C extensions need CPython\n```", "answer_tailored": true}
