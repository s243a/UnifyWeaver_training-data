{"pair_id": "semantic-adversarial-001_p0", "cluster_id": "semantic-adversarial-001", "question": "How does UnifyWeaver protect against adversarial nodes?", "question_type": "medium", "answer": "UnifyWeaver employs three defense mechanisms against adversarial nodes:\n\n**Soft Collisions (Outlier Detection):** The system rejects statistically anomalous results by analyzing embedding distances. Nodes returning embeddings with z-scores exceeding a threshold (typically 2.5) are flagged:\n```python\ndef detect_outliers(embeddings, threshold=2.5):\n    distances = pairwise_distances(embeddings)\n    z_scores = (distances - distances.mean()) / distances.std()\n    return z_scores > threshold\n```\n\n**Hard Collisions (Region Locking):** Using KSK-style region assignment, nodes claim responsibility for specific embedding space regions. Results are validated against region ownership:\n```python\ndef verify_region_ownership(node_id, embedding, region_registry):\n    claimed_region = region_registry.get(node_id)\n    return claimed_region.contains(embedding)\n```\n\n**Consensus Voting:** A quorum-based approach requires multiple nodes to agree before accepting results:\n```python\ndef requires_quorum(result, min_agreeing_nodes=3):\n    agreeing = [n for n in nodes if n.agrees(result)]\n    return len(agreeing) >= min_agreeing_nodes\n```\n\nTrust is managed using direct trust scores combined with FMS two-dimensional metrics (competence and benevolence). See education/book-13-semantic-search/11_adversarial_robustness.md for implementation details.", "answer_variant": "default", "answer_source": "book-13-semantic-search/11_adversarial_robustness.md", "topics": [], "original_answer": "Three defense mechanisms:\n\n**1. Soft Collisions (Outlier Detection):**\nReject results that are statistically anomalous:\n```python\ndef detect_outliers(embeddings, threshold=2.5):\n    distances = pairwise_distances(embeddings)\n    z_scores = (distances - distances.mean()) / distances.std()\n    return z_scores > threshold\n```\n\n**2. Hard Collisions (KSK-style Region Locking):**\nNodes claim responsibility for specific embedding regions:\n```python\ndef verify_region_ownership(node_id, embedding, region_registry):\n    claimed_region = region_registry.get(node_id)\n    return claimed_region.contains(embedding)\n```\n\n**3. Consensus Voting with Quorum:**\n```python\ndef requires_quorum(result, min_agreeing_nodes=3):\n    agreeing = [n for n in nodes if n.agrees(result)]\n    return len(agreeing) >= min_agreeing_nodes\n```\n\n**Trust management:** Direct trust + FMS two-dimensional (competence, benevolence).", "answer_tailored": true}
{"pair_id": "semantic-routing-001_p0", "cluster_id": "semantic-routing-001", "question": "What's the difference between greedy routing and Kleinberg routing?", "question_type": "medium", "answer": "The key difference is in network structure requirements and guarantees:\n\n**Greedy routing** forwards queries to whichever neighbor is closest to the target. It's straightforward to implement but provides no guarantees on path length\u2014you might traverse many hops or hit dead ends.\n\n**Kleinberg routing** exploits a carefully constructed small-world graph where nodes have both local connections (`k_local` nearest neighbors) and long-range shortcuts sampled with probability inversely proportional to distance (`P ~ 1/distance^\u03b1`). When \u03b1=2 and the network structure is properly configured, Kleinberg proved you get O(log\u00b2n) expected path length.\n\nWithout the right small-world structure, you're stuck with basic greedy routing. With it, you get provable efficiency:\n\n```prolog\n% Build a proper small-world network for Kleinberg routing\n?- compile_small_world_proper_python([\n       k_local(10),\n       k_long(5),\n       alpha(2.0),\n       angle_ordering(cosine_based)\n   ], Code).\n```\n\n**Note:** HNSW (Hierarchical Navigable Small World) extends these ideas with multiple layers and tunable connectivity (M parameter), achieving O(log n) search complexity. See `education/book-13-semantic-search/` for implementation details.", "answer_variant": "default", "answer_source": "book-13-semantic-search/13_advanced_routing.md", "topics": [], "original_answer": "**Greedy routing:** Forward to the closest neighbor. Simple but no path length guarantees.\n\n**Kleinberg routing:** Requires proper **small-world network structure**:\n- `k_local`: Nearest-neighbor connections for local connectivity\n- `k_long`: Probability-weighted long-range shortcuts (P ~ 1/distance^\u03b1)\n\n**Without proper structure:** Only greedy routing\n**With proper structure:** O(log\u00b2n) expected path length\n\n```prolog\n% Generate proper small-world network\n?- compile_small_world_proper_python([\n       k_local(10),\n       k_long(5),\n       alpha(2.0),\n       angle_ordering(cosine_based)\n   ], Code).\n```\n\n**HNSW (Hierarchical Navigable Small World):**\nLayered structure with tunable M parameter:\n- Higher M = better recall, more memory\n- Lower M = faster search, less recall\n\nO(log n) scaling for both search and construction.", "answer_tailored": true}
{"pair_id": "semantic-scalefree-001_p0", "cluster_id": "semantic-scalefree-001", "question": "What are scale-free multi-interface nodes?", "question_type": "medium", "answer": "Scale-free multi-interface nodes follow a power-law distribution where most nodes handle few interfaces while a small number become major hubs:\n\n```\nP(k) \u221d k^(-\u03b3)  where k = interface count\n```\n\n**Typical distribution (\u03b3=2.5):**\n- ~60% nodes: 1-2 interfaces (specialized leaves)\n- ~25% nodes: 3-5 interfaces (mid-tier nodes)\n- ~12% nodes: 6-20 interfaces (regional hubs)\n- ~3% nodes: 20+ interfaces (major hubs)\n\nThis architecture provides:\n1. **Capacity-aligned scaling:** High-capacity hubs manage more traffic, specialists focus on specific tasks\n2. **Efficient unified lookup:** O(log n) binary search across all interfaces within a node\n3. **Internal routing shortcuts:** Related interfaces colocated on the same node\n\n```prolog\n?- compile_multi_interface_node_go([\n       gamma(2.5),\n       min_interfaces(1),\n       max_interfaces(100),\n       unified_search(true)\n   ], Code).\n```\n\nThis mirrors real-world network patterns like web traffic, where a few popular sites handle massive traffic while most sites serve niche audiences. See education/book-13-semantic-search/ for implementation details.", "answer_variant": "default", "answer_source": "book-13-semantic-search/14_scale_free_networks.md", "topics": [], "original_answer": "Power-law distribution of interfaces per node:\n\n```\nP(k) \u221d k^(-\u03b3)  where k = interface count\n```\n\n**Distribution with gamma=2.5:**\n- ~60% nodes: 1-2 interfaces (leaf specialists)\n- ~25% nodes: 3-5 interfaces (mid-tier)\n- ~12% nodes: 6-20 interfaces (regional hubs)\n- ~3% nodes: 20+ interfaces (major hubs)\n\n**Benefits:**\n1. **Capacity-proportional sizing:** Hubs handle more traffic, leaves specialize\n2. **Unified binary search:** O(log n) lookup across all interfaces\n3. **Internal shortcuts:** Related interfaces on same node\n\n```prolog\n?- compile_multi_interface_node_go([\n       gamma(2.5),\n       min_interfaces(1),\n       max_interfaces(100),\n       unified_search(true)\n   ], Code).\n```\n\nMirrors web traffic patterns: few high-traffic hubs, many specialized sites.", "answer_tailored": true}
