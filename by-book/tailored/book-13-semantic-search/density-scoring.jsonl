{"pair_id": "semantic-density-001_p0", "cluster_id": "semantic-density-001", "question": "What is flux-softmax density scoring?", "question_type": "medium", "answer": "Flux-softmax density scoring is a technique that amplifies results in semantically dense regions to surface consensus signals:\n\n**Core Formula:**\n```\nP(i) = exp(s\u1d62/\u03c4) * (1 + w * d\u1d62) / Z\n```\nWhere:\n- s\u1d62 = base similarity score\n- \u03c4 = temperature (controls sharpness)\n- w = density weight (0 = disabled, 1 = maximum influence)\n- d\u1d62 = normalized density from KDE\n- Z = normalization constant\n\n**Implementation:**\n```python\ndef flux_softmax(scores, densities, density_weight=0.3, temperature=1.0):\n    scaled = scores / temperature - scores.max()\n    flux_factor = 1.0 + density_weight * densities\n    exp_scores = np.exp(scaled) * flux_factor\n    return exp_scores / exp_scores.sum()\n```\n\n**Why it matters:** Traditional max/sum ranking can favor isolated high-scoring outliers. Flux-softmax corrects this by identifying clusters of similar answers (consensus) and boosting their probability. The typical pipeline clusters documents by similarity (greedy or HDBSCAN), computes KDE density within each cluster, then applies the flux-softmax formula to favor dense regions.\n\nSee education/book-13-semantic-search/07_density_scoring.md for complete details.", "answer_variant": "default", "answer_source": "book-13-semantic-search/07_density_scoring.md", "topics": [], "original_answer": "Density scoring boosts results in semantically dense regions (consensus signal):\n\n**Problem:** Naive max/sum ranks isolated high-scoring results above clustered consensus.\n\n**Flux-softmax formula:**\n```\nP(i) = exp(s\u1d62/\u03c4) * (1 + w * d\u1d62) / Z\n```\n- \u03c4 = temperature (sharpness)\n- w = density weight (0 = ignore, 1 = strong)\n- d\u1d62 = normalized density score\n\n```python\ndef flux_softmax(scores, densities, density_weight=0.3, temperature=1.0):\n    scaled = scores / temperature - scores.max()\n    flux_factor = 1.0 + density_weight * densities\n    exp_scores = np.exp(scaled) * flux_factor\n    return exp_scores / exp_scores.sum()\n```\n\n**Two-stage pipeline:**\n1. Cluster by similarity (greedy or HDBSCAN)\n2. Compute KDE density **within** each cluster\n3. Apply flux-softmax\n\nDense clusters = consensus = higher probability.", "answer_tailored": true}
{"pair_id": "semantic-density-001_p0", "cluster_id": "semantic-density-001", "question": "How do I configure density scoring in Prolog?", "question_type": "medium", "answer": "To configure density scoring in Prolog, define it within your service's federation settings:\n\n```prolog\nservice(semantic_search_node, [\n    transport(http('/kg', [port(8080)])),\n    federation([\n        aggregation(density_flux, [\n            density_weight(0.3),\n            clustering_enabled(true),\n            similarity_threshold(0.7),\n            min_cluster_size(2)\n        ]),\n        federation_k(5)\n    ])\n], [receive(Query), handle_federated_query(Query, Response), respond(Response)]).\n```\n\nThe `density_weight` parameter controls how much density scoring influences results (0.0-1.0). Use `similarity_threshold` to filter cluster membership and `min_cluster_size` to set minimum cluster requirements.\n\n**Validation rules:**\n```prolog\nis_valid_density_option(bandwidth(auto)).\nis_valid_density_option(bandwidth(silverman)).\nis_valid_density_option(bandwidth(B)) :- number(B), B > 0.\nis_valid_density_option(density_weight(W)) :- number(W), W >= 0, W =< 1.\n```\n\n**Configuration guidance:**\n- For high-precision domains (legal/medical): set `similarity_threshold(0.8)` or higher\n- For exploratory search: use `similarity_threshold(0.5)` to `0.6`\n- For consensus-driven results: increase `density_weight(0.5)` or higher\n\nSee education/book-13-semantic-search/07_density_scoring.md for implementation details.", "answer_variant": "default", "answer_source": "book-13-semantic-search/07_density_scoring.md", "topics": [], "original_answer": "Configure via service definition:\n\n```prolog\nservice(semantic_search_node, [\n    transport(http('/kg', [port(8080)])),\n    federation([\n        aggregation(density_flux, [\n            density_weight(0.3),\n            clustering_enabled(true),\n            similarity_threshold(0.7),\n            min_cluster_size(2)\n        ]),\n        federation_k(5)\n    ])\n], [receive(Query), handle_federated_query(Query, Response), respond(Response)]).\n```\n\n**Validation predicates:**\n```prolog\nis_valid_density_option(bandwidth(auto)).\nis_valid_density_option(bandwidth(silverman)).\nis_valid_density_option(bandwidth(B)) :- number(B), B > 0.\nis_valid_density_option(density_weight(W)) :- number(W), W >= 0, W =< 1.\n```\n\n**Tuning:**\n- High precision (legal, medical): `similarity_threshold(0.8+)`\n- Exploratory: `similarity_threshold(0.5-0.6)`\n- Consensus-heavy: `density_weight(0.5+)`", "answer_tailored": true}
