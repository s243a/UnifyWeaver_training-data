{"pair_id": "b6-a1-core-apis_p0", "cluster_id": "b6-a1-core-apis", "question": "What APIs does the Go target provide?", "question_type": "medium", "answer": "The Go target provides two main compilation APIs:\n\n**compile_predicate_to_go/3** - Compiles Prolog predicates to Go code with support for streaming (stdin\u2192stdout processing) and generator (fixpoint Datalog) modes. Configurable options include JSON input handling, parallel worker goroutines, and BoltDB persistence backend.\n\n**compile_facts_to_go/3** - Exports Prolog facts as Go struct slices with generated accessor methods: `GetAll<NAME>()` for batch retrieval, `Stream<NAME>()` for iteration, and `Contains<NAME>()` for membership checks.\n\nFor complete API documentation and usage examples, see education/book-06-go-target/A1_api_reference.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-predicate-to-go", "compile-facts-to-go", "api-reference"], "original_answer": "## Go Target Core APIs\n\n### compile_predicate_to_go/3\n\nMain compilation predicate for streaming and generator modes.\n\n```prolog\ncompile_predicate_to_go(+Predicate/Arity, +Options, -Code)\n```\n\n**Options:**\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `mode(streaming)` | \u2713 | stdin\u2192stdout processor |\n| `mode(generator)` | - | Fixpoint Datalog engine |\n| `json_input(true)` | false | Read JSONL from stdin |\n| `workers(N)` | 1 | Parallel goroutines |\n| `db_backend(bbolt)` | - | BoltDB persistence |\n\n### compile_facts_to_go/3\n\nExports facts as Go struct slices.\n\n```prolog\ncompile_facts_to_go(+Functor, +Arity, -Code)\n```\n\nGenerates: `GetAll<NAME>()`, `Stream<NAME>()`, `Contains<NAME>()`", "answer_tailored": true}
{"pair_id": "b6-a1-core-apis_p1", "cluster_id": "b6-a1-core-apis", "question": "What is compile_predicate_to_go/3?", "question_type": "medium", "answer": "`compile_predicate_to_go/3` is the primary compilation predicate for converting Prolog rules to Go code. It supports two execution modes:\n\n**Syntax:**\n```prolog\ncompile_predicate_to_go(+Predicate/Arity, +Options, -Code)\n```\n\n**Key Options:**\n\n- `mode(streaming)` (default) - Generates a stdin\u2192stdout processor\n- `mode(generator)` - Produces a fixpoint Datalog engine\n- `json_input(true)` - Enables JSONL input parsing (default: false)\n- `workers(N)` - Sets parallel goroutine count (default: 1)\n- `db_backend(bbolt)` - Adds BoltDB persistence layer\n\nFor fact compilation, use `compile_facts_to_go/3` instead, which generates `GetAll<NAME>()`, `Stream<NAME>()`, and `Contains<NAME>()` accessors for struct slices.\n\nSee education/book-06-go-target/A1_api_reference.md for complete API documentation.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-predicate-to-go", "compile-facts-to-go", "api-reference"], "original_answer": "## Go Target Core APIs\n\n### compile_predicate_to_go/3\n\nMain compilation predicate for streaming and generator modes.\n\n```prolog\ncompile_predicate_to_go(+Predicate/Arity, +Options, -Code)\n```\n\n**Options:**\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `mode(streaming)` | \u2713 | stdin\u2192stdout processor |\n| `mode(generator)` | - | Fixpoint Datalog engine |\n| `json_input(true)` | false | Read JSONL from stdin |\n| `workers(N)` | 1 | Parallel goroutines |\n| `db_backend(bbolt)` | - | BoltDB persistence |\n\n### compile_facts_to_go/3\n\nExports facts as Go struct slices.\n\n```prolog\ncompile_facts_to_go(+Functor, +Arity, -Code)\n```\n\nGenerates: `GetAll<NAME>()`, `Stream<NAME>()`, `Contains<NAME>()`", "answer_tailored": true}
{"pair_id": "b6-a1-core-apis_p2", "cluster_id": "b6-a1-core-apis", "question": "What options does compile_predicate_to_go accept?", "question_type": "medium", "answer": "The `compile_predicate_to_go/3` predicate accepts an Options list that controls compilation behavior:\n\n- **`mode(streaming)`** (default): Generates a stdin\u2192stdout processing pipeline\n- **`mode(generator)`**: Produces a fixpoint Datalog engine implementation\n- **`json_input(true)`**: Configures the compiled Go code to parse JSONL from standard input (defaults to false)\n- **`workers(N)`**: Sets the number of parallel goroutines for concurrent processing (defaults to 1)\n- **`db_backend(bbolt)`**: Enables BoltDB-based persistence for storing intermediate results\n\nFor complete API details and usage examples, see education/book-06-go-target/A1_api_reference.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-predicate-to-go", "compile-facts-to-go", "api-reference"], "original_answer": "## Go Target Core APIs\n\n### compile_predicate_to_go/3\n\nMain compilation predicate for streaming and generator modes.\n\n```prolog\ncompile_predicate_to_go(+Predicate/Arity, +Options, -Code)\n```\n\n**Options:**\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `mode(streaming)` | \u2713 | stdin\u2192stdout processor |\n| `mode(generator)` | - | Fixpoint Datalog engine |\n| `json_input(true)` | false | Read JSONL from stdin |\n| `workers(N)` | 1 | Parallel goroutines |\n| `db_backend(bbolt)` | - | BoltDB persistence |\n\n### compile_facts_to_go/3\n\nExports facts as Go struct slices.\n\n```prolog\ncompile_facts_to_go(+Functor, +Arity, -Code)\n```\n\nGenerates: `GetAll<NAME>()`, `Stream<NAME>()`, `Contains<NAME>()`", "answer_tailored": true}
{"pair_id": "b6-a1-recursion-apis_p0", "cluster_id": "b6-a1-recursion-apis", "question": "What recursion APIs does Go target have?", "question_type": "medium", "answer": "The Go target provides four recursion APIs:\n\n**compile_recursive/3** - Implements BFS-based transitive closure with O(V + E) complexity. Use it for graph-like predicates:\n```prolog\ncompile_recursive(ancestor/2, [target(go)], Code).\n```\n\n**compile_tail_recursion_go/3** - Transforms tail-recursive predicates into iterative loops, achieving O(1) stack space:\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n**compile_linear_recursion_go/3** - Applies memoization using `map[int]int` for O(n) time complexity through caching:\n```prolog\ncompile_linear_recursion_go(triangular/2, [], Code).\n```\n\n**compile_mutual_recursion_go/3** - Handles mutually recursive predicates with a shared memoization map:\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nFor complete API documentation, see education/book-06-go-target/A1_api_reference.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-recursive", "tail-recursion", "memoization", "mutual-recursion"], "original_answer": "## Go Target Recursion APIs\n\n### compile_recursive/3\n\nBFS-based transitive closure. O(V + E) complexity.\n\n```prolog\ncompile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### compile_tail_recursion_go/3\n\nConverts tail recursion to iterative loops. O(1) stack space.\n\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n### compile_linear_recursion_go/3\n\nAdds memoization with `map[int]int`. O(n) time via caching.\n\n```prolog\ncompile_linear_recursion_go(triangular/2, [], Code).\n```\n\n### compile_mutual_recursion_go/3\n\nShared memo map for mutually recursive predicates.\n\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a1-recursion-apis_p1", "cluster_id": "b6-a1-recursion-apis", "question": "How do I compile tail recursion to Go?", "question_type": "medium", "answer": "To compile tail recursion to Go in UnifyWeaver, use the `compile_tail_recursion_go/3` predicate. This converts tail-recursive predicates into iterative loops, achieving O(1) stack space instead of building up the call stack:\n\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\nThis transformation is particularly useful for predicates like list accumulators or counting operations where the recursive call is the last operation. The generated Go code uses a loop structure that avoids stack overflow on large inputs.\n\nFor other recursion patterns in Go, see `compile_recursive/3` for BFS-based transitive closure (O(V + E) complexity), `compile_linear_recursion_go/3` for memoized linear recursion with `map[int]int` caching, or `compile_mutual_recursion_go/3` for mutually recursive predicates with shared memoization. Full details are in education/book-06-go-target/A1_api_reference.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-recursive", "tail-recursion", "memoization", "mutual-recursion"], "original_answer": "## Go Target Recursion APIs\n\n### compile_recursive/3\n\nBFS-based transitive closure. O(V + E) complexity.\n\n```prolog\ncompile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### compile_tail_recursion_go/3\n\nConverts tail recursion to iterative loops. O(1) stack space.\n\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n### compile_linear_recursion_go/3\n\nAdds memoization with `map[int]int`. O(n) time via caching.\n\n```prolog\ncompile_linear_recursion_go(triangular/2, [], Code).\n```\n\n### compile_mutual_recursion_go/3\n\nShared memo map for mutually recursive predicates.\n\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a1-recursion-apis_p2", "cluster_id": "b6-a1-recursion-apis", "question": "What is compile_mutual_recursion_go/3?", "question_type": "medium", "answer": "`compile_mutual_recursion_go/3` handles mutually recursive predicates in Go by using a shared memoization map. This is essential when you have predicates that call each other (like `is_even/1` and `is_odd/1`).\n\n**Usage:**\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nThe predicate takes a list of mutually recursive predicates as the first argument, options as the second (typically empty list), and unifies the generated Go code with the third argument. The implementation creates a shared memo map that all predicates in the mutual recursion group can access, avoiding redundant computation.\n\nFor other recursion patterns in the Go target, see `compile_recursive/3` (BFS-based transitive closure), `compile_tail_recursion_go/3` (tail call optimization), and `compile_linear_recursion_go/3` (single-predicate memoization). Full API details are in education/book-06-go-target/A1_api_reference.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-recursive", "tail-recursion", "memoization", "mutual-recursion"], "original_answer": "## Go Target Recursion APIs\n\n### compile_recursive/3\n\nBFS-based transitive closure. O(V + E) complexity.\n\n```prolog\ncompile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### compile_tail_recursion_go/3\n\nConverts tail recursion to iterative loops. O(1) stack space.\n\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n### compile_linear_recursion_go/3\n\nAdds memoization with `map[int]int`. O(n) time via caching.\n\n```prolog\ncompile_linear_recursion_go(triangular/2, [], Code).\n```\n\n### compile_mutual_recursion_go/3\n\nShared memo map for mutually recursive predicates.\n\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a1-api-selection_p0", "cluster_id": "b6-a1-api-selection", "question": "Which Go target API should I use?", "question_type": "medium", "answer": "The Go target provides several APIs depending on your compilation needs:\n\n**For fact/data compilation:**\n- Use `compile_facts_to_go/3` to export Prolog facts as Go structs\n\n**For query compilation:**\n- Use `compile_predicate_to_go/3` with streaming mode for simple transformations (O(n) single-pass, O(1) memory) - ideal for ETL workflows\n- Use `compile_predicate_to_go/3` with generator mode for complex queries involving joins, recursion, or negation (fixpoint iteration with O(n) memory)\n\n**For specialized recursion patterns:**\n- `compile_recursive/3` - handles transitive closure using BFS\n- `compile_tail_recursion_go/3` - optimizes accumulator-style loops\n- `compile_linear_recursion_go/3` - generates memoized recursive functions\n- `compile_mutual_recursion_go/3` - compiles mutually recursive predicates\n\nChoose streaming mode for pipeline-style data transformations, and generator mode when you need Datalog semantics with joins or recursive queries. For detailed examples and usage patterns, see education/book-06-go-target/A1_api_reference.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["api-selection", "streaming-vs-generator", "when-to-use"], "original_answer": "## API Selection Guide\n\n| Use Case | API | Mode |\n|----------|-----|------|\n| Export facts to structs | `compile_facts_to_go/3` | - |\n| Simple stream transform | `compile_predicate_to_go/3` | streaming |\n| Full Datalog with joins | `compile_predicate_to_go/3` | generator |\n| Transitive closure (BFS) | `compile_recursive/3` | - |\n| Accumulator loops | `compile_tail_recursion_go/3` | - |\n| Memoized recursion | `compile_linear_recursion_go/3` | - |\n| Mutual recursion | `compile_mutual_recursion_go/3` | - |\n\n### Mode Selection\n\n- **Streaming**: O(n) single-pass, O(1) memory. For ETL pipelines.\n- **Generator**: Fixpoint iteration, O(n) memory. For recursion, joins, negation.", "answer_tailored": true}
{"pair_id": "b6-a1-api-selection_p1", "cluster_id": "b6-a1-api-selection", "question": "When do I use generator mode vs streaming?", "question_type": "medium", "answer": "Choose **streaming mode** when you have a simple single-pass transformation that processes records one at a time with O(1) memory usage - ideal for ETL pipelines and linear data processing.\n\nChoose **generator mode** when you need:\n- Datalog features like joins, recursion, or negation\n- Fixpoint iteration to compute derived facts\n- O(n) memory to store intermediate results\n\nFor example, filtering or mapping records works well in streaming mode, while computing transitive relationships or performing relational joins requires generator mode.\n\nSee `education/book-06-go-target/A1_api_reference.md` for the complete API selection guide showing which compilation predicates support each mode.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["api-selection", "streaming-vs-generator", "when-to-use"], "original_answer": "## API Selection Guide\n\n| Use Case | API | Mode |\n|----------|-----|------|\n| Export facts to structs | `compile_facts_to_go/3` | - |\n| Simple stream transform | `compile_predicate_to_go/3` | streaming |\n| Full Datalog with joins | `compile_predicate_to_go/3` | generator |\n| Transitive closure (BFS) | `compile_recursive/3` | - |\n| Accumulator loops | `compile_tail_recursion_go/3` | - |\n| Memoized recursion | `compile_linear_recursion_go/3` | - |\n| Mutual recursion | `compile_mutual_recursion_go/3` | - |\n\n### Mode Selection\n\n- **Streaming**: O(n) single-pass, O(1) memory. For ETL pipelines.\n- **Generator**: Fixpoint iteration, O(n) memory. For recursion, joins, negation.", "answer_tailored": true}
{"pair_id": "b6-a1-api-selection_p2", "cluster_id": "b6-a1-api-selection", "question": "How do I choose between recursion APIs?", "question_type": "medium", "answer": "When selecting between UnifyWeaver's recursion APIs for Go target compilation, consider these guidelines:\n\n**For transitive closure with breadth-first search**: Use `compile_recursive/3`\n\n**For tail-recursive accumulator patterns**: Use `compile_tail_recursion_go/3`\n\n**For memoized recursive computations**: Use `compile_linear_recursion_go/3`\n\n**For mutually recursive predicates**: Use `compile_mutual_recursion_go/3`\n\n**For non-recursive cases**:\n- Use `compile_predicate_to_go/3` with streaming mode for single-pass transformations (O(n) time, O(1) memory)\n- Use `compile_predicate_to_go/3` with generator mode for Datalog queries requiring joins, fixpoint iteration, or negation (O(n) memory)\n\nStreaming mode is ideal for ETL pipelines, while generator mode handles recursive logic and complex query patterns. See education/book-06-go-target/A1_api_reference.md for complete API details.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["api-selection", "streaming-vs-generator", "when-to-use"], "original_answer": "## API Selection Guide\n\n| Use Case | API | Mode |\n|----------|-----|------|\n| Export facts to structs | `compile_facts_to_go/3` | - |\n| Simple stream transform | `compile_predicate_to_go/3` | streaming |\n| Full Datalog with joins | `compile_predicate_to_go/3` | generator |\n| Transitive closure (BFS) | `compile_recursive/3` | - |\n| Accumulator loops | `compile_tail_recursion_go/3` | - |\n| Memoized recursion | `compile_linear_recursion_go/3` | - |\n| Mutual recursion | `compile_mutual_recursion_go/3` | - |\n\n### Mode Selection\n\n- **Streaming**: O(n) single-pass, O(1) memory. For ETL pipelines.\n- **Generator**: Fixpoint iteration, O(n) memory. For recursion, joins, negation.", "answer_tailored": true}
