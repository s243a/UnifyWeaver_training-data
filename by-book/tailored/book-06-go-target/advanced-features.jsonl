{"pair_id": "b6-c3-regex-constraints_p0", "cluster_id": "b6-c3-regex-constraints", "question": "How does Go target handle regex matching?", "question_type": "medium", "answer": "The Go target compiles Prolog `match/2` and `match/4` predicates to Go's `regexp` package. For simple pattern matching like `match(Line, 'ERROR')`, it generates efficient regex checks to filter data. When using `match/4` with capture groups, you can extract substrings\u2014for example, `match(Line, '^([0-9-]+) ([A-Z]+):', auto, [Date, Level])` parses log entries and binds the date and log level to variables. The compiler optimizes these patterns into native Go regex operations for performance. For comprehensive examples of Go target features including pattern matching, see education/book-06-go-target/03_advanced_features.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/03_advanced_features.md", "topics": ["regex", "constraints", "aggregations"], "original_answer": "## Advanced Features\n\n### Regex Matching\n\n```prolog\n% Filter lines containing 'ERROR'\nerror_log(Line) :-\n    log(Line),\n    match(Line, 'ERROR').\n\n% Capture groups with match/4\nparse_log(Date, Level) :-\n    log(Line),\n    match(Line, '^([0-9-]+) ([A-Z]+):', auto, [Date, Level]).\n```\n\nCompiles to efficient Go `regexp` calls.\n\n### Constraints\n\nSupported operators: `>`, `<`, `>=`, `=<`, `==`, `\\=`\n\n```prolog\nadult(Name, Age) :-\n    person(Name, Age),\n    Age >= 18.\n```\n\n### Aggregations\n\nSupported: `sum`, `count`, `avg`, `min`, `max`\n\n```prolog\ntotal_score(Sum) :-\n    aggregation(sum),\n    score(Sum).\n```", "answer_tailored": true}
{"pair_id": "b6-c3-regex-constraints_p1", "cluster_id": "b6-c3-regex-constraints", "question": "What constraints are supported in Go target?", "question_type": "medium", "answer": "The Go target supports the following constraint operators: `>` (greater than), `<` (less than), `>=` (greater than or equal), `=<` (less than or equal), `==` (equal), and `\\=` (not equal).\n\nThese constraints work seamlessly in rule bodies for filtering data:\n\n```prolog\nadult(Name, Age) :-\n    person(Name, Age),\n    Age >= 18.\n```\n\nThe compiler translates these operators into efficient Go comparison expressions during code generation. For additional advanced features like regex matching and aggregations in the Go target, see education/book-06-go-target/03_advanced_features.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/03_advanced_features.md", "topics": ["regex", "constraints", "aggregations"], "original_answer": "## Advanced Features\n\n### Regex Matching\n\n```prolog\n% Filter lines containing 'ERROR'\nerror_log(Line) :-\n    log(Line),\n    match(Line, 'ERROR').\n\n% Capture groups with match/4\nparse_log(Date, Level) :-\n    log(Line),\n    match(Line, '^([0-9-]+) ([A-Z]+):', auto, [Date, Level]).\n```\n\nCompiles to efficient Go `regexp` calls.\n\n### Constraints\n\nSupported operators: `>`, `<`, `>=`, `=<`, `==`, `\\=`\n\n```prolog\nadult(Name, Age) :-\n    person(Name, Age),\n    Age >= 18.\n```\n\n### Aggregations\n\nSupported: `sum`, `count`, `avg`, `min`, `max`\n\n```prolog\ntotal_score(Sum) :-\n    aggregation(sum),\n    score(Sum).\n```", "answer_tailored": true}
{"pair_id": "b6-c3-regex-constraints_p2", "cluster_id": "b6-c3-regex-constraints", "question": "What aggregations can I use in Go?", "question_type": "medium", "answer": "In Go target compilation, UnifyWeaver supports five aggregation operations: `sum`, `count`, `avg`, `min`, and `max`. To use them, specify the aggregation type in your Prolog query:\n\n```prolog\ntotal_score(Sum) :-\n    aggregation(sum),\n    score(Sum).\n```\n\nThe compiler generates efficient Go code to compute these aggregations over your data sources. For complete details on Go target features including regex matching and constraints, see education/book-06-go-target/03_advanced_features.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/03_advanced_features.md", "topics": ["regex", "constraints", "aggregations"], "original_answer": "## Advanced Features\n\n### Regex Matching\n\n```prolog\n% Filter lines containing 'ERROR'\nerror_log(Line) :-\n    log(Line),\n    match(Line, 'ERROR').\n\n% Capture groups with match/4\nparse_log(Date, Level) :-\n    log(Line),\n    match(Line, '^([0-9-]+) ([A-Z]+):', auto, [Date, Level]).\n```\n\nCompiles to efficient Go `regexp` calls.\n\n### Constraints\n\nSupported operators: `>`, `<`, `>=`, `=<`, `==`, `\\=`\n\n```prolog\nadult(Name, Age) :-\n    person(Name, Age),\n    Age >= 18.\n```\n\n### Aggregations\n\nSupported: `sum`, `count`, `avg`, `min`, `max`\n\n```prolog\ntotal_score(Sum) :-\n    aggregation(sum),\n    score(Sum).\n```", "answer_tailored": true}
{"pair_id": "b6-c4-json-processing_p0", "cluster_id": "b6-c4-json-processing", "question": "How do I process JSON with the Go target?", "question_type": "medium", "answer": "To process JSON in the Go target, use `json_get/2` to extract fields from the input. For example, to extract a user's name and city:\n\n```prolog\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n```\n\nWhen compiling, enable JSON processing with the `json_input(true)` option:\n\n```prolog\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\nFor arrays, combine `json_get/2` with `json_array_member/3` to iterate over elements:\n\n```prolog\n% Processes: {\"users\": [{\"name\": \"alice\"}, {\"name\": \"bob\"}]}\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\nTo generate JSON output, add `json_output(true)` to your compilation options:\n\n```prolog\ncompile_predicate_to_go(transform/2, [\n    json_input(true),\n    json_output(true)\n], Code).\n```\n\nYou can enforce structure using schema validation:\n\n```prolog\n:- json_schema(user, [\n    field(name, string, [required]),\n    field(age, integer, [min(0)])\n]).\n```\n\nFor complete examples and advanced patterns, see education/book-06-go-target/04_json_processing.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/04_json_processing.md", "topics": ["json", "field-extraction", "schema-validation"], "original_answer": "## JSON Processing\n\n### Field Extraction\n\n```prolog\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n```\n\nCompile with `json_input(true)`:\n\n```prolog\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\n### Array Iteration\n\n```prolog\n% Input: {\"users\": [{\"name\": \"alice\"}, {\"name\": \"bob\"}]}\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\n### JSON Output\n\n```prolog\ncompile_predicate_to_go(transform/2, [\n    json_input(true),\n    json_output(true)\n], Code).\n```\n\n### Schema Validation\n\n```prolog\n:- json_schema(user, [\n    field(name, string, [required]),\n    field(age, integer, [min(0)])\n]).\n```", "answer_tailored": true}
{"pair_id": "b6-c4-json-processing_p1", "cluster_id": "b6-c4-json-processing", "question": "How do I extract nested JSON fields?", "question_type": "medium", "answer": "To extract nested JSON fields in UnifyWeaver, use `json_get/2` with a path list. For example, to access a city nested under an address object:\n\n```prolog\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n```\n\nThe path `[address, city]` navigates through the JSON structure: first to the `address` object, then to its `city` field.\n\nWhen compiling to Go, enable JSON input processing:\n\n```prolog\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\nFor accessing fields within JSON arrays, combine path extraction with `json_array_member/2`:\n\n```prolog\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\nThis extracts each user object from the array and then retrieves the nested `name` field.\n\nYou can also enable `json_output(true)` if your predicate should return JSON results. See education/book-06-go-target/04_json_processing.md for complete documentation on JSON handling patterns.", "answer_variant": "default", "answer_source": "education/book-06-go-target/04_json_processing.md", "topics": ["json", "field-extraction", "schema-validation"], "original_answer": "## JSON Processing\n\n### Field Extraction\n\n```prolog\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n```\n\nCompile with `json_input(true)`:\n\n```prolog\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\n### Array Iteration\n\n```prolog\n% Input: {\"users\": [{\"name\": \"alice\"}, {\"name\": \"bob\"}]}\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\n### JSON Output\n\n```prolog\ncompile_predicate_to_go(transform/2, [\n    json_input(true),\n    json_output(true)\n], Code).\n```\n\n### Schema Validation\n\n```prolog\n:- json_schema(user, [\n    field(name, string, [required]),\n    field(age, integer, [min(0)])\n]).\n```", "answer_tailored": true}
{"pair_id": "b6-c4-json-processing_p2", "cluster_id": "b6-c4-json-processing", "question": "What is json_array_member?", "question_type": "medium", "answer": "`json_array_member/2` is a built-in predicate used to iterate over elements in a JSON array. It takes two arguments: the array itself and a member variable that unifies with each element.\n\nFor example, given input `{\"users\": [{\"name\": \"alice\"}, {\"name\": \"bob\"}]}`:\n\n```prolog\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\nThis extracts the `users` array, then `json_array_member/2` iterates through each user object in that array, binding each one to `User`. The predicate backtracks to generate all solutions, making it possible to retrieve \"alice\" and \"bob\" in sequence.\n\nSee education/book-06-go-target/04_json_processing.md for complete JSON processing examples.", "answer_variant": "default", "answer_source": "education/book-06-go-target/04_json_processing.md", "topics": ["json", "field-extraction", "schema-validation"], "original_answer": "## JSON Processing\n\n### Field Extraction\n\n```prolog\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n```\n\nCompile with `json_input(true)`:\n\n```prolog\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\n### Array Iteration\n\n```prolog\n% Input: {\"users\": [{\"name\": \"alice\"}, {\"name\": \"bob\"}]}\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\n### JSON Output\n\n```prolog\ncompile_predicate_to_go(transform/2, [\n    json_input(true),\n    json_output(true)\n], Code).\n```\n\n### Schema Validation\n\n```prolog\n:- json_schema(user, [\n    field(name, string, [required]),\n    field(age, integer, [min(0)])\n]).\n```", "answer_tailored": true}
