{"pair_id": "b6-a2-mode-complexity_p0", "cluster_id": "b6-a2-mode-complexity", "question": "What is the complexity of Go target modes?", "question_type": "medium", "answer": "The Go target has two modes with different complexity characteristics:\n\n**Streaming Mode** processes data in a single pass with minimal memory:\n- Simple transformations: O(n) time, O(1) space\n- Regex matching: O(n \u00d7 m) time, O(1) space  \n- JSON parsing: O(n) time, O(d) space where d is nesting depth\n\n**Generator Mode** uses fixpoint iteration for recursive queries:\n- Fixpoint iteration: O(n \u00d7 k) time, O(n) space where k is iteration count\n- Indexed joins: O(1) lookup time, O(n) space\n- Unindexed joins: O(n\u00b2) time, O(n) space\n- Aggregation: O(n) time, O(g) space where g is the number of groups\n\nHere n represents the number of facts being processed. For more details on Go target implementation, see education/book-06-go-target/.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["complexity", "big-o", "streaming-mode", "generator-mode"], "original_answer": "## Go Target Mode Complexity\n\n### Streaming Mode\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Simple transform | O(n) | O(1) |\n| Regex matching | O(n \u00d7 m) | O(1) |\n| JSON parsing | O(n) | O(d) |\n\n### Generator Mode (Fixpoint)\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Fixpoint iteration | O(n \u00d7 k) | O(n) |\n| Indexed join | O(1) lookup | O(n) |\n| Unindexed join | O(n\u00b2) | O(n) |\n| Aggregation | O(n) | O(g) |\n\nWhere: n = facts, k = iterations, g = groups, d = nesting depth", "answer_tailored": true}
{"pair_id": "b6-a2-mode-complexity_p1", "cluster_id": "b6-a2-mode-complexity", "question": "What is Big-O for streaming vs generator mode?", "question_type": "medium", "answer": "## Big-O Complexity: Streaming vs Generator Mode\n\n**Streaming Mode** operates with constant memory overhead:\n- Simple transformations: O(n) time, O(1) space\n- Regex matching: O(n \u00d7 m) time, O(1) space  \n- JSON parsing: O(n) time, O(d) space (d = nesting depth)\n\n**Generator Mode (Fixpoint)** maintains state in memory:\n- Fixpoint iteration: O(n \u00d7 k) time, O(n) space (k = iterations)\n- Indexed joins: O(1) lookup time, O(n) space\n- Unindexed joins: O(n\u00b2) time, O(n) space\n- Aggregations: O(n) time, O(g) space (g = group count)\n\nThe key difference: streaming uses constant space O(1) for most operations, while generator mode requires O(n) space to store facts between iterations.\n\nFor detailed Go target compilation patterns, see education/book-06-go-target/A2_complexity_guide.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["complexity", "big-o", "streaming-mode", "generator-mode"], "original_answer": "## Go Target Mode Complexity\n\n### Streaming Mode\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Simple transform | O(n) | O(1) |\n| Regex matching | O(n \u00d7 m) | O(1) |\n| JSON parsing | O(n) | O(d) |\n\n### Generator Mode (Fixpoint)\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Fixpoint iteration | O(n \u00d7 k) | O(n) |\n| Indexed join | O(1) lookup | O(n) |\n| Unindexed join | O(n\u00b2) | O(n) |\n| Aggregation | O(n) | O(g) |\n\nWhere: n = facts, k = iterations, g = groups, d = nesting depth", "answer_tailored": true}
{"pair_id": "b6-a2-mode-complexity_p2", "cluster_id": "b6-a2-mode-complexity", "question": "How does fixpoint iteration scale?", "question_type": "medium", "answer": "Fixpoint iteration in Go target mode has time complexity O(n \u00d7 k) where n is the number of facts and k is the number of iterations needed to reach fixpoint. Space complexity is O(n) to store the working set of facts. For indexed joins during fixpoint computation, lookup time is O(1) per fact while maintaining O(n) space overhead. Unindexed joins within fixpoint loops scale as O(n\u00b2) time. The iteration count k depends on rule recursion depth - simple transitive closures converge quickly while complex mutual recursion may require more iterations. See education/book-06-go-target/A2_complexity_guide.md for the complete complexity analysis across streaming and generator modes.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["complexity", "big-o", "streaming-mode", "generator-mode"], "original_answer": "## Go Target Mode Complexity\n\n### Streaming Mode\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Simple transform | O(n) | O(1) |\n| Regex matching | O(n \u00d7 m) | O(1) |\n| JSON parsing | O(n) | O(d) |\n\n### Generator Mode (Fixpoint)\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Fixpoint iteration | O(n \u00d7 k) | O(n) |\n| Indexed join | O(1) lookup | O(n) |\n| Unindexed join | O(n\u00b2) | O(n) |\n| Aggregation | O(n) | O(g) |\n\nWhere: n = facts, k = iterations, g = groups, d = nesting depth", "answer_tailored": true}
{"pair_id": "b6-a2-recursion-complexity_p0", "cluster_id": "b6-a2-recursion-complexity", "question": "What is the complexity of recursive compilation?", "question_type": "medium", "answer": "Recursive compilation in UnifyWeaver varies by pattern type:\n\n**Time Complexity:**\n- BFS transitive closure: O(V + E) where V is vertices and E is edges\n- Tail recursion: O(n) - compiles to efficient iterative loops\n- Linear recursion with memoization: O(n)\n- Mutual recursion: O(n)\n\n**Space Complexity:**\n- BFS: O(V) for visited tracking and queue storage\n- Tail recursion: O(1) - no stack growth due to loop conversion\n- Memoized patterns: O(n) for cache storage\n- Mutual recursion: O(n) for shared memoization map\n\n**Generated Code Characteristics:**\n\nFor BFS patterns, the compiler generates:\n```go\nvisited := make(map[string]bool)  // O(V) space\nqueue := []string{start}          // O(V) max size\n```\n\nFor memoized recursion:\n```go\nvar memo = make(map[int]int)  // O(n) space\nif result, ok := memo[n]; ok { return result }  // O(1) lookup\n```\n\nTail-recursive predicates compile to simple for-loops, achieving O(1) space instead of O(n) call stack depth.\n\nFor detailed examples and implementation strategies, see education/book-06-go-target/A2_complexity_guide.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["recursion-complexity", "bfs", "memoization", "tail-recursion"], "original_answer": "## Recursion Pattern Complexity\n\n| Pattern | Time | Space | Generated Code |\n|---------|------|-------|----------------|\n| BFS transitive closure | O(V + E) | O(V) | Queue + visited set |\n| Tail recursion | O(n) | O(1) | Iterative for-loop |\n| Linear (memoized) | O(n) | O(n) | Map-based cache |\n| Mutual recursion | O(n) | O(n) | Shared memo map |\n\n### BFS Implementation\n\n```go\nvisited := make(map[string]bool)  // O(V) space\nqueue := []string{start}          // O(V) max size\n```\n\n### Memoization\n\n```go\nvar memo = make(map[int]int)  // O(n) space\nif result, ok := memo[n]; ok { return result }  // O(1) lookup\n```", "answer_tailored": true}
{"pair_id": "b6-a2-recursion-complexity_p1", "cluster_id": "b6-a2-recursion-complexity", "question": "How does BFS transitive closure scale?", "question_type": "medium", "answer": "BFS transitive closure in UnifyWeaver's Go target has **O(V + E) time complexity** and **O(V) space complexity**, where V is vertices and E is edges. The generated code uses a queue for breadth-first traversal and a visited set to track processed nodes:\n\n```go\nvisited := make(map[string]bool)  // O(V) space\nqueue := []string{start}          // O(V) max size\n```\n\nThis makes BFS efficient for graph traversal queries, visiting each vertex once and examining each edge once. The space overhead is linear in the number of vertices, dominated by the visited map and queue storage.\n\nFor comparison with other recursion patterns:\n- Tail recursion: O(n) time, O(1) space (converts to iterative loop)\n- Linear with memoization: O(n) time, O(n) space (map-based cache)\n- Mutual recursion: O(n) time, O(n) space (shared memo map)\n\nSee education/book-06-go-target/A2_complexity_guide.md for detailed complexity analysis of all recursion patterns.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["recursion-complexity", "bfs", "memoization", "tail-recursion"], "original_answer": "## Recursion Pattern Complexity\n\n| Pattern | Time | Space | Generated Code |\n|---------|------|-------|----------------|\n| BFS transitive closure | O(V + E) | O(V) | Queue + visited set |\n| Tail recursion | O(n) | O(1) | Iterative for-loop |\n| Linear (memoized) | O(n) | O(n) | Map-based cache |\n| Mutual recursion | O(n) | O(n) | Shared memo map |\n\n### BFS Implementation\n\n```go\nvisited := make(map[string]bool)  // O(V) space\nqueue := []string{start}          // O(V) max size\n```\n\n### Memoization\n\n```go\nvar memo = make(map[int]int)  // O(n) space\nif result, ok := memo[n]; ok { return result }  // O(1) lookup\n```", "answer_tailored": true}
{"pair_id": "b6-a2-recursion-complexity_p2", "cluster_id": "b6-a2-recursion-complexity", "question": "What is the complexity of memoized recursion?", "question_type": "medium", "answer": "Memoized recursion has **O(n) time complexity** and **O(n) space complexity**. The linear time comes from computing each unique subproblem at most once, while the space is needed for the memoization cache that stores previously computed results.\n\nIn Go, this is implemented using a map-based cache:\n\n```go\nvar memo = make(map[int]int)  // O(n) space for cache\nif result, ok := memo[n]; ok { \n    return result  // O(1) lookup for cached values\n}\n```\n\nThis applies to both linear recursion and mutual recursion patterns, which share the same O(n)/O(n) complexity profile. For the complete recursion pattern complexity comparison including BFS and tail recursion, see education/book-06-go-target/A2_complexity_guide.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["recursion-complexity", "bfs", "memoization", "tail-recursion"], "original_answer": "## Recursion Pattern Complexity\n\n| Pattern | Time | Space | Generated Code |\n|---------|------|-------|----------------|\n| BFS transitive closure | O(V + E) | O(V) | Queue + visited set |\n| Tail recursion | O(n) | O(1) | Iterative for-loop |\n| Linear (memoized) | O(n) | O(n) | Map-based cache |\n| Mutual recursion | O(n) | O(n) | Shared memo map |\n\n### BFS Implementation\n\n```go\nvisited := make(map[string]bool)  // O(V) space\nqueue := []string{start}          // O(V) max size\n```\n\n### Memoization\n\n```go\nvar memo = make(map[int]int)  // O(n) space\nif result, ok := memo[n]; ok { return result }  // O(1) lookup\n```", "answer_tailored": true}
{"pair_id": "b6-a2-db-complexity_p0", "cluster_id": "b6-a2-db-complexity", "question": "What is the complexity of BoltDB queries?", "question_type": "medium", "answer": "BoltDB queries have different complexity characteristics depending on how they're structured:\n\n**Direct key lookups** (e.g., `key = value`) achieve O(log n) complexity through BoltDB's B+tree index, providing fast retrieval for exact matches.\n\n**Range scans with composite keys** (e.g., `key_prefix = value`) perform at O(k log n) where k is the number of matching records, making prefix-based queries efficient when the prefix is part of the key.\n\n**Non-indexed field queries** (e.g., filtering on `field > value` when the field isn't in the key) require full bucket scans at O(n) complexity, examining every record.\n\n**Performance optimization:** Structure your keys to include frequently queried fields. This transforms potential O(n) full scans into O(log n) indexed lookups. Hash keys and single-field keys both provide O(log n) exact lookups but don't support efficient range scans.\n\nFor detailed key design strategies and composite key patterns, see education/book-06-go-target/A2_complexity_guide.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["database-complexity", "boltdb", "key-lookup", "query-optimization"], "original_answer": "## Database Query Complexity\n\n### Key Strategy Performance\n\n| Strategy | Lookup | Range Scan | Full Scan |\n|----------|--------|------------|----------|\n| Single field key | O(log n) | N/A | O(n) |\n| Composite key | O(log n) | O(k log n) | O(n) |\n| Hash key | O(log n) | N/A | O(n) |\n\n### Query Optimization\n\n| Query Pattern | Strategy | Complexity |\n|---------------|----------|------------|\n| `key = value` | Direct lookup | O(log n) |\n| `key_prefix = value` | Prefix scan | O(k log n) |\n| `field > value` (non-key) | Full scan | O(n) |\n\n**Tip:** Put frequently queried fields in the key for O(log n) lookups.", "answer_tailored": true}
{"pair_id": "b6-a2-db-complexity_p1", "cluster_id": "b6-a2-db-complexity", "question": "How do key strategies affect performance?", "question_type": "medium", "answer": "Key strategies significantly impact query performance in UnifyWeaver's database compilation:\n\n**Direct Performance Impact:**\n- **Single field keys** enable O(log n) lookups for equality checks, falling back to O(n) for full scans\n- **Composite keys** maintain O(log n) for exact matches and support O(k log n) range scans with prefix matching\n- **Hash keys** provide O(log n) lookups but cannot support range queries\n\n**Query Pattern Optimization:**\n- Exact matches (`key = value`) achieve O(log n) through direct lookup\n- Prefix matches (`key_prefix = value`) perform at O(k log n) via prefix scanning\n- Non-key field filters (`field > value`) require O(n) full scans\n\n**Best Practice:** Position frequently queried fields in your key definition to leverage logarithmic lookup performance instead of linear scanning. See education/book-06-go-target/A2_complexity_guide.md for detailed complexity analysis.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["database-complexity", "boltdb", "key-lookup", "query-optimization"], "original_answer": "## Database Query Complexity\n\n### Key Strategy Performance\n\n| Strategy | Lookup | Range Scan | Full Scan |\n|----------|--------|------------|----------|\n| Single field key | O(log n) | N/A | O(n) |\n| Composite key | O(log n) | O(k log n) | O(n) |\n| Hash key | O(log n) | N/A | O(n) |\n\n### Query Optimization\n\n| Query Pattern | Strategy | Complexity |\n|---------------|----------|------------|\n| `key = value` | Direct lookup | O(log n) |\n| `key_prefix = value` | Prefix scan | O(k log n) |\n| `field > value` (non-key) | Full scan | O(n) |\n\n**Tip:** Put frequently queried fields in the key for O(log n) lookups.", "answer_tailored": true}
{"pair_id": "b6-a2-db-complexity_p2", "cluster_id": "b6-a2-db-complexity", "question": "When is full scan vs direct lookup used?", "question_type": "medium", "answer": "Direct lookup (O(log n)) is used when querying by an exact key match (`key = value`) or by a hash key. Full scan (O(n)) is necessary when filtering on non-key fields (e.g., `field > value`) or when the query pattern doesn't match any indexed structure.\n\nFor composite keys, prefix scans offer a middle ground with O(k log n) complexity when matching key prefixes. To optimize query performance, place frequently queried fields in the key definition to enable efficient lookups instead of costly full scans.\n\nSee education/book-06-go-target/A2_complexity_guide.md for complete complexity analysis.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["database-complexity", "boltdb", "key-lookup", "query-optimization"], "original_answer": "## Database Query Complexity\n\n### Key Strategy Performance\n\n| Strategy | Lookup | Range Scan | Full Scan |\n|----------|--------|------------|----------|\n| Single field key | O(log n) | N/A | O(n) |\n| Composite key | O(log n) | O(k log n) | O(n) |\n| Hash key | O(log n) | N/A | O(n) |\n\n### Query Optimization\n\n| Query Pattern | Strategy | Complexity |\n|---------------|----------|------------|\n| `key = value` | Direct lookup | O(log n) |\n| `key_prefix = value` | Prefix scan | O(k log n) |\n| `field > value` (non-key) | Full scan | O(n) |\n\n**Tip:** Put frequently queried fields in the key for O(log n) lookups.", "answer_tailored": true}
