{"pair_id": "csharp-stream-target_p0", "cluster_id": "csharp-stream-target", "question": "What is the C# Stream Target?", "question_type": "medium", "answer": "The C# Stream Target is a compilation mode in UnifyWeaver that transforms Prolog predicates into C# LINQ streaming pipelines. It converts Prolog facts into static C# arrays and Prolog rules into LINQ operations like Select and Where. When a predicate has multiple clauses, the compiler generates a Union to combine them, and uses Distinct() to eliminate duplicates.\n\nFor instance, simple facts like `parent(alice, bob)` become readonly tuples stored in an array, with a Stream() method that returns them as an IEnumerable. The compiler infers C# types from Prolog terms: integers map to `int`, floating-point numbers to `double`, atoms to `string`, and compound terms to tuples.\n\nYou can compile predicates using `compile_predicate_to_csharp/3`, which generates the complete C# class code that can be written to a .cs file.\n\nFor comprehensive details on the Stream Target implementation, see education/book-03-csharp-target/02_csharp_stream_target.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["stream-target", "linq", "csharp", "facts"], "original_answer": "## C# Stream Target\n\nThe Stream Target compiles Prolog to LINQ pipelines:\n\n- **Facts** \u2192 C# arrays\n- **Rules** \u2192 LINQ Select/Where\n- **Multiple clauses** \u2192 Union\n- **Deduplication** \u2192 Distinct()\n\n### Example: Facts to Arrays\n\n**Prolog:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C#:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Compile Command\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Inference\n\n| Prolog | C# Type |\n|--------|--------|\n| `42` | `int` |\n| `3.14` | `double` |\n| `atom` | `string` |\n| `(a, b)` | `(string, string)` |", "answer_tailored": true}
{"pair_id": "csharp-stream-target_p1", "cluster_id": "csharp-stream-target", "question": "How are Prolog facts translated to C#?", "question_type": "medium", "answer": "In UnifyWeaver's C# Stream Target, Prolog facts are translated to C# arrays of tuples. Each fact becomes an element in a readonly static array, and the predicate provides a `Stream()` method that returns the facts as an `IEnumerable`.\n\nFor example, these Prolog facts:\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nCompile to this C# code:\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\nThe compiler automatically infers C# types from Prolog terms: integers become `int`, floating-point numbers become `double`, atoms become `string`, and compound terms become tuples with appropriate type parameters.\n\nTo compile a predicate to C#:\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\nFor more details on the C# Stream Target, see education/book-03-csharp-target/02_csharp_stream_target.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["stream-target", "linq", "csharp", "facts"], "original_answer": "## C# Stream Target\n\nThe Stream Target compiles Prolog to LINQ pipelines:\n\n- **Facts** \u2192 C# arrays\n- **Rules** \u2192 LINQ Select/Where\n- **Multiple clauses** \u2192 Union\n- **Deduplication** \u2192 Distinct()\n\n### Example: Facts to Arrays\n\n**Prolog:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C#:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Compile Command\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Inference\n\n| Prolog | C# Type |\n|--------|--------|\n| `42` | `int` |\n| `3.14` | `double` |\n| `atom` | `string` |\n| `(a, b)` | `(string, string)` |", "answer_tailored": true}
{"pair_id": "csharp-stream-target_p2", "cluster_id": "csharp-stream-target", "question": "What LINQ operations are generated?", "question_type": "medium", "answer": "The C# Stream Target generates these LINQ operations when compiling Prolog:\n\n- **Select** - For transforming data in rules\n- **Where** - For filtering conditions in rules\n- **Union** - For combining results from multiple clauses\n- **Distinct()** - For deduplicating results\n- **AsEnumerable()** - For converting arrays to streams\n\n### Example Generation\n\nWhen compiling a simple fact predicate like `parent(alice, bob)`, the compiler generates:\n\n```csharp\npublic static IEnumerable<(string, string)> Stream()\n    => Facts.AsEnumerable();\n```\n\nFor rules with conditions, you'll see Select and Where operations. When a predicate has multiple clauses, the compiler uses Union to combine them, followed by Distinct() to remove duplicates.\n\nThe specific LINQ operation depends on the Prolog construct being compiled. See education/book-03-csharp-target/02_csharp_stream_target.md for complete examples of each operation type.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["stream-target", "linq", "csharp", "facts"], "original_answer": "## C# Stream Target\n\nThe Stream Target compiles Prolog to LINQ pipelines:\n\n- **Facts** \u2192 C# arrays\n- **Rules** \u2192 LINQ Select/Where\n- **Multiple clauses** \u2192 Union\n- **Deduplication** \u2192 Distinct()\n\n### Example: Facts to Arrays\n\n**Prolog:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C#:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Compile Command\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Inference\n\n| Prolog | C# Type |\n|--------|--------|\n| `42` | `int` |\n| `3.14` | `double` |\n| `atom` | `string` |\n| `(a, b)` | `(string, string)` |", "answer_tailored": true}
{"pair_id": "csharp-stream-target_p3", "cluster_id": "csharp-stream-target", "question": "How do I compile facts to C# arrays?", "question_type": "medium", "answer": "To compile Prolog facts to C# arrays, use UnifyWeaver's C# Stream Target, which translates fact definitions into static readonly arrays.\n\n### Basic Compilation\n\nFacts are converted to typed C# arrays with automatic type inference:\n\n**Prolog Input:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**C# Output:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Compilation Command\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Mapping\n\nThe compiler infers C# types from Prolog terms:\n\n| Prolog Term | C# Type |\n|-------------|---------|\n| `42` | `int` |\n| `3.14` | `double` |\n| `atom` | `string` |\n| `(a, b)` | `(string, string)` |\n\n### Stream Target Features\n\n- **Rules** \u2192 LINQ Select/Where operations\n- **Multiple clauses** \u2192 Union combinators\n- **Deduplication** \u2192 Distinct() calls\n\nFor comprehensive examples, see education/book-03-csharp-target/02_csharp_stream_target.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["stream-target", "linq", "csharp", "facts"], "original_answer": "## C# Stream Target\n\nThe Stream Target compiles Prolog to LINQ pipelines:\n\n- **Facts** \u2192 C# arrays\n- **Rules** \u2192 LINQ Select/Where\n- **Multiple clauses** \u2192 Union\n- **Deduplication** \u2192 Distinct()\n\n### Example: Facts to Arrays\n\n**Prolog:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C#:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Compile Command\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Inference\n\n| Prolog | C# Type |\n|--------|--------|\n| `42` | `int` |\n| `3.14` | `double` |\n| `atom` | `string` |\n| `(a, b)` | `(string, string)` |", "answer_tailored": true}
{"pair_id": "csharp-stream-rules_p0", "cluster_id": "csharp-stream-rules", "question": "How are Prolog rules translated to LINQ?", "question_type": "medium", "answer": "Prolog rules translate to LINQ by mapping logical conditions to query operations:\n\n**Filtering Conditions**: A rule with constraints like `adult(Person) :- age(Person, Age), Age >= 18` becomes a LINQ query with `.Where()` for the condition and `.Select()` to extract the result variable.\n\n**Joins for Multi-Predicate Rules**: When a rule references multiple predicates like `grandparent(GP, GC) :- parent(GP, P), parent(P, GC)`, UnifyWeaver generates a `.Join()` operation that connects the two relations on the shared variable `P`.\n\n**Union for Multiple Clauses**: If a predicate has both facts and rules (multiple clauses), each clause compiles separately and the results combine using `.Union()` to merge all solutions.\n\nThe translation preserves Prolog's logical semantics while leveraging LINQ's declarative query syntax. Each Prolog variable becomes part of the LINQ pipeline, with tuple projections handling multi-argument predicates. See education/book-03-csharp-target/02_csharp_stream_target.md for complete examples and patterns.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["rules", "linq", "where", "join"], "original_answer": "## Rules to LINQ Translation\n\n### Simple Rule with Conditions\n\n**Prolog:**\n```prolog\nadult(Person) :-\n    age(Person, Age),\n    Age >= 18.\n```\n\n**Generated C#:**\n```csharp\npublic static IEnumerable<string> Stream()\n{\n    return AgeFacts\n        .Where(t => t.Item2 >= 18)  // Age >= 18\n        .Select(t => t.Item1);       // Return Person\n}\n```\n\n### Join Pattern (Grandparent)\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C#:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // P (child)\n        inner => inner.Item1,  // P (parent)\n        (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n    );\n```\n\n### Multiple Clauses \u2192 Union\n\n**Prolog:**\n```prolog\nsibling(alice, bob).  % Fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule\n```\n\n**Generated:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = /* computed siblings */;\nreturn clause1.Union(clause2);  // Combines both\n```", "answer_tailored": true}
{"pair_id": "csharp-stream-rules_p1", "cluster_id": "csharp-stream-rules", "question": "How does the Join operation work in C#?", "question_type": "medium", "answer": "The Join operation in C# is used when a Prolog rule requires matching facts across two relations. For example, in the grandparent rule:\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C#:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // P (child from first relation)\n        inner => inner.Item1,  // P (parent from second relation)\n        (outer, inner) => (outer.Item1, inner.Item2)  // Projects (GP, GC)\n    );\n```\n\nThe Join works by:\n1. Taking the outer collection (first `ParentFacts`)\n2. Matching it with the inner collection (second `ParentFacts`)\n3. Using key selectors: `outer.Item2` matches with `inner.Item1` (both representing the intermediate person P)\n4. Projecting the result: combines `outer.Item1` (grandparent) with `inner.Item2` (grandchild)\n\nThis corresponds to finding all pairs where someone's child is also someone else's parent. For more examples of C# stream operations, see education/book-03-csharp-target/02_csharp_stream_target.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["rules", "linq", "where", "join"], "original_answer": "## Rules to LINQ Translation\n\n### Simple Rule with Conditions\n\n**Prolog:**\n```prolog\nadult(Person) :-\n    age(Person, Age),\n    Age >= 18.\n```\n\n**Generated C#:**\n```csharp\npublic static IEnumerable<string> Stream()\n{\n    return AgeFacts\n        .Where(t => t.Item2 >= 18)  // Age >= 18\n        .Select(t => t.Item1);       // Return Person\n}\n```\n\n### Join Pattern (Grandparent)\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C#:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // P (child)\n        inner => inner.Item1,  // P (parent)\n        (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n    );\n```\n\n### Multiple Clauses \u2192 Union\n\n**Prolog:**\n```prolog\nsibling(alice, bob).  % Fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule\n```\n\n**Generated:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = /* computed siblings */;\nreturn clause1.Union(clause2);  // Combines both\n```", "answer_tailored": true}
{"pair_id": "csharp-stream-rules_p2", "cluster_id": "csharp-stream-rules", "question": "How are multiple clauses combined?", "question_type": "medium", "answer": "Multiple clauses for the same predicate are combined using `Union` operations in C#. Each clause becomes a separate LINQ expression, and the results are merged together.\n\n**Example with Mixed Facts and Rules:**\n\nWhen you have both fact and rule clauses:\n```prolog\nsibling(alice, bob).  % Fact clause\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule clause\n```\n\nThe generated C# creates separate streams and unions them:\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = ParentFacts\n    .Join(ParentFacts,\n          outer => outer.Item1,\n          inner => inner.Item1,\n          (outer, inner) => (outer.Item2, inner.Item2))\n    .Where(t => t.Item1 != t.Item2);\n    \nreturn clause1.Union(clause2);\n```\n\n**How It Works:**\n- Each clause is compiled independently to its own LINQ expression\n- Facts become literal arrays or enumerable collections\n- Rules become LINQ query chains (joins, filters, projections)\n- All clause results are combined with `.Union()` to produce the final result set\n\nThis mirrors Prolog's semantics where multiple clauses represent alternative ways to satisfy a query. See education/book-03-csharp-target/02_csharp_stream_target.md for complete examples.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["rules", "linq", "where", "join"], "original_answer": "## Rules to LINQ Translation\n\n### Simple Rule with Conditions\n\n**Prolog:**\n```prolog\nadult(Person) :-\n    age(Person, Age),\n    Age >= 18.\n```\n\n**Generated C#:**\n```csharp\npublic static IEnumerable<string> Stream()\n{\n    return AgeFacts\n        .Where(t => t.Item2 >= 18)  // Age >= 18\n        .Select(t => t.Item1);       // Return Person\n}\n```\n\n### Join Pattern (Grandparent)\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C#:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // P (child)\n        inner => inner.Item1,  // P (parent)\n        (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n    );\n```\n\n### Multiple Clauses \u2192 Union\n\n**Prolog:**\n```prolog\nsibling(alice, bob).  % Fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule\n```\n\n**Generated:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = /* computed siblings */;\nreturn clause1.Union(clause2);  // Combines both\n```", "answer_tailored": true}
{"pair_id": "csharp-stream-rules_p3", "cluster_id": "csharp-stream-rules", "question": "What is the Union pattern for clauses?", "question_type": "medium", "answer": "The Union pattern handles predicates defined by multiple clauses in Prolog. When a predicate has both facts and rules (or multiple rules), each clause generates a separate C# LINQ expression, and these are combined using `.Union()`.\n\n**Example - Multiple Clause Definition:**\n\n**Prolog:**\n```prolog\nsibling(alice, bob).  % First clause: direct fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Second clause: computed rule\n```\n\n**Generated C#:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };  // From fact\nvar clause2 = ParentFacts\n    .Join(ParentFacts,\n        outer => outer.Item1,  // Shared parent P\n        inner => inner.Item1,\n        (outer, inner) => (outer.Item2, inner.Item2))  // (X, Y)\n    .Where(t => t.Item1 != t.Item2);  // X \\= Y\n\nreturn clause1.Union(clause2);  // Combines both clauses\n```\n\nEach clause becomes its own stream, then `.Union()` merges them into a single result set. This preserves Prolog's semantics where any clause can satisfy the predicate. The pattern works for any number of clauses - facts, simple rules, or complex joins.\n\nFor more on C# target compilation patterns, see education/book-03-csharp-target/.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["rules", "linq", "where", "join"], "original_answer": "## Rules to LINQ Translation\n\n### Simple Rule with Conditions\n\n**Prolog:**\n```prolog\nadult(Person) :-\n    age(Person, Age),\n    Age >= 18.\n```\n\n**Generated C#:**\n```csharp\npublic static IEnumerable<string> Stream()\n{\n    return AgeFacts\n        .Where(t => t.Item2 >= 18)  // Age >= 18\n        .Select(t => t.Item1);       // Return Person\n}\n```\n\n### Join Pattern (Grandparent)\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C#:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // P (child)\n        inner => inner.Item1,  // P (parent)\n        (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n    );\n```\n\n### Multiple Clauses \u2192 Union\n\n**Prolog:**\n```prolog\nsibling(alice, bob).  % Fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule\n```\n\n**Generated:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = /* computed siblings */;\nreturn clause1.Union(clause2);  // Combines both\n```", "answer_tailored": true}
{"pair_id": "stream-target-limitations_p0", "cluster_id": "stream-target-limitations", "question": "What are the limitations of the Stream Target?", "question_type": "medium", "answer": "The Stream Target has three main constraints:\n\n**1. No Recursive Rules**\nStream Target cannot handle predicates that call themselves. For example, this ancestor definition won't work:\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Self-reference not supported\n```\nFor recursive predicates, switch to the C# Query Runtime (covered in Chapter 3).\n\n**2. No Duplicate Variables in Head**\nYou cannot use the same variable multiple times in a predicate head:\n```prolog\nduplicate(X, X) :- number(X).  % Error: X used twice in head\n```\nInstead, move the equality check into the body using explicit unification.\n\n**3. Restricted Built-in Predicates**\nOnly basic operations are available: `=`, `\\=`, `<`, `>`, `=<`, `>=`, and `is`. Advanced features like `findall`, `bagof`, `setof`, and complex arithmetic are not supported.\n\n**When These Limitations Matter:**\nSwitch to Query Runtime if you need:\n- Recursive predicates (ancestor chains, graph traversal)\n- Mutual recursion (like is_even/is_odd)\n- Semi-naive evaluation for optimization\n- Complex query processing\n\n**Quick Decision Rule:**\n- Non-recursive predicate \u2192 Stream Target (simpler, faster)\n- Recursive predicate \u2192 Query Runtime (full capability)", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["limitations", "recursion", "stream-target"], "original_answer": "## Stream Target Limitations\n\n### 1. No Recursion\n\n**Does NOT work:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Recursive!\n```\n\n**Workaround:** Use C# Query Runtime (Chapter 3)\n\n### 2. No Repeated Head Variables\n\n**Does NOT work:**\n```prolog\nduplicate(X, X) :- number(X).  % X appears twice\n```\n\n**Workaround:** Add explicit equality in body\n\n### 3. Limited Built-ins\n\n**Supported:** `=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`\n\n**Not supported:** `findall`, `bagof`, `setof`, complex arithmetic\n\n### When to Use Query Runtime\n\n- Recursive predicates (ancestor, transitive closure)\n- Complex query optimization needed\n- Semi-naive evaluation required\n- Mutual recursion (is_even/is_odd)\n\n### Decision\n\n```\nIs predicate recursive?\n\u251c\u2500 NO  \u2192 Stream Target (simple, fast)\n\u2514\u2500 YES \u2192 Query Runtime (handles recursion)\n```", "answer_tailored": true}
{"pair_id": "stream-target-limitations_p1", "cluster_id": "stream-target-limitations", "question": "Why doesn't Stream Target support recursion?", "question_type": "medium", "answer": "Stream Target doesn't support recursion because it compiles Prolog predicates directly to C# code that yields results through IEnumerable streams. This direct compilation approach can't handle recursive calls without risking infinite loops or stack overflow.\n\nFor example, this recursive ancestor predicate won't work in Stream Target:\n\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Recursive call\n```\n\n**Why the limitation exists:**\n- Stream Target generates straightforward C# iterator methods\n- No query evaluation engine or fixpoint computation\n- Can't detect or manage recursive cycles\n\n**Solution:**\nSwitch to C# Query Runtime (covered in education/book-03-csharp-target/03_csharp_query_runtime.md), which implements semi-naive evaluation to handle recursive predicates safely. Query Runtime builds an in-memory database and iteratively computes fixpoints until no new facts are derived.\n\n**Quick decision guide:**\n- **Non-recursive predicates** \u2192 Use Stream Target (simpler, faster)\n- **Recursive predicates** \u2192 Use Query Runtime (handles transitive closure, mutual recursion, etc.)\n\nOther Stream Target limitations include no repeated head variables (e.g., `duplicate(X, X)`) and limited built-in support (only basic comparison and arithmetic operators).", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["limitations", "recursion", "stream-target"], "original_answer": "## Stream Target Limitations\n\n### 1. No Recursion\n\n**Does NOT work:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Recursive!\n```\n\n**Workaround:** Use C# Query Runtime (Chapter 3)\n\n### 2. No Repeated Head Variables\n\n**Does NOT work:**\n```prolog\nduplicate(X, X) :- number(X).  % X appears twice\n```\n\n**Workaround:** Add explicit equality in body\n\n### 3. Limited Built-ins\n\n**Supported:** `=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`\n\n**Not supported:** `findall`, `bagof`, `setof`, complex arithmetic\n\n### When to Use Query Runtime\n\n- Recursive predicates (ancestor, transitive closure)\n- Complex query optimization needed\n- Semi-naive evaluation required\n- Mutual recursion (is_even/is_odd)\n\n### Decision\n\n```\nIs predicate recursive?\n\u251c\u2500 NO  \u2192 Stream Target (simple, fast)\n\u2514\u2500 YES \u2192 Query Runtime (handles recursion)\n```", "answer_tailored": true}
{"pair_id": "stream-target-limitations_p2", "cluster_id": "stream-target-limitations", "question": "What built-ins are supported in Stream Target?", "question_type": "medium", "answer": "## Supported Built-ins in Stream Target\n\nThe C# Stream Target supports a limited set of built-in predicates:\n\n**Supported:**\n- `=` (unification)\n- `\\=` (not unifiable)\n- `<`, `>`, `=<`, `>=` (comparison operators)\n- `is` (arithmetic evaluation)\n\n**Not Supported:**\n- `findall`, `bagof`, `setof` (collection predicates)\n- Complex arithmetic operations\n- Meta-predicates requiring advanced evaluation\n\nFor more complex built-in operations, you'll need to use the C# Query Runtime instead (covered in Chapter 3 of education/book-03-csharp-target/).\n\nThe Stream Target is designed for simple, non-recursive predicates with basic comparisons and arithmetic. If you need advanced built-ins or collection operations, switch to the Query Runtime compilation mode.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["limitations", "recursion", "stream-target"], "original_answer": "## Stream Target Limitations\n\n### 1. No Recursion\n\n**Does NOT work:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Recursive!\n```\n\n**Workaround:** Use C# Query Runtime (Chapter 3)\n\n### 2. No Repeated Head Variables\n\n**Does NOT work:**\n```prolog\nduplicate(X, X) :- number(X).  % X appears twice\n```\n\n**Workaround:** Add explicit equality in body\n\n### 3. Limited Built-ins\n\n**Supported:** `=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`\n\n**Not supported:** `findall`, `bagof`, `setof`, complex arithmetic\n\n### When to Use Query Runtime\n\n- Recursive predicates (ancestor, transitive closure)\n- Complex query optimization needed\n- Semi-naive evaluation required\n- Mutual recursion (is_even/is_odd)\n\n### Decision\n\n```\nIs predicate recursive?\n\u251c\u2500 NO  \u2192 Stream Target (simple, fast)\n\u2514\u2500 YES \u2192 Query Runtime (handles recursion)\n```", "answer_tailored": true}
{"pair_id": "stream-target-limitations_p3", "cluster_id": "stream-target-limitations", "question": "When should I use Query Runtime instead?", "question_type": "medium", "answer": "Use Query Runtime when you need:\n\n**Recursive predicates** - The Stream Target cannot handle recursion at all. Any predicate that calls itself (like `ancestor(X,Y) :- parent(X,Y), ancestor(Y,Z)`) requires Query Runtime with its semi-naive evaluation engine.\n\n**Mutual recursion** - Predicates that call each other cyclically (e.g., `is_even` calling `is_odd` and vice versa) need Query Runtime's incremental computation model.\n\n**Complex query optimization** - When you need sophisticated join reordering, predicate pushdown, or other optimizations beyond simple streaming evaluation.\n\n**Advanced built-ins** - Operations like `findall`, `bagof`, `setof`, or complex constraint solving that Stream Target doesn't support.\n\n**Quick decision rule:**\n- Does your predicate call itself or participate in a call cycle? \u2192 Query Runtime\n- Is it a simple forward-chaining rule with no recursion? \u2192 Stream Target\n\nFor details on implementing with Query Runtime, see education/book-03-csharp-target/03_csharp_query_runtime.md. The Stream Target works well for non-recursive rules like basic fact transformations and simple filtering operations.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["limitations", "recursion", "stream-target"], "original_answer": "## Stream Target Limitations\n\n### 1. No Recursion\n\n**Does NOT work:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Recursive!\n```\n\n**Workaround:** Use C# Query Runtime (Chapter 3)\n\n### 2. No Repeated Head Variables\n\n**Does NOT work:**\n```prolog\nduplicate(X, X) :- number(X).  % X appears twice\n```\n\n**Workaround:** Add explicit equality in body\n\n### 3. Limited Built-ins\n\n**Supported:** `=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`\n\n**Not supported:** `findall`, `bagof`, `setof`, complex arithmetic\n\n### When to Use Query Runtime\n\n- Recursive predicates (ancestor, transitive closure)\n- Complex query optimization needed\n- Semi-naive evaluation required\n- Mutual recursion (is_even/is_odd)\n\n### Decision\n\n```\nIs predicate recursive?\n\u251c\u2500 NO  \u2192 Stream Target (simple, fast)\n\u2514\u2500 YES \u2192 Query Runtime (handles recursion)\n```", "answer_tailored": true}
