{"pair_id": "runtime-architecture_p0", "cluster_id": "runtime-architecture", "question": "What is the C# runtime architecture?", "question_type": "medium", "answer": "The C# runtime uses a layered architecture where your application references UnifyWeaver.Runtime.dll, which provides a shared query engine. This engine executes QueryPlan IR structures (generated from your Prolog source) that operate on data including both base facts and computed results.\n\nThe core runtime library consists of:\n- **QueryEngine.cs** - Implements the fixpoint iteration engine\n- **IR.cs** - Defines IR data structures like RelationRef and Join nodes\n- **SemiNaiveEvaluator.cs** - Provides semi-naive optimization logic\n- **TupleStore.cs** - Manages in-memory tuple storage\n\nYour compiled code generates query plans as IR instances, base fact data, and entry point Main methods.\n\nFor mutual recursion support (v0.1), the runtime includes MutualFixpointNode for coordinating strongly connected components, MutualMember structures pairing predicates with plans, CrossRefNode for referencing peer predicates, EvaluationContext for tracking totals and deltas, and HashSet<object[]> for tuple deduplication matching Bash target behavior.\n\nFor implementation details, see education/book-03-csharp-target/04_runtime_libraries_deployment.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["runtime", "architecture", "deployment"], "original_answer": "## Runtime Architecture\n\n```\nYour Application\n    \u2193 uses\nUnifyWeaver.Runtime.dll  \u2190 Shared query engine\n    \u2193 executes\nQueryPlan (IR)  \u2190 Generated from Prolog\n    \u2193 operates on\nData (facts, computed results)\n```\n\n### Core Runtime Library\n\n- **`QueryEngine.cs`**: Fixpoint iteration engine\n- **`IR.cs`**: IR data structures (RelationRef, Join, etc.)\n- **`SemiNaiveEvaluator.cs`**: Optimization logic\n- **`TupleStore.cs`**: In-memory tuple storage\n\n### Generated Code\n\n- Query plans (IR instances)\n- Base fact data\n- Entry points (Main methods)\n\n### Mutual Fixpoint Artifacts (v0.1)\n\n- `MutualFixpointNode` - Coordinator for SCCs\n- `MutualMember` - Pairs predicate with plans\n- `CrossRefNode` - Reference to peer predicate\n- `EvaluationContext` - Tracks totals/deltas\n- `HashSet<object[]>` - Bash-parity deduplication", "answer_tailored": true}
{"pair_id": "runtime-architecture_p1", "cluster_id": "runtime-architecture", "question": "What components make up the Query Runtime?", "question_type": "medium", "answer": "The Query Runtime consists of several key components working together:\n\n**Shared Runtime Library (UnifyWeaver.Runtime.dll)**\n- `QueryEngine.cs` - Core fixpoint iteration engine that drives query evaluation\n- `SemiNaiveEvaluator.cs` - Implements optimization strategies for efficient evaluation\n- `TupleStore.cs` - Manages in-memory storage for tuples/facts\n- `IR.cs` - Defines intermediate representation structures (RelationRef, Join nodes, etc.)\n\n**Generated Artifacts**\n- Query plan instances (instantiated IR nodes from compiled Prolog)\n- Base fact data structures\n- Entry point methods (Main functions)\n\n**Mutual Fixpoint Support (v0.1)**\n- `MutualFixpointNode` - Coordinates evaluation across strongly connected components (SCCs)\n- `MutualMember` - Associates predicates with their execution plans\n- `CrossRefNode` - Enables references between mutually recursive predicates\n- `EvaluationContext` - Maintains total and delta relation states during evaluation\n- `HashSet<object[]>` - Provides deduplication to match Bash target semantics\n\nThe runtime follows this flow: Your application uses UnifyWeaver.Runtime.dll, which executes the generated QueryPlan (IR), operating on your data (facts and computed results).\n\nFor implementation details, see education/book-03-csharp-target/04_runtime_libraries_deployment.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["runtime", "architecture", "deployment"], "original_answer": "## Runtime Architecture\n\n```\nYour Application\n    \u2193 uses\nUnifyWeaver.Runtime.dll  \u2190 Shared query engine\n    \u2193 executes\nQueryPlan (IR)  \u2190 Generated from Prolog\n    \u2193 operates on\nData (facts, computed results)\n```\n\n### Core Runtime Library\n\n- **`QueryEngine.cs`**: Fixpoint iteration engine\n- **`IR.cs`**: IR data structures (RelationRef, Join, etc.)\n- **`SemiNaiveEvaluator.cs`**: Optimization logic\n- **`TupleStore.cs`**: In-memory tuple storage\n\n### Generated Code\n\n- Query plans (IR instances)\n- Base fact data\n- Entry points (Main methods)\n\n### Mutual Fixpoint Artifacts (v0.1)\n\n- `MutualFixpointNode` - Coordinator for SCCs\n- `MutualMember` - Pairs predicate with plans\n- `CrossRefNode` - Reference to peer predicate\n- `EvaluationContext` - Tracks totals/deltas\n- `HashSet<object[]>` - Bash-parity deduplication", "answer_tailored": true}
{"pair_id": "runtime-architecture_p2", "cluster_id": "runtime-architecture", "question": "How are generated code and runtime related?", "question_type": "medium", "answer": "The generated code and runtime work together in a layered architecture. Generated code produces IR instances (query plans), base facts, and entry points, while the runtime library (`UnifyWeaver.Runtime.dll`) provides the shared query engine that executes those plans. Specifically, the runtime includes `QueryEngine.cs` for fixpoint iteration, `IR.cs` for data structures like `RelationRef` and `Join`, `SemiNaiveEvaluator.cs` for optimization, and `TupleStore.cs` for in-memory storage. Your application uses the runtime to execute the QueryPlan IR generated from Prolog, which operates on fact data and computed results. For mutual fixpoint support (v0.1), the runtime provides `MutualFixpointNode` to coordinate strongly connected components, `MutualMember` for predicate-plan pairs, `CrossRefNode` for peer references, `EvaluationContext` for tracking totals/deltas, and `HashSet<object[]>` for deduplication matching Bash behavior. See education/book-03-csharp-target/04_runtime_libraries_deployment.md for complete details.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["runtime", "architecture", "deployment"], "original_answer": "## Runtime Architecture\n\n```\nYour Application\n    \u2193 uses\nUnifyWeaver.Runtime.dll  \u2190 Shared query engine\n    \u2193 executes\nQueryPlan (IR)  \u2190 Generated from Prolog\n    \u2193 operates on\nData (facts, computed results)\n```\n\n### Core Runtime Library\n\n- **`QueryEngine.cs`**: Fixpoint iteration engine\n- **`IR.cs`**: IR data structures (RelationRef, Join, etc.)\n- **`SemiNaiveEvaluator.cs`**: Optimization logic\n- **`TupleStore.cs`**: In-memory tuple storage\n\n### Generated Code\n\n- Query plans (IR instances)\n- Base fact data\n- Entry points (Main methods)\n\n### Mutual Fixpoint Artifacts (v0.1)\n\n- `MutualFixpointNode` - Coordinator for SCCs\n- `MutualMember` - Pairs predicate with plans\n- `CrossRefNode` - Reference to peer predicate\n- `EvaluationContext` - Tracks totals/deltas\n- `HashSet<object[]>` - Bash-parity deduplication", "answer_tailored": true}
{"pair_id": "runtime-architecture_p3", "cluster_id": "runtime-architecture", "question": "What is the QueryEngine?", "question_type": "medium", "answer": "The QueryEngine is the core fixpoint iteration engine in UnifyWeaver's C# runtime, implemented in `QueryEngine.cs`. It executes query plans (represented as IR - intermediate representation) that were generated from your Prolog source code.\n\nThe QueryEngine works with several supporting components:\n- **IR.cs** provides the data structures (RelationRef, Join, etc.) that define query plans\n- **SemiNaiveEvaluator.cs** implements optimization logic for efficient iteration\n- **TupleStore.cs** handles in-memory storage of tuples during execution\n\nFor mutual recursion scenarios (v0.1), the QueryEngine coordinates with:\n- `MutualFixpointNode` to manage strongly connected components (SCCs)\n- `EvaluationContext` to track total and delta tuples across iterations\n- `HashSet<object[]>` for deduplication (matching Bash target behavior)\n\nThe engine is packaged in `UnifyWeaver.Runtime.dll`, which your generated C# code references to execute queries against facts and produce results. See education/book-03-csharp-target/04_runtime_libraries_deployment.md for the complete runtime architecture.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["runtime", "architecture", "deployment"], "original_answer": "## Runtime Architecture\n\n```\nYour Application\n    \u2193 uses\nUnifyWeaver.Runtime.dll  \u2190 Shared query engine\n    \u2193 executes\nQueryPlan (IR)  \u2190 Generated from Prolog\n    \u2193 operates on\nData (facts, computed results)\n```\n\n### Core Runtime Library\n\n- **`QueryEngine.cs`**: Fixpoint iteration engine\n- **`IR.cs`**: IR data structures (RelationRef, Join, etc.)\n- **`SemiNaiveEvaluator.cs`**: Optimization logic\n- **`TupleStore.cs`**: In-memory tuple storage\n\n### Generated Code\n\n- Query plans (IR instances)\n- Base fact data\n- Entry points (Main methods)\n\n### Mutual Fixpoint Artifacts (v0.1)\n\n- `MutualFixpointNode` - Coordinator for SCCs\n- `MutualMember` - Pairs predicate with plans\n- `CrossRefNode` - Reference to peer predicate\n- `EvaluationContext` - Tracks totals/deltas\n- `HashSet<object[]>` - Bash-parity deduplication", "answer_tailored": true}
{"pair_id": "dotnet-deployment_p0", "cluster_id": "dotnet-deployment", "question": "How do I deploy C# generated code?", "question_type": "medium", "answer": "To deploy C# code generated by UnifyWeaver, use `dotnet publish` with options based on your deployment needs:\n\n**Self-Contained Deployment (recommended for distribution):**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# Creates ~60MB executable with bundled .NET runtime\n# Output: bin/Release/net6.0/linux-x64/publish/\n```\n\n**Framework-Dependent Deployment (smaller size):**\n```bash\ndotnet publish -c Release\n# Creates ~200KB output, requires .NET runtime on target system\n```\n\n**Single-File Executable:**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained -p:PublishSingleFile=true\n# Bundles everything into one executable\n```\n\n**Cross-Platform Targets:**\n- Windows: `dotnet publish -r win-x64 --self-contained`\n- Linux: `dotnet publish -r linux-x64 --self-contained`\n- macOS: `dotnet publish -r osx-x64 --self-contained`\n\n**As NuGet Package (for libraries):**\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Outputs: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```\n\nFor detailed runtime library information, see education/book-03-csharp-target/04_runtime_libraries_deployment.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["deployment", "publish", "cross-platform", "nuget"], "original_answer": "## Deployment Scenarios\n\n### Console Application\n\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# Output: bin/Release/net6.0/linux-x64/publish/\n```\n\n### Cross-Platform Publishing\n\n**Windows:**\n```bash\ndotnet publish -r win-x64 --self-contained\n```\n\n**Linux:**\n```bash\ndotnet publish -r linux-x64 --self-contained\n```\n\n**macOS:**\n```bash\ndotnet publish -r osx-x64 --self-contained\n```\n\n### Deployment Types\n\n**Framework-Dependent (smaller):**\n```bash\ndotnet publish -c Release\n# ~200KB, requires .NET runtime on target\n```\n\n**Self-Contained (no dependencies):**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# ~60MB, includes .NET runtime\n```\n\n**Single-File:**\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\n### NuGet Package\n\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Generates: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```", "answer_tailored": true}
{"pair_id": "dotnet-deployment_p1", "cluster_id": "dotnet-deployment", "question": "How do I create a NuGet package?", "question_type": "medium", "answer": "To create a NuGet package for UnifyWeaver components, use these steps:\n\n```bash\n# Create a class library project\ndotnet new classlib -n UnifyWeaver.Runtime\n\n# Build and package\ndotnet pack -c Release\n```\n\nThis generates a `.nupkg` file at `bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg`.\n\n**Package Configuration:**\n\nAdd metadata to your `.csproj` file:\n\n```xml\n<PropertyGroup>\n  <PackageId>UnifyWeaver.Runtime</PackageId>\n  <Version>1.0.0</Version>\n  <Authors>Your Name</Authors>\n  <Description>Runtime library for UnifyWeaver</Description>\n</PropertyGroup>\n```\n\n**Publishing Options:**\n\nLocal feed:\n```bash\ndotnet nuget push bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg -s ~/local-packages\n```\n\nNuGet.org:\n```bash\ndotnet nuget push bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg -k YOUR_API_KEY -s https://api.nuget.org/v3/index.json\n```\n\nFor more details on C# deployment scenarios, see education/book-03-csharp-target/04_runtime_libraries_deployment.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["deployment", "publish", "cross-platform", "nuget"], "original_answer": "## Deployment Scenarios\n\n### Console Application\n\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# Output: bin/Release/net6.0/linux-x64/publish/\n```\n\n### Cross-Platform Publishing\n\n**Windows:**\n```bash\ndotnet publish -r win-x64 --self-contained\n```\n\n**Linux:**\n```bash\ndotnet publish -r linux-x64 --self-contained\n```\n\n**macOS:**\n```bash\ndotnet publish -r osx-x64 --self-contained\n```\n\n### Deployment Types\n\n**Framework-Dependent (smaller):**\n```bash\ndotnet publish -c Release\n# ~200KB, requires .NET runtime on target\n```\n\n**Self-Contained (no dependencies):**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# ~60MB, includes .NET runtime\n```\n\n**Single-File:**\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\n### NuGet Package\n\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Generates: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```", "answer_tailored": true}
{"pair_id": "dotnet-deployment_p2", "cluster_id": "dotnet-deployment", "question": "What are the deployment options?", "question_type": "medium", "answer": "UnifyWeaver's C# target supports multiple deployment options depending on your needs:\n\n**Framework-Dependent Deployment** - Creates a lightweight package (~200KB) that requires .NET runtime to be installed on the target system:\n```bash\ndotnet publish -c Release\n```\n\n**Self-Contained Deployment** - Bundles the .NET runtime with your application (~60MB) so no dependencies are needed on the target:\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n```\n\n**Single-File Deployment** - Packages everything into one executable for easier distribution:\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\n**Cross-Platform Publishing** - Target different operating systems by specifying the runtime identifier:\n- Windows: `dotnet publish -r win-x64 --self-contained`\n- Linux: `dotnet publish -r linux-x64 --self-contained`\n- macOS: `dotnet publish -r osx-x64 --self-contained`\n\n**NuGet Package** - For distributing UnifyWeaver runtime libraries:\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Creates: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```\n\nFor detailed runtime library information, see education/book-03-csharp-target/04_runtime_libraries_deployment.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["deployment", "publish", "cross-platform", "nuget"], "original_answer": "## Deployment Scenarios\n\n### Console Application\n\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# Output: bin/Release/net6.0/linux-x64/publish/\n```\n\n### Cross-Platform Publishing\n\n**Windows:**\n```bash\ndotnet publish -r win-x64 --self-contained\n```\n\n**Linux:**\n```bash\ndotnet publish -r linux-x64 --self-contained\n```\n\n**macOS:**\n```bash\ndotnet publish -r osx-x64 --self-contained\n```\n\n### Deployment Types\n\n**Framework-Dependent (smaller):**\n```bash\ndotnet publish -c Release\n# ~200KB, requires .NET runtime on target\n```\n\n**Self-Contained (no dependencies):**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# ~60MB, includes .NET runtime\n```\n\n**Single-File:**\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\n### NuGet Package\n\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Generates: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```", "answer_tailored": true}
{"pair_id": "dotnet-deployment_p3", "cluster_id": "dotnet-deployment", "question": "How do I publish for different platforms?", "question_type": "medium", "answer": "To publish your UnifyWeaver C# compilation output for different platforms, use the `dotnet publish` command with runtime identifiers:\n\n**Windows:**\n```bash\ndotnet publish -r win-x64 --self-contained\n```\n\n**Linux:**\n```bash\ndotnet publish -r linux-x64 --self-contained\n```\n\n**macOS:**\n```bash\ndotnet publish -r osx-x64 --self-contained\n```\n\nThe `--self-contained` flag bundles the .NET runtime (~60MB) so the target machine doesn't need .NET installed. For smaller deployments (~200KB), omit this flag to create a framework-dependent build, though this requires .NET runtime on the target system.\n\nYou can also create a single executable file:\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\nPublished binaries are output to `bin/Release/net6.0/{runtime-id}/publish/`. For complete deployment options and NuGet packaging, see education/book-03-csharp-target/04_runtime_libraries_deployment.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["deployment", "publish", "cross-platform", "nuget"], "original_answer": "## Deployment Scenarios\n\n### Console Application\n\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# Output: bin/Release/net6.0/linux-x64/publish/\n```\n\n### Cross-Platform Publishing\n\n**Windows:**\n```bash\ndotnet publish -r win-x64 --self-contained\n```\n\n**Linux:**\n```bash\ndotnet publish -r linux-x64 --self-contained\n```\n\n**macOS:**\n```bash\ndotnet publish -r osx-x64 --self-contained\n```\n\n### Deployment Types\n\n**Framework-Dependent (smaller):**\n```bash\ndotnet publish -c Release\n# ~200KB, requires .NET runtime on target\n```\n\n**Self-Contained (no dependencies):**\n```bash\ndotnet publish -c Release -r linux-x64 --self-contained\n# ~60MB, includes .NET runtime\n```\n\n**Single-File:**\n```bash\ndotnet publish -c Release -r linux-x64 \\\n    --self-contained \\\n    -p:PublishSingleFile=true\n```\n\n### NuGet Package\n\n```bash\ndotnet new classlib -n UnifyWeaver.Runtime\ndotnet pack -c Release\n# Generates: bin/Release/UnifyWeaver.Runtime.1.0.0.nupkg\n```", "answer_tailored": true}
{"pair_id": "csharp-testing_p0", "cluster_id": "csharp-testing", "question": "How do I test C# Query Runtime?", "question_type": "medium", "answer": "The C# Query Runtime can be tested in several ways:\n\n**Skip Execution Mode** - Validate query compilation without running dotnet by setting `SKIP_CSHARP_EXECUTION=1` when running the test suite:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nThis validates facts, joins, selections, arithmetic operations, and both linear and mutual recursion patterns.\n\n**Build-First Workflow** - The standard testing approach:\n1. Generate a C# project under `output/csharp/<uuid>/`\n2. Build with `dotnet build --no-restore`\n3. Run the compiled binary\n4. Check output matches expectations (e.g., `0, 2, 4` for even number queries)\n\n**Unit Tests with xUnit** - Write traditional C# unit tests for your queries:\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n**CI Integration** - Automate testing in GitHub Actions:\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```\n\nFor comprehensive testing examples, see education/book-03-csharp-target/04_runtime_libraries_deployment.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["testing", "skip-execution", "validation", "ci-cd"], "original_answer": "## Testing the Query Runtime\n\n### Skip Execution Mode\n\nValidate without running dotnet:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nCovers: facts, joins, selections, arithmetic, linear/mutual recursion.\n\n### Build-First Workflow\n\n1. Generate project under `output/csharp/<uuid>/`\n2. Run `dotnet build --no-restore`\n3. Execute the compiled binary\n4. Verify output (e.g., `0, 2, 4` for even/odd)\n\n### Unit Tests (xUnit)\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n### GitHub Actions CI\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```", "answer_tailored": true}
{"pair_id": "csharp-testing_p1", "cluster_id": "csharp-testing", "question": "What is SKIP_CSHARP_EXECUTION?", "question_type": "medium", "answer": "`SKIP_CSHARP_EXECUTION` is an environment variable that enables validation mode for C# query compilation without actually running the dotnet toolchain. When set to `1`, the test suite will generate C# code from Prolog but skip the build and execution steps:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nThis is useful for quickly verifying that the code generation phase works correctly across various query patterns\u2014including facts, joins, selections, arithmetic operations, and both linear and mutual recursion\u2014without waiting for the .NET compiler. For full end-to-end testing including compilation and execution, omit this flag and follow the standard build-first workflow described in education/book-03-csharp-target/04_runtime_libraries_deployment.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["testing", "skip-execution", "validation", "ci-cd"], "original_answer": "## Testing the Query Runtime\n\n### Skip Execution Mode\n\nValidate without running dotnet:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nCovers: facts, joins, selections, arithmetic, linear/mutual recursion.\n\n### Build-First Workflow\n\n1. Generate project under `output/csharp/<uuid>/`\n2. Run `dotnet build --no-restore`\n3. Execute the compiled binary\n4. Verify output (e.g., `0, 2, 4` for even/odd)\n\n### Unit Tests (xUnit)\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n### GitHub Actions CI\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```", "answer_tailored": true}
{"pair_id": "csharp-testing_p2", "cluster_id": "csharp-testing", "question": "How do I validate generated code without running it?", "question_type": "medium", "answer": "UnifyWeaver provides several validation approaches without executing generated code:\n\n**Skip Execution Mode** - Set `SKIP_CSHARP_EXECUTION=1` to validate code generation and compilation structure without running the dotnet runtime:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nThis tests facts, joins, selections, arithmetic, and recursion patterns by verifying the generated C# code structure.\n\n**Build-Only Validation** - Generate the project under `output/csharp/<uuid>/` and run `dotnet build --no-restore` to catch compilation errors, type mismatches, and syntax issues without executing the binary.\n\n**Static Analysis** - Review the generated C# source files directly. UnifyWeaver produces readable code that follows standard C# conventions, making manual inspection straightforward.\n\n**Unit Test Frameworks** - Write xUnit tests against the generated code's public API:\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n}\n```\n\n**CI Pipeline Validation** - GitHub Actions can generate and build code on every commit without execution:\n\n```yaml\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n- name: Build\n  run: dotnet build\n```\n\nSee education/book-03-csharp-target/04_runtime_libraries_deployment.md for complete testing workflows.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["testing", "skip-execution", "validation", "ci-cd"], "original_answer": "## Testing the Query Runtime\n\n### Skip Execution Mode\n\nValidate without running dotnet:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nCovers: facts, joins, selections, arithmetic, linear/mutual recursion.\n\n### Build-First Workflow\n\n1. Generate project under `output/csharp/<uuid>/`\n2. Run `dotnet build --no-restore`\n3. Execute the compiled binary\n4. Verify output (e.g., `0, 2, 4` for even/odd)\n\n### Unit Tests (xUnit)\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n### GitHub Actions CI\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```", "answer_tailored": true}
{"pair_id": "csharp-testing_p3", "cluster_id": "csharp-testing", "question": "How do I set up CI/CD for UnifyWeaver?", "question_type": "medium", "answer": "## CI/CD Setup for UnifyWeaver\n\n### GitHub Actions Workflow\n\nCreate `.github/workflows/csharp-target.yml`:\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```\n\n### Pipeline Stages\n\n1. **Code Generation**: Use SWI-Prolog to compile queries to target languages (C#, Python, Go, etc.)\n2. **Build**: Run `dotnet build --no-restore` for generated projects under `output/csharp/<uuid>/`\n3. **Test**: Execute unit tests (xUnit for C#) and validate output\n4. **Validation**: Use skip-execution mode to verify generation without runtime: `SKIP_CSHARP_EXECUTION=1 swipl -q -f tests/core/test_csharp_query_target.pl`\n\n### Testing Strategy\n\n- **Unit Tests**: Cover facts, joins, selections, arithmetic, and recursion patterns\n- **Integration Tests**: Verify end-to-end compilation and execution\n- **Output Validation**: Check query results match expected values (e.g., `0, 2, 4` for filtering predicates)\n\nSee `education/book-03-csharp-target/04_runtime_libraries_deployment.md` for deployment details and `tests/core/` for test examples.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/04_runtime_libraries_deployment.md", "topics": ["testing", "skip-execution", "validation", "ci-cd"], "original_answer": "## Testing the Query Runtime\n\n### Skip Execution Mode\n\nValidate without running dotnet:\n\n```bash\nSKIP_CSHARP_EXECUTION=1 swipl -q \\\n    -f tests/core/test_csharp_query_target.pl \\\n    -g test_csharp_query_target:test_csharp_query_target \\\n    -t halt\n```\n\nCovers: facts, joins, selections, arithmetic, linear/mutual recursion.\n\n### Build-First Workflow\n\n1. Generate project under `output/csharp/<uuid>/`\n2. Run `dotnet build --no-restore`\n3. Execute the compiled binary\n4. Verify output (e.g., `0, 2, 4` for even/odd)\n\n### Unit Tests (xUnit)\n\n```csharp\n[Fact]\npublic void Execute_ShouldReturnAllAncestors()\n{\n    var ancestors = AncestorQuery.Execute().ToList();\n    Assert.Contains((\"alice\", \"bob\"), ancestors);\n    Assert.Contains((\"alice\", \"dave\"), ancestors);\n}\n```\n\n### GitHub Actions CI\n\n```yaml\nsteps:\n- name: Setup .NET\n  uses: actions/setup-dotnet@v1\n  with:\n    dotnet-version: 6.0.x\n\n- name: Generate C# from Prolog\n  run: swipl -g \"compile_all, halt\"\n\n- name: Build and Test\n  run: |\n    dotnet build\n    dotnet test\n```", "answer_tailored": true}
