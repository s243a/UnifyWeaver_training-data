{"pair_id": "b7-c7-dotnet-bridges_p0", "cluster_id": "b7-c7-dotnet-bridges", "question": "How do I create .NET bridges?", "question_type": "medium", "answer": "To create .NET bridges in UnifyWeaver, you use dedicated Prolog predicates to generate C# code that hosts other runtimes in-process. This approach is highly efficient as it allows for direct object passing between languages, completely avoiding serialization overhead.\n\nYou can generate these bridges using the following predicates:\n\n```prolog\n% Generate C# code to host PowerShell in-process\ngenerate_powershell_bridge(Options, CSharpCode).\n\n% Generate C# code to host IronPython in-process\ngenerate_ironpython_bridge(Options, CSharpCode).\n```\n\nThe resulting C# bridge leverages native hosting capabilities to execute scripts and retrieve typed results directly:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>(); // Direct object passing!\n```\n\nThe UnifyWeaver runtime automatically detects the environment, managing differences between PowerShell Core and Windows PowerShell, and handling IronPython availability with CPython fallbacks where necessary. For more details on implementing these integrations, refer to `education/book-07-cross-target-glue/07_dotnet_bridges.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/07_dotnet_bridges.md", "topics": ["dotnet-bridge", "powershell-hosting", "ironpython"], "original_answer": "## .NET Bridge Generation\n\n### In-Process Benefits\n\nFor .NET family, avoid serialization entirely:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\n### Bridge Generation\n\n```prolog\n% C# hosting PowerShell in-process\ngenerate_powershell_bridge(Options, CSharpCode).\n\n% C# hosting IronPython in-process\ngenerate_ironpython_bridge(Options, CSharpCode).\n```\n\n### Runtime Detection\n\nThe system automatically detects:\n- PowerShell Core vs Windows PowerShell\n- IronPython availability\n- CPython fallback", "answer_tailored": true}
{"pair_id": "b7-c7-dotnet-bridges_p1", "cluster_id": "b7-c7-dotnet-bridges", "question": "How does PowerShell in-process hosting work?", "question_type": "medium", "answer": "PowerShell in-process hosting works by leveraging the .NET `PowerShell` SDK to execute scripts within the host application's memory space, which eliminates the need for expensive data serialization. By using the `PowerShell.Create()` method, the system enables direct object passing between the C# host and the PowerShell environment:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>(); // Direct object interaction\n```\n\nUnifyWeaver automates this process through the `generate_powershell_bridge(Options, CSharpCode)` Prolog predicate, which produces the necessary C# hosting logic. During execution, the system automatically detects the environment to choose between PowerShell Core or Windows PowerShell, ensuring the bridge operates correctly across different platforms.\n\nFor more comprehensive details on .NET bridge generation and in-process benefits, see `education/book-07-cross-target-glue/07_dotnet_bridges.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/07_dotnet_bridges.md", "topics": ["dotnet-bridge", "powershell-hosting", "ironpython"], "original_answer": "## .NET Bridge Generation\n\n### In-Process Benefits\n\nFor .NET family, avoid serialization entirely:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\n### Bridge Generation\n\n```prolog\n% C# hosting PowerShell in-process\ngenerate_powershell_bridge(Options, CSharpCode).\n\n% C# hosting IronPython in-process\ngenerate_ironpython_bridge(Options, CSharpCode).\n```\n\n### Runtime Detection\n\nThe system automatically detects:\n- PowerShell Core vs Windows PowerShell\n- IronPython availability\n- CPython fallback", "answer_tailored": true}
{"pair_id": "b7-c7-dotnet-bridges_p2", "cluster_id": "b7-c7-dotnet-bridges", "question": "What is generate_powershell_bridge?", "question_type": "medium", "answer": "`generate_powershell_bridge` is a Prolog predicate within UnifyWeaver's cross-target glue system designed to generate C# code that hosts PowerShell in-process. This mechanism allows for direct object passing between C# and PowerShell environments, effectively bypassing the performance overhead of traditional serialization.\n\nKey features include:\n- **In-Process Integration**: Generates hosting code (e.g., utilizing `PowerShell.Create()`) so results can be invoked as direct types (`Invoke<OutputType>`).\n- **Prolog API**: The predicate is called as `generate_powershell_bridge(Options, CSharpCode)` to produce the bridging source.\n- **Runtime Adaptability**: The generated bridge supports automatic detection of PowerShell Core versus Windows PowerShell and can fallback to alternative runtimes if necessary.\n\nFor a comprehensive guide on implementing .NET bridges and cross-language interoperability, see `education/book-07-cross-target-glue/07_dotnet_bridges.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/07_dotnet_bridges.md", "topics": ["dotnet-bridge", "powershell-hosting", "ironpython"], "original_answer": "## .NET Bridge Generation\n\n### In-Process Benefits\n\nFor .NET family, avoid serialization entirely:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\n### Bridge Generation\n\n```prolog\n% C# hosting PowerShell in-process\ngenerate_powershell_bridge(Options, CSharpCode).\n\n% C# hosting IronPython in-process\ngenerate_ironpython_bridge(Options, CSharpCode).\n```\n\n### Runtime Detection\n\nThe system automatically detects:\n- PowerShell Core vs Windows PowerShell\n- IronPython availability\n- CPython fallback", "answer_tailored": true}
{"pair_id": "b7-c8-ironpython-compat_p0", "cluster_id": "b7-c8-ironpython-compat", "question": "What modules work with IronPython?", "question_type": "medium", "answer": "IronPython supports most of the Python standard library, including core modules like `json`, `xml`, and `re`, along with basic data structures. However, it is incompatible with any C extension modules such as `numpy`, `pandas`, `scipy`, `TensorFlow`, or `PyTorch`, which necessitate a full CPython environment.\n\nUnifyWeaver manages these compatibility constraints through its dependency detection system. By declaring specific requirements in Prolog, the compiler can automatically determine if it can run in-process via IronPython or if it must fallback to CPython using pipe-based transport:\n\n```prolog\n% UnifyWeaver detects libraries requiring CPython\n:- declare_target(ml_transform/2, python, [\n    requires([numpy, pandas])\n]).\n```\n\nWhen C extensions are detected, the system shifts from the default in-process execution to an external CPython process. Detailed compatibility matrices and migration strategies are available in `education/book-07-cross-target-glue/08_ironpython_compat.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/08_ironpython_compat.md", "topics": ["ironpython", "cpython", "compatibility"], "original_answer": "## IronPython Compatibility\n\n### Compatible Modules\n\n- Standard library (most of it)\n- json, xml, re\n- Basic data structures\n\n### Incompatible (Require CPython)\n\n- numpy, pandas, scipy\n- TensorFlow, PyTorch\n- Any C extension module\n\n### Automatic Selection\n\n```prolog\n% System detects numpy usage and uses CPython\n:- declare_target(ml_transform/2, python, [\n    requires([numpy, pandas])\n]).\n\n% Result: Falls back to CPython with pipe transport\n```\n\n### Migration Strategy\n\n1. Start with IronPython (in-process)\n2. Detect C extension usage\n3. Fallback to CPython (pipes)", "answer_tailored": true}
{"pair_id": "b7-c8-ironpython-compat_p1", "cluster_id": "b7-c8-ironpython-compat", "question": "When should I use CPython vs IronPython?", "question_type": "medium", "answer": "Use IronPython when you need high-performance, in-process execution within the .NET ecosystem, provided your code relies only on the Python standard library and basic data structures. You must switch to CPython when your project requires C extension modules or data science libraries like `numpy`, `pandas`, `scipy`, `TensorFlow`, or `PyTorch`.\n\n**IronPython Use Cases:**\n* Projects using standard modules like `json`, `xml`, or `re`.\n* Tasks involving native .NET interop and basic data manipulation.\n\n**CPython Use Cases:**\n* Any workload requiring C-based extensions.\n* Machine learning and heavy numerical analysis.\n\nIn UnifyWeaver, you can automate this selection using the `requires/1` constraint. For example, declaring `requires([numpy, pandas])` tells the system to fall back to CPython via pipe transport rather than attempting in-process IronPython execution. For a complete guide on managing these environments, see `education/book-07-cross-target-glue/08_ironpython_compat.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/08_ironpython_compat.md", "topics": ["ironpython", "cpython", "compatibility"], "original_answer": "## IronPython Compatibility\n\n### Compatible Modules\n\n- Standard library (most of it)\n- json, xml, re\n- Basic data structures\n\n### Incompatible (Require CPython)\n\n- numpy, pandas, scipy\n- TensorFlow, PyTorch\n- Any C extension module\n\n### Automatic Selection\n\n```prolog\n% System detects numpy usage and uses CPython\n:- declare_target(ml_transform/2, python, [\n    requires([numpy, pandas])\n]).\n\n% Result: Falls back to CPython with pipe transport\n```\n\n### Migration Strategy\n\n1. Start with IronPython (in-process)\n2. Detect C extension usage\n3. Fallback to CPython (pipes)", "answer_tailored": true}
{"pair_id": "b7-c8-ironpython-compat_p2", "cluster_id": "b7-c8-ironpython-compat", "question": "What is incompatible with IronPython?", "question_type": "medium", "answer": "IronPython is incompatible with any Python module that relies on native C extensions. Key examples of incompatible libraries include:\n\n- **Data Science & Math:** numpy, pandas, scipy\n- **AI/Machine Learning:** TensorFlow, PyTorch\n- **Native Extensions:** Any module that requires a C compiler for installation or execution\n\nUnifyWeaver manages these limitations by automatically selecting the appropriate runtime based on requirements. If a Prolog predicate specifies a dependency on these libraries, the compiler switches the target from in-process IronPython to external CPython using pipe-based transport:\n\n```prolog\n% UnifyWeaver detects C-extension requirements and selects CPython fallback\n:- declare_target(ml_transform/2, python, [\n    requires([numpy, pandas])\n]).\n```\n\nThis allows developers to leverage high-performance ML libraries while defaulting to IronPython for simpler, low-latency tasks. For a detailed breakdown of compatibility and migration strategies, see `education/book-07-cross-target-glue/08_ironpython_compat.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/08_ironpython_compat.md", "topics": ["ironpython", "cpython", "compatibility"], "original_answer": "## IronPython Compatibility\n\n### Compatible Modules\n\n- Standard library (most of it)\n- json, xml, re\n- Basic data structures\n\n### Incompatible (Require CPython)\n\n- numpy, pandas, scipy\n- TensorFlow, PyTorch\n- Any C extension module\n\n### Automatic Selection\n\n```prolog\n% System detects numpy usage and uses CPython\n:- declare_target(ml_transform/2, python, [\n    requires([numpy, pandas])\n]).\n\n% Result: Falls back to CPython with pipe transport\n```\n\n### Migration Strategy\n\n1. Start with IronPython (in-process)\n2. Detect C extension usage\n3. Fallback to CPython (pipes)", "answer_tailored": true}
