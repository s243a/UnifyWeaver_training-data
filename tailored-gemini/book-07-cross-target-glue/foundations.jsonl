{"pair_id": "b7-c1-cross-target-overview_p0", "cluster_id": "b7-c1-cross-target-overview", "question": "What is cross-target glue?", "question_type": "medium", "answer": "I will read the source file to gather additional context for the rewritten answer.\nCross-target glue is the UnifyWeaver system that allows predicates compiled into different target languages\u2014such as AWK, Python, Go, and SQL\u2014to communicate and function together seamlessly. It extends the Unix \"pipes and filters\" philosophy across language and machine boundaries, enabling you to combine the unique strengths of various targets into a single, unified pipeline.\n\nThe glue system treats location and transport as separate concerns, ensuring your Prolog logic remains location-agnostic:\n\n*   **Locations:** Define where logic runs, including `in_process` (same runtime), `local_process` (same machine via pipes), or `remote(Host)` (distributed over a network).\n*   **Transports:** Define how data moves, such as `direct` function calls for zero-serialization communication, `pipe` streams using TSV or JSON, and `http` for REST API interactions.\n*   **Runtime Families:** Optimized communication paths exist for targets within the same family (e.g., C# and PowerShell in the .NET family can pass objects directly).\n\nFor a comprehensive overview of how these components integrate, refer to `education/book-07-cross-target-glue/01_introduction.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["cross-target-glue", "multi-language", "pipelines"], "original_answer": "## Cross-Target Glue Overview\n\nCross-target glue enables predicates compiled to different languages to communicate seamlessly.\n\n### The Unix Philosophy Extended\n\n```\nTraditional Unix:    grep | sort | uniq | wc\nCross-target glue:   awk_filter | python_transform | go_aggregate | sql_store\n```\n\n### Location and Transport Model\n\n| Location | Description |\n|----------|-------------|\n| `in_process` | Same runtime (C# calling PowerShell) |\n| `local_process` | Separate process, same machine (pipes) |\n| `remote(Host)` | Different machine (network) |\n\n| Transport | Use Case |\n|-----------|----------|\n| `direct` | Function call (in-process) |\n| `pipe` | Unix pipes with TSV/JSON |\n| `http` | REST API calls |", "answer_tailored": true}
{"pair_id": "b7-c1-cross-target-overview_p1", "cluster_id": "b7-c1-cross-target-overview", "question": "Why do I need multi-language pipelines?", "question_type": "medium", "answer": "Multi-language pipelines are essential when you need to leverage the unique strengths of different programming environments\u2014such as Python's AI libraries, Go's high-concurrency performance, or SQL's data persistence\u2014within a single, unified workflow. UnifyWeaver facilitates this by extending the classic Unix philosophy to a polyglot context, allowing you to chain predicates across different runtimes (e.g., `awk_filter | python_transform | go_aggregate | sql_store`).\n\nThis communication is managed through defined location and transport models:\n\n*   **Locations:** Determines where the code runs, including `in_process` (same runtime), `local_process` (separate processes on the same machine), or `remote(Host)` (across the network).\n*   **Transports:** Defines the communication method, such as `direct` function calls for in-process tasks, Unix `pipe` streams using TSV or JSON for local processes, and `http` for REST API interactions.\n\nFor more information on orchestrating these cross-language workflows, refer to `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["cross-target-glue", "multi-language", "pipelines"], "original_answer": "## Cross-Target Glue Overview\n\nCross-target glue enables predicates compiled to different languages to communicate seamlessly.\n\n### The Unix Philosophy Extended\n\n```\nTraditional Unix:    grep | sort | uniq | wc\nCross-target glue:   awk_filter | python_transform | go_aggregate | sql_store\n```\n\n### Location and Transport Model\n\n| Location | Description |\n|----------|-------------|\n| `in_process` | Same runtime (C# calling PowerShell) |\n| `local_process` | Separate process, same machine (pipes) |\n| `remote(Host)` | Different machine (network) |\n\n| Transport | Use Case |\n|-----------|----------|\n| `direct` | Function call (in-process) |\n| `pipe` | Unix pipes with TSV/JSON |\n| `http` | REST API calls |", "answer_tailored": true}
{"pair_id": "b7-c1-cross-target-overview_p2", "cluster_id": "b7-c1-cross-target-overview", "question": "How does UnifyWeaver connect different targets?", "question_type": "medium", "answer": "UnifyWeaver connects different targets through a \"Cross-Target Glue\" system that allows predicates compiled into various languages to communicate seamlessly. This architecture extends the Unix philosophy of piped commands into a multi-language pipeline (e.g., `awk_filter | python_transform | go_aggregate`).\n\nConnections are managed through a combined Location and Transport model:\n\n*   **local_process:** Connects separate processes on the same machine typically via Unix **pipes** using TSV or JSON formats.\n*   **in_process:** Operates within the same runtime (such as C# calling PowerShell) using **direct** function calls for maximum performance.\n*   **remote(Host):** Facilitates communication between different machines using the **http** transport for REST API interactions.\n\nFor a comprehensive guide on implementing these connections, see `education/book-07-cross-target-glue/01_introduction.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["cross-target-glue", "multi-language", "pipelines"], "original_answer": "## Cross-Target Glue Overview\n\nCross-target glue enables predicates compiled to different languages to communicate seamlessly.\n\n### The Unix Philosophy Extended\n\n```\nTraditional Unix:    grep | sort | uniq | wc\nCross-target glue:   awk_filter | python_transform | go_aggregate | sql_store\n```\n\n### Location and Transport Model\n\n| Location | Description |\n|----------|-------------|\n| `in_process` | Same runtime (C# calling PowerShell) |\n| `local_process` | Separate process, same machine (pipes) |\n| `remote(Host)` | Different machine (network) |\n\n| Transport | Use Case |\n|-----------|----------|\n| `direct` | Function call (in-process) |\n| `pipe` | Unix pipes with TSV/JSON |\n| `http` | REST API calls |", "answer_tailored": true}
{"pair_id": "b7-c1-runtime-families_p0", "cluster_id": "b7-c1-runtime-families", "question": "What are runtime families?", "question_type": "medium", "answer": "Runtime families are classifications of compilation targets that share a common execution environment, allowing for optimized interoperability. Targets within the same family can communicate more efficiently, often using in-process calls to avoid the overhead of data serialization.\n\n| Family | Targets | Communication Method |\n| :--- | :--- | :--- |\n| **.NET** | C#, PowerShell, IronPython | In-process (zero serialization) |\n| **JVM** | Java, Scala, Jython | In-process |\n| **Shell** | Bash, AWK, sed | Pipes |\n| **Native** | Go, Rust, C | Pipes or shared memory |\n| **Python** | CPython | Pipes |\n\n### .NET In-Process Interaction\nWhen targets share a family like .NET, they can exchange live objects directly:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\nThe core advantage is that a C# host calling a PowerShell script can pass data structures in-memory. In contrast, communication between different families\u2014such as AWK calling a Python script\u2014requires serializing data through pipes. For a comprehensive guide on how these targets interact, refer to `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["runtime-families", "in-process", "communication"], "original_answer": "## Runtime Families\n\nTargets in the same family can communicate more efficiently:\n\n| Family | Targets | Communication |\n|--------|---------|---------------|\n| .NET | C#, PowerShell, IronPython | In-process (zero serialization) |\n| JVM | Java, Scala, Jython | In-process |\n| Shell | Bash, AWK, sed | Pipes |\n| Native | Go, Rust, C | Pipes or shared memory |\n| Python | CPython | Pipes |\n\n### Example: .NET In-Process\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\n**Key insight**: C# calling PowerShell passes objects directly. AWK calling Python must serialize.", "answer_tailored": true}
{"pair_id": "b7-c1-runtime-families_p1", "cluster_id": "b7-c1-runtime-families", "question": "Which targets can communicate in-process?", "question_type": "medium", "answer": "Targets within the .NET and JVM families can communicate in-process, enabling direct object passing with zero serialization. Specifically:\n\n*   **.NET Family:** C#, PowerShell, and IronPython can exchange data without the overhead of serialization. For example, a C# host can use `PowerShell.Create()` to invoke scripts and receive results as typed objects directly.\n*   **JVM Family:** Java, Scala, and Jython targets also support efficient in-process interaction.\n\nOther families, such as Shell (Bash, AWK, sed) and Native (Go, Rust), typically rely on pipes or shared memory, which requires data to be serialized into a stream format. While C# can pass a live object to PowerShell, an AWK script calling Python must convert that data into text first.\n\nFor a comprehensive breakdown of runtime families and communication mechanisms, see `education/book-07-cross-target-glue/01_introduction.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["runtime-families", "in-process", "communication"], "original_answer": "## Runtime Families\n\nTargets in the same family can communicate more efficiently:\n\n| Family | Targets | Communication |\n|--------|---------|---------------|\n| .NET | C#, PowerShell, IronPython | In-process (zero serialization) |\n| JVM | Java, Scala, Jython | In-process |\n| Shell | Bash, AWK, sed | Pipes |\n| Native | Go, Rust, C | Pipes or shared memory |\n| Python | CPython | Pipes |\n\n### Example: .NET In-Process\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\n**Key insight**: C# calling PowerShell passes objects directly. AWK calling Python must serialize.", "answer_tailored": true}
{"pair_id": "b7-c1-runtime-families_p2", "cluster_id": "b7-c1-runtime-families", "question": "How do .NET targets communicate?", "question_type": "medium", "answer": ".NET targets, including C#, PowerShell, and IronPython, communicate **in-process** with zero serialization. Because they share the same runtime family, they can pass objects directly between languages rather than relying on pipes or text-based serialization. For example, a C# application can execute a PowerShell script and receive native output objects directly:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>(); // Direct object passing!\n```\n\nThis in-process communication makes .NET targets exceptionally efficient compared to families like Python or Shell that must serialize data across pipes. For more details on runtime family bridges, see `education/book-07-cross-target-glue/`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["runtime-families", "in-process", "communication"], "original_answer": "## Runtime Families\n\nTargets in the same family can communicate more efficiently:\n\n| Family | Targets | Communication |\n|--------|---------|---------------|\n| .NET | C#, PowerShell, IronPython | In-process (zero serialization) |\n| JVM | Java, Scala, Jython | In-process |\n| Shell | Bash, AWK, sed | Pipes |\n| Native | Go, Rust, C | Pipes or shared memory |\n| Python | CPython | Pipes |\n\n### Example: .NET In-Process\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\n**Key insight**: C# calling PowerShell passes objects directly. AWK calling Python must serialize.", "answer_tailored": true}
{"pair_id": "b7-c2-design-principles_p0", "cluster_id": "b7-c2-design-principles", "question": "What is location transparency?", "question_type": "medium", "answer": "Location transparency is the design principle that allows predicates to be called without regard for where or in what language they execute. In the context of UnifyWeaver, this enables a single logical process to transparently bridge multiple runtimes\u2014for example, fetching data via a Bash script, processing it through a Python library, and storing it in a remote SQL database. The system automatically selects the most efficient transport method, defaulting to TSV-based pipes for local cross-runtime communication and JSON/HTTP for remote interactions. For a deeper dive into these architectural philosophies, see `education/book-07-cross-target-glue/02_philosophy.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["location-transparency", "design-principles", "streaming"], "original_answer": "## Cross-Target Design Principles\n\n### 1. Location Transparency\n\nPredicates should be callable regardless of where they execute:\n\n```prolog\nresult(X) :-\n    fetch_data(RawData),      % Maybe Bash/curl\n    analyze(RawData, Result),  % Maybe Python/pandas\n    store(Result, X).          % Maybe SQL on remote DB\n```\n\n### 2. Sensible Defaults with Override\n\n| Scenario | Default |\n|----------|--------|\n| Same runtime family | In-process |\n| Different runtimes | Pipes with TSV |\n| Remote targets | HTTP with JSON |\n\n### 3. Streaming by Default\n\n```bash\n# Works on 100GB with 1MB memory\ncat huge.tsv | awk '{...}' | python3 transform.py | sort\n```\n\nAll stages run concurrently (pipeline parallelism).", "answer_tailored": true}
{"pair_id": "b7-c2-design-principles_p1", "cluster_id": "b7-c2-design-principles", "question": "What are the design principles of cross-target glue?", "question_type": "medium", "answer": "The design principles of cross-target glue in UnifyWeaver are centered on enabling seamless interoperability between disparate runtimes while maintaining high performance. These principles include:\n\n### 1. Location Transparency\nExecution details are abstracted away, allowing predicates to be called regardless of their underlying implementation or physical location. A single Prolog rule can orchestrate logic across Bash (e.g., data retrieval), Python (e.g., complex analysis), and SQL (e.g., database storage) without the caller needing to manage the transitions.\n\n### 2. Sensible Defaults with Overrides\nThe system automatically chooses the most efficient communication mechanism based on the relationship between targets, which can be manually tuned if necessary:\n*   **In-process:** Used by default for components within the same runtime family.\n*   **Pipes with TSV:** The standard for different runtimes executing on the same host.\n*   **HTTP with JSON:** The default for interacting with remote targets.\n\n### 3. Streaming by Default\nTo support massive datasets with minimal memory footprints, the glue logic prioritizes streaming. By using pipeline parallelism, stages like Python transformations and Bash filtering run concurrently, allowing the system to process files far larger than available RAM.\n\nFor a comprehensive exploration of these architectural choices, see `education/book-07-cross-target-glue/02_philosophy.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["location-transparency", "design-principles", "streaming"], "original_answer": "## Cross-Target Design Principles\n\n### 1. Location Transparency\n\nPredicates should be callable regardless of where they execute:\n\n```prolog\nresult(X) :-\n    fetch_data(RawData),      % Maybe Bash/curl\n    analyze(RawData, Result),  % Maybe Python/pandas\n    store(Result, X).          % Maybe SQL on remote DB\n```\n\n### 2. Sensible Defaults with Override\n\n| Scenario | Default |\n|----------|--------|\n| Same runtime family | In-process |\n| Different runtimes | Pipes with TSV |\n| Remote targets | HTTP with JSON |\n\n### 3. Streaming by Default\n\n```bash\n# Works on 100GB with 1MB memory\ncat huge.tsv | awk '{...}' | python3 transform.py | sort\n```\n\nAll stages run concurrently (pipeline parallelism).", "answer_tailored": true}
{"pair_id": "b7-c2-design-principles_p2", "cluster_id": "b7-c2-design-principles", "question": "Why is streaming the default?", "question_type": "medium", "answer": "Streaming is the default in UnifyWeaver to facilitate the processing of massive datasets while keeping memory overhead extremely low\u2014for instance, processing 100GB of data using only 1MB of RAM. This approach leverages pipeline parallelism, allowing different execution stages (such as a Bash data fetch followed by a Python transformation) to run concurrently and exchange data through standard pipes. By prioritizing streaming, the system ensures high performance and scalability across mixed-language environments without requiring the entire dataset to fit in memory. For a full explanation of these design principles, see `education/book-07-cross-target-glue/02_philosophy.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["location-transparency", "design-principles", "streaming"], "original_answer": "## Cross-Target Design Principles\n\n### 1. Location Transparency\n\nPredicates should be callable regardless of where they execute:\n\n```prolog\nresult(X) :-\n    fetch_data(RawData),      % Maybe Bash/curl\n    analyze(RawData, Result),  % Maybe Python/pandas\n    store(Result, X).          % Maybe SQL on remote DB\n```\n\n### 2. Sensible Defaults with Override\n\n| Scenario | Default |\n|----------|--------|\n| Same runtime family | In-process |\n| Different runtimes | Pipes with TSV |\n| Remote targets | HTTP with JSON |\n\n### 3. Streaming by Default\n\n```bash\n# Works on 100GB with 1MB memory\ncat huge.tsv | awk '{...}' | python3 transform.py | sort\n```\n\nAll stages run concurrently (pipeline parallelism).", "answer_tailored": true}
{"pair_id": "b7-c2-data-formats_p0", "cluster_id": "b7-c2-data-formats", "question": "What data formats does cross-target glue support?", "question_type": "medium", "answer": "UnifyWeaver's cross-target glue primarily supports **TSV (Tab-Separated Values)** and **JSON (JSON Lines)** for inter-process communication.\n\n### TSV (Tab-Separated Values)\nTSV is the default format for pipeline execution because it is universal, supports line-by-line streaming with low memory overhead, and is easily debugged using standard CLI tools like `head` or `tail`.\n\n### JSON (JSON Lines)\nJSON is preferred when handling nested data structures, self-describing schemas, or when maintaining compatibility with external APIs.\n\n### Configuration in Prolog\nThe data format is specified in the `generate_pipeline/3` options:\n\n```prolog\n% Default: TSV\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% Structural: JSON Lines\ngenerate_pipeline(Steps, [format(json)], Script).\n```\n\nFor a deeper dive into data exchange strategies, see `education/book-07-cross-target-glue/02_philosophy.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["tsv", "json", "pipe-protocols"], "original_answer": "## Data Format Selection\n\n### TSV: The Default Choice\n\nTSV is default for pipes because:\n- **Universal**: Every language can parse it\n- **Streaming**: Process line-by-line, bounded memory\n- **Debuggable**: `cat`, `head`, `tail` work perfectly\n\n```\nname    age    city\nAlice   30     NYC\nBob     25     LA\n```\n\n### JSON: For Structure\n\nUse JSON when you need:\n- Nested data structures\n- Self-describing format\n- API compatibility\n\n### Protocol Specification\n\n```prolog\n% TSV (default)\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% JSON Lines\ngenerate_pipeline(Steps, [format(json)], Script).\n```", "answer_tailored": true}
{"pair_id": "b7-c2-data-formats_p1", "cluster_id": "b7-c2-data-formats", "question": "When should I use TSV vs JSON?", "question_type": "medium", "answer": "In UnifyWeaver, you should use TSV as your default choice for pipe-based communication, switching to JSON only when your data requires complex nesting or specific API compatibility.\n\n### When to use TSV (The Default)\nTSV is the preferred format for most pipelines because it is:\n*   **Streaming-oriented**: It supports line-by-line processing with a constant memory footprint, making it highly efficient.\n*   **Universal**: Every target language supported by the compiler can parse it easily without complex dependencies.\n*   **Transparent**: It is simple to debug using standard Unix utilities like `cat`, `head`, and `tail`.\n\n### When to use JSON\nJSON (specifically JSON Lines) is the better choice when your workflow demands:\n*   **Hierarchical Data**: Handling nested structures that are difficult to represent in a flat tab-separated format.\n*   **Self-describing Records**: When individual records must carry their own schema information.\n*   **External Interoperability**: When connecting to modern web services or third-party APIs that expect JSON payloads.\n\n### Specifying the Format\nYou can control the data format within your Prolog protocol specifications:\n\n```prolog\n% Setting TSV (default behavior)\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% Setting JSON Lines\ngenerate_pipeline(Steps, [format(json)], Script).\n```\n\nFor more details on the underlying philosophy of cross-target data exchange, refer to `education/book-07-cross-target-glue/02_philosophy.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["tsv", "json", "pipe-protocols"], "original_answer": "## Data Format Selection\n\n### TSV: The Default Choice\n\nTSV is default for pipes because:\n- **Universal**: Every language can parse it\n- **Streaming**: Process line-by-line, bounded memory\n- **Debuggable**: `cat`, `head`, `tail` work perfectly\n\n```\nname    age    city\nAlice   30     NYC\nBob     25     LA\n```\n\n### JSON: For Structure\n\nUse JSON when you need:\n- Nested data structures\n- Self-describing format\n- API compatibility\n\n### Protocol Specification\n\n```prolog\n% TSV (default)\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% JSON Lines\ngenerate_pipeline(Steps, [format(json)], Script).\n```", "answer_tailored": true}
{"pair_id": "b7-c2-data-formats_p2", "cluster_id": "b7-c2-data-formats", "question": "What is the TSV protocol?", "question_type": "medium", "answer": "In UnifyWeaver, the TSV (Tab-Separated Values) protocol is the default format used for piping data between components. It is the preferred choice because it is universal across all supported target languages, enables efficient line-by-line streaming to maintain a bounded memory footprint, and remains highly debuggable using standard Unix tools like `cat` and `tail`.\n\nThe protocol is specified in Prolog via the `format(tsv)` option:\n\n```prolog\n% TSV is the default choice for data pipelines\ngenerate_pipeline(Steps, [format(tsv)], Script).\n```\n\nWhile TSV is ideal for flat data streams, UnifyWeaver also supports JSON for scenarios requiring nested structures or self-describing formats. For more information on the design philosophy behind these data formats, refer to `education/book-07-cross-target-glue/02_philosophy.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["tsv", "json", "pipe-protocols"], "original_answer": "## Data Format Selection\n\n### TSV: The Default Choice\n\nTSV is default for pipes because:\n- **Universal**: Every language can parse it\n- **Streaming**: Process line-by-line, bounded memory\n- **Debuggable**: `cat`, `head`, `tail` work perfectly\n\n```\nname    age    city\nAlice   30     NYC\nBob     25     LA\n```\n\n### JSON: For Structure\n\nUse JSON when you need:\n- Nested data structures\n- Self-describing format\n- API compatibility\n\n### Protocol Specification\n\n```prolog\n% TSV (default)\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% JSON Lines\ngenerate_pipeline(Steps, [format(json)], Script).\n```", "answer_tailored": true}
