{"pair_id": "b7-c9-native-code-gen_p0", "cluster_id": "b7-c9-native-code-gen", "question": "How do I generate Go pipe wrappers?", "question_type": "medium", "answer": "To generate Go pipe wrappers in UnifyWeaver, you use the `generate_go_pipe_main/3` predicate. This predicate produces Go source code designed to read data from standard input (TSV or JSON), process the records according to your specified logic, and output the results to standard output.\n\n```prolog\n% Logic: The processing rules\n% Options: Configuration for the generator\n% Code: The resulting Go source code string\ngenerate_go_pipe_main(Logic, Options, Code).\n```\n\nFor performance-intensive tasks, you can enable concurrent processing using worker goroutines by passing a parallelism option:\n\n```prolog\n% Generate Go code with 8 parallel worker goroutines\ngenerate_go_pipe_main(Logic, [parallel(8)], Code).\n```\n\nAdditional details on native code generation and cross-compilation scripts can be found in `education/book-07-cross-target-glue/09_native_code_gen.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/09_native_code_gen.md", "topics": ["go-wrapper", "rust-wrapper", "native-code"], "original_answer": "## Native Code Generation\n\n### Go Pipe Wrapper\n\n```prolog\ngenerate_go_pipe_main(Logic, Options, Code).\n```\n\nGenerates Go code that:\n- Reads from stdin\n- Parses TSV/JSON\n- Processes records\n- Writes to stdout\n\n### Rust Pipe Wrapper\n\n```prolog\ngenerate_rust_pipe_main(Logic, Options, Code).\n```\n\n### Parallel Processing\n\n```prolog\n% Generate Go with 8 parallel workers\ngenerate_go_pipe_main(Logic, [parallel(8)], Code).\n```\n\nGenerates goroutines that process records concurrently.\n\n### Build Script Generation\n\n```prolog\n% Cross-compile for multiple platforms\ngenerate_cross_compile(go, Source, [\n    linux-amd64, darwin-arm64, windows-amd64\n], Script).\n```", "answer_tailored": true}
{"pair_id": "b7-c9-native-code-gen_p1", "cluster_id": "b7-c9-native-code-gen", "question": "How do I generate Rust pipe wrappers?", "question_type": "medium", "answer": "To generate Rust pipe wrappers, use the `generate_rust_pipe_main(Logic, Options, Code)` predicate. This command generates Rust source code that implements a standard pipe pattern: it reads data from standard input, parses it (supporting formats like TSV or JSON), executes your processing logic, and streams the results to standard output. Further details on generating native code wrappers can be found in `education/book-07-cross-target-glue/09_native_code_gen.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/09_native_code_gen.md", "topics": ["go-wrapper", "rust-wrapper", "native-code"], "original_answer": "## Native Code Generation\n\n### Go Pipe Wrapper\n\n```prolog\ngenerate_go_pipe_main(Logic, Options, Code).\n```\n\nGenerates Go code that:\n- Reads from stdin\n- Parses TSV/JSON\n- Processes records\n- Writes to stdout\n\n### Rust Pipe Wrapper\n\n```prolog\ngenerate_rust_pipe_main(Logic, Options, Code).\n```\n\n### Parallel Processing\n\n```prolog\n% Generate Go with 8 parallel workers\ngenerate_go_pipe_main(Logic, [parallel(8)], Code).\n```\n\nGenerates goroutines that process records concurrently.\n\n### Build Script Generation\n\n```prolog\n% Cross-compile for multiple platforms\ngenerate_cross_compile(go, Source, [\n    linux-amd64, darwin-arm64, windows-amd64\n], Script).\n```", "answer_tailored": true}
{"pair_id": "b7-c9-native-code-gen_p2", "cluster_id": "b7-c9-native-code-gen", "question": "What is generate_go_pipe_main?", "question_type": "medium", "answer": "`generate_go_pipe_main/3` is a Prolog predicate used to generate Go source code for a standalone pipe-based executable. It creates a \"main\" wrapper that manages the lifecycle of a data stream by reading from stdin, parsing input formats (such as TSV or JSON), executing the compiled processing logic, and writing the resulting records to stdout.\n\nThe predicate accepts options to enhance performance, such as `parallel(N)`, which generates Go code utilizing goroutines for concurrent record processing. For a deeper dive into native code generation and cross-target glue, refer to `education/book-07-cross-target-glue/09_native_code_gen.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/09_native_code_gen.md", "topics": ["go-wrapper", "rust-wrapper", "native-code"], "original_answer": "## Native Code Generation\n\n### Go Pipe Wrapper\n\n```prolog\ngenerate_go_pipe_main(Logic, Options, Code).\n```\n\nGenerates Go code that:\n- Reads from stdin\n- Parses TSV/JSON\n- Processes records\n- Writes to stdout\n\n### Rust Pipe Wrapper\n\n```prolog\ngenerate_rust_pipe_main(Logic, Options, Code).\n```\n\n### Parallel Processing\n\n```prolog\n% Generate Go with 8 parallel workers\ngenerate_go_pipe_main(Logic, [parallel(8)], Code).\n```\n\nGenerates goroutines that process records concurrently.\n\n### Build Script Generation\n\n```prolog\n% Cross-compile for multiple platforms\ngenerate_cross_compile(go, Source, [\n    linux-amd64, darwin-arm64, windows-amd64\n], Script).\n```", "answer_tailored": true}
{"pair_id": "b7-c10-native-orchestration_p0", "cluster_id": "b7-c10-native-orchestration", "question": "How do I manage native binaries?", "question_type": "medium", "answer": "Native binaries are managed through UnifyWeaver's native orchestration system, which automates the lifecycle of compiled executables within your pipelines. This system handles compilation on demand, caches binaries for reuse, and performs version detection to ensure the correct environment setup.\n\n### Core Management Features\n- **Compilation on Demand:** Automatically builds binaries from source when they are first required or updated.\n- **Caching:** Stores compiled artifacts to avoid redundant build cycles and improve execution speed.\n- **Cross-Compilation:** Support for building for multiple platforms and architectures from a single source:\n  ```bash\n  # Building for Linux, macOS, and Windows\n  GOOS=linux GOARCH=amd64 go build -o tool-linux-amd64\n  GOOS=darwin GOARCH=arm64 go build -o tool-darwin-arm64\n  GOOS=windows GOARCH=amd64 go build -o tool-windows.exe\n  ```\n\n### Orchestration in Mixed Pipelines\nUnifyWeaver allows you to integrate native binaries seamlessly with shell-based tools using Prolog-defined pipelines:\n```prolog\n% Example: Orchestrating AWK and Go in a single pipeline\ngenerate_pipeline([\n    step(parse, awk, 'parse.awk', []),\n    step(process, go, 'process', [parallel(4)]),\n    step(format, awk, 'format.awk', [])\n], Options, Script).\n```\n\nThe orchestrator is responsible for binary detection, conditional compilation, and managing the pipe connections between native and shell-based stages. Detailed information on these mechanisms can be found in `education/book-07-cross-target-glue/10_native_orchestration.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/10_native_orchestration.md", "topics": ["binary-management", "cross-compilation", "orchestration"], "original_answer": "## Native Binary Orchestration\n\n### Binary Management\n\n- Compilation on demand\n- Caching of compiled binaries\n- Version detection\n\n### Cross-Compilation\n\n```bash\n# Build for 5 platforms from one source\nGOOS=linux GOARCH=amd64 go build -o tool-linux-amd64\nGOOS=darwin GOARCH=arm64 go build -o tool-darwin-arm64\nGOOS=windows GOARCH=amd64 go build -o tool-windows.exe\n```\n\n### Mixed Pipelines\n\n```prolog\n% Shell + native in same pipeline\ngenerate_pipeline([\n    step(parse, awk, 'parse.awk', []),\n    step(process, go, 'process', [parallel(4)]),\n    step(format, awk, 'format.awk', [])\n], Options, Script).\n```\n\nThe orchestrator handles:\n- Binary detection\n- Compilation if needed\n- Pipe connections", "answer_tailored": true}
{"pair_id": "b7-c10-native-orchestration_p1", "cluster_id": "b7-c10-native-orchestration", "question": "How does cross-compilation work?", "question_type": "medium", "answer": "Cross-compilation works by using UnifyWeaver's native binary orchestration to generate platform-specific executables from a single source. For example, a single Go source can be built for multiple platforms (such as `linux/amd64`, `darwin/arm64`, and `windows/amd64`) by setting the appropriate `GOOS` and `GOARCH` environment variables during the build process. The orchestrator manages these builds through on-demand compilation, binary caching, and version detection. This capability allows for mixed-target pipelines where Prolog coordinates data flow between shell-based tools (like AWK) and native binaries, with the orchestrator handling binary detection and pipe connections. For more details on binary management and orchestration, see `education/book-07-cross-target-glue/10_native_orchestration.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/10_native_orchestration.md", "topics": ["binary-management", "cross-compilation", "orchestration"], "original_answer": "## Native Binary Orchestration\n\n### Binary Management\n\n- Compilation on demand\n- Caching of compiled binaries\n- Version detection\n\n### Cross-Compilation\n\n```bash\n# Build for 5 platforms from one source\nGOOS=linux GOARCH=amd64 go build -o tool-linux-amd64\nGOOS=darwin GOARCH=arm64 go build -o tool-darwin-arm64\nGOOS=windows GOARCH=amd64 go build -o tool-windows.exe\n```\n\n### Mixed Pipelines\n\n```prolog\n% Shell + native in same pipeline\ngenerate_pipeline([\n    step(parse, awk, 'parse.awk', []),\n    step(process, go, 'process', [parallel(4)]),\n    step(format, awk, 'format.awk', [])\n], Options, Script).\n```\n\nThe orchestrator handles:\n- Binary detection\n- Compilation if needed\n- Pipe connections", "answer_tailored": true}
{"pair_id": "b7-c10-native-orchestration_p2", "cluster_id": "b7-c10-native-orchestration", "question": "Can I mix shell and native stages?", "question_type": "medium", "answer": "Yes, UnifyWeaver allows you to seamlessly mix shell stages (such as Awk or Bash) and native stages (like Go, Rust, or C#) within the same execution pipeline. The orchestrator manages the complexity of connecting these different environments, including pipe setup and data flow.\n\nIn Prolog, you can define a mixed pipeline like this:\n\n```prolog\ngenerate_pipeline([\n    step(parse, awk, 'parse.awk', []),\n    step(process, go, 'process', [parallel(4)]),\n    step(format, awk, 'format.awk', [])\n], Options, Script).\n```\n\nThe orchestration system handles binary management tasks such as:\n- **Compilation on demand:** Building native tools from source when needed.\n- **Binary detection and caching:** Ensuring the correct versions are available and reusing them.\n- **Cross-compilation:** Supporting multiple platforms (e.g., Linux, macOS, Windows) from a single source.\n\nFor more details on building and managing these hybrid pipelines, refer to `education/book-07-cross-target-glue/10_native_orchestration.md`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/10_native_orchestration.md", "topics": ["binary-management", "cross-compilation", "orchestration"], "original_answer": "## Native Binary Orchestration\n\n### Binary Management\n\n- Compilation on demand\n- Caching of compiled binaries\n- Version detection\n\n### Cross-Compilation\n\n```bash\n# Build for 5 platforms from one source\nGOOS=linux GOARCH=amd64 go build -o tool-linux-amd64\nGOOS=darwin GOARCH=arm64 go build -o tool-darwin-arm64\nGOOS=windows GOARCH=amd64 go build -o tool-windows.exe\n```\n\n### Mixed Pipelines\n\n```prolog\n% Shell + native in same pipeline\ngenerate_pipeline([\n    step(parse, awk, 'parse.awk', []),\n    step(process, go, 'process', [parallel(4)]),\n    step(format, awk, 'format.awk', [])\n], Options, Script).\n```\n\nThe orchestrator handles:\n- Binary detection\n- Compilation if needed\n- Pipe connections", "answer_tailored": true}
