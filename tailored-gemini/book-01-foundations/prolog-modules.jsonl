{"pair_id": "prolog-modules_p0", "cluster_id": "prolog-modules", "question": "What are Prolog modules and why does UnifyWeaver need them?", "question_type": "medium", "answer": "Prolog modules are a namespace system used to organize code into distinct units, preventing naming collisions. UnifyWeaver requires modules because its architecture consists of many specialized backends (Bash, Python, Go, etc.) that would otherwise conflict if they all shared a global namespace for predicates like `compile/3` or `generate/2`.\n\n### Module Definition\nA module is declared at the top of a file using the `module/2` directive. This defines which predicates are public:\n\n```prolog\n:- module(go_compiler, [compile_go/3]).\n\n% compile_go/3 is public, while helper predicates stay private.\n```\n\n### The unifyweaver(...) Alias\nUnifyWeaver simplifies module loading by defining a custom file search path in `init.pl`:\n\n```prolog\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n```\n\nThis allows you to load internal tools using a clean library syntax rather than relative file paths:\n\n```prolog\n% Load a core component\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### Accessing Predicates\nOnce a module is loaded with `use_module/1`, its exported predicates are available for use. You can also use module-qualified syntax to call a predicate explicitly from a specific namespace:\n\n```prolog\n% Explicitly call from the bash_compiler module\n?- bash_compiler:emit_header(Output).\n```\n\nFor more information on the foundational structure of the project, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["modules", "use_module", "library", "namespaces"], "original_answer": "## Prolog Modules\n\nModules organize Prolog code into namespaces, preventing naming conflicts.\n\n### Why Modules?\n\nWithout modules, all predicates share a global namespace. If two files define `compile/3`, they conflict. Modules solve this:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Loading Modules\n\n```prolog\n% Load a module\n?- use_module(library(lists)).\n\n% Load UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The unifyweaver(...) Syntax\n\nThe `unifyweaver(...)` syntax is a library alias:\n\n```prolog\n% Defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% So this:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Becomes:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### Accessing Module Predicates\n\n```prolog\n% Exported predicates are available directly\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified syntax\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Module Declaration\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported predicates\n    predicate2/3\n]).\n\n% Private predicates (not in export list)\n% are only visible inside the module\n```", "answer_tailored": true}
{"pair_id": "prolog-modules_p1", "cluster_id": "prolog-modules", "question": "How do I use use_module in Prolog?", "question_type": "medium", "answer": "To use `use_module` in Prolog, you call the predicate with the path or library alias of the module file you wish to import. This loads the module and makes its exported predicates available in your current environment, helping to prevent naming conflicts by organizing code into namespaces.\n\n### Loading Modules\n\nYou can load standard libraries or project-specific files:\n\n```prolog\n% Load a standard library\n?- use_module(library(lists)).\n\n% Load a specific UnifyWeaver module using our library alias\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The `unifyweaver(...)` Alias\n\nUnifyWeaver uses a custom search path defined in `init.pl` to make imports cleaner. The `unifyweaver` alias points to the `src/unifyweaver` directory:\n\n```prolog\n% This definition in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Allows this shorthand:\nuse_module(unifyweaver(core/recursive_compiler))\n```\n\n### Accessing Predicates\n\nOnce a module is loaded, you can call its exported predicates directly. If you need to avoid ambiguity or access a predicate without importing everything, use module-qualified syntax:\n\n```prolog\n% Call an exported predicate directly\n?- compile_recursive(Target, Options, Result).\n\n% Call using module-qualification\n?- stream_compiler:compile_stream(Target, Options, Result).\n```\n\n### Module Definitions\n\nModules are defined using the `module/2` directive at the top of a file, which specifies the module name and the list of predicates to be exported (made public):\n\n```prolog\n:- module(my_module, [\n    public_pred/1,\n    another_public_pred/2\n]).\n```\n\nFor more details on Prolog namespaces and module organization, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["modules", "use_module", "library", "namespaces"], "original_answer": "## Prolog Modules\n\nModules organize Prolog code into namespaces, preventing naming conflicts.\n\n### Why Modules?\n\nWithout modules, all predicates share a global namespace. If two files define `compile/3`, they conflict. Modules solve this:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Loading Modules\n\n```prolog\n% Load a module\n?- use_module(library(lists)).\n\n% Load UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The unifyweaver(...) Syntax\n\nThe `unifyweaver(...)` syntax is a library alias:\n\n```prolog\n% Defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% So this:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Becomes:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### Accessing Module Predicates\n\n```prolog\n% Exported predicates are available directly\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified syntax\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Module Declaration\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported predicates\n    predicate2/3\n]).\n\n% Private predicates (not in export list)\n% are only visible inside the module\n```", "answer_tailored": true}
{"pair_id": "prolog-modules_p2", "cluster_id": "prolog-modules", "question": "What does unifyweaver(core/...) syntax mean?", "question_type": "medium", "answer": "The `unifyweaver(core/...)` syntax is a library alias used to load modules from the UnifyWeaver source directory. \n\nThis alias is defined in `init.pl` using the Prolog `file_search_path/2` predicate:\n\n```prolog\n% Mapping the 'unifyweaver' alias to the source directory\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n```\n\nWhen you use the directive `use_module(unifyweaver(core/recursive_compiler))`, Prolog automatically resolves the alias to the full path: `src/unifyweaver/core/recursive_compiler.pl`. Using this syntax allows for consistent, portable imports across the codebase regardless of a file's location in the directory tree.\n\nModules are critical in UnifyWeaver for maintaining clean namespaces and preventing predicate name collisions. A typical module declaration looks like this:\n\n```prolog\n:- module(module_name, [\n    predicate1/2, % Exported to other modules\n    predicate2/3\n]).\n```\n\nFor more information on the project's structure and module handling, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["modules", "use_module", "library", "namespaces"], "original_answer": "## Prolog Modules\n\nModules organize Prolog code into namespaces, preventing naming conflicts.\n\n### Why Modules?\n\nWithout modules, all predicates share a global namespace. If two files define `compile/3`, they conflict. Modules solve this:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Loading Modules\n\n```prolog\n% Load a module\n?- use_module(library(lists)).\n\n% Load UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The unifyweaver(...) Syntax\n\nThe `unifyweaver(...)` syntax is a library alias:\n\n```prolog\n% Defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% So this:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Becomes:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### Accessing Module Predicates\n\n```prolog\n% Exported predicates are available directly\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified syntax\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Module Declaration\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported predicates\n    predicate2/3\n]).\n\n% Private predicates (not in export list)\n% are only visible inside the module\n```", "answer_tailored": true}
{"pair_id": "prolog-modules_p3", "cluster_id": "prolog-modules", "question": "How do modules prevent naming conflicts?", "question_type": "medium", "answer": "Prolog modules prevent naming conflicts by isolating predicates within distinct namespaces. In a standard global namespace, multiple definitions of a predicate like `compile/3` would overwrite each other. Modules solve this by making predicates private to the file unless they are explicitly exported in the module header.\n\n### Module Scoping\nEach file defines its own namespace using the `module/2` directive:\n```prolog\n% Isolated in recursive_compiler namespace\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% Isolated in stream_compiler namespace\n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Explicit Imports and Aliases\nTo use a module, you load it with `use_module/1`. UnifyWeaver utilizes a library alias for cleaner imports:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\nThis alias is configured in `init.pl` via `user:file_search_path(unifyweaver, 'src/unifyweaver')`, allowing the system to resolve the path to the core source directory.\n\n### Module Qualification\nIf you need to specify exactly which module's predicate to execute, or to access a predicate without importing it, use the module-qualified syntax (`Module:Predicate`):\n```prolog\n?- stream_compiler:compile_facts(Target, Arity, Opts, Code).\n```\n\n### Visibility Control\nOnly predicates listed in the export list are visible to the rest of the application. Private predicates (those not in the list) remain hidden, ensuring they do not conflict with predicates defined elsewhere in the project.\n\nFor a comprehensive guide on Prolog modules and UnifyWeaver's project structure, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["modules", "use_module", "library", "namespaces"], "original_answer": "## Prolog Modules\n\nModules organize Prolog code into namespaces, preventing naming conflicts.\n\n### Why Modules?\n\nWithout modules, all predicates share a global namespace. If two files define `compile/3`, they conflict. Modules solve this:\n\n```prolog\n% In recursive_compiler.pl\n:- module(recursive_compiler, [compile_recursive/3]).\n\n% In stream_compiler.pl  \n:- module(stream_compiler, [compile_stream/3]).\n```\n\n### Loading Modules\n\n```prolog\n% Load a module\n?- use_module(library(lists)).\n\n% Load UnifyWeaver module\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### The unifyweaver(...) Syntax\n\nThe `unifyweaver(...)` syntax is a library alias:\n\n```prolog\n% Defined in init.pl:\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% So this:\nuse_module(unifyweaver(core/recursive_compiler))\n\n% Becomes:\nuse_module('src/unifyweaver/core/recursive_compiler')\n```\n\n### Accessing Module Predicates\n\n```prolog\n% Exported predicates are available directly\n?- compile_recursive(ancestor/2, [], Code).\n\n% Or use module-qualified syntax\n?- stream_compiler:compile_facts(parent, 2, [], Code).\n```\n\n### Module Declaration\n\n```prolog\n:- module(module_name, [\n    predicate1/2,    % exported predicates\n    predicate2/3\n]).\n\n% Private predicates (not in export list)\n% are only visible inside the module\n```", "answer_tailored": true}
{"pair_id": "prolog-directives_p0", "cluster_id": "prolog-directives", "question": "What is a Prolog directive or pragma?", "question_type": "medium", "answer": "A Prolog directive or pragma is a specialized instruction prefixed by `:-` that tells the compiler or runtime environment how to process a file, rather than defining a logical fact or rule. While standard facts are added to the knowledge base, directives are executed immediately when the file is loaded.\n\nIn Prolog and the UnifyWeaver environment, directives serve several roles:\n- **System Configuration:** Using `:- module(name, [exports])` to define modules or `:- use_module(path)` to import dependencies.\n- **Runtime Behavior:** Declaring `:- dynamic(predicate/arity)` for predicates that change during execution, or `:- initialization(goal)` to run code automatically after loading.\n- **Compilation Pragmas:** UnifyWeaver utilizes a custom `:- constraint(predicate/arity, [options])` pragma. This informs the compiler about data properties\u2014such as `unique(true)` or `ordered`\u2014allowing it to generate optimized target code for specific languages like SQL or Go.\n\nUnlike queries (marked with `?-`), which are used interactively to prove goals, directives are embedded in source files to manage the compilation and execution environment. For a deeper look at these fundamentals, refer to `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["directives", "pragmas", ":-", "initialization"], "original_answer": "## Prolog Directives\n\nA directive (starting with `:-`) is an instruction to Prolog, not a fact or rule.\n\n### Directive vs Query\n\n```prolog\n% Query (interactive prompt) - asks Prolog to prove something\n?- parent(alice, bob).\n\n% Directive (in file) - executes when file loads\n:- use_module(library(lists)).\n```\n\n### Common Directives\n\n```prolog\n% Load a module\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Declare a module\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicate (can be modified at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization (runs after file loads)\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragma\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n### How Directives Execute\n\nWhen Prolog loads a file:\n1. Facts and rules are added to the knowledge base\n2. Directives are executed immediately\n3. Initialization goals run after everything loads\n\n### UnifyWeaver's constraint Directive\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nUnifyWeaver intercepts this during compilation:\n1. Extracts predicate name and arity\n2. Stores constraint options\n3. Uses them to guide code generation\n\n```prolog\n% Example: preserve order, allow duplicates\n:- constraint(event_log/3, [unique(false), ordered]).\n```", "answer_tailored": true}
{"pair_id": "prolog-directives_p1", "cluster_id": "prolog-directives", "question": "What does :- mean at the start of a line?", "question_type": "medium", "answer": "In Prolog, the symbol `:-` at the beginning of a line indicates a **directive**. Unlike facts or rules which define logic for the knowledge base, a directive is a command that the Prolog environment or the UnifyWeaver compiler executes immediately as the source file is being loaded.\n\n### Directives vs. Queries\nIt is important to distinguish directives from queries:\n*   **Queries (`?-`)**: Usually entered at an interactive prompt to ask Prolog to prove a goal.\n*   **Directives (`:-`)**: Written in source files to configure the system or load dependencies at compile-time.\n\n### Standard Prolog Directives\nDirectives are commonly used for environment setup and module management:\n*   `:- use_module(library(lists)).` \u2014 Loads an external library or module.\n*   `:- module(my_app, [run/1]).` \u2014 Declares the current file as a module and defines its exports.\n*   `:- dynamic(user_session/2).` \u2014 Informs the system that a predicate's definition may change during execution.\n*   `:- initialization(main_goal).` \u2014 Specifies a goal to be run automatically after the file finishes loading.\n\n### UnifyWeaver's `constraint` Directive\nUnifyWeaver utilizes the directive syntax to provide metadata for its code generation engine via the `:- constraint/2` pragma. This directive guides how predicates are translated into target languages like Go, Python, or SQL:\n\n```prolog\n% Example: Instructing the compiler to ensure uniqueness for a predicate\n:- constraint(ancestor/2, [unique(true)]).\n```\n\nWhen the compiler encounters this, it extracts the predicate name and options (like `unique` or `ordered`) to determine the appropriate data structures and logic in the generated output.\n\nFor a deeper dive into Prolog syntax and directives, see **education/book-01-foundations/02_prolog_fundamentals.md**.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["directives", "pragmas", ":-", "initialization"], "original_answer": "## Prolog Directives\n\nA directive (starting with `:-`) is an instruction to Prolog, not a fact or rule.\n\n### Directive vs Query\n\n```prolog\n% Query (interactive prompt) - asks Prolog to prove something\n?- parent(alice, bob).\n\n% Directive (in file) - executes when file loads\n:- use_module(library(lists)).\n```\n\n### Common Directives\n\n```prolog\n% Load a module\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Declare a module\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicate (can be modified at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization (runs after file loads)\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragma\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n### How Directives Execute\n\nWhen Prolog loads a file:\n1. Facts and rules are added to the knowledge base\n2. Directives are executed immediately\n3. Initialization goals run after everything loads\n\n### UnifyWeaver's constraint Directive\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nUnifyWeaver intercepts this during compilation:\n1. Extracts predicate name and arity\n2. Stores constraint options\n3. Uses them to guide code generation\n\n```prolog\n% Example: preserve order, allow duplicates\n:- constraint(event_log/3, [unique(false), ordered]).\n```", "answer_tailored": true}
{"pair_id": "prolog-directives_p2", "cluster_id": "prolog-directives", "question": "How does UnifyWeaver process the constraint directive?", "question_type": "medium", "answer": "UnifyWeaver processes the `constraint` directive as a compilation pragma rather than a standard Prolog rule. When the compiler encounters `:- constraint(predicate/arity, [options])`, it intercepts the directive to influence how the specific predicate is handled across different target languages.\n\nThe processing involves three primary phases:\n1. **Extraction:** The compiler identifies the predicate name and its arity.\n2. **Metadata Storage:** It parses the provided options\u2014such as `unique(true)`, `ordered`, or specific indexing strategies\u2014and stores them in the compilation context.\n3. **Code Generation Guidance:** These constraints inform the backend generator, allowing it to select appropriate data structures (e.g., using a hash set for unique constraints or an ordered array for sequences) in the final output, whether it be Bash, Python, Go, or SQL.\n\n**Example:**\n```prolog\n% Directs UnifyWeaver to ensure uniqueness and order for specific predicates\n:- constraint(ancestor/2, [unique(true)]).\n:- constraint(event_log/3, [unique(false), ordered]).\n```\n\nFor a deeper dive into how directives function within the UnifyWeaver environment, see the documentation in `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["directives", "pragmas", ":-", "initialization"], "original_answer": "## Prolog Directives\n\nA directive (starting with `:-`) is an instruction to Prolog, not a fact or rule.\n\n### Directive vs Query\n\n```prolog\n% Query (interactive prompt) - asks Prolog to prove something\n?- parent(alice, bob).\n\n% Directive (in file) - executes when file loads\n:- use_module(library(lists)).\n```\n\n### Common Directives\n\n```prolog\n% Load a module\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Declare a module\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicate (can be modified at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization (runs after file loads)\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragma\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n### How Directives Execute\n\nWhen Prolog loads a file:\n1. Facts and rules are added to the knowledge base\n2. Directives are executed immediately\n3. Initialization goals run after everything loads\n\n### UnifyWeaver's constraint Directive\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nUnifyWeaver intercepts this during compilation:\n1. Extracts predicate name and arity\n2. Stores constraint options\n3. Uses them to guide code generation\n\n```prolog\n% Example: preserve order, allow duplicates\n:- constraint(event_log/3, [unique(false), ordered]).\n```", "answer_tailored": true}
{"pair_id": "prolog-directives_p3", "cluster_id": "prolog-directives", "question": "What's the difference between a directive and a query?", "question_type": "medium", "answer": "In Prolog, the fundamental difference lies in their intent and execution: a **query** is a goal the system attempts to prove, while a **directive** is a command that instructs the compiler or runtime environment during the loading process.\n\n### Queries (`?-`)\nQueries are typically used at the interactive prompt to ask Prolog to search its knowledge base or prove a specific relationship.\n```prolog\n?- parent(alice, bob). % Asks: \"Is alice the parent of bob?\"\n```\n\n### Directives (`:-`)\nDirectives are embedded in source files and execute immediately when the file is loaded. Rather than being facts to be proven, they are instructions that configure the system or the compilation process.\n```prolog\n:- use_module(unifyweaver(core/recursive_compiler)). % Load a specific module\n:- dynamic(app_state/2).                             % Allow predicate modification at runtime\n:- initialization(setup_env).                       % Run a goal after the file is loaded\n```\n\n### UnifyWeaver Specifics\nUnifyWeaver utilizes the `:- constraint/2` directive to guide code generation. Unlike a query that searches for data, this directive tells the UnifyWeaver compiler how to handle data structures in the target language (such as Bash, Python, or Go).\n```prolog\n% Directive instructing the compiler to ensure uniqueness in the generated output\n:- constraint(session_log/3, [unique(true), ordered]).\n```\n\n### Summary of Differences\n*   **Timing:** Directives execute at load-time or compile-time; queries execute at runtime.\n*   **Prefix:** Directives start with `:-` in a file, while queries are denoted by `?-` at the prompt.\n*   **Function:** Directives manage environment state and compiler behavior; queries perform inference to find solutions.\n\nFor a deeper dive into Prolog syntax and its application in the compiler, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["directives", "pragmas", ":-", "initialization"], "original_answer": "## Prolog Directives\n\nA directive (starting with `:-`) is an instruction to Prolog, not a fact or rule.\n\n### Directive vs Query\n\n```prolog\n% Query (interactive prompt) - asks Prolog to prove something\n?- parent(alice, bob).\n\n% Directive (in file) - executes when file loads\n:- use_module(library(lists)).\n```\n\n### Common Directives\n\n```prolog\n% Load a module\n:- use_module(unifyweaver(core/recursive_compiler)).\n\n% Declare a module\n:- module(my_module, [my_pred/2]).\n\n% Dynamic predicate (can be modified at runtime)\n:- dynamic(my_fact/2).\n\n% Initialization (runs after file loads)\n:- initialization(setup_defaults).\n\n% UnifyWeaver constraint pragma\n:- constraint(ancestor/2, [unique(true)]).\n```\n\n### How Directives Execute\n\nWhen Prolog loads a file:\n1. Facts and rules are added to the knowledge base\n2. Directives are executed immediately\n3. Initialization goals run after everything loads\n\n### UnifyWeaver's constraint Directive\n\n```prolog\n:- constraint(predicate/arity, [options]).\n```\n\nUnifyWeaver intercepts this during compilation:\n1. Extracts predicate name and arity\n2. Stores constraint options\n3. Uses them to guide code generation\n\n```prolog\n% Example: preserve order, allow duplicates\n:- constraint(event_log/3, [unique(false), ordered]).\n```", "answer_tailored": true}
{"pair_id": "prolog-file-io_p0", "cluster_id": "prolog-file-io", "question": "How do I write to a file in Prolog?", "question_type": "medium", "answer": "To write to a file in Prolog, you manage file access through streams by opening the file, performing write operations, and then closing the stream.\n\n### Basic File Writing\nThe standard procedure uses `open/3`, `write/2` (or similar), and `close/1`:\n\n```prolog\n% Open file for writing, perform write, then close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### Writing Predicates\n*   **`write(Stream, Content)`**: Outputs a term without a newline.\n*   **`writeln(Stream, Content)`**: Outputs a term followed by a newline.\n*   **`format(Stream, FormatString, Args)`**: Used for formatted output (e.g., `format(Stream, '~w: ~d~n', [Key, Value])`).\n\n### Opening Modes\nWhen using `open(FileName, Mode, Stream)`, the `Mode` determines how the file is handled:\n*   `write`: Creates a new file or overwrites an existing one.\n*   `append`: Appends content to the end of an existing file.\n\n### Recommended Safe Pattern\nFor robust code, use `setup_call_cleanup/3` to guarantee that the stream is closed even if an exception occurs during the writing process:\n\n```prolog\nsetup_call_cleanup(\n    open('log.txt', append, S),\n    writeln(S, 'New log entry'),\n    close(S)\n).\n```\n\n### Creating Directories\nIf you need to ensure the target directory exists before writing, use:\n```prolog\nmake_directory_path('education/output').\n```\n\nFor a comprehensive overview of Prolog fundamentals and I/O, refer to `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["file-io", "open", "write", "close", "streams"], "original_answer": "## Prolog File I/O\n\nProlog uses streams for file operations.\n\n### Basic Pattern\n\n```prolog\n% Open file, write, close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### open/3 Parameters\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\n| Mode | Purpose |\n|------|--------|\n| `read` | Read from existing file |\n| `write` | Create/overwrite file |\n| `append` | Add to end of file |\n\n### Writing Content\n\n```prolog\n% Write term (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Reading Content\n\n```prolog\n% Read a term\nread(Stream, Term).\n\n% Read a line as string\nread_line_to_string(Stream, Line).\n\n% Read entire file\nread_file_to_string(FileName, Content, []).\n```\n\n### Safe Pattern with setup_call_cleanup\n\n```prolog\n% Ensures file is closed even on error\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Creating Directories\n\n```prolog\n% Create directory (including parents)\n?- make_directory_path('education/output').\n```", "answer_tailored": true}
{"pair_id": "prolog-file-io_p1", "cluster_id": "prolog-file-io", "question": "What do open, write, and close do in Prolog?", "question_type": "medium", "answer": "In Prolog, `open`, `write`, and `close` are the fundamental predicates used to manage file I/O through streams.\n\n### Core Predicates\n*   **`open(FileName, Mode, Stream)`**: This initializes a connection to a file. The **Mode** can be `write` (to create or overwrite), `append` (to add to the end of a file), or `read` (to retrieve data). It returns a **Stream** handle for subsequent operations.\n*   **`write(Stream, Term)`**: This sends a Prolog term to the specified stream. For more control, you can use `writeln/2` to include a newline or `format/3` for templated output (e.g., `format(S, '~w/~w~n', [Name, Arity])`).\n*   **`close(Stream)`**: This terminates the stream connection, ensuring all data is flushed and system resources are released.\n\n### Standard Pattern\nA typical write operation follows this sequence:\n```prolog\nopen('output/script.sh', write, Stream),\nwrite(Stream, Code),\nclose(Stream).\n```\n\n### Error-Safe I/O\nTo ensure that a stream is closed even if an error occurs during processing, use the `setup_call_cleanup/3` pattern:\n```prolog\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Reading and Utilities\nThese stream handles are also used for reading operations, such as `read(Stream, Term)` or `read_line_to_string(Stream, Line)`. When preparing for file output, you can use `make_directory_path/1` to ensure the target directory structure exists.\n\nFor a detailed look at Prolog's stream-based system, refer to `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["file-io", "open", "write", "close", "streams"], "original_answer": "## Prolog File I/O\n\nProlog uses streams for file operations.\n\n### Basic Pattern\n\n```prolog\n% Open file, write, close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### open/3 Parameters\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\n| Mode | Purpose |\n|------|--------|\n| `read` | Read from existing file |\n| `write` | Create/overwrite file |\n| `append` | Add to end of file |\n\n### Writing Content\n\n```prolog\n% Write term (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Reading Content\n\n```prolog\n% Read a term\nread(Stream, Term).\n\n% Read a line as string\nread_line_to_string(Stream, Line).\n\n% Read entire file\nread_file_to_string(FileName, Content, []).\n```\n\n### Safe Pattern with setup_call_cleanup\n\n```prolog\n% Ensures file is closed even on error\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Creating Directories\n\n```prolog\n% Create directory (including parents)\n?- make_directory_path('education/output').\n```", "answer_tailored": true}
{"pair_id": "prolog-file-io_p2", "cluster_id": "prolog-file-io", "question": "How does Prolog file I/O work?", "question_type": "medium", "answer": "Prolog handles file I/O operations by utilizing **streams** as an interface between the language and the filesystem. This allows for a consistent workflow where files are opened as streams, processed, and then closed to release system resources.\n\n### The Basic I/O Pattern\nA standard file operation involves establishing a stream, performing the desired read or write actions, and ensuring the stream is properly terminated:\n\n```prolog\n% Open file for writing, output content, and close stream\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### The open/3 Predicate\nThe `open(FileName, Mode, Stream)` predicate is used to initialize the connection. The `Mode` parameter defines the interaction type:\n\n| Mode | Purpose |\n|------|---------|\n| `read` | Access an existing file for input |\n| `write` | Create a new file or overwrite an existing one |\n| `append` | Add content to the end of a file |\n\n### Writing to Streams\nSeveral predicates allow you to send data to an active stream:\n*   `write(Stream, Term)`: Outputs a term without a newline.\n*   `writeln(Stream, Term)`: Outputs a term followed by a newline.\n*   `format(Stream, Template, Args)`: Provides formatted output using control sequences (e.g., `format(S, '~w/~w~n', [Name, Arity])`).\n\n### Reading from Streams\nData can be retrieved from streams using various methods:\n*   `read(Stream, Term)`: Parses the next Prolog term.\n*   `read_line_to_string(Stream, Line)`: Reads a single line into a string variable.\n*   `read_file_to_string(FileName, Content, [])`: A utility to read an entire file's content into memory.\n\n### Robust I/O with setup_call_cleanup\nTo ensure that streams are closed even if an error occurs during execution, the `setup_call_cleanup/3` pattern is recommended:\n\n```prolog\nsetup_call_cleanup(\n    open('data.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Directory Creation\nProlog also supports filesystem management, such as creating directory structures and their parents:\n`make_directory_path('education/output').`\n\nFor more information on these core mechanics, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["file-io", "open", "write", "close", "streams"], "original_answer": "## Prolog File I/O\n\nProlog uses streams for file operations.\n\n### Basic Pattern\n\n```prolog\n% Open file, write, close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### open/3 Parameters\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\n| Mode | Purpose |\n|------|--------|\n| `read` | Read from existing file |\n| `write` | Create/overwrite file |\n| `append` | Add to end of file |\n\n### Writing Content\n\n```prolog\n% Write term (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Reading Content\n\n```prolog\n% Read a term\nread(Stream, Term).\n\n% Read a line as string\nread_line_to_string(Stream, Line).\n\n% Read entire file\nread_file_to_string(FileName, Content, []).\n```\n\n### Safe Pattern with setup_call_cleanup\n\n```prolog\n% Ensures file is closed even on error\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Creating Directories\n\n```prolog\n% Create directory (including parents)\n?- make_directory_path('education/output').\n```", "answer_tailored": true}
{"pair_id": "prolog-file-io_p3", "cluster_id": "prolog-file-io", "question": "What are Prolog streams?", "question_type": "medium", "answer": "Prolog streams are the primary mechanism for performing file I/O operations, providing a handle to read from or write to external data sources.\n\n### Managing Streams with open/3\nTo begin working with a stream, use the `open(FileName, Mode, Stream)` predicate. The `Mode` determines the type of access allowed:\n\n| Mode | Description |\n|------|-------------|\n| `read` | Opens an existing file for reading. |\n| `write` | Creates a new file or overwrites an existing one. |\n| `append` | Adds data to the end of an existing file. |\n\n### Writing to Streams\nOnce a stream is open for output, you can send content using several predicates:\n- `write(Stream, Term)`: Outputs a term without a trailing newline.\n- `writeln(Stream, Term)`: Outputs a term followed by a newline.\n- `format(Stream, Format, Args)`: Provides structured output (e.g., `format(S, '~w/~w~n', [Name, Arity])`).\n\n### Reading from Streams\nTo retrieve data from an open input stream:\n- `read(Stream, Term)`: Reads the next Prolog term from the stream.\n- `read_line_to_string(Stream, Line)`: Reads a single line into a string.\n- `read_file_to_string(FileName, Content, [])`: A utility to read an entire file's content at once.\n\n### Safe Stream Management\nTo prevent resource leaks, use the `setup_call_cleanup/3` pattern. This ensures the stream is closed even if an error occurs during the operation:\n\n```prolog\nsetup_call_cleanup(\n    open('output.txt', write, S),\n    write(S, 'Data'),\n    close(S)\n).\n```\n\n### Directory Preparation\nBefore opening a stream for writing to a new path, you can ensure the directory exists using `make_directory_path/1`, which creates all parent directories as needed.\n\nFor more information on file I/O and Prolog fundamentals, see `education/book-01-foundations/02_prolog_fundamentals.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["file-io", "open", "write", "close", "streams"], "original_answer": "## Prolog File I/O\n\nProlog uses streams for file operations.\n\n### Basic Pattern\n\n```prolog\n% Open file, write, close\nopen('output/script.sh', write, Stream),\nwrite(Stream, BashCode),\nclose(Stream).\n```\n\n### open/3 Parameters\n\n```prolog\nopen(FileName, Mode, Stream)\n```\n\n| Mode | Purpose |\n|------|--------|\n| `read` | Read from existing file |\n| `write` | Create/overwrite file |\n| `append` | Add to end of file |\n\n### Writing Content\n\n```prolog\n% Write term (no newline)\nwrite(Stream, 'Hello').\n\n% Write with newline\nwriteln(Stream, 'Hello').\n\n% Formatted output\nformat(Stream, '~w/~w~n', [Name, Arity]).\n```\n\n### Reading Content\n\n```prolog\n% Read a term\nread(Stream, Term).\n\n% Read a line as string\nread_line_to_string(Stream, Line).\n\n% Read entire file\nread_file_to_string(FileName, Content, []).\n```\n\n### Safe Pattern with setup_call_cleanup\n\n```prolog\n% Ensures file is closed even on error\nsetup_call_cleanup(\n    open('file.txt', write, S),\n    write(S, Content),\n    close(S)\n).\n```\n\n### Creating Directories\n\n```prolog\n% Create directory (including parents)\n?- make_directory_path('education/output').\n```", "answer_tailored": true}
{"pair_id": "init-pl-explained_p0", "cluster_id": "init-pl-explained", "question": "What does education/init.pl do?", "question_type": "medium", "answer": "The `education/init.pl` file is responsible for bootstrapping the UnifyWeaver environment by configuring Prolog's library search paths and loading essential compiler modules.\n\nIts primary functions include:\n\n1.  **Path Resolution**: It defines the `unifyweaver` library alias using `file_search_path/2`. This allows Prolog to resolve paths like `unifyweaver(core/compiler_driver)` to the actual source directory at `src/unifyweaver/core/compiler_driver.pl`.\n2.  **Automated Loading**: It imports core modules (such as the `compiler_driver`) to ensure the environment is ready for compiling Prolog queries into target languages.\n3.  **Initialization Confirmation**: It provides visual feedback in the console to confirm that the educational environment has been successfully initialized.\n\nWithout running this script, Prolog will return a \"source_sink does not exist\" error when attempting to load UnifyWeaver modules because the library alias remains undefined.\n\n### Usage\nYou can initialize the environment manually within SWI-Prolog:\n```prolog\n?- ['education/init'].\n```\n\nOr automatically via the command line:\n```bash\nswipl -f education/init.pl\n```\n\nFor a deeper dive into how the project structure is organized, refer to `education/book-01-foundations/01_introduction.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["init.pl", "initialization", "setup", "library-paths"], "original_answer": "## Understanding init.pl\n\nThe `init.pl` file sets up the UnifyWeaver environment.\n\n### What It Does\n\n```prolog\n% education/init.pl typically contains:\n\n% 1. Set library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Print confirmation\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Why It's Necessary\n\nWithout init.pl:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nWith init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Library Search Paths\n\nProlog uses `file_search_path/2` to resolve library aliases:\n\n```prolog\n% Define alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Alternative: Using -f Flag\n\n```bash\n# Load init.pl automatically\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "answer_tailored": true}
{"pair_id": "init-pl-explained_p1", "cluster_id": "init-pl-explained", "question": "Why do I need to load init.pl first?", "question_type": "medium", "answer": "You must load `init.pl` first because it initializes the UnifyWeaver environment and configures the library search paths required to locate the system's core modules.\n\n### Why It Is Required\nProlog uses the `file_search_path/2` predicate to resolve library aliases. `init.pl` defines the `unifyweaver` alias so that the system can find the source code located in `src/unifyweaver`.\n\nWithout this initialization, attempting to load a module will fail:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nBy loading `init.pl`, the paths are correctly mapped, and core components like the `compiler_driver` are brought into the environment:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Automation with the -f Flag\nTo streamline your workflow, you can instruct SWI-Prolog to load the initialization file automatically upon startup using the `-f` flag:\n```bash\nswipl -f education/init.pl\n```\n\nFor a deeper dive into environment configuration and foundations, refer to `education/book-01-foundations/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["init.pl", "initialization", "setup", "library-paths"], "original_answer": "## Understanding init.pl\n\nThe `init.pl` file sets up the UnifyWeaver environment.\n\n### What It Does\n\n```prolog\n% education/init.pl typically contains:\n\n% 1. Set library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Print confirmation\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Why It's Necessary\n\nWithout init.pl:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nWith init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Library Search Paths\n\nProlog uses `file_search_path/2` to resolve library aliases:\n\n```prolog\n% Define alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Alternative: Using -f Flag\n\n```bash\n# Load init.pl automatically\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "answer_tailored": true}
{"pair_id": "init-pl-explained_p2", "cluster_id": "init-pl-explained", "question": "What does init.pl set up?", "question_type": "medium", "answer": "`init.pl` sets up the UnifyWeaver environment by defining library aliases and loading core modules required for compilation.\n\nKey setup actions include:\n- **Defining Search Paths:** It uses `user:file_search_path/2` to map the `unifyweaver` library alias to the project's source directory (`src/unifyweaver`). This ensures that statements like `use_module(unifyweaver(core/recursive_compiler))` resolve correctly.\n- **Loading Common Modules:** It pre-loads essential components such as `unifyweaver(core/compiler_driver)` so they are immediately available in the session.\n- **Environment Confirmation:** It provides visual feedback that the educational or development environment has been initialized.\n\nThe environment can be initialized by running `swipl -f education/init.pl`. For further details on project foundations, see `education/book-01-foundations/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["init.pl", "initialization", "setup", "library-paths"], "original_answer": "## Understanding init.pl\n\nThe `init.pl` file sets up the UnifyWeaver environment.\n\n### What It Does\n\n```prolog\n% education/init.pl typically contains:\n\n% 1. Set library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Print confirmation\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Why It's Necessary\n\nWithout init.pl:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nWith init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Library Search Paths\n\nProlog uses `file_search_path/2` to resolve library aliases:\n\n```prolog\n% Define alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Alternative: Using -f Flag\n\n```bash\n# Load init.pl automatically\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "answer_tailored": true}
{"pair_id": "init-pl-explained_p3", "cluster_id": "init-pl-explained", "question": "How do library search paths work in Prolog?", "question_type": "medium", "answer": "Prolog resolves library paths using the `file_search_path/2` predicate, which maps logical aliases to specific directory locations. This mechanism allows UnifyWeaver to import modules using consistent names rather than hardcoded or relative file paths.\n\n### Defining Search Paths\nA search path is established by asserting a fact into the `user` namespace. This defines how an alias should be expanded:\n```prolog\n% Define 'unifyweaver' as a library alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now Prolog can resolve this alias in import statements:\n:- use_module(unifyweaver(core/compiler_driver)).\n```\n\n### Automation with init.pl\nTo ensure the environment is correctly configured regardless of the working directory, UnifyWeaver utilizes an `init.pl` file. This script dynamically calculates the absolute path to the library and registers it:\n```prolog\n% Dynamically calculate and assert the search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n```\n\n### Usage and Importance\nWithout properly configured search paths, attempting to load a module via an alias will result in a `source_sink` error. You can automatically initialize these paths when starting the SWI-Prolog interpreter by using the `-f` flag:\n```bash\nswipl -f education/init.pl\n```\nOnce initialized, the environment is ready to resolve all internal UnifyWeaver dependencies.\n\nFor more details on library management and initial environment setup, refer to `education/book-01-foundations/01_introduction.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["init.pl", "initialization", "setup", "library-paths"], "original_answer": "## Understanding init.pl\n\nThe `init.pl` file sets up the UnifyWeaver environment.\n\n### What It Does\n\n```prolog\n% education/init.pl typically contains:\n\n% 1. Set library search path\n:- prolog_load_context(directory, Dir),\n   atom_concat(Dir, '/../src/unifyweaver', LibPath),\n   asserta(user:file_search_path(unifyweaver, LibPath)).\n\n% 2. Load common modules\n:- use_module(unifyweaver(core/compiler_driver)).\n\n% 3. Print confirmation\n:- writeln('[UnifyWeaver] Educational environment initialized.').\n```\n\n### Why It's Necessary\n\nWithout init.pl:\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\nERROR: source_sink `unifyweaver(core/recursive_compiler)' does not exist\n```\n\nWith init.pl:\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Library Search Paths\n\nProlog uses `file_search_path/2` to resolve library aliases:\n\n```prolog\n% Define alias\nuser:file_search_path(unifyweaver, 'src/unifyweaver').\n\n% Now these are equivalent:\nuse_module(unifyweaver(core/foo))\nuse_module('src/unifyweaver/core/foo')\n```\n\n### Alternative: Using -f Flag\n\n```bash\n# Load init.pl automatically\nswipl -f education/init.pl\n\n# Or from project root\nswipl -f init.pl\n```", "answer_tailored": true}
