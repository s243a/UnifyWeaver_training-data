{"pair_id": "compilation-pipeline_p0", "cluster_id": "compilation-pipeline", "question": "How does the UnifyWeaver compilation pipeline work?", "question_type": "medium", "answer": "The UnifyWeaver compilation pipeline functions by transforming Prolog predicates into executable target-language code through a multi-stage analysis and rendering process. Managed primarily by the modules within `src/unifyweaver/core/`, the workflow proceeds as follows:\n\n1. **Predicate Classification**: The `recursive_compiler.pl` module acts as the main dispatcher. It analyzes the predicate's structure to determine if it consists of simple facts and non-recursive rules (handled by `stream_compiler.pl`) or more complex recursive patterns.\n2. **Specialized Analysis**: Recursive predicates are further categorized to optimize code generation:\n   - **Tail Recursion**: Processed by `tail_recursion.pl`.\n   - **Linear Recursion**: Processed by `linear_recursion.pl`.\n   - **Mutual Recursion**: Handled by `mutual_recursion.pl`, which utilizes SCC (Strongly Connected Component) detection.\n3. **Constraint & Option Analysis**: The `constraint_analyzer.pl` module evaluates the predicate for specific requirements, such as `unique` or `ordered` constraints, which influence how the target code is structured.\n4. **Code Generation**: Finally, the `template_system.pl` engine selects the appropriate template for the requested target (e.g., Bash, Python, Go) and renders the final source files.\n\nYou can invoke the pipeline using the `compiler_driver` module:\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(predicate_name/Arity, [target(Language)], Scripts).\n```\n\nFor more detailed information on the architectural components, refer to `education/book-01-foundations/03_unifyweaver_architecture.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["architecture", "compilation", "pipeline", "recursive-compiler", "stream-compiler", "template-system"], "original_answer": "## Compilation Pipeline\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prolog Predicate \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Classify Pattern \u2502  (recursive_compiler.pl)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Non-Rec \u2502  \u2502 Recursive           \u2502\n\u2502stream  \u2502  \u2502 advanced_recursive  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Analyze Constraints & Options    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Select & Render Template         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Generated Code \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Core Modules\n\n```prolog\n% Module structure\nsrc/unifyweaver/core/\n\u251c\u2500\u2500 template_system.pl      % Template rendering engine\n\u251c\u2500\u2500 stream_compiler.pl      % Non-recursive predicates\n\u251c\u2500\u2500 recursive_compiler.pl   % Main dispatcher\n\u251c\u2500\u2500 constraint_analyzer.pl  % unique, ordered constraints\n\u2514\u2500\u2500 advanced/\n    \u251c\u2500\u2500 advanced_recursive_compiler.pl\n    \u251c\u2500\u2500 tail_recursion.pl\n    \u251c\u2500\u2500 linear_recursion.pl\n    \u2514\u2500\u2500 mutual_recursion.pl\n```\n\n## Classification\n\n```prolog\n% recursive_compiler dispatches based on pattern:\n% - Facts only \u2192 stream_compiler\n% - Non-recursive rules \u2192 stream_compiler  \n% - Tail recursion \u2192 tail_recursion.pl\n% - Linear recursion \u2192 linear_recursion.pl\n% - Mutual recursion \u2192 mutual_recursion.pl (SCC detection)\n```\n\n## Example: Compiling a Predicate\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n\n% Output:\n=== Compiling ancestor/2 ===\n  Constraints: [unique(true)]\nType: linear_recursion\nScripts: ['output/ancestor.sh']\n```", "answer_tailored": true}
{"pair_id": "compilation-pipeline_p1", "cluster_id": "compilation-pipeline", "question": "What are the core modules in UnifyWeaver?", "question_type": "medium", "answer": "UnifyWeaver\u2019s core architecture consists of several specialized Prolog modules located in `src/unifyweaver/core/` that orchestrate the transformation of Prolog predicates into target-language code.\n\nThe primary modules in the system are:\n\n*   **recursive_compiler.pl**: Functions as the main dispatcher, classifying Prolog patterns into specific recursive or non-recursive types.\n*   **stream_compiler.pl**: Handles the compilation of non-recursive predicates and simple facts.\n*   **template_system.pl**: The engine responsible for selecting and rendering the final templates into the desired target language.\n*   **constraint_analyzer.pl**: Processes predicate options and performance constraints, such as `unique` or `ordered` requirements.\n*   **Advanced Recursive Modules**: Specialized logic housed in the `advanced/` subdirectory, including `tail_recursion.pl`, `linear_recursion.pl`, and `mutual_recursion.pl` (which handles SCC detection).\n\nThe compilation pipeline follows a structured path where input predicates are classified, analyzed for constraints, and finally passed through the template system to generate executable scripts. For more in-depth details on the system's design, see `education/book-01-foundations/03_unifyweaver_architecture.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["architecture", "compilation", "pipeline", "recursive-compiler", "stream-compiler", "template-system"], "original_answer": "## Compilation Pipeline\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prolog Predicate \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Classify Pattern \u2502  (recursive_compiler.pl)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Non-Rec \u2502  \u2502 Recursive           \u2502\n\u2502stream  \u2502  \u2502 advanced_recursive  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Analyze Constraints & Options    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Select & Render Template         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Generated Code \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Core Modules\n\n```prolog\n% Module structure\nsrc/unifyweaver/core/\n\u251c\u2500\u2500 template_system.pl      % Template rendering engine\n\u251c\u2500\u2500 stream_compiler.pl      % Non-recursive predicates\n\u251c\u2500\u2500 recursive_compiler.pl   % Main dispatcher\n\u251c\u2500\u2500 constraint_analyzer.pl  % unique, ordered constraints\n\u2514\u2500\u2500 advanced/\n    \u251c\u2500\u2500 advanced_recursive_compiler.pl\n    \u251c\u2500\u2500 tail_recursion.pl\n    \u251c\u2500\u2500 linear_recursion.pl\n    \u2514\u2500\u2500 mutual_recursion.pl\n```\n\n## Classification\n\n```prolog\n% recursive_compiler dispatches based on pattern:\n% - Facts only \u2192 stream_compiler\n% - Non-recursive rules \u2192 stream_compiler  \n% - Tail recursion \u2192 tail_recursion.pl\n% - Linear recursion \u2192 linear_recursion.pl\n% - Mutual recursion \u2192 mutual_recursion.pl (SCC detection)\n```\n\n## Example: Compiling a Predicate\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n\n% Output:\n=== Compiling ancestor/2 ===\n  Constraints: [unique(true)]\nType: linear_recursion\nScripts: ['output/ancestor.sh']\n```", "answer_tailored": true}
{"pair_id": "compilation-pipeline_p2", "cluster_id": "compilation-pipeline", "question": "How does UnifyWeaver classify predicates?", "question_type": "medium", "answer": "UnifyWeaver classifies predicates by analyzing their structural patterns through the `recursive_compiler.pl` module in `src/unifyweaver/core/`. This classification determines which specialized compilation path the predicate follows:\n\n*   **Non-Recursive Predicates**: Simple facts and rules that do not involve self-references are categorized as \"Non-Rec\" and dispatched to the `stream_compiler.pl`.\n*   **Recursive Predicates**: These are further subdivided into specific patterns:\n    *   **Tail Recursion**: Handled by `tail_recursion.pl`.\n    *   **Linear Recursion**: Handled by `linear_recursion.pl`.\n    *   **Mutual Recursion**: Identified using Strongly Connected Component (SCC) detection and processed by `mutual_recursion.pl`.\n\nThis classification occurs early in the compilation pipeline, allowing the system to then perform targeted constraint analysis and select the optimal rendering template for the generated code. For a complete overview of the core modules and compilation stages, see `education/book-01-foundations/03_unifyweaver_architecture.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["architecture", "compilation", "pipeline", "recursive-compiler", "stream-compiler", "template-system"], "original_answer": "## Compilation Pipeline\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prolog Predicate \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Classify Pattern \u2502  (recursive_compiler.pl)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Non-Rec \u2502  \u2502 Recursive           \u2502\n\u2502stream  \u2502  \u2502 advanced_recursive  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Analyze Constraints & Options    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Select & Render Template         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Generated Code \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Core Modules\n\n```prolog\n% Module structure\nsrc/unifyweaver/core/\n\u251c\u2500\u2500 template_system.pl      % Template rendering engine\n\u251c\u2500\u2500 stream_compiler.pl      % Non-recursive predicates\n\u251c\u2500\u2500 recursive_compiler.pl   % Main dispatcher\n\u251c\u2500\u2500 constraint_analyzer.pl  % unique, ordered constraints\n\u2514\u2500\u2500 advanced/\n    \u251c\u2500\u2500 advanced_recursive_compiler.pl\n    \u251c\u2500\u2500 tail_recursion.pl\n    \u251c\u2500\u2500 linear_recursion.pl\n    \u2514\u2500\u2500 mutual_recursion.pl\n```\n\n## Classification\n\n```prolog\n% recursive_compiler dispatches based on pattern:\n% - Facts only \u2192 stream_compiler\n% - Non-recursive rules \u2192 stream_compiler  \n% - Tail recursion \u2192 tail_recursion.pl\n% - Linear recursion \u2192 linear_recursion.pl\n% - Mutual recursion \u2192 mutual_recursion.pl (SCC detection)\n```\n\n## Example: Compiling a Predicate\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n\n% Output:\n=== Compiling ancestor/2 ===\n  Constraints: [unique(true)]\nType: linear_recursion\nScripts: ['output/ancestor.sh']\n```", "answer_tailored": true}
{"pair_id": "compilation-pipeline_p3", "cluster_id": "compilation-pipeline", "question": "What is the difference between stream_compiler and recursive_compiler?", "question_type": "medium", "answer": "In UnifyWeaver's architecture, the `recursive_compiler` acts as the primary dispatcher for the compilation pipeline, while the `stream_compiler` is a specialized module dedicated to non-recursive logic.\n\nWhen a Prolog predicate enters the pipeline, the `recursive_compiler` (located in `src/unifyweaver/core/recursive_compiler.pl`) analyzes its structure to determine the appropriate compilation strategy:\n\n1.  **stream_compiler**: Handles predicates that consist of simple facts or non-recursive rules. These are rendered as standard data streams or iterative filters in the target language.\n2.  **recursive_compiler**: Dispatches recursive patterns to specialized sub-modules based on the type of recursion detected:\n    *   **Tail Recursion**: Handled by `tail_recursion.pl`.\n    *   **Linear Recursion**: Handled by `linear_recursion.pl`.\n    *   **Mutual Recursion**: Handled by `mutual_recursion.pl` after performing Strongly Connected Component (SCC) detection.\n\n### Module Relationship\n```prolog\n% src/unifyweaver/core/\n\u251c\u2500\u2500 recursive_compiler.pl   % Main dispatcher and pattern classifier\n\u251c\u2500\u2500 stream_compiler.pl      % Generates code for non-recursive predicates\n\u2514\u2500\u2500 advanced/               % Specialized recursive handlers\n    \u251c\u2500\u2500 tail_recursion.pl\n    \u251c\u2500\u2500 linear_recursion.pl\n    \u2514\u2500\u2500 mutual_recursion.pl\n```\n\nThe `recursive_compiler` ensures that each predicate is routed to the most efficient generator, whether it's a simple stream transformation or a complex recursive function. For more details on the classification process and the underlying module structure, refer to `education/book-01-foundations/03_unifyweaver_architecture.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["architecture", "compilation", "pipeline", "recursive-compiler", "stream-compiler", "template-system"], "original_answer": "## Compilation Pipeline\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prolog Predicate \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Classify Pattern \u2502  (recursive_compiler.pl)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Non-Rec \u2502  \u2502 Recursive           \u2502\n\u2502stream  \u2502  \u2502 advanced_recursive  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Analyze Constraints & Options    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Select & Render Template         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Generated Code \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Core Modules\n\n```prolog\n% Module structure\nsrc/unifyweaver/core/\n\u251c\u2500\u2500 template_system.pl      % Template rendering engine\n\u251c\u2500\u2500 stream_compiler.pl      % Non-recursive predicates\n\u251c\u2500\u2500 recursive_compiler.pl   % Main dispatcher\n\u251c\u2500\u2500 constraint_analyzer.pl  % unique, ordered constraints\n\u2514\u2500\u2500 advanced/\n    \u251c\u2500\u2500 advanced_recursive_compiler.pl\n    \u251c\u2500\u2500 tail_recursion.pl\n    \u251c\u2500\u2500 linear_recursion.pl\n    \u2514\u2500\u2500 mutual_recursion.pl\n```\n\n## Classification\n\n```prolog\n% recursive_compiler dispatches based on pattern:\n% - Facts only \u2192 stream_compiler\n% - Non-recursive rules \u2192 stream_compiler  \n% - Tail recursion \u2192 tail_recursion.pl\n% - Linear recursion \u2192 linear_recursion.pl\n% - Mutual recursion \u2192 mutual_recursion.pl (SCC detection)\n```\n\n## Example: Compiling a Predicate\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n\n% Output:\n=== Compiling ancestor/2 ===\n  Constraints: [unique(true)]\nType: linear_recursion\nScripts: ['output/ancestor.sh']\n```", "answer_tailored": true}
