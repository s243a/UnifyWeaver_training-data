{"pair_id": "recursion-patterns_p0", "cluster_id": "recursion-patterns", "question": "What recursion patterns does UnifyWeaver support?", "question_type": "medium", "answer": "UnifyWeaver supports five primary recursion patterns across its supported target languages (Bash, Python, and C#): Tail Recursion, Linear Recursion, Tree Recursion, Transitive Closure, and Mutual Recursion.\n\n### Core Recursion Patterns\n- **Tail Recursion:** The compiler detects when the recursive call is the final operation and optimizes it into an iterative loop. This prevents stack overflow and improves performance in targets like Bash and Python.\n- **Linear Recursion:** Standard single-branch recursive calls, typically used when computing scalar values (e.g., calculating Fibonacci numbers).\n- **Tree Recursion:** Involves multiple recursive calls to handle structural decomposition, such as traversing nested list structures or trees.\n- **Transitive Closure:** Specifically handles reachability queries (e.g., `ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y)`). It is compiled into a Breadth-First Search (BFS) implementation using memoization and a queue to manage the search frontier.\n- **Mutual Recursion:** Support for interdependent predicates where Predicate A calls Predicate B, which in turn calls Predicate A.\n\n### Key Differences\nThe compiler distinguishes between **Tree Recursion** (which decomposes data structures) and **Linear Recursion** (which operates on computed values). While tail-recursive calls are converted to loops, transitive closure queries are implemented via an explicit state-management pattern to ensure stability in non-logic-based target languages.\n\nFor more technical details on compilation strategies, refer to `docs/RECURSION_PATTERN_THEORY.md`. For target-specific implementation examples, see `education/book-02-bash-target/` and `education/book-03-python-runtime/`.", "answer_variant": "default", "answer_source": "docs/RECURSION_PATTERN_THEORY.md", "topics": ["recursion", "tail-recursion", "linear-recursion", "tree-recursion", "transitive-closure", "mutual-recursion"], "original_answer": "## Supported Recursion Patterns\n\n| Pattern | Description | Bash | Python | C# |\n|---------|-------------|:----:|:------:|:--:|\n| Tail Recursion | Last call is recursive | \u2705 | \u2705 | \u2705 |\n| Linear Recursion | Single recursive call | \u2705 | \u2705 | \u2705 |\n| Tree Recursion | Multiple recursive calls on structure | \u2705 | \u2705 | \u2705 |\n| Transitive Closure | Reachability queries | \u2705 | \u2705 | \u2705 |\n| Mutual Recursion | A calls B, B calls A | \u2705 | \u2705 | \u2705 |\n\n## Tree vs Linear Recursion\n\nThe key difference is **what gets passed** to recursive calls:\n\n```prolog\n% TREE RECURSION - structural decomposition\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n\n% LINEAR RECURSION - computed scalar values\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is computed\n    N2 is N - 2,           % N2 is computed\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n## Transitive Closure Compilation\n\n```prolog\n% Prolog (what you write)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompiles to BFS with memoization:\n\n```bash\n# Generated Bash (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand frontier...\n    done\n}\n```\n\n## Tail Recursion Optimization\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nCompiles to iterative loop (no stack growth).", "answer_tailored": true}
{"pair_id": "recursion-patterns_p1", "cluster_id": "recursion-patterns", "question": "What is the difference between tree and linear recursion?", "question_type": "medium", "answer": "The fundamental difference between tree and linear recursion in UnifyWeaver is determined by **the type of arguments passed to recursive calls**: tree recursion involves **structural decomposition**, whereas linear recursion handles **computed scalar values**.\n\n### Recursion Patterns at a Glance\n\n| Pattern | Description | Key Characteristic | Optimization |\n|---------|-------------|--------------------|:------------:|\n| **Tree** | Multiple calls on structures | Args from pattern matching | Structure Parsing |\n| **Linear** | Single or multiple calls on scalars | Args from arithmetic/computation | Memoization |\n| **Tail** | Last call is recursive | No work after recursion | Iterative Loop |\n\n### Tree Recursion (Structural Decomposition)\nTree recursion occurs when a predicate breaks down a compound data structure (like a tree or list) and recurses on its constituent parts.\n*   **Mechanism**: The arguments are variables bound during head unification (e.g., `Left` and `Right` subtrees extracted from a node `[Value, Left, Right]`).\n*   **Compilation**: UnifyWeaver generates structure-aware code to decompose the input and traverse the structural parts.\n\n```prolog\n% TREE RECURSION - structural parts are passed\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n```\n\n### Linear Recursion (Computed Aggregation)\nLinear recursion (referred to as \"linear with aggregation\" when it involves multiple recursive calls) handles steps based on computed values rather than structure parts.\n*   **Mechanism**: The arguments are typically scalars (numbers or atoms) resulting from computation (e.g., `N - 1`).\n*   **Compilation**: These patterns are compiled using memoization tables to ensure independent calls are efficient and to avoid the overhead of structural parsing.\n\n```prolog\n% LINEAR RECURSION - computed scalars are passed\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is a computed value\n    N2 is N - 2,           % N2 is a computed value\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\nFor a comprehensive explanation of how UnifyWeaver detects these patterns and routes them to different compiler backends, see `docs/RECURSION_PATTERN_THEORY.md`. You can find introductory recursion examples in `education/book-01-foundations/02_prolog_fundamentals.md` and target-specific implementations in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "docs/RECURSION_PATTERN_THEORY.md", "topics": ["recursion", "tail-recursion", "linear-recursion", "tree-recursion", "transitive-closure", "mutual-recursion"], "original_answer": "## Supported Recursion Patterns\n\n| Pattern | Description | Bash | Python | C# |\n|---------|-------------|:----:|:------:|:--:|\n| Tail Recursion | Last call is recursive | \u2705 | \u2705 | \u2705 |\n| Linear Recursion | Single recursive call | \u2705 | \u2705 | \u2705 |\n| Tree Recursion | Multiple recursive calls on structure | \u2705 | \u2705 | \u2705 |\n| Transitive Closure | Reachability queries | \u2705 | \u2705 | \u2705 |\n| Mutual Recursion | A calls B, B calls A | \u2705 | \u2705 | \u2705 |\n\n## Tree vs Linear Recursion\n\nThe key difference is **what gets passed** to recursive calls:\n\n```prolog\n% TREE RECURSION - structural decomposition\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n\n% LINEAR RECURSION - computed scalar values\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is computed\n    N2 is N - 2,           % N2 is computed\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n## Transitive Closure Compilation\n\n```prolog\n% Prolog (what you write)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompiles to BFS with memoization:\n\n```bash\n# Generated Bash (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand frontier...\n    done\n}\n```\n\n## Tail Recursion Optimization\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nCompiles to iterative loop (no stack growth).", "answer_tailored": true}
{"pair_id": "recursion-patterns_p2", "cluster_id": "recursion-patterns", "question": "How does UnifyWeaver compile transitive closures?", "question_type": "medium", "answer": "UnifyWeaver compiles transitive closures\u2014such as reachability queries or ancestor relationships\u2014by transforming recursive Prolog definitions into iterative search algorithms using Breadth-First Search (BFS) and memoization.\n\nWhen you define a transitive closure in Prolog:\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nThe compiler generates target code (Bash, Python, C#, etc.) that implements an iterative loop. This generated code maintains a `visited` set to prevent infinite recursion in cyclic graphs and a queue to manage the frontier expansion. For example, in the Bash target, it utilizes an associative array for memoization and an array-based queue to traverse the relationships. This ensures that reachability queries are both performant and stack-safe across all supported platforms.\n\nFor more technical details on how different recursion patterns are handled, refer to `docs/RECURSION_PATTERN_THEORY.md` or explore the implementation examples in `education/book-01-foundations/`.", "answer_variant": "default", "answer_source": "docs/RECURSION_PATTERN_THEORY.md", "topics": ["recursion", "tail-recursion", "linear-recursion", "tree-recursion", "transitive-closure", "mutual-recursion"], "original_answer": "## Supported Recursion Patterns\n\n| Pattern | Description | Bash | Python | C# |\n|---------|-------------|:----:|:------:|:--:|\n| Tail Recursion | Last call is recursive | \u2705 | \u2705 | \u2705 |\n| Linear Recursion | Single recursive call | \u2705 | \u2705 | \u2705 |\n| Tree Recursion | Multiple recursive calls on structure | \u2705 | \u2705 | \u2705 |\n| Transitive Closure | Reachability queries | \u2705 | \u2705 | \u2705 |\n| Mutual Recursion | A calls B, B calls A | \u2705 | \u2705 | \u2705 |\n\n## Tree vs Linear Recursion\n\nThe key difference is **what gets passed** to recursive calls:\n\n```prolog\n% TREE RECURSION - structural decomposition\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n\n% LINEAR RECURSION - computed scalar values\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is computed\n    N2 is N - 2,           % N2 is computed\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n## Transitive Closure Compilation\n\n```prolog\n% Prolog (what you write)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompiles to BFS with memoization:\n\n```bash\n# Generated Bash (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand frontier...\n    done\n}\n```\n\n## Tail Recursion Optimization\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nCompiles to iterative loop (no stack growth).", "answer_tailored": true}
{"pair_id": "recursion-patterns_p3", "cluster_id": "recursion-patterns", "question": "What is tail recursion optimization?", "question_type": "medium", "answer": "Tail recursion optimization in UnifyWeaver occurs when the recursive call is the final operation in a predicate. Instead of creating a new stack frame for each call, the compiler transforms the recursion into an efficient iterative loop, preventing stack growth and avoiding stack overflow errors for deep recursions.\n\nThis optimization is supported across various targets, including Bash, Python, and C#. In the following example, the recursive call to `count/3` is in the tail position:\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, \n    N1 is N - 1, \n    Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nWhen compiled, this Prolog logic is converted into a standard `while` or `for` loop in the target language. For implementation details regarding specific languages, refer to the target-specific documentation such as `education/book-02-bash-target/` or `education/book-03-python-target/`.", "answer_variant": "default", "answer_source": "docs/RECURSION_PATTERN_THEORY.md", "topics": ["recursion", "tail-recursion", "linear-recursion", "tree-recursion", "transitive-closure", "mutual-recursion"], "original_answer": "## Supported Recursion Patterns\n\n| Pattern | Description | Bash | Python | C# |\n|---------|-------------|:----:|:------:|:--:|\n| Tail Recursion | Last call is recursive | \u2705 | \u2705 | \u2705 |\n| Linear Recursion | Single recursive call | \u2705 | \u2705 | \u2705 |\n| Tree Recursion | Multiple recursive calls on structure | \u2705 | \u2705 | \u2705 |\n| Transitive Closure | Reachability queries | \u2705 | \u2705 | \u2705 |\n| Mutual Recursion | A calls B, B calls A | \u2705 | \u2705 | \u2705 |\n\n## Tree vs Linear Recursion\n\nThe key difference is **what gets passed** to recursive calls:\n\n```prolog\n% TREE RECURSION - structural decomposition\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n\n% LINEAR RECURSION - computed scalar values\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is computed\n    N2 is N - 2,           % N2 is computed\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n## Transitive Closure Compilation\n\n```prolog\n% Prolog (what you write)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompiles to BFS with memoization:\n\n```bash\n# Generated Bash (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand frontier...\n    done\n}\n```\n\n## Tail Recursion Optimization\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nCompiles to iterative loop (no stack growth).", "answer_tailored": true}
