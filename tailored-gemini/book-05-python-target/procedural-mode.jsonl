{"pair_id": "b5-c2-procedural-mode_p0", "cluster_id": "b5-c2-procedural-mode", "question": "What is procedural mode in the Python target?", "question_type": "medium", "answer": "Procedural mode is the default translation strategy for UnifyWeaver's Python target, converting Prolog predicates into Python generator functions that leverage streaming semantics. This approach allows for lazy evaluation and memory-efficient processing of large datasets.\n\nThe mode implements specific mapping patterns:\n- **Facts**: Translated into constant `yield` statements.\n- **Rules**: Converted into nested loops that iterate through generators.\n- **Constraints**: Represented as standard Python `if` conditions.\n- **Recursion**: Managed through memoization or loop-based optimizations to prevent stack overflows.\n\nTo maintain Prolog's set semantics, procedural mode incorporates an automatic deduplication mechanism within its streaming architecture. It uses a `seen` set (often hashing the JSON representation of results) to ensure that unique solutions are yielded exactly once:\n\n```python\ndef process_stream(records):\n    seen = set()\n    for record in records:\n        for result in _clause_0(record):\n            key = json.dumps(result, sort_keys=True)\n            if key not in seen:\n                seen.add(key)\n                yield result\n```\n\nFor further details on configuration and advanced usage, refer to `education/book-05-python-target/`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["procedural-mode", "streaming", "generator-functions"], "original_answer": "## Procedural Mode\n\nProcedural mode (default) translates Prolog predicates into Python generator functions with streaming semantics.\n\n### Translation Pattern\n\n- **Facts** \u2192 constant yields\n- **Rules** \u2192 nested generator loops\n- **Constraints** \u2192 `if` conditions\n- **Recursion** \u2192 memoization or loop optimization\n\n### Streaming Architecture\n\n```python\ndef process_stream(records):\n    seen = set()\n    for record in records:\n        for result in _clause_0(record):\n            key = json.dumps(result, sort_keys=True)\n            if key not in seen:\n                seen.add(key)\n                yield result\n```\n\n### Automatic Deduplication\n\nGenerated scripts use a `seen` set to ensure each unique result is yielded exactly once, matching Prolog's set semantics.", "answer_tailored": true}
{"pair_id": "b5-c2-procedural-mode_p1", "cluster_id": "b5-c2-procedural-mode", "question": "How does procedural mode handle streaming?", "question_type": "medium", "answer": "Procedural mode handles streaming by translating Prolog predicates into Python generator functions that utilize `yield` for lazy, on-demand evaluation. In this translation, facts become constant yields, rules are transformed into nested generator loops, and constraints are handled via `if` conditions. To ensure compliance with Prolog\u2019s set semantics, the streaming architecture includes an automatic deduplication mechanism using a `seen` set to track and yield only unique results. For more details on these translation patterns, refer to `education/book-05-python-target/02_procedural_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["procedural-mode", "streaming", "generator-functions"], "original_answer": "## Procedural Mode\n\nProcedural mode (default) translates Prolog predicates into Python generator functions with streaming semantics.\n\n### Translation Pattern\n\n- **Facts** \u2192 constant yields\n- **Rules** \u2192 nested generator loops\n- **Constraints** \u2192 `if` conditions\n- **Recursion** \u2192 memoization or loop optimization\n\n### Streaming Architecture\n\n```python\ndef process_stream(records):\n    seen = set()\n    for record in records:\n        for result in _clause_0(record):\n            key = json.dumps(result, sort_keys=True)\n            if key not in seen:\n                seen.add(key)\n                yield result\n```\n\n### Automatic Deduplication\n\nGenerated scripts use a `seen` set to ensure each unique result is yielded exactly once, matching Prolog's set semantics.", "answer_tailored": true}
{"pair_id": "b5-c2-procedural-mode_p2", "cluster_id": "b5-c2-procedural-mode", "question": "How are Prolog facts translated to Python?", "question_type": "medium", "answer": "In UnifyWeaver's Python target, Prolog facts are translated into constant yields within Python generator functions. Operating in the default procedural mode, the compiler uses streaming semantics where each fact becomes a `yield` statement. To maintain Prolog's set semantics, the generated scripts include a deduplication mechanism using a `seen` set, which ensures that each unique fact is emitted only once during execution. For more technical details on the translation patterns for facts and rules, see `education/book-05-python-target/02_procedural_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["procedural-mode", "streaming", "generator-functions"], "original_answer": "## Procedural Mode\n\nProcedural mode (default) translates Prolog predicates into Python generator functions with streaming semantics.\n\n### Translation Pattern\n\n- **Facts** \u2192 constant yields\n- **Rules** \u2192 nested generator loops\n- **Constraints** \u2192 `if` conditions\n- **Recursion** \u2192 memoization or loop optimization\n\n### Streaming Architecture\n\n```python\ndef process_stream(records):\n    seen = set()\n    for record in records:\n        for result in _clause_0(record):\n            key = json.dumps(result, sort_keys=True)\n            if key not in seen:\n                seen.add(key)\n                yield result\n```\n\n### Automatic Deduplication\n\nGenerated scripts use a `seen` set to ensure each unique result is yielded exactly once, matching Prolog's set semantics.", "answer_tailored": true}
{"pair_id": "b5-c2-constraints-arithmetic_p0", "cluster_id": "b5-c2-constraints-arithmetic", "question": "How does Python target handle arithmetic expressions?", "question_type": "medium", "answer": "In the Python target, arithmetic expressions are handled by translating Prolog's `is/2` predicate into standard Python assignments. The compiler maps Prolog operators directly to their Python counterparts: `+`, `-`, `*`, and `/` remain the same, while `mod` is converted to `%` and `**` is used for exponentiation.\n\nFor example, the Prolog rule `double(X, Y) :- Y is X * 2.` is compiled into a Python operation where `y = x * 2`. Comparison constraints that accompany these expressions are transformed into Python `if` statements to maintain logical consistency during execution.\n\nFurther details on arithmetic compilation and the procedural mode can be found in `education/book-05-python-target/02_procedural_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["constraints", "arithmetic", "compilation"], "original_answer": "## Arithmetic and Constraints\n\n### Arithmetic Compilation\n\nProlog `is/2` expressions translate directly to Python:\n\n```prolog\ndouble(X, Y) :- Y is X * 2.\n```\n\n```python\ndef _clause_0(record):\n    x = record.get('arg0')\n    if x is not None:\n        y = x * 2\n        yield {'arg0': x, 'arg1': y}\n```\n\n### Supported Operations\n\n| Prolog | Python | Description |\n|--------|--------|-------------|\n| `X + Y` | `x + y` | Addition |\n| `X - Y` | `x - y` | Subtraction |\n| `X * Y` | `x * y` | Multiplication |\n| `X / Y` | `x / y` | Division |\n| `X mod Y` | `x % y` | Modulo |\n| `X ** Y` | `x ** y` | Exponentiation |\n\n### Comparison Constraints\n\nConstraints become `if` conditions in Python.", "answer_tailored": true}
{"pair_id": "b5-c2-constraints-arithmetic_p1", "cluster_id": "b5-c2-constraints-arithmetic", "question": "How are Prolog constraints compiled to Python?", "question_type": "medium", "answer": "In the UnifyWeaver Python target, Prolog constraints and arithmetic expressions are compiled into native Python assignments and conditional statements. Arithmetic evaluation using the `is/2` operator maps directly to Python variable calculations, while comparison constraints are implemented as `if` blocks that guard the `yield` statements in the generated clause functions.\n\n### Arithmetic Compilation\nWhen the compiler encounters `is/2`, it generates direct Python arithmetic. For example:\n\n```prolog\ndouble(X, Y) :- Y is X * 2.\n```\n\nTranslates to a generator function where the result is calculated and yielded:\n\n```python\ndef _clause_0(record):\n    x = record.get('arg0')\n    if x is not None:\n        y = x * 2\n        yield {'arg0': x, 'arg1': y}\n```\n\n### Supported Mapping\nThe following table illustrates how Prolog operators are transformed into their Python equivalents:\n\n| Prolog | Python | Description |\n|--------|--------|-------------|\n| `X + Y` | `x + y` | Addition |\n| `X - Y` | `x - y` | Subtraction |\n| `X * Y` | `x * y` | Multiplication |\n| `X / Y` | `x / y` | Division |\n| `X mod Y` | `x % y` | Modulo |\n| `X ** Y` | `x ** y` | Exponentiation |\n\n### Comparison Constraints\nComparison operators (such as `>`, `<`, or `=:=`) are compiled into `if` conditions. If the condition evaluates to false, the clause fails to yield a record, mimicking Prolog's backtracking behavior.\n\nFor further technical details on procedural compilation, see the documentation in `education/book-05-python-target/`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["constraints", "arithmetic", "compilation"], "original_answer": "## Arithmetic and Constraints\n\n### Arithmetic Compilation\n\nProlog `is/2` expressions translate directly to Python:\n\n```prolog\ndouble(X, Y) :- Y is X * 2.\n```\n\n```python\ndef _clause_0(record):\n    x = record.get('arg0')\n    if x is not None:\n        y = x * 2\n        yield {'arg0': x, 'arg1': y}\n```\n\n### Supported Operations\n\n| Prolog | Python | Description |\n|--------|--------|-------------|\n| `X + Y` | `x + y` | Addition |\n| `X - Y` | `x - y` | Subtraction |\n| `X * Y` | `x * y` | Multiplication |\n| `X / Y` | `x / y` | Division |\n| `X mod Y` | `x % y` | Modulo |\n| `X ** Y` | `x ** y` | Exponentiation |\n\n### Comparison Constraints\n\nConstraints become `if` conditions in Python.", "answer_tailored": true}
{"pair_id": "b5-c2-constraints-arithmetic_p2", "cluster_id": "b5-c2-constraints-arithmetic", "question": "What arithmetic operations are supported?", "question_type": "medium", "answer": "UnifyWeaver supports a standard suite of arithmetic operations when compiling Prolog to Python. These operations are typically handled via the `is/2` predicate, which translates Prolog expressions into native Python code.\n\nThe following arithmetic mappings are supported:\n- **Addition:** `X + Y` becomes `x + y`\n- **Subtraction:** `X - Y` becomes `x - y`\n- **Multiplication:** `X * Y` becomes `x * y`\n- **Division:** `X / Y` becomes `x / y`\n- **Modulo:** `X mod Y` becomes `x % y`\n- **Exponentiation:** `X ** Y` becomes `x ** y`\n\nIn Python's procedural mode, these expressions are embedded directly within clause functions. For instance, the Prolog rule `double(X, Y) :- Y is X * 2.` is compiled into a Python function where `y = x * 2` is evaluated before yielding the result. Additionally, comparison constraints are converted into Python `if` statements to filter results.\n\nFor more information on arithmetic compilation and procedural mode, see `education/book-05-python-target/02_procedural_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["constraints", "arithmetic", "compilation"], "original_answer": "## Arithmetic and Constraints\n\n### Arithmetic Compilation\n\nProlog `is/2` expressions translate directly to Python:\n\n```prolog\ndouble(X, Y) :- Y is X * 2.\n```\n\n```python\ndef _clause_0(record):\n    x = record.get('arg0')\n    if x is not None:\n        y = x * 2\n        yield {'arg0': x, 'arg1': y}\n```\n\n### Supported Operations\n\n| Prolog | Python | Description |\n|--------|--------|-------------|\n| `X + Y` | `x + y` | Addition |\n| `X - Y` | `x - y` | Subtraction |\n| `X * Y` | `x * y` | Multiplication |\n| `X / Y` | `x / y` | Division |\n| `X mod Y` | `x % y` | Modulo |\n| `X ** Y` | `x ** y` | Exponentiation |\n\n### Comparison Constraints\n\nConstraints become `if` conditions in Python.", "answer_tailored": true}
{"pair_id": "b5-c2-io-formats_p0", "cluster_id": "b5-c2-io-formats", "question": "What input/output formats does the Python target support?", "question_type": "medium", "answer": "The Python target in UnifyWeaver supports JSONL, NUL-delimited JSON, and XML as its primary input and output formats.\n\n*   **JSONL (Default):** The target defaults to JSON Lines, where each line represents a single JSON object. This is ideal for standard shell piping.\n*   **NUL-Delimited JSON:** For binary-safe streaming that can handle embedded NUL characters, the target supports NUL-delimited records. This is enabled by setting `record_format(nul_json)` in the compiler options.\n*   **Native XML Input:** UnifyWeaver can process XML directly using `lxml.etree.iterparse`. This allows for memory-efficient streaming of large XML datasets by targeting specific tags, configured via the `input_source(xml('file.xml', ['tag']))` option.\n\nFor a deeper dive into these procedural mode data formats, refer to `education/book-05-python-target/02_procedural_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["jsonl", "nul-json", "xml", "io-formats"], "original_answer": "## Input/Output Formats\n\n### JSONL (Default)\n\nJSON Lines - one JSON object per line:\n\n```bash\necho '{\"x\": 5}\n{\"x\": 10}' | python3 script.py\n```\n\n### NUL-Delimited JSON\n\nBinary-safe streaming for embedded NULs:\n\n```prolog\ncompile_predicate_to_python(pred/2, [record_format(nul_json)], Code).\n```\n\n### Native XML Input\n\nDirect XML processing with lxml:\n\n```prolog\ncompile_predicate_to_python(process_products/1, [\n    input_source(xml('data.xml', ['product']))\n], Code).\n```\n\nUses `lxml.etree.iterparse` for memory-efficient streaming of large XML files.", "answer_tailored": true}
{"pair_id": "b5-c2-io-formats_p1", "cluster_id": "b5-c2-io-formats", "question": "How do I process XML files with Python target?", "question_type": "medium", "answer": "To process XML files using the UnifyWeaver Python target, you can utilize the native XML input source configuration during compilation. This allows for direct ingestion of XML data by specifying the source file and the specific tags you wish to process.\n\nYou configure this by providing the `input_source` option to the compilation predicate:\n\n```prolog\ncompile_predicate_to_python(process_products/1, [\n    input_source(xml('data.xml', ['product']))\n], Code).\n```\n\nUnder the hood, the generated code uses `lxml.etree.iterparse` to perform memory-efficient streaming. This approach is specifically designed to handle large XML datasets without exhausting system memory. For more information on procedural mode and input configurations, refer to `education/book-05-python-target/02_procedural_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["jsonl", "nul-json", "xml", "io-formats"], "original_answer": "## Input/Output Formats\n\n### JSONL (Default)\n\nJSON Lines - one JSON object per line:\n\n```bash\necho '{\"x\": 5}\n{\"x\": 10}' | python3 script.py\n```\n\n### NUL-Delimited JSON\n\nBinary-safe streaming for embedded NULs:\n\n```prolog\ncompile_predicate_to_python(pred/2, [record_format(nul_json)], Code).\n```\n\n### Native XML Input\n\nDirect XML processing with lxml:\n\n```prolog\ncompile_predicate_to_python(process_products/1, [\n    input_source(xml('data.xml', ['product']))\n], Code).\n```\n\nUses `lxml.etree.iterparse` for memory-efficient streaming of large XML files.", "answer_tailored": true}
{"pair_id": "b5-c2-io-formats_p2", "cluster_id": "b5-c2-io-formats", "question": "What is NUL-delimited JSON?", "question_type": "medium", "answer": "NUL-delimited JSON is a binary-safe streaming format designed for processing JSON records that might contain embedded NUL characters. Unlike the default JSONL format which uses newlines to separate objects, NUL-delimited JSON uses the NUL byte as a delimiter to ensure reliable record separation in complex data streams where standard line endings might appear within the data itself.\n\nIn UnifyWeaver's Python target, you can enable this format by specifying the `record_format(nul_json)` option during compilation:\n\n```prolog\ncompile_predicate_to_python(pred/2, [record_format(nul_json)], Code).\n```\n\nThis ensures the generated Python runtime can safely ingest and emit records without data corruption or parsing errors. For a complete guide on Python target input and output formats, refer to `education/book-05-python-target/02_procedural_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/02_procedural_mode.md", "topics": ["jsonl", "nul-json", "xml", "io-formats"], "original_answer": "## Input/Output Formats\n\n### JSONL (Default)\n\nJSON Lines - one JSON object per line:\n\n```bash\necho '{\"x\": 5}\n{\"x\": 10}' | python3 script.py\n```\n\n### NUL-Delimited JSON\n\nBinary-safe streaming for embedded NULs:\n\n```prolog\ncompile_predicate_to_python(pred/2, [record_format(nul_json)], Code).\n```\n\n### Native XML Input\n\nDirect XML processing with lxml:\n\n```prolog\ncompile_predicate_to_python(process_products/1, [\n    input_source(xml('data.xml', ['product']))\n], Code).\n```\n\nUses `lxml.etree.iterparse` for memory-efficient streaming of large XML files.", "answer_tailored": true}
