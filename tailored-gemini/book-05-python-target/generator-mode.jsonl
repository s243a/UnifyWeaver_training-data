{"pair_id": "b5-c3-generator-mode_p0", "cluster_id": "b5-c3-generator-mode", "question": "What is generator mode in the Python target?", "question_type": "medium", "answer": "Generator mode in the Python target is a compilation strategy designed to implement semi-naive fixpoint evaluation for recursive queries. It is primarily used for handling transitive closures (such as graph pathfinding), reachability queries, and recursive joins. By utilizing an iterative approach rather than standard recursion, it successfully avoids Python's default recursion depth limits during deep traversals.\n\nThe underlying semi-naive algorithm maintains two sets of facts:\n- **total**: The collection of all facts discovered throughout the process.\n- **delta**: The specific set of facts discovered in the most recent iteration.\n\nThe process begins by initializing both sets with base input facts. It then iteratively applies rules to the facts in **delta** to find new derivations. If new facts are found, they become the new **delta** for the next iteration; otherwise, the system has reached a fixpoint and the evaluation terminates.\n\nTo enable this mode during compilation, specify the `generator` mode in the compilation predicate:\n```prolog\ncompile_predicate_to_python(path/2, [mode(generator)], Code).\n```\n\nFurther details on implementation and usage can be found in `education/book-05-python-target/03_generator_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["generator-mode", "semi-naive", "fixpoint-evaluation"], "original_answer": "## Generator Mode\n\nGenerator mode implements semi-naive fixpoint evaluation for recursive queries.\n\n### When to Use Generator Mode\n\n- Transitive closure (all paths in a graph)\n- Reachability queries\n- Recursive joins\n- Deep recursion (avoiding Python's limit)\n\n### Semi-Naive Algorithm\n\nMaintains two sets:\n- **total** - All facts discovered so far\n- **delta** - Facts discovered in current iteration\n\n### Algorithm Steps\n\n1. Initialize total and delta with input facts\n2. Apply rules to facts in delta\n3. Add newly derived facts to new_delta\n4. If new_delta empty \u2192 fixpoint reached\n5. Otherwise delta = new_delta, repeat\n\n### Compilation\n\n```prolog\ncompile_predicate_to_python(path/2, [mode(generator)], Code).\n```", "answer_tailored": true}
{"pair_id": "b5-c3-generator-mode_p1", "cluster_id": "b5-c3-generator-mode", "question": "How does semi-naive fixpoint evaluation work?", "question_type": "medium", "answer": "Semi-naive fixpoint evaluation in UnifyWeaver functions by iteratively applying recursive rules specifically to the most recently discovered facts, preventing redundant computations and safely handling deep recursion. In the Python target, this is implemented via **Generator Mode** to support operations like transitive closure and graph reachability without hitting Python's recursion depth limits.\n\nThe algorithm manages two primary data structures:\n- **Total**: The set containing every unique fact discovered since the evaluation began.\n- **Delta**: The set containing only the new facts discovered during the previous iteration.\n\nThe evaluation process follows these stages:\n1. **Seeding**: Initialize both the total and delta sets with the base input facts.\n2. **Incremental Rule Application**: Apply the recursive rules only to the facts present in the current delta.\n3. **Capture**: Store any newly derived facts that are not already in the total set into a `new_delta`.\n4. **Fixpoint Check**: If `new_delta` is empty, the fixpoint has been reached and the evaluation terminates.\n5. **Update**: Add the `new_delta` to the total set, assign `new_delta` to be the next delta, and repeat the cycle.\n\nFor implementation examples and details on compiling predicates for this mode, refer to `education/book-05-python-target/03_generator_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["generator-mode", "semi-naive", "fixpoint-evaluation"], "original_answer": "## Generator Mode\n\nGenerator mode implements semi-naive fixpoint evaluation for recursive queries.\n\n### When to Use Generator Mode\n\n- Transitive closure (all paths in a graph)\n- Reachability queries\n- Recursive joins\n- Deep recursion (avoiding Python's limit)\n\n### Semi-Naive Algorithm\n\nMaintains two sets:\n- **total** - All facts discovered so far\n- **delta** - Facts discovered in current iteration\n\n### Algorithm Steps\n\n1. Initialize total and delta with input facts\n2. Apply rules to facts in delta\n3. Add newly derived facts to new_delta\n4. If new_delta empty \u2192 fixpoint reached\n5. Otherwise delta = new_delta, repeat\n\n### Compilation\n\n```prolog\ncompile_predicate_to_python(path/2, [mode(generator)], Code).\n```", "answer_tailored": true}
{"pair_id": "b5-c3-generator-mode_p2", "cluster_id": "b5-c3-generator-mode", "question": "When should I use generator mode vs procedural mode?", "question_type": "medium", "answer": "Use generator mode rather than procedural mode when your queries involve recursion that requires fixpoint evaluation, such as transitive closures (finding all paths in a graph), reachability analysis, or recursive joins. A key advantage of generator mode is its ability to handle deep recursion without triggering Python's stack depth limits.\n\nThis mode implements a semi-naive fixpoint algorithm using two primary data structures:\n*   **total**: Stores all facts discovered since the start of execution.\n*   **delta**: Contains only the facts identified during the most recent iteration.\n\nThe algorithm applies rules to the delta set and continues until no new facts are produced (reaching the fixpoint). To compile a predicate in this mode, use the following command:\n```prolog\ncompile_predicate_to_python(your_predicate/2, [mode(generator)], Code).\n```\n\nFor more details on when to apply these different execution strategies, see the documentation in `education/book-05-python-target/03_generator_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["generator-mode", "semi-naive", "fixpoint-evaluation"], "original_answer": "## Generator Mode\n\nGenerator mode implements semi-naive fixpoint evaluation for recursive queries.\n\n### When to Use Generator Mode\n\n- Transitive closure (all paths in a graph)\n- Reachability queries\n- Recursive joins\n- Deep recursion (avoiding Python's limit)\n\n### Semi-Naive Algorithm\n\nMaintains two sets:\n- **total** - All facts discovered so far\n- **delta** - Facts discovered in current iteration\n\n### Algorithm Steps\n\n1. Initialize total and delta with input facts\n2. Apply rules to facts in delta\n3. Add newly derived facts to new_delta\n4. If new_delta empty \u2192 fixpoint reached\n5. Otherwise delta = new_delta, repeat\n\n### Compilation\n\n```prolog\ncompile_predicate_to_python(path/2, [mode(generator)], Code).\n```", "answer_tailored": true}
{"pair_id": "b5-c3-frozendict_p0", "cluster_id": "b5-c3-frozendict", "question": "What is FrozenDict in the Python target?", "question_type": "medium", "answer": "FrozenDict is an immutable, hashable data structure implemented in the UnifyWeaver Python target to enable dictionary-like data to be stored in sets. Because standard Python `dict` objects are mutable and unhashable, they cannot be used for efficient duplicate detection during fixpoint iteration. FrozenDict provides a solution with the following characteristics:\n\n- **Immutability**: Once created, the content cannot be changed.\n- **Hashability**: It can be used as an element in a `set` or a key in another dictionary, allowing for $O(1)$ average lookup.\n- **Dictionary Interface**: It maintains a familiar interface, including the `get()` method for safe value access.\n\nThis structure is primarily used by the runtime to track seen facts and prevent infinite loops during recursive query execution.\n\n### Example Usage\n\n```python\n# Create from a standard dictionary\nfd = FrozenDict.from_dict({'id': 1, 'status': 'active'})\n\n# Add to a set for deduplication\nstates = set()\nstates.add(fd)\n\n# Membership testing\nis_seen = FrozenDict.from_dict({'id': 1, 'status': 'active'}) in states # True\n\n# Accessing values\nval = fd.get('status')\n\n# Revert to standard dict if needed\nd = fd.to_dict()\n```\n\nFor a deeper look at how this supports generator-mode execution, see `education/book-05-python-target/03_generator_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["frozendict", "hashable", "immutable", "data-structure"], "original_answer": "## FrozenDict Data Structure\n\nPython's `dict` is mutable and unhashable, so it can't be stored in a `set`. FrozenDict provides:\n\n- **Immutability** - Cannot be modified after creation\n- **Hashability** - Can be used as set elements\n- **Dictionary interface** - `get()` method for accessing values\n\n### Usage\n\n```python\n# Creating a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Using in a set (O(1) average lookup)\nfacts = set()\nfacts.add(fd)\n\n# Checking membership\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd2 in facts)  # True\n\n# Converting back to dict\nd = fd.to_dict()\n```\n\nThis enables efficient duplicate detection in fixpoint iteration.", "answer_tailored": true}
{"pair_id": "b5-c3-frozendict_p1", "cluster_id": "b5-c3-frozendict", "question": "Why can't Python dicts be used in sets?", "question_type": "medium", "answer": "Standard Python `dict` objects cannot be used in `set` elements because they are mutable, which makes them unhashable. In Python, a set requires its members to be hashable so that their position can be determined by a constant hash value; since a dictionary's contents can change, it cannot provide this stable hash.\n\nTo address this requirement for fixpoint iteration and duplicate detection, UnifyWeaver utilizes the `FrozenDict` structure:\n\n- **Immutability**: The object cannot be altered after creation, ensuring data integrity.\n- **Hashability**: It provides a stable hash value, enabling storage in sets and use as dictionary keys.\n- **Interface**: It maintains a dictionary-like interface, including the `.get()` method.\n\n### Example Usage\n\n```python\n# Wrap a standard dict into a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Successfully store in a set (providing O(1) average lookup)\nseen_facts = set()\nseen_facts.add(fd)\n\n# Content-based membership verification\nfd_copy = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd_copy in seen_facts)  # True\n\n# Extract back to a mutable dict if needed\nmutable_d = fd.to_dict()\n```\n\nBy using `FrozenDict`, the Python target can efficiently manage state and perform set-based operations on complex records. For more details on data structures in the Python runtime, see `education/book-05-python-target/03_generator_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["frozendict", "hashable", "immutable", "data-structure"], "original_answer": "## FrozenDict Data Structure\n\nPython's `dict` is mutable and unhashable, so it can't be stored in a `set`. FrozenDict provides:\n\n- **Immutability** - Cannot be modified after creation\n- **Hashability** - Can be used as set elements\n- **Dictionary interface** - `get()` method for accessing values\n\n### Usage\n\n```python\n# Creating a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Using in a set (O(1) average lookup)\nfacts = set()\nfacts.add(fd)\n\n# Checking membership\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd2 in facts)  # True\n\n# Converting back to dict\nd = fd.to_dict()\n```\n\nThis enables efficient duplicate detection in fixpoint iteration.", "answer_tailored": true}
{"pair_id": "b5-c3-frozendict_p2", "cluster_id": "b5-c3-frozendict", "question": "How does FrozenDict enable fixpoint evaluation?", "question_type": "medium", "answer": "FrozenDict enables fixpoint evaluation by providing a hashable and immutable alternative to standard Python dictionaries, allowing records to be stored in sets for rapid duplicate detection. During fixpoint iteration, the compiler must track \"seen\" facts to determine when no new information is being produced (the fixpoint). Because standard Python `dict` objects are mutable and unhashable, they cannot be used as elements in a `set`. \n\nFrozenDict facilitates this process through:\n- **Immutability**: Once created, the record cannot be modified, ensuring the integrity of the fact base.\n- **Hashability**: By implementing `__hash__`, FrozenDicts can be added to a `set`, enabling $O(1)$ average time complexity for membership checks.\n- **Dictionary Compatibility**: It maintains a `get()` interface for field access while allowing conversion back to a standard dictionary via `to_dict()`.\n\n### Example Implementation\n```python\n# Create a hashable record\nrecord = FrozenDict.from_dict({'id': 101, 'status': 'active'})\n\n# Store in a set for fixpoint tracking\nseen_facts = set()\nseen_facts.add(record)\n\n# Efficiently check for existing facts to prevent infinite recursion\nnew_fact = FrozenDict.from_dict({'id': 101, 'status': 'active'})\nif new_fact in seen_facts:\n    pass # Duplicate detected, termination condition check\n```\n\nFor more implementation details on Python state management, see `education/book-05-python-target/`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["frozendict", "hashable", "immutable", "data-structure"], "original_answer": "## FrozenDict Data Structure\n\nPython's `dict` is mutable and unhashable, so it can't be stored in a `set`. FrozenDict provides:\n\n- **Immutability** - Cannot be modified after creation\n- **Hashability** - Can be used as set elements\n- **Dictionary interface** - `get()` method for accessing values\n\n### Usage\n\n```python\n# Creating a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Using in a set (O(1) average lookup)\nfacts = set()\nfacts.add(fd)\n\n# Checking membership\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd2 in facts)  # True\n\n# Converting back to dict\nd = fd.to_dict()\n```\n\nThis enables efficient duplicate detection in fixpoint iteration.", "answer_tailored": true}
{"pair_id": "b5-c3-negation_p0", "cluster_id": "b5-c3-negation", "question": "How does generator mode handle negation?", "question_type": "medium", "answer": "In generator mode, negation is handled using **negation-as-failure (NAF)** combined with strict **stratification** requirements. The compiler enforces that a negated predicate cannot depend, directly or indirectly, on the predicate currently being defined. This validation occurs at compile time to ensure logical consistency.\n\n### Implementation Logic\nIn the generated Python code, the generator checks for the existence of the negated fact within the accumulated results (`total`). If the fact is found, the rule simply returns, which effectively implements the failure condition.\n\n### Example\n```prolog\nblocked(b, c).\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\n```\n\nThe corresponding Python implementation demonstrates this check:\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check if the negated fact exists in the total set\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation condition met, so the rule fails\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\nFor more details on Python target compilation and stratification rules, see `education/book-05-python-target/03_generator_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["negation", "stratification", "negation-as-failure"], "original_answer": "## Negation in Generator Mode\n\nGenerator mode supports negation-as-failure with stratification.\n\n### Example\n\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\n### Generated Python\n\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check negation\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\n### Stratification Requirement\n\nNegated predicates must not depend (directly or indirectly) on the predicate being defined. The compiler validates this at compile time.", "answer_tailored": true}
{"pair_id": "b5-c3-negation_p1", "cluster_id": "b5-c3-negation", "question": "What is stratified negation?", "question_type": "medium", "answer": "Stratified negation is a form of negation-as-failure where the compiler ensures that negated predicates do not depend, directly or indirectly, on the predicate being defined. This prevents logical cycles and ensures a consistent evaluation order across strata. In UnifyWeaver's Python generator mode, this is implemented by checking for the existence of facts in the current fact set before proceeding with a rule's execution.\n\n### Prolog Example\nThe following code demonstrates a safe path search that uses negation to avoid blocked edges:\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\n### Python Implementation\nWhen compiled to Python, the generator checks if the negated \"blocked\" fact exists in the known fact set (`total`). If found, the negation fails and the generator returns early:\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Stratified negation check\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails, stop generator\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\n### Constraints\nThe compiler performs dependency analysis at compile time to validate the stratification requirement. Any attempt to define a predicate that depends on its own negation will result in a compilation error. For more details on generator-based execution and negation, see `education/book-05-python-target/`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["negation", "stratification", "negation-as-failure"], "original_answer": "## Negation in Generator Mode\n\nGenerator mode supports negation-as-failure with stratification.\n\n### Example\n\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\n### Generated Python\n\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check negation\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\n### Stratification Requirement\n\nNegated predicates must not depend (directly or indirectly) on the predicate being defined. The compiler validates this at compile time.", "answer_tailored": true}
{"pair_id": "b5-c3-negation_p2", "cluster_id": "b5-c3-negation", "question": "Can I use negation in recursive predicates?", "question_type": "medium", "answer": "Yes, you can use negation within recursive predicates in UnifyWeaver's generator mode, provided the program is stratified. This means that a negated predicate cannot depend\u2014either directly or indirectly\u2014on the predicate currently being defined.\n\nFor example, a recursive `safe_path/2` predicate can use negation to exclude specific blocked edges:\n\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\nIn the generated Python code, the compiler implements this by checking for the existence of the negated fact in the current state before yielding results. If the negated fact (e.g., `blocked(X, Y)`) exists, the rule fails for that specific combination:\n\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check negation\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails, rule stops here\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\nThe compiler validates stratification requirements at compile time to ensure logical consistency. For more details on implementing negation in the Python target, see `education/book-05-python-target/03_generator_mode.md`.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["negation", "stratification", "negation-as-failure"], "original_answer": "## Negation in Generator Mode\n\nGenerator mode supports negation-as-failure with stratification.\n\n### Example\n\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\n### Generated Python\n\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check negation\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\n### Stratification Requirement\n\nNegated predicates must not depend (directly or indirectly) on the predicate being defined. The compiler validates this at compile time.", "answer_tailored": true}
