{"pair_id": "b4-c1-workflows-vs-playbooks_p0", "cluster_id": "b4-c1-workflows-vs-playbooks", "question": "What is the difference between workflows and playbooks in UnifyWeaver?", "question_type": "medium", "answer": "In UnifyWeaver, the distinction between workflows and playbooks centers on their scope: **Workflows** function as high-level strategic frameworks for decision-making, while **Playbooks** are tactical execution scripts used to perform specific tasks.\n\n### Core Differences\n\n*   **Focus:** Workflows address the \"What\" and \"Why\" (strategic goals and criteria), whereas Playbooks address the \"How\" (tactical commands and sequences).\n*   **Content:** A workflow defines logic and decision points (e.g., choosing between C# and Bash targets based on environment constraints). A playbook contains the actual implementation details, such as the parameters and steps required to compile a specific predicate.\n*   **Hierarchy:** Workflows orchestrate Playbooks. A workflow evaluates a situation and then triggers the appropriate playbook to execute the necessary steps.\n\n**Example Relationship:**\nA \"Deployment Workflow\" might determine if a system requires high performance. If the criteria are met, it executes a \"Rust Compilation Playbook\"; otherwise, it might run a \"Bash Stream Playbook.\"\n\nFor more detailed information on designing decision frameworks, see `education/book-04-workflows/`. Specific implementation examples can be found in the `playbooks/` directory.", "answer_variant": "default", "answer_source": "education/book-04-workflows/01_introduction.md", "topics": ["workflows", "playbooks", "strategic-hierarchy"], "original_answer": "## Workflows vs Playbooks\n\n**Workflows** are high-level strategic guides that define decision-making frameworks and processes.\n\n**Playbooks** are concrete execution scripts that implement specific steps.\n\n### Key Differences\n\n| Aspect | Workflows | Playbooks |\n|--------|-----------|------------|\n| Focus | What & Why | How |\n| Level | Strategic | Tactical |\n| Content | Goals, criteria, decisions | Commands, sequences, params |\n| Example | When to use C# vs Bash | How to compile factorial |\n\n### Relationship\n\nWorkflows reference playbooks as implementation details. A workflow defines the decision points; playbooks provide the execution steps for each choice.\n\n```\nWorkflow: \"Compilation Strategy\"\n\u251c\u2500 Decision: Is predicate recursive?\n\u2502  \u251c\u2500 YES \u2192 Playbook: \"Compile with Query Runtime\"\n\u2502  \u2514\u2500 NO  \u2192 Playbook: \"Compile with Stream Target\"\n```", "answer_tailored": true}
{"pair_id": "b4-c1-workflows-vs-playbooks_p1", "cluster_id": "b4-c1-workflows-vs-playbooks", "question": "How do workflows guide AI agents?", "question_type": "medium", "answer": "Workflows guide AI agents by providing high-level strategic frameworks that define decision-making logic and process goals. While playbooks function as tactical execution scripts (focusing on \"how\"), workflows establish the \"what\" and \"why,\" allowing agents to navigate complex architectural choices.\n\n### Strategic Guidance vs. Tactical Execution\n\n| Aspect | Workflows (Guidance) | Playbooks (Execution) |\n|--------|-----------|------------|\n| Role | Strategic Framework | Tactical Script |\n| Purpose | Defining goals and criteria | Commands and sequences |\n| Context | High-level decision making | Specific implementation steps |\n\n### How Agents Use Workflows\n\nAgents use workflows to determine which implementation path to take based on the specific context of a task. The workflow defines the decision points, while playbooks provide the execution steps for those choices. For example, a workflow for \"Compilation Strategy\" might guide an agent through a recursive check:\n\n1. **Strategic Decision:** Is the Prolog predicate recursive?\n2. **Path A (Recursive):** Workflow directs the agent to the \"Compile with Query Runtime\" playbook.\n3. **Path B (Non-Recursive):** Workflow directs the agent to the \"Compile with Stream Target\" playbook.\n\nBy following workflows, agents maintain strategic alignment across different target languages and execution environments. Further details on designing these frameworks are available in `education/book-04-workflows/`.", "answer_variant": "default", "answer_source": "education/book-04-workflows/01_introduction.md", "topics": ["workflows", "playbooks", "strategic-hierarchy"], "original_answer": "## Workflows vs Playbooks\n\n**Workflows** are high-level strategic guides that define decision-making frameworks and processes.\n\n**Playbooks** are concrete execution scripts that implement specific steps.\n\n### Key Differences\n\n| Aspect | Workflows | Playbooks |\n|--------|-----------|------------|\n| Focus | What & Why | How |\n| Level | Strategic | Tactical |\n| Content | Goals, criteria, decisions | Commands, sequences, params |\n| Example | When to use C# vs Bash | How to compile factorial |\n\n### Relationship\n\nWorkflows reference playbooks as implementation details. A workflow defines the decision points; playbooks provide the execution steps for each choice.\n\n```\nWorkflow: \"Compilation Strategy\"\n\u251c\u2500 Decision: Is predicate recursive?\n\u2502  \u251c\u2500 YES \u2192 Playbook: \"Compile with Query Runtime\"\n\u2502  \u2514\u2500 NO  \u2192 Playbook: \"Compile with Stream Target\"\n```", "answer_tailored": true}
{"pair_id": "b4-c1-workflows-vs-playbooks_p2", "cluster_id": "b4-c1-workflows-vs-playbooks", "question": "What is the relationship between workflows and playbooks?", "question_type": "medium", "answer": "Workflows and playbooks relate to each other as strategic guides versus tactical execution scripts. A workflow defines the high-level decision-making framework\u2014the \"what\" and \"why\"\u2014while a playbook implements the specific, concrete steps\u2014the \"how\"\u2014required to achieve a goal.\n\nIn the UnifyWeaver ecosystem, workflows reference playbooks as their implementation details. The workflow handles the logic of choosing a path, while the playbook provides the execution sequence for that path.\n\n### Key Distinctions\n\n| Aspect | Workflows | Playbooks |\n|--------|-----------|------------|\n| **Focus** | Strategic (What & Why) | Tactical (How) |\n| **Content** | Decision criteria and goals | Commands, sequences, and parameters |\n| **Example** | Determining when to use C# vs. Bash targets | Executing the compilation of a factorial function |\n\nFor example, a \"Compilation Strategy\" workflow defines decision points, such as checking if a predicate is recursive. Based on that decision, it triggers either a \"Query Runtime\" playbook or a \"Stream Target\" playbook to handle the actual execution.\n\nFor more information on implementing these processes, see the documentation in `education/book-04-workflows/`.", "answer_variant": "default", "answer_source": "education/book-04-workflows/01_introduction.md", "topics": ["workflows", "playbooks", "strategic-hierarchy"], "original_answer": "## Workflows vs Playbooks\n\n**Workflows** are high-level strategic guides that define decision-making frameworks and processes.\n\n**Playbooks** are concrete execution scripts that implement specific steps.\n\n### Key Differences\n\n| Aspect | Workflows | Playbooks |\n|--------|-----------|------------|\n| Focus | What & Why | How |\n| Level | Strategic | Tactical |\n| Content | Goals, criteria, decisions | Commands, sequences, params |\n| Example | When to use C# vs Bash | How to compile factorial |\n\n### Relationship\n\nWorkflows reference playbooks as implementation details. A workflow defines the decision points; playbooks provide the execution steps for each choice.\n\n```\nWorkflow: \"Compilation Strategy\"\n\u251c\u2500 Decision: Is predicate recursive?\n\u2502  \u251c\u2500 YES \u2192 Playbook: \"Compile with Query Runtime\"\n\u2502  \u2514\u2500 NO  \u2192 Playbook: \"Compile with Stream Target\"\n```", "answer_tailored": true}
{"pair_id": "b4-c2-playbook-format_p0", "cluster_id": "b4-c2-playbook-format", "question": "What is the structure of a UnifyWeaver playbook?", "question_type": "medium", "answer": "I will list the contents of the `education/` directory to ensure I have the full context for the playbook format.\n\nI will read the `02_playbook_format.md` file in `education/book-04-workflows/` to gather any additional details for a more complete answer.\n\nUnifyWeaver playbooks are organized as structured Markdown documents that provide AI agents with a precise execution plan. A playbook's structure typically includes:\n\n1.  **Frontmatter (YAML)**: Technical metadata including ID, version, prerequisites, and target language.\n2.  **Goal Statement and Context**: A clear definition of the task's objective, assumptions, and background details.\n3.  **Strategies**: A breakdown of different approaches based on trade-offs like cost, speed, and quality.\n4.  **Execution Steps**: Sequential procedures with exact commands and verification checks for each stage.\n5.  **Output Specifications**: Detailed definitions of expected results using `[!output]` callouts.\n6.  **Verification and Troubleshooting**: A checklist of success criteria and solutions for common failures.\n\nThe format also utilizes a specific callout system for clarity:\n*   `[!output]`: Identifies mandatory fields for generated artifacts (language, purpose, location).\n*   `[!example-record]`: References reusable logic from the codebase.\n*   `[!decision]`: Marks branch points or strategic choices in the workflow.\n*   `[!warning]` / `[!tip]`: Highlights critical safety info or performance optimizations.\n\nDetailed specifications for the playbook format and callout schema are available in `education/book-04-workflows/`.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["playbook-format", "callouts", "markdown-structure"], "original_answer": "## Playbook Structure\n\nPlaybooks use structured markdown with special callouts:\n\n### Sections\n\n1. **Header metadata**: Name, version, prerequisites\n2. **Overview**: What this playbook accomplishes\n3. **Steps**: Step-by-step procedures\n4. **Outputs**: Expected results\n5. **Troubleshooting**: Common issues\n\n### Callout Types\n\n| Callout | Purpose |\n|---------|----------|\n| `[!output]` | Expected command outputs |\n| `[!example-record]` | Reusable code patterns |\n| `[!decision]` | Branch points |\n| `[!warning]` | Important notes |\n\n### Example Step\n\n```markdown\n## Step 2: Compile the Predicate\n\n> [!action]\n> Run the compilation command\n\n```bash\nswipl -q -g \"compile(factorial/2, [], _), halt\"\n```\n\n> [!output]\n> Generated: factorial.sh\n```", "answer_tailored": true}
{"pair_id": "b4-c2-playbook-format_p1", "cluster_id": "b4-c2-playbook-format", "question": "What callout types are used in playbooks?", "question_type": "medium", "answer": "Playbooks employ specialized Markdown callout types to structure procedures and highlight key information. The primary callouts include:\n\n* **`[!action]`**: Specifies a task or command to be executed by the user.\n* **`[!output]`**: Illustrates the expected results or console output from a preceding action.\n* **`[!example-record]`**: Marks reusable code patterns or architectural examples.\n* **`[!decision]`**: Indicates logical branch points where the workflow may diverge.\n* **`[!warning]`**: Flags critical information or potential issues to keep in mind.\n\nThese structured callouts ensure that playbooks remain consistent and easy to follow. You can find the full specification for these elements in `education/book-04-workflows/02_playbook_format.md`.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["playbook-format", "callouts", "markdown-structure"], "original_answer": "## Playbook Structure\n\nPlaybooks use structured markdown with special callouts:\n\n### Sections\n\n1. **Header metadata**: Name, version, prerequisites\n2. **Overview**: What this playbook accomplishes\n3. **Steps**: Step-by-step procedures\n4. **Outputs**: Expected results\n5. **Troubleshooting**: Common issues\n\n### Callout Types\n\n| Callout | Purpose |\n|---------|----------|\n| `[!output]` | Expected command outputs |\n| `[!example-record]` | Reusable code patterns |\n| `[!decision]` | Branch points |\n| `[!warning]` | Important notes |\n\n### Example Step\n\n```markdown\n## Step 2: Compile the Predicate\n\n> [!action]\n> Run the compilation command\n\n```bash\nswipl -q -g \"compile(factorial/2, [], _), halt\"\n```\n\n> [!output]\n> Generated: factorial.sh\n```", "answer_tailored": true}
{"pair_id": "b4-c2-playbook-format_p2", "cluster_id": "b4-c2-playbook-format", "question": "How do you write a playbook in markdown?", "question_type": "medium", "answer": "To write a playbook in markdown, you use a structured format that combines standard Markdown headers with specialized callout tags to define procedures and expected results. The process involves organizing your content into specific sections and using callouts to highlight actions or outputs.\n\n### Key Sections\nA standard playbook includes the following components:\n- **Metadata Header**: Defines the playbook name, version, and necessary prerequisites.\n- **Overview**: A brief explanation of the playbook's goal.\n- **Steps**: The core procedural instructions.\n- **Outputs**: Descriptions of what the user should see after completion.\n- **Troubleshooting**: Guidance for resolving frequent errors.\n\n### Using Special Callouts\nUnifyWeaver playbooks utilize distinct callout syntax to provide semantic meaning to the documentation:\n*   `[!action]`: Specifies a task to perform.\n*   `[!output]`: Displays expected command-line results.\n*   `[!example-record]`: Highlights reusable code patterns.\n*   `[!decision]`: Marks points where a choice or branch occurs.\n*   `[!warning]`: Indicates critical notes or safety information.\n\n### Markdown Example\nWhen writing a step, you combine a header, a callout for the action, and a code block:\n\n```markdown\n## Step 1: Initialize Project\n\n> [!action]\n> Initialize the local environment.\n\n```bash\nunifyweaver-init .\n```\n\n> [!output]\n> Initialization complete.\n```\n\nFor more detailed specifications on the playbook format, refer to the documentation in `education/book-04-workflows/02_playbook_format.md`.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["playbook-format", "callouts", "markdown-structure"], "original_answer": "## Playbook Structure\n\nPlaybooks use structured markdown with special callouts:\n\n### Sections\n\n1. **Header metadata**: Name, version, prerequisites\n2. **Overview**: What this playbook accomplishes\n3. **Steps**: Step-by-step procedures\n4. **Outputs**: Expected results\n5. **Troubleshooting**: Common issues\n\n### Callout Types\n\n| Callout | Purpose |\n|---------|----------|\n| `[!output]` | Expected command outputs |\n| `[!example-record]` | Reusable code patterns |\n| `[!decision]` | Branch points |\n| `[!warning]` | Important notes |\n\n### Example Step\n\n```markdown\n## Step 2: Compile the Predicate\n\n> [!action]\n> Run the compilation command\n\n```bash\nswipl -q -g \"compile(factorial/2, [], _), halt\"\n```\n\n> [!output]\n> Generated: factorial.sh\n```", "answer_tailored": true}
{"pair_id": "b4-c2-callout-types_p0", "cluster_id": "b4-c2-callout-types", "question": "What is the [!example-record] callout format?", "question_type": "medium", "answer": "The `[!example-record]` callout is a structured Markdown format used to document reusable patterns and examples within UnifyWeaver playbooks. It organizes metadata within a blockquote to ensure examples are searchable and well-categorized:\n\n```markdown\n> [!example-record]\n> id: YYYYMMDD-name\n> name: unifyweaver.category.specific\n> pattern: pattern_type\n> difficulty: beginner|intermediate|advanced\n```\n\n### Metadata Configuration\n- **id**: A required unique identifier using the `YYYYMMDD-name` convention.\n- **name**: A required namespaced identifier (e.g., `unifyweaver.logic.recursion`).\n- **pattern**: An optional field for classifying the pattern type.\n- **difficulty**: An optional rating (beginner, intermediate, or advanced).\n- **Relationships**: Fields like `parent_example`, `child_examples`, and `related` allow for mapping dependencies and cross-references between records.\n- **tags**: Optional keywords for improved discovery.\n\nThis format is typically complemented by the `[!output]` callout, which displays the expected command output to verify the example's correctness. For a complete guide on playbook documentation standards, refer to `education/book-04-workflows/02_playbook_format.md`.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["example-record", "output-callout", "metadata"], "original_answer": "## Example Record Callout\n\nThe `[!example-record]` callout documents reusable patterns:\n\n```markdown\n> [!example-record]\n> id: YYYYMMDD-name\n> name: unifyweaver.category.specific\n> pattern: pattern_type\n> difficulty: beginner|intermediate|advanced\n```\n\n### Metadata Fields\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `id` | Yes | Unique ID (YYYYMMDD-name) |\n| `name` | Yes | Namespaced name |\n| `pattern` | No | Classification |\n| `difficulty` | No | beginner/intermediate/advanced |\n| `parent_example` | No | Parent example ID |\n| `child_examples` | No | List of dependents |\n| `related` | No | Cross-references |\n| `tags` | No | Additional tags |\n\n### Output Callout\n\n```markdown\n> [!output]\n> factorial 5\n> 120\n```\n\nShows expected command output for verification.", "answer_tailored": true}
{"pair_id": "b4-c2-callout-types_p1", "cluster_id": "b4-c2-callout-types", "question": "How do you document expected outputs in playbooks?", "question_type": "medium", "answer": "Expected outputs in UnifyWeaver playbooks are documented using the `[!output]` callout, which displays the specific command and its corresponding verified result. This format ensures that users can easily compare their local execution against the intended outcome.\n\n```markdown\n> [!output]\n> factorial 5\n> 120\n```\n\nTo provide context for these outputs, they are typically preceded by an `[!example-record]` callout. This callout contains metadata for the example, including required fields like a unique `id` (YYYYMMDD-name) and a namespaced `name`. It can also include optional classification such as `pattern` type, `difficulty` (beginner, intermediate, or advanced), and relationship markers like `parent_example`, `child_examples`, or `related` tags.\n\nFor more details on the specific syntax and available metadata fields, see `education/book-04-workflows/02_playbook_format.md`.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["example-record", "output-callout", "metadata"], "original_answer": "## Example Record Callout\n\nThe `[!example-record]` callout documents reusable patterns:\n\n```markdown\n> [!example-record]\n> id: YYYYMMDD-name\n> name: unifyweaver.category.specific\n> pattern: pattern_type\n> difficulty: beginner|intermediate|advanced\n```\n\n### Metadata Fields\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `id` | Yes | Unique ID (YYYYMMDD-name) |\n| `name` | Yes | Namespaced name |\n| `pattern` | No | Classification |\n| `difficulty` | No | beginner/intermediate/advanced |\n| `parent_example` | No | Parent example ID |\n| `child_examples` | No | List of dependents |\n| `related` | No | Cross-references |\n| `tags` | No | Additional tags |\n\n### Output Callout\n\n```markdown\n> [!output]\n> factorial 5\n> 120\n```\n\nShows expected command output for verification.", "answer_tailored": true}
{"pair_id": "b4-c2-callout-types_p2", "cluster_id": "b4-c2-callout-types", "question": "What metadata fields are used in example records?", "question_type": "medium", "answer": "Example records in UnifyWeaver utilize the `[!example-record]` callout format to define metadata for reusable library patterns. The specific fields used include:\n\n*   **id** (Required): A unique identifier following the `YYYYMMDD-name` format.\n*   **name** (Required): A namespaced name identifying the record (e.g., `unifyweaver.category.specific`).\n*   **pattern**: An optional classification tag for the pattern type.\n*   **difficulty**: An optional indicator of complexity level (`beginner`, `intermediate`, or `advanced`).\n*   **parent_example**: An optional identifier for a parent record in a hierarchy.\n*   **child_examples**: An optional list of dependent or related child examples.\n*   **related**: Optional cross-references to other relevant library records.\n*   **tags**: Additional labels for supplemental classification.\n\nThese fields ensure that patterns are well-documented and easily discoverable. For more details on the playbook format and example records, see `education/book-04-workflows/02_playbook_format.md`.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["example-record", "output-callout", "metadata"], "original_answer": "## Example Record Callout\n\nThe `[!example-record]` callout documents reusable patterns:\n\n```markdown\n> [!example-record]\n> id: YYYYMMDD-name\n> name: unifyweaver.category.specific\n> pattern: pattern_type\n> difficulty: beginner|intermediate|advanced\n```\n\n### Metadata Fields\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `id` | Yes | Unique ID (YYYYMMDD-name) |\n| `name` | Yes | Namespaced name |\n| `pattern` | No | Classification |\n| `difficulty` | No | beginner/intermediate/advanced |\n| `parent_example` | No | Parent example ID |\n| `child_examples` | No | List of dependents |\n| `related` | No | Cross-references |\n| `tags` | No | Additional tags |\n\n### Output Callout\n\n```markdown\n> [!output]\n> factorial 5\n> 120\n```\n\nShows expected command output for verification.", "answer_tailored": true}
