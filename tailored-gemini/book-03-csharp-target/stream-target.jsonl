{"pair_id": "csharp-stream-target_p0", "cluster_id": "csharp-stream-target", "question": "What is the C# Stream Target?", "question_type": "medium", "answer": "The C# Stream Target is a UnifyWeaver compilation backend that translates Prolog predicates into functional LINQ pipelines in C#. It maps logical relationships to streaming data structures, where Prolog facts are represented as static arrays and rules are implemented using standard LINQ operators like `Select`, `Where`, and `Distinct()`. Multiple clauses for the same predicate are handled through `Union` operations.\n\n### Core Mappings\n- **Facts** \u2192 Static C# arrays.\n- **Rules** \u2192 LINQ `Select` and `Where` transformations.\n- **Multiple Clauses** \u2192 Combined using `Union`.\n- **Deduplication** \u2192 Handled via `Distinct()`.\n\n### Example: Fact Compilation\n**Prolog Input:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C# Output:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### How to Compile\nTo generate the C# implementation for a predicate, use the following Prolog command:\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Mapping and Inference\nThe target automatically infers C# types from Prolog terms:\n- `int` for integers (e.g., `42`)\n- `double` for floats (e.g., `3.14`)\n- `string` for atoms\n- Tuples (e.g., `(string, string)`) for compound terms\n\nFor a deeper dive into the C# implementation details, see `education/book-03-csharp-target/`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["stream-target", "linq", "csharp", "facts"], "original_answer": "## C# Stream Target\n\nThe Stream Target compiles Prolog to LINQ pipelines:\n\n- **Facts** \u2192 C# arrays\n- **Rules** \u2192 LINQ Select/Where\n- **Multiple clauses** \u2192 Union\n- **Deduplication** \u2192 Distinct()\n\n### Example: Facts to Arrays\n\n**Prolog:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C#:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Compile Command\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Inference\n\n| Prolog | C# Type |\n|--------|--------|\n| `42` | `int` |\n| `3.14` | `double` |\n| `atom` | `string` |\n| `(a, b)` | `(string, string)` |", "answer_tailored": true}
{"pair_id": "csharp-stream-target_p1", "cluster_id": "csharp-stream-target", "question": "How are Prolog facts translated to C#?", "question_type": "medium", "answer": "Prolog facts are translated to C# by converting them into static readonly arrays within a generated class. This class exposes the data through a `Stream()` method that returns an `IEnumerable`, allowing the facts to be seamlessly integrated into LINQ-based pipelines.\n\n### Example Conversion\nWhen compiling Prolog facts like these:\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\nThe UnifyWeaver compiler generates the following C# structure:\n```csharp\npublic static class Parent\n{\n    // Facts are stored in a static array\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    // The Stream method provides LINQ compatibility\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Type Mapping and Inference\nThe translation process maps Prolog data types to their C# equivalents:\n- **Atoms** translate to `string`\n- **Integers** translate to `int`\n- **Floats** translate to `double`\n- **Compounds** translate to `ValueTuple` (e.g., `(string, string)`)\n\n### Compilation Command\nTo generate the C# source for a fact-based predicate, use the following Prolog command:\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\nFor a comprehensive guide on C# code generation and stream processing, see `education/book-03-csharp-target/02_csharp_stream_target.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["stream-target", "linq", "csharp", "facts"], "original_answer": "## C# Stream Target\n\nThe Stream Target compiles Prolog to LINQ pipelines:\n\n- **Facts** \u2192 C# arrays\n- **Rules** \u2192 LINQ Select/Where\n- **Multiple clauses** \u2192 Union\n- **Deduplication** \u2192 Distinct()\n\n### Example: Facts to Arrays\n\n**Prolog:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C#:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Compile Command\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Inference\n\n| Prolog | C# Type |\n|--------|--------|\n| `42` | `int` |\n| `3.14` | `double` |\n| `atom` | `string` |\n| `(a, b)` | `(string, string)` |", "answer_tailored": true}
{"pair_id": "csharp-stream-target_p2", "cluster_id": "csharp-stream-target", "question": "What LINQ operations are generated?", "question_type": "medium", "answer": "The UnifyWeaver C# Stream Target generates several standard LINQ operations to translate Prolog logic into functional C# pipelines. Prolog rules are primarily compiled into `Select` and `Where` calls for projection and filtering. When a predicate contains multiple clauses, the compiler uses the `Union` operation to combine the results, and `Distinct()` is applied to handle deduplication. Additionally, predicate facts are represented as C# arrays and converted into streams using `AsEnumerable()`.\n\nYou can find more detailed examples and the type inference mapping in education/book-03-csharp-target/02_csharp_stream_target.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["stream-target", "linq", "csharp", "facts"], "original_answer": "## C# Stream Target\n\nThe Stream Target compiles Prolog to LINQ pipelines:\n\n- **Facts** \u2192 C# arrays\n- **Rules** \u2192 LINQ Select/Where\n- **Multiple clauses** \u2192 Union\n- **Deduplication** \u2192 Distinct()\n\n### Example: Facts to Arrays\n\n**Prolog:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C#:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Compile Command\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Inference\n\n| Prolog | C# Type |\n|--------|--------|\n| `42` | `int` |\n| `3.14` | `double` |\n| `atom` | `string` |\n| `(a, b)` | `(string, string)` |", "answer_tailored": true}
{"pair_id": "csharp-stream-target_p3", "cluster_id": "csharp-stream-target", "question": "How do I compile facts to C# arrays?", "question_type": "medium", "answer": "To compile Prolog facts into C# arrays, UnifyWeaver uses its Stream Target to map predicates into static readonly arrays within a generated class. This structure allows Prolog data to be exposed as `IEnumerable` collections for use in LINQ pipelines.\n\n### Example: Fact Compilation\n\n**Prolog Source:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C# Class:**\n```csharp\npublic static class Parent\n{\n    // Facts are stored in a static readonly array of tuples\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### How to Run the Compilation\n\nUse the `compile_predicate_to_csharp/3` predicate to generate the code and write it to a file:\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Data Type Mapping\n\nThe UnifyWeaver compiler performs the following type inferences when generating the C# array:\n\n| Prolog Term | C# Target Type |\n|-------------|----------------|\n| `42`        | `int`          |\n| `3.14`      | `double`       |\n| `atom`      | `string`       |\n| `(a, b)`    | `(string, string)` |\n\nFor a deeper dive into LINQ pipeline generation, including rules and deduplication, see `education/book-03-csharp-target/02_csharp_stream_target.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["stream-target", "linq", "csharp", "facts"], "original_answer": "## C# Stream Target\n\nThe Stream Target compiles Prolog to LINQ pipelines:\n\n- **Facts** \u2192 C# arrays\n- **Rules** \u2192 LINQ Select/Where\n- **Multiple clauses** \u2192 Union\n- **Deduplication** \u2192 Distinct()\n\n### Example: Facts to Arrays\n\n**Prolog:**\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\n```\n\n**Generated C#:**\n```csharp\npublic static class Parent\n{\n    static readonly (string, string)[] Facts = {\n        (\"alice\", \"bob\"),\n        (\"bob\", \"charlie\")\n    };\n\n    public static IEnumerable<(string, string)> Stream()\n        => Facts.AsEnumerable();\n}\n```\n\n### Compile Command\n\n```prolog\n?- compile_predicate_to_csharp(parent/2, [], Code),\n   open('Parent.cs', write, S),\n   write(S, Code),\n   close(S).\n```\n\n### Type Inference\n\n| Prolog | C# Type |\n|--------|--------|\n| `42` | `int` |\n| `3.14` | `double` |\n| `atom` | `string` |\n| `(a, b)` | `(string, string)` |", "answer_tailored": true}
{"pair_id": "csharp-stream-rules_p0", "cluster_id": "csharp-stream-rules", "question": "How are Prolog rules translated to LINQ?", "question_type": "medium", "answer": "Prolog rules are translated to C# LINQ by mapping logical goals and variable relationships to functional sequence operations such as `.Where()`, `.Join()`, and `.Union()`. This transformation allows UnifyWeaver to execute Prolog logic as a high-performance data pipeline.\n\n### Filtering and Selection\nSimple rules that apply constraints to variables are translated into `.Where()` clauses for filtering, while the rule head defines the final `.Select()` projection.\n\n**Prolog:**\n```prolog\nadult(Person) :-\n    age(Person, Age),\n    Age >= 18.\n```\n\n**LINQ Translation:**\n```csharp\nreturn AgeFacts\n    .Where(t => t.Item2 >= 18)  // Age >= 18\n    .Select(t => t.Item1);       // Return Person\n```\n\n### Relational Joins\nWhen multiple goals in a rule body share a variable, the compiler generates a `.Join()` operation. A common example is the `grandparent` relationship joining on a shared parent variable `P`:\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**LINQ Translation:**\n```csharp\nreturn ParentFacts.Join(\n    ParentFacts,\n    outer => outer.Item2,  // Match on P (child of GP)\n    inner => inner.Item1,  // Match on P (parent of GC)\n    (outer, inner) => (outer.Item1, inner.Item2) // Result (GP, GC)\n);\n```\n\n### Multiple Clauses and Disjunction\nIf a predicate is defined by multiple facts or rules, UnifyWeaver aggregates the results into a single stream using the `.Union()` method.\n\n**Prolog:**\n```prolog\nsibling(alice, bob).\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.\n```\n\n**LINQ Translation:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = /* generated LINQ for the sibling rule */;\nreturn clause1.Union(clause2);\n```\n\nFor more detailed information on the C# stream target implementation, see `education/book-03-csharp-target/02_csharp_stream_target.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["rules", "linq", "where", "join"], "original_answer": "## Rules to LINQ Translation\n\n### Simple Rule with Conditions\n\n**Prolog:**\n```prolog\nadult(Person) :-\n    age(Person, Age),\n    Age >= 18.\n```\n\n**Generated C#:**\n```csharp\npublic static IEnumerable<string> Stream()\n{\n    return AgeFacts\n        .Where(t => t.Item2 >= 18)  // Age >= 18\n        .Select(t => t.Item1);       // Return Person\n}\n```\n\n### Join Pattern (Grandparent)\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C#:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // P (child)\n        inner => inner.Item1,  // P (parent)\n        (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n    );\n```\n\n### Multiple Clauses \u2192 Union\n\n**Prolog:**\n```prolog\nsibling(alice, bob).  % Fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule\n```\n\n**Generated:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = /* computed siblings */;\nreturn clause1.Union(clause2);  // Combines both\n```", "answer_tailored": true}
{"pair_id": "csharp-stream-rules_p1", "cluster_id": "csharp-stream-rules", "question": "How does the Join operation work in C#?", "question_type": "medium", "answer": "In UnifyWeaver, Prolog conjunctions that represent joins are translated directly into C# LINQ `.Join()` operations. This allows the compiler to bridge two data streams by matching shared variables, such as when linking generations in a grandparent relationship.\n\n### Join Pattern Translation (Grandparent Example)\n\n**Prolog Source:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C# LINQ:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // Links the shared variable P (child of GP)\n        inner => inner.Item1,  // Links the shared variable P (parent of GC)\n        (outer, inner) => (outer.Item1, inner.Item2)  // Projects the result (GP, GC)\n    );\n```\n\n### Key Components of the Translation:\n*   **Key Selectors:** The compiler identifies shared variables (like `P`) and generates selectors for the outer and inner streams to perform the match.\n*   **Result Selector:** A projection is created to return the variables specified in the Prolog head (e.g., `GP` and `GC`).\n*   **Stream Composition:** These joins can be chained or combined with `.Where()` for conditions or `.Union()` for multiple clauses to fulfill complex logic.\n\nFor a deeper look at how relational logic is mapped to C# streams, refer to `education/book-03-csharp-target/02_csharp_stream_target.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["rules", "linq", "where", "join"], "original_answer": "## Rules to LINQ Translation\n\n### Simple Rule with Conditions\n\n**Prolog:**\n```prolog\nadult(Person) :-\n    age(Person, Age),\n    Age >= 18.\n```\n\n**Generated C#:**\n```csharp\npublic static IEnumerable<string> Stream()\n{\n    return AgeFacts\n        .Where(t => t.Item2 >= 18)  // Age >= 18\n        .Select(t => t.Item1);       // Return Person\n}\n```\n\n### Join Pattern (Grandparent)\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C#:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // P (child)\n        inner => inner.Item1,  // P (parent)\n        (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n    );\n```\n\n### Multiple Clauses \u2192 Union\n\n**Prolog:**\n```prolog\nsibling(alice, bob).  % Fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule\n```\n\n**Generated:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = /* computed siblings */;\nreturn clause1.Union(clause2);  // Combines both\n```", "answer_tailored": true}
{"pair_id": "csharp-stream-rules_p2", "cluster_id": "csharp-stream-rules", "question": "How are multiple clauses combined?", "question_type": "medium", "answer": "In the UnifyWeaver C# target, multiple clauses for the same predicate are combined using the LINQ `.Union()` operator. Each clause is compiled into its own `IEnumerable` stream, and the compiler aggregates them to ensure that results from every fact or rule definition are included in the final output.\n\n### Translation Example: Fact and Rule Combination\n\nWhen a predicate like `sibling/2` is defined by both a static fact and a computed rule, the generated C# code computes each as a separate clause before merging them:\n\n**Prolog Source:**\n```prolog\nsibling(alice, bob).  % Clause 1: Fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Clause 2: Rule\n```\n\n**Generated C# Logic:**\n```csharp\n// Clause 1 logic (Direct Fact)\nvar clause1 = new[] { (\"alice\", \"bob\") };\n\n// Clause 2 logic (Join Pattern)\nvar clause2 = ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item1,  // Match on Parent P\n        inner => inner.Item1,  // Match on Parent P\n        (outer, inner) => (outer.Item2, inner.Item2) // Return (X, Y)\n    )\n    .Where(t => t.Item1 != t.Item2); // Filter X \\= Y\n\n// Combine both clauses into a single stream\nreturn clause1.Union(clause2);\n```\n\nWhile individual rules utilize `.Where()` for conditions and `.Join()` for goals, the `.Union()` method is the primary mechanism for handling predicates with multiple definitions. For more details on rule-to-LINQ translation patterns, see `education/book-03-csharp-target/02_csharp_stream_target.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["rules", "linq", "where", "join"], "original_answer": "## Rules to LINQ Translation\n\n### Simple Rule with Conditions\n\n**Prolog:**\n```prolog\nadult(Person) :-\n    age(Person, Age),\n    Age >= 18.\n```\n\n**Generated C#:**\n```csharp\npublic static IEnumerable<string> Stream()\n{\n    return AgeFacts\n        .Where(t => t.Item2 >= 18)  // Age >= 18\n        .Select(t => t.Item1);       // Return Person\n}\n```\n\n### Join Pattern (Grandparent)\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C#:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // P (child)\n        inner => inner.Item1,  // P (parent)\n        (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n    );\n```\n\n### Multiple Clauses \u2192 Union\n\n**Prolog:**\n```prolog\nsibling(alice, bob).  % Fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule\n```\n\n**Generated:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = /* computed siblings */;\nreturn clause1.Union(clause2);  // Combines both\n```", "answer_tailored": true}
{"pair_id": "csharp-stream-rules_p3", "cluster_id": "csharp-stream-rules", "question": "What is the Union pattern for clauses?", "question_type": "medium", "answer": "In UnifyWeaver's C# target, the **Union pattern** is used to handle predicates defined by multiple clauses. Since multiple clauses for a single predicate represent a logical disjunction (OR), the compiler translates each clause into its own LINQ expression and then merges the results using the `.Union()` method.\n\n**Prolog Example:**\n```prolog\nsibling(alice, bob).  % Fact clause\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule clause\n```\n\n**Generated C# Translation:**\n```csharp\n// Evaluate the first clause (fact)\nvar clause1 = new[] { (\"alice\", \"bob\") };\n\n// Evaluate the second clause (rule)\nvar clause2 = ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item1, // Parent P\n        inner => inner.Item1, // Parent P\n        (outer, inner) => (outer.Item2, inner.Item2) // (X, Y)\n    )\n    .Where(t => t.Item1 != t.Item2);\n\n// Combine results using Union to represent the disjunction\nreturn clause1.Union(clause2);\n```\n\nThis pattern ensures that the output stream contains all unique records generated by any of the individual clauses. For a deeper look at C# stream translation and rule generation, refer to `education/book-03-csharp-target/02_csharp_stream_target.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["rules", "linq", "where", "join"], "original_answer": "## Rules to LINQ Translation\n\n### Simple Rule with Conditions\n\n**Prolog:**\n```prolog\nadult(Person) :-\n    age(Person, Age),\n    Age >= 18.\n```\n\n**Generated C#:**\n```csharp\npublic static IEnumerable<string> Stream()\n{\n    return AgeFacts\n        .Where(t => t.Item2 >= 18)  // Age >= 18\n        .Select(t => t.Item1);       // Return Person\n}\n```\n\n### Join Pattern (Grandparent)\n\n**Prolog:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n**Generated C#:**\n```csharp\nreturn ParentFacts\n    .Join(\n        ParentFacts,\n        outer => outer.Item2,  // P (child)\n        inner => inner.Item1,  // P (parent)\n        (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n    );\n```\n\n### Multiple Clauses \u2192 Union\n\n**Prolog:**\n```prolog\nsibling(alice, bob).  % Fact\nsibling(X, Y) :- parent(P, X), parent(P, Y), X \\= Y.  % Rule\n```\n\n**Generated:**\n```csharp\nvar clause1 = new[] { (\"alice\", \"bob\") };\nvar clause2 = /* computed siblings */;\nreturn clause1.Union(clause2);  // Combines both\n```", "answer_tailored": true}
{"pair_id": "stream-target-limitations_p0", "cluster_id": "stream-target-limitations", "question": "What are the limitations of the Stream Target?", "question_type": "medium", "answer": "The C# Stream Target has three primary limitations: no support for recursion, restrictions on repeated head variables, and a limited set of supported built-in predicates.\n\n*   **No Recursion**: The Stream Target cannot compile recursive predicates like `ancestor/2`. If your logic requires recursion or transitive closures, you must use the C# Query Runtime.\n*   **No Repeated Head Variables**: You cannot define a rule where a variable appears twice in the head (e.g., `duplicate(X, X)`). To work around this, use unique variables and an explicit equality constraint in the body.\n*   **Limited Built-ins**: It supports basic comparisons and assignment (`=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`) but lacks support for aggregation predicates like `findall`, `bagof`, and `setof`.\n\nWhen recursion, mutual recursion, or complex optimization is required, use the Query Runtime instead. See `education/book-03-csharp-target/` for more information on selecting the appropriate C# target.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["limitations", "recursion", "stream-target"], "original_answer": "## Stream Target Limitations\n\n### 1. No Recursion\n\n**Does NOT work:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Recursive!\n```\n\n**Workaround:** Use C# Query Runtime (Chapter 3)\n\n### 2. No Repeated Head Variables\n\n**Does NOT work:**\n```prolog\nduplicate(X, X) :- number(X).  % X appears twice\n```\n\n**Workaround:** Add explicit equality in body\n\n### 3. Limited Built-ins\n\n**Supported:** `=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`\n\n**Not supported:** `findall`, `bagof`, `setof`, complex arithmetic\n\n### When to Use Query Runtime\n\n- Recursive predicates (ancestor, transitive closure)\n- Complex query optimization needed\n- Semi-naive evaluation required\n- Mutual recursion (is_even/is_odd)\n\n### Decision\n\n```\nIs predicate recursive?\n\u251c\u2500 NO  \u2192 Stream Target (simple, fast)\n\u2514\u2500 YES \u2192 Query Runtime (handles recursion)\n```", "answer_tailored": true}
{"pair_id": "stream-target-limitations_p1", "cluster_id": "stream-target-limitations", "question": "Why doesn't Stream Target support recursion?", "question_type": "medium", "answer": "The Stream Target does not support recursion because it is architecturally optimized for high-performance, single-pass processing of data streams rather than complex relational evaluation. In this simplified execution model, recursive rules\u2014such as `ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z)`\u2014cannot be resolved.\n\nIf your logic requires recursive predicates, transitive closures, or mutual recursion (like `is_even` and `is_odd`), you must use the C# Query Runtime. The Query Runtime is specifically designed to handle these cases using semi-naive evaluation and advanced query optimization.\n\nWhile the Stream Target is ideal for fast and simple transformations, it operates under several constraints:\n* **No Recursion:** Recursive calls are strictly prohibited.\n* **No Repeated Head Variables:** Patterns like `duplicate(X, X)` must be rewritten with explicit equality constraints in the rule body.\n* **Restricted Built-ins:** Only basic operators (`=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`) are supported; complex predicates like `findall` or `bagof` are unavailable.\n\nFor detailed implementation guidelines and a comparison of execution models, see `education/book-03-csharp-target/02_csharp_stream_target.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["limitations", "recursion", "stream-target"], "original_answer": "## Stream Target Limitations\n\n### 1. No Recursion\n\n**Does NOT work:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Recursive!\n```\n\n**Workaround:** Use C# Query Runtime (Chapter 3)\n\n### 2. No Repeated Head Variables\n\n**Does NOT work:**\n```prolog\nduplicate(X, X) :- number(X).  % X appears twice\n```\n\n**Workaround:** Add explicit equality in body\n\n### 3. Limited Built-ins\n\n**Supported:** `=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`\n\n**Not supported:** `findall`, `bagof`, `setof`, complex arithmetic\n\n### When to Use Query Runtime\n\n- Recursive predicates (ancestor, transitive closure)\n- Complex query optimization needed\n- Semi-naive evaluation required\n- Mutual recursion (is_even/is_odd)\n\n### Decision\n\n```\nIs predicate recursive?\n\u251c\u2500 NO  \u2192 Stream Target (simple, fast)\n\u2514\u2500 YES \u2192 Query Runtime (handles recursion)\n```", "answer_tailored": true}
{"pair_id": "stream-target-limitations_p2", "cluster_id": "stream-target-limitations", "question": "What built-ins are supported in Stream Target?", "question_type": "medium", "answer": "The C# Stream Target supports a specific set of built-in predicates: `=`, `\\=`, `<`, `>`, `=<`, `>=`, and `is`.\n\nThese core operators facilitate unification, inequality testing, and standard numerical comparisons. However, many advanced built-ins are not available in the Stream Target, including `findall`, `bagof`, `setof`, and complex arithmetic functions. Additionally, the Stream Target does not support recursion or repeated head variables. For scenarios requiring recursion or advanced built-ins, the C# Query Runtime is the appropriate choice.\n\nYou can find more information in `education/book-03-csharp-target/02_csharp_stream_target.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["limitations", "recursion", "stream-target"], "original_answer": "## Stream Target Limitations\n\n### 1. No Recursion\n\n**Does NOT work:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Recursive!\n```\n\n**Workaround:** Use C# Query Runtime (Chapter 3)\n\n### 2. No Repeated Head Variables\n\n**Does NOT work:**\n```prolog\nduplicate(X, X) :- number(X).  % X appears twice\n```\n\n**Workaround:** Add explicit equality in body\n\n### 3. Limited Built-ins\n\n**Supported:** `=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`\n\n**Not supported:** `findall`, `bagof`, `setof`, complex arithmetic\n\n### When to Use Query Runtime\n\n- Recursive predicates (ancestor, transitive closure)\n- Complex query optimization needed\n- Semi-naive evaluation required\n- Mutual recursion (is_even/is_odd)\n\n### Decision\n\n```\nIs predicate recursive?\n\u251c\u2500 NO  \u2192 Stream Target (simple, fast)\n\u2514\u2500 YES \u2192 Query Runtime (handles recursion)\n```", "answer_tailored": true}
{"pair_id": "stream-target-limitations_p3", "cluster_id": "stream-target-limitations", "question": "When should I use Query Runtime instead?", "question_type": "medium", "answer": "You should use the C# Query Runtime instead of the Stream Target whenever your Prolog logic requires recursion, mutual recursion, or advanced evaluation strategies. While the Stream Target is optimized for high-speed processing of simple, flat queries, it lacks the machinery to handle recursive predicates like transitive closures or mutually recursive definitions.\n\nThe Query Runtime is the correct choice in the following scenarios:\n*   **Recursion and Mutual Recursion:** It is required for predicates that call themselves (e.g., `ancestor/2`) or participate in a recursive loop (e.g., `is_even` and `is_odd`).\n*   **Advanced Evaluation:** When your application requires semi-naive evaluation to efficiently process deep trees or cyclic graphs.\n*   **Aggregation and Complex Built-ins:** If your code relies on predicates like `findall/3`, `bagof/3`, or `setof/3`, or complex arithmetic beyond basic comparisons.\n*   **Head Unification:** When you have repeated variables in a predicate head (e.g., `match(X, X)`), which require manual refactoring in the Stream Target.\n\nFor simple, non-recursive rules using only basic built-ins, the Stream Target remains the more efficient alternative. Detailed implementation guides for both targets can be found in `education/book-03-csharp-target/`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/02_csharp_stream_target.md", "topics": ["limitations", "recursion", "stream-target"], "original_answer": "## Stream Target Limitations\n\n### 1. No Recursion\n\n**Does NOT work:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).  % Recursive!\n```\n\n**Workaround:** Use C# Query Runtime (Chapter 3)\n\n### 2. No Repeated Head Variables\n\n**Does NOT work:**\n```prolog\nduplicate(X, X) :- number(X).  % X appears twice\n```\n\n**Workaround:** Add explicit equality in body\n\n### 3. Limited Built-ins\n\n**Supported:** `=`, `\\=`, `<`, `>`, `=<`, `>=`, `is`\n\n**Not supported:** `findall`, `bagof`, `setof`, complex arithmetic\n\n### When to Use Query Runtime\n\n- Recursive predicates (ancestor, transitive closure)\n- Complex query optimization needed\n- Semi-naive evaluation required\n- Mutual recursion (is_even/is_odd)\n\n### Decision\n\n```\nIs predicate recursive?\n\u251c\u2500 NO  \u2192 Stream Target (simple, fast)\n\u2514\u2500 YES \u2192 Query Runtime (handles recursion)\n```", "answer_tailored": true}
