{"pair_id": "query-runtime-overview_p0", "cluster_id": "query-runtime-overview", "question": "What is the C# Query Runtime?", "question_type": "medium", "answer": "The C# Query Runtime is the core execution component for the UnifyWeaver C# target, responsible for processing queries that have been translated from Prolog into a specialized Intermediate Representation (IR). It functions as the final stage of the compilation pipeline: Prolog is converted into an IR-based Query Plan, which the Runtime Engine then executes to produce results.\n\nKey characteristics of the C# Query Runtime include:\n*   **Intermediate Representation (IR):** By decoupling Prolog from the final execution via IR, the system can independently optimize query plans and support complex logic.\n*   **Recursion Support:** It implements fixpoint iteration, allowing for the execution of recursive Prolog queries.\n*   **Relational Primitives:** The engine uses standard components to manage data flow, such as `RelationRef` for tuple fetching, `Selection` for filtering (SQL `WHERE`), `Projection` for reshaping (SQL `SELECT`), and `Join` for combining data sets.\n\nAn example IR plan and its execution in C# looks like this:\n\n```csharp\n// Defining an IR plan\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause { Body = new RelationRef(\"parent\", 2) }\n    }\n};\n\n// Executing the plan using the Semi-Naive engine\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```\n\nThis architecture ensures that the query execution is both flexible and high-performance. For a deep dive into the IR components and the query engine's implementation details, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["query-runtime", "ir", "intermediate-representation"], "original_answer": "## C# Query Runtime\n\nThe Query Runtime uses **Intermediate Representation (IR)**:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\n### Why IR?\n\n- **Supports recursion** via fixpoint iteration\n- **Shared runtime** can be optimized independently\n- **Flexible** query execution strategies\n\n### Core IR Components\n\n| Component | Purpose | SQL Equivalent |\n|-----------|---------|----------------|\n| `RelationRef` | Fetch tuples | `SELECT * FROM table` |\n| `Selection` | Filter rows | `WHERE condition` |\n| `Projection` | Reshape tuples | `SELECT col1, col2` |\n| `Join` | Combine tuples | `JOIN ON key` |\n| `Union` | Merge results | `UNION` |\n| `Distinct` | Remove duplicates | `DISTINCT` |\n\n### Example IR\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n### Execution\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```", "answer_tailored": true}
{"pair_id": "query-runtime-overview_p1", "cluster_id": "query-runtime-overview", "question": "What is IR (Intermediate Representation)?", "question_type": "medium", "answer": "In UnifyWeaver's C# target, **Intermediate Representation (IR)** is the compiled query plan that acts as a bridge between Prolog source code and the execution engine. It transforms logical predicates into a structured format that the runtime can optimize and execute.\n\n### Why IR is Used\nIR is essential for the C# target because it provides:\n*   **Recursion Support:** It enables fixpoint iteration for recursive queries.\n*   **Modular Optimization:** The runtime engine can be tuned independently of the compiler.\n*   **Execution Flexibility:** It allows for varied query strategies within a shared runtime.\n\n### Core IR Components\nThe IR translates Prolog logic into relational operations:\n*   **RelationRef:** Retrieves tuples (SQL `SELECT *`).\n*   **Selection:** Filters results based on conditions (SQL `WHERE`).\n*   **Projection:** Reshapes tuples (SQL `SELECT col1`).\n*   **Join:** Combines tuples across relations.\n*   **Union/Distinct:** Merges results and eliminates duplicates.\n\n### IR Structure and Execution\nA query plan is built by assembling these components into a `QueryPlan` object:\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause { Body = new RelationRef(\"parent\", 2) }\n    }\n};\n```\n\nThe `QueryEngine` then processes this IR, often employing semi-naive evaluation to handle recursive logic efficiently:\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```\n\nFor more detailed information on the C# query engine, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["query-runtime", "ir", "intermediate-representation"], "original_answer": "## C# Query Runtime\n\nThe Query Runtime uses **Intermediate Representation (IR)**:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\n### Why IR?\n\n- **Supports recursion** via fixpoint iteration\n- **Shared runtime** can be optimized independently\n- **Flexible** query execution strategies\n\n### Core IR Components\n\n| Component | Purpose | SQL Equivalent |\n|-----------|---------|----------------|\n| `RelationRef` | Fetch tuples | `SELECT * FROM table` |\n| `Selection` | Filter rows | `WHERE condition` |\n| `Projection` | Reshape tuples | `SELECT col1, col2` |\n| `Join` | Combine tuples | `JOIN ON key` |\n| `Union` | Merge results | `UNION` |\n| `Distinct` | Remove duplicates | `DISTINCT` |\n\n### Example IR\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n### Execution\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```", "answer_tailored": true}
{"pair_id": "query-runtime-overview_p2", "cluster_id": "query-runtime-overview", "question": "How does Query Runtime differ from Stream Target?", "question_type": "medium", "answer": "The C# Query Runtime differs from the Stream Target primarily by utilizing an **Intermediate Representation (IR)** and a dynamic execution engine to support complex relational logic and recursion. While the Stream Target typically focuses on high-performance, one-pass sequential processing, the Query Runtime operates as a relational engine with several distinct characteristics:\n\n*   **Intermediate Representation (IR):** Unlike Stream Targets that may transpile Prolog directly to target code, the Query Runtime compiles Prolog into a structured Query Plan consisting of components like `RelationRef`, `Join`, `Selection`, and `Projection`.\n*   **Recursion Support:** The Query Runtime is designed to handle recursion via **fixpoint iteration (Semi-Naive evaluation)**, allowing it to solve queries that require multiple passes over data which Stream Targets generally avoid.\n*   **Decoupled Execution:** By using a `QueryEngine` to execute the IR, the system can optimize execution strategies (such as distinct result sets and join ordering) independently of the source Prolog.\n\nFor a detailed breakdown of the IR components and the C# engine implementation, refer to `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["query-runtime", "ir", "intermediate-representation"], "original_answer": "## C# Query Runtime\n\nThe Query Runtime uses **Intermediate Representation (IR)**:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\n### Why IR?\n\n- **Supports recursion** via fixpoint iteration\n- **Shared runtime** can be optimized independently\n- **Flexible** query execution strategies\n\n### Core IR Components\n\n| Component | Purpose | SQL Equivalent |\n|-----------|---------|----------------|\n| `RelationRef` | Fetch tuples | `SELECT * FROM table` |\n| `Selection` | Filter rows | `WHERE condition` |\n| `Projection` | Reshape tuples | `SELECT col1, col2` |\n| `Join` | Combine tuples | `JOIN ON key` |\n| `Union` | Merge results | `UNION` |\n| `Distinct` | Remove duplicates | `DISTINCT` |\n\n### Example IR\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n### Execution\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```", "answer_tailored": true}
{"pair_id": "query-runtime-overview_p3", "cluster_id": "query-runtime-overview", "question": "Why use IR instead of direct translation?", "question_type": "medium", "answer": "UnifyWeaver utilizes Intermediate Representation (IR) rather than direct translation to provide a robust framework for handling complex logic like recursion while decoupling the query plan from the execution engine. By translating Prolog into a structured Query Plan (`Prolog \u2192 IR \u2192 Runtime Engine`), the system achieves several key benefits:\n\n*   **Native Recursion Support:** IR allows the runtime to implement fixpoint iteration (Semi-Naive evaluation), which is necessary for recursive Prolog predicates that direct code translation often struggles to represent efficiently.\n*   **Independent Optimization:** Because the runtime is shared and decoupled, performance improvements can be made to the execution engine without modifying the compiler's translation logic.\n*   **Execution Flexibility:** The use of IR enables the system to apply different execution strategies based on the specific requirements of the query.\n\nThe IR maps logical Prolog operations to relational components:\n- **RelationRef:** Fetches tuples (equivalent to `SELECT *`).\n- **Selection:** Filters rows (equivalent to `WHERE`).\n- **Projection:** Reshapes tuples (equivalent to `SELECT col`).\n- **Join/Union/Distinct:** Standard relational algebra for combining and refining results.\n\nIn practice, a `QueryPlan` is constructed in C# and passed to a `QueryEngine` for execution. For a comprehensive look at how this IR is implemented and executed, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["query-runtime", "ir", "intermediate-representation"], "original_answer": "## C# Query Runtime\n\nThe Query Runtime uses **Intermediate Representation (IR)**:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\n### Why IR?\n\n- **Supports recursion** via fixpoint iteration\n- **Shared runtime** can be optimized independently\n- **Flexible** query execution strategies\n\n### Core IR Components\n\n| Component | Purpose | SQL Equivalent |\n|-----------|---------|----------------|\n| `RelationRef` | Fetch tuples | `SELECT * FROM table` |\n| `Selection` | Filter rows | `WHERE condition` |\n| `Projection` | Reshape tuples | `SELECT col1, col2` |\n| `Join` | Combine tuples | `JOIN ON key` |\n| `Union` | Merge results | `UNION` |\n| `Distinct` | Remove duplicates | `DISTINCT` |\n\n### Example IR\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n### Execution\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```", "answer_tailored": true}
{"pair_id": "ir-components_p0", "cluster_id": "ir-components", "question": "What are the IR components in Query Runtime?", "question_type": "medium", "answer": "The IR components in the UnifyWeaver C# Query Runtime serve as the fundamental building blocks for executing compiled Prolog logic. These components include:\n\n*   **RelationRef**: Responsible for fetching tuples from a specified relation (e.g., `new RelationRef(\"parent\", 2)` retrieves all parent/2 facts).\n*   **Selection**: Applies filtering logic to rows based on a predicate (e.g., `tuple => tuple.Item2 >= 18` for age constraints).\n*   **Projection**: Reshapes the structure of tuples by selecting or reordering specific fields.\n*   **Join**: Combines two data sources by matching keys, which is essential for resolving recursive rules and multi-goal clauses like `grandparent(GP, GC) :- parent(GP, P), parent(P, GC)`.\n*   **Union**: Merges the results produced by multiple clauses within a single predicate.\n\nFor a comprehensive breakdown of the query engine's architecture, refer to `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["ir", "relationref", "selection", "join", "projection"], "original_answer": "## IR Components Explained\n\n### RelationRef - Fetch Tuples\n\n```csharp\nnew RelationRef(\"parent\", 2)\n// \u2192 All parent/2 tuples\n```\n\n### Selection - Filter Rows\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Age >= 18\n)\n```\n\n**Prolog equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\n### Projection - Reshape Tuples\n\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Keep fields 1 and 3\n)\n```\n\n### Join - Combine Tuples\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Key: P (child)\n    inner => inner.Item1,          // Key: P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n)\n```\n\n**Prolog equivalent:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n### Union - Merge Results\n\n```csharp\nnew Union(clause1, clause2)\n// Combines results from multiple clauses\n```", "answer_tailored": true}
{"pair_id": "ir-components_p1", "cluster_id": "ir-components", "question": "How does RelationRef work?", "question_type": "medium", "answer": "RelationRef is the fundamental Intermediate Representation (IR) component used to fetch tuples from a relation. In the C# query engine, it identifies a predicate by its name and arity to retrieve its full set of data, serving as the base input for the query pipeline.\n\nFor example, fetching all `parent/2` tuples is performed using:\n```csharp\nnew RelationRef(\"parent\", 2)\n```\n\nIn practice, RelationRef acts as the data source for other IR components that refine or combine the results:\n*   **Selection:** Filters the tuples (e.g., `new Selection(new RelationRef(\"age\", 2), t => t.Item2 >= 18)`).\n*   **Projection:** Reshapes the tuples by selecting specific fields.\n*   **Join:** Combines data from multiple RelationRef sources. For instance, joining two `parent/2` relations to find grandparents.\n*   **Union:** Merges results from different clauses.\n\n**Example Join (representing Prolog: `grandparent(GP, GC) :- parent(GP, P), parent(P, GC).`):**\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),\n    new RelationRef(\"parent\", 2),\n    outer => outer.Item2,\n    inner => inner.Item1,\n    (outer, inner) => (outer.Item1, inner.Item2)\n)\n```\n\nFor more details on how RelationRef and other IR components function within the engine, refer to `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["ir", "relationref", "selection", "join", "projection"], "original_answer": "## IR Components Explained\n\n### RelationRef - Fetch Tuples\n\n```csharp\nnew RelationRef(\"parent\", 2)\n// \u2192 All parent/2 tuples\n```\n\n### Selection - Filter Rows\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Age >= 18\n)\n```\n\n**Prolog equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\n### Projection - Reshape Tuples\n\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Keep fields 1 and 3\n)\n```\n\n### Join - Combine Tuples\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Key: P (child)\n    inner => inner.Item1,          // Key: P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n)\n```\n\n**Prolog equivalent:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n### Union - Merge Results\n\n```csharp\nnew Union(clause1, clause2)\n// Combines results from multiple clauses\n```", "answer_tailored": true}
{"pair_id": "ir-components_p2", "cluster_id": "ir-components", "question": "How are joins represented in IR?", "question_type": "medium", "answer": "In the UnifyWeaver Intermediate Representation (IR), joins are represented by the `Join` component, which merges data from two sources based on matching keys. In the C# target, this is implemented as a structure that defines an outer source, an inner source, key selectors for both sides, and a result selector to define the shape of the output tuple.\n\nFor example, a join representing the Prolog rule `grandparent(GP, GC) :- parent(GP, P), parent(P, GC)` is constructed as:\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // Outer: parent(GP, P)\n    new RelationRef(\"parent\", 2),  // Inner: parent(P, GC)\n    outer => outer.Item2,          // Key: P (from outer)\n    inner => inner.Item1,          // Key: P (from inner)\n    (outer, inner) => (outer.Item1, inner.Item2)  // Result: (GP, GC)\n)\n```\n\nThe `Join` component typically works alongside other IR elements like `RelationRef` (fetching tuples), `Selection` (filtering via predicates), and `Projection` (reshaping the final output). For a comprehensive breakdown of the query engine's IR components, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["ir", "relationref", "selection", "join", "projection"], "original_answer": "## IR Components Explained\n\n### RelationRef - Fetch Tuples\n\n```csharp\nnew RelationRef(\"parent\", 2)\n// \u2192 All parent/2 tuples\n```\n\n### Selection - Filter Rows\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Age >= 18\n)\n```\n\n**Prolog equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\n### Projection - Reshape Tuples\n\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Keep fields 1 and 3\n)\n```\n\n### Join - Combine Tuples\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Key: P (child)\n    inner => inner.Item1,          // Key: P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n)\n```\n\n**Prolog equivalent:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n### Union - Merge Results\n\n```csharp\nnew Union(clause1, clause2)\n// Combines results from multiple clauses\n```", "answer_tailored": true}
{"pair_id": "ir-components_p3", "cluster_id": "ir-components", "question": "What is Selection in IR?", "question_type": "medium", "answer": "In the UnifyWeaver Intermediate Representation (IR), **Selection** is the component responsible for filtering rows or tuples based on specific criteria. It allows the query engine to refine a data source by applying a predicate function that determines which tuples should be retained.\n\nIn the C# target implementation, a `Selection` object typically wraps a source (like a `RelationRef`) and evaluates a lambda expression against each tuple:\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Filters for Age >= 18\n)\n```\n\nThis IR component directly maps to Prolog rules containing constraints. For example, the Prolog goal `adult(P) :- age(P, Age), Age >= 18.` is implemented using Selection to enforce the `Age >= 18` condition.\n\nFor more details on how the query engine handles IR components, refer to `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["ir", "relationref", "selection", "join", "projection"], "original_answer": "## IR Components Explained\n\n### RelationRef - Fetch Tuples\n\n```csharp\nnew RelationRef(\"parent\", 2)\n// \u2192 All parent/2 tuples\n```\n\n### Selection - Filter Rows\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Age >= 18\n)\n```\n\n**Prolog equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\n### Projection - Reshape Tuples\n\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Keep fields 1 and 3\n)\n```\n\n### Join - Combine Tuples\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Key: P (child)\n    inner => inner.Item1,          // Key: P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n)\n```\n\n**Prolog equivalent:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n### Union - Merge Results\n\n```csharp\nnew Union(clause1, clause2)\n// Combines results from multiple clauses\n```", "answer_tailored": true}
{"pair_id": "fixpoint-iteration_p0", "cluster_id": "fixpoint-iteration", "question": "What is fixpoint iteration?", "question_type": "medium", "answer": "Fixpoint iteration is the evaluation strategy UnifyWeaver uses for recursive predicates, where the engine repeatedly computes a set of results until it reaches a stable state where no new tuples can be derived.\n\n### How It Works\nUsing a recursive `ancestor/2` predicate as an example:\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\nThe engine executes the following logic:\n- **Iteration 1**: It identifies all direct parents and adds them to the ancestor set.\n- **Iteration 2**: It joins parents with the results from Iteration 1 to find grandparents.\n- **Iteration 3**: It continues joining until it finds great-grandparents and so on.\n- **Termination**: When an iteration produces zero new tuples, the \"fixpoint\" has been reached and the process stops.\n\n### Performance Optimization\nWhile a naive approach would re-process every tuple in every step, UnifyWeaver employs **Semi-Naive Optimization**. This technique ensures that only the \"delta\" (the new tuples discovered in the most recent iteration) is used in the next join. This drastically reduces computational overhead for deep hierarchies.\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1         | 3           | 3                |\n| 2         | 15          | 6                |\n| 3         | 45          | 3                |\n| 4         | 135         | 0 (Complete)     |\n\nDetailed implementation specifics for the C# target engine can be found in `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["fixpoint", "semi-naive", "recursion", "iteration"], "original_answer": "## Fixpoint Iteration\n\nFor recursive predicates, the engine iterates until no new tuples are produced.\n\n### Example: ancestor/2\n\n**Prolog:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\n### Iteration Trace\n\n**Iteration 0 (Base):**\n```\nparent: (alice, bob), (bob, charlie), (charlie, dave)\nancestor: {} (empty)\n```\n\n**Iteration 1:**\n```\nancestor = {(alice, bob), (bob, charlie), (charlie, dave)}\n```\n\n**Iteration 2:**\n```\nancestor += {(alice, charlie), (bob, dave)}\n```\n\n**Iteration 3:**\n```\nancestor += {(alice, dave)}\n```\n\n**Iteration 4:**\n```\nNo new tuples \u2192 Fixpoint reached!\n```\n\n### Semi-Naive Optimization\n\n**Naive:** Re-join ALL tuples every iteration (slow)\n\n**Semi-naive:** Only join with NEW tuples from last iteration (fast)\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**Much faster for deep recursion!**", "answer_tailored": true}
{"pair_id": "fixpoint-iteration_p1", "cluster_id": "fixpoint-iteration", "question": "How does semi-naive evaluation work?", "question_type": "medium", "answer": "Semi-naive evaluation is an optimization technique used in the UnifyWeaver query engine to compute the fixpoint of recursive predicates efficiently. While naive evaluation re-processes all known tuples in every iteration, the semi-naive approach ensures that only the **new tuples** generated in the previous iteration are used in joins for the current step. This eliminates redundant computations and significantly accelerates convergence.\n\n### Recursive Fixpoint Iteration\nFor a recursive rule such as `ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z)`, the engine iterates until no new tuples are produced:\n\n1.  **Iteration 0:** Start with an empty set.\n2.  **Iteration 1:** Load base facts (e.g., direct parents).\n3.  **Iteration 2+:** Join base facts with only the *newly discovered* ancestor tuples from the previous iteration.\n4.  **Fixpoint:** Stop when an iteration produces zero new results.\n\n### Performance Benefit\nBy focusing only on the \"delta\" (new data), the semi-naive strategy drastically reduces the number of join operations compared to the naive method:\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1         | 3           | 3                |\n| 2         | 15          | 6                |\n| 3         | 45          | 3                |\n| 4         | 135         | 0 (Done)         |\n\nThis optimization is essential for handling deep recursion without performance degradation. For a detailed breakdown of the query engine's implementation, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["fixpoint", "semi-naive", "recursion", "iteration"], "original_answer": "## Fixpoint Iteration\n\nFor recursive predicates, the engine iterates until no new tuples are produced.\n\n### Example: ancestor/2\n\n**Prolog:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\n### Iteration Trace\n\n**Iteration 0 (Base):**\n```\nparent: (alice, bob), (bob, charlie), (charlie, dave)\nancestor: {} (empty)\n```\n\n**Iteration 1:**\n```\nancestor = {(alice, bob), (bob, charlie), (charlie, dave)}\n```\n\n**Iteration 2:**\n```\nancestor += {(alice, charlie), (bob, dave)}\n```\n\n**Iteration 3:**\n```\nancestor += {(alice, dave)}\n```\n\n**Iteration 4:**\n```\nNo new tuples \u2192 Fixpoint reached!\n```\n\n### Semi-Naive Optimization\n\n**Naive:** Re-join ALL tuples every iteration (slow)\n\n**Semi-naive:** Only join with NEW tuples from last iteration (fast)\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**Much faster for deep recursion!**", "answer_tailored": true}
{"pair_id": "fixpoint-iteration_p2", "cluster_id": "fixpoint-iteration", "question": "Why is semi-naive faster than naive?", "question_type": "medium", "answer": "Semi-naive evaluation is significantly more efficient than naive evaluation because it eliminates redundant computations during recursive fixpoint iterations. In a naive approach, the engine re-joins all available tuples in every iteration, regardless of whether they have already been processed. In contrast, the semi-naive optimization ensures that only the new tuples generated in the previous iteration (the \"delta\") are used in joins for the current step.\n\n### Example: recursive ancestor/2\nUsing a standard recursive definition:\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\nFor a family tree with several generations, the performance difference becomes clear as the engine searches for the fixpoint:\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 (Base)  | 3           | 3                |\n| 2         | 15          | 6                |\n| 3         | 45          | 3                |\n| 4         | 135         | 0 (Fixpoint)     |\n\nBy focusing exclusively on the \"new\" results from the last pass, the semi-naive method avoids the exponential growth in join operations, making it essential for deep recursion and large datasets. For more details on query engine optimizations, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["fixpoint", "semi-naive", "recursion", "iteration"], "original_answer": "## Fixpoint Iteration\n\nFor recursive predicates, the engine iterates until no new tuples are produced.\n\n### Example: ancestor/2\n\n**Prolog:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\n### Iteration Trace\n\n**Iteration 0 (Base):**\n```\nparent: (alice, bob), (bob, charlie), (charlie, dave)\nancestor: {} (empty)\n```\n\n**Iteration 1:**\n```\nancestor = {(alice, bob), (bob, charlie), (charlie, dave)}\n```\n\n**Iteration 2:**\n```\nancestor += {(alice, charlie), (bob, dave)}\n```\n\n**Iteration 3:**\n```\nancestor += {(alice, dave)}\n```\n\n**Iteration 4:**\n```\nNo new tuples \u2192 Fixpoint reached!\n```\n\n### Semi-Naive Optimization\n\n**Naive:** Re-join ALL tuples every iteration (slow)\n\n**Semi-naive:** Only join with NEW tuples from last iteration (fast)\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**Much faster for deep recursion!**", "answer_tailored": true}
{"pair_id": "fixpoint-iteration_p3", "cluster_id": "fixpoint-iteration", "question": "When does fixpoint iteration terminate?", "question_type": "medium", "answer": "Fixpoint iteration terminates once the engine determines that no new tuples can be generated for recursive predicates. In this stable state, the result set has \"fixed,\" and further computation is unnecessary.\n\nFor example, with a recursive `ancestor/2` rule:\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\nThe engine starts with an empty set and iteratively adds relations (first parents, then grandparents, and so on). Each pass checks if any new ancestor pairs were discovered; when an iteration produces zero new results, the fixpoint is confirmed.\n\nTo improve efficiency, the engine utilizes **semi-naive optimization**. Rather than re-joining the entire dataset in every pass (naive approach), it only performs joins using the new tuples produced in the previous iteration. This drastically reduces the number of joins required for deep recursion.\n\nDetailed implementation details for the query engine can be found in `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["fixpoint", "semi-naive", "recursion", "iteration"], "original_answer": "## Fixpoint Iteration\n\nFor recursive predicates, the engine iterates until no new tuples are produced.\n\n### Example: ancestor/2\n\n**Prolog:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\n### Iteration Trace\n\n**Iteration 0 (Base):**\n```\nparent: (alice, bob), (bob, charlie), (charlie, dave)\nancestor: {} (empty)\n```\n\n**Iteration 1:**\n```\nancestor = {(alice, bob), (bob, charlie), (charlie, dave)}\n```\n\n**Iteration 2:**\n```\nancestor += {(alice, charlie), (bob, dave)}\n```\n\n**Iteration 3:**\n```\nancestor += {(alice, dave)}\n```\n\n**Iteration 4:**\n```\nNo new tuples \u2192 Fixpoint reached!\n```\n\n### Semi-Naive Optimization\n\n**Naive:** Re-join ALL tuples every iteration (slow)\n\n**Semi-naive:** Only join with NEW tuples from last iteration (fast)\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**Much faster for deep recursion!**", "answer_tailored": true}
{"pair_id": "mutual-recursion-csharp_p0", "cluster_id": "mutual-recursion-csharp", "question": "How does C# Query Runtime handle mutual recursion?", "question_type": "medium", "answer": "The C# Query Runtime manages mutual recursion by identifying Strongly Connected Components (SCCs) and executing them through a semi-naive fixpoint iteration.\n\n### Key Implementation Components\nWhen predicates are mutually recursive\u2014such as `is_even/1` and `is_odd/1`\u2014the runtime organizes them using specific plan nodes:\n- **`MutualFixpointNode`**: Acts as the primary orchestrator for the recursive group.\n- **`MutualMember`**: Contains the base and recursive execution plans for an individual predicate in the SCC.\n- **`CrossRefNode`**: Handles dependencies where one predicate in the SCC references another.\n\n### Semi-Naive Execution Model\nThe runtime ensures efficiency by only processing \"delta\" tuples (newly discovered facts) in each iteration. The execution loop continues as long as new data is being produced:\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans specifically against the latest deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nThis approach prevents redundant computations and ensures that the mutual recursion eventually reaches a stable state. Detailed architectural patterns for the C# query engine can be found in `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["mutual-recursion", "scc", "mutualfixpointnode", "crossrefnode"], "original_answer": "## Mutual Recursion in Query Runtime (v0.1)\n\nThe runtime handles strongly connected predicate groups.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### Key Plan Nodes\n\n- **`MutualFixpointNode`**: Orchestrates the group\n- **`MutualMember`**: Describes each predicate (base + recursive plans)\n- **`CrossRefNode`**: References another predicate in the SCC\n\n### Generated Plan\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Execution Model\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nOnly **new tuples** participate in each iteration (semi-naive).", "answer_tailored": true}
{"pair_id": "mutual-recursion-csharp_p1", "cluster_id": "mutual-recursion-csharp", "question": "What is MutualFixpointNode?", "question_type": "medium", "answer": "In the UnifyWeaver C# target, the **`MutualFixpointNode`** is a runtime plan node responsible for orchestrating the execution of mutually recursive predicates. It manages \"Strongly Connected Component\" (SCC) groups\u2014predicates that depend on each other, such as an `is_even`/`is_odd` pair.\n\n### Technical Functionality\nThe node coordinates several components to achieve fixed-point iteration:\n*   **`MutualMember`**: Each predicate in the group is represented by a member containing its specific base and recursive execution plans.\n*   **`CrossRefNode`**: Handles references between different predicates within the same recursive group.\n*   **Semi-Naive Evaluation**: The node executes a `while` loop that continues as long as new tuples (deltas) are being produced. By only processing these new tuples in each iteration, the runtime ensures efficient convergence toward the final result set.\n\nFor a comprehensive deep dive into how the C# query engine handles these recursive structures, refer to **`education/book-03-csharp-target/03_query_engine_deep_dive.md`**.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["mutual-recursion", "scc", "mutualfixpointnode", "crossrefnode"], "original_answer": "## Mutual Recursion in Query Runtime (v0.1)\n\nThe runtime handles strongly connected predicate groups.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### Key Plan Nodes\n\n- **`MutualFixpointNode`**: Orchestrates the group\n- **`MutualMember`**: Describes each predicate (base + recursive plans)\n- **`CrossRefNode`**: References another predicate in the SCC\n\n### Generated Plan\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Execution Model\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nOnly **new tuples** participate in each iteration (semi-naive).", "answer_tailored": true}
{"pair_id": "mutual-recursion-csharp_p2", "cluster_id": "mutual-recursion-csharp", "question": "What is CrossRefNode?", "question_type": "medium", "answer": "A `CrossRefNode` is a specialized plan node in the UnifyWeaver C# query runtime that represents a reference to another predicate within the same Strongly Connected Component (SCC).\n\nIn the context of mutual recursion\u2014where multiple predicates like `is_even` and `is_odd` depend on each other\u2014the `CrossRefNode` allows the query engine to link these dependencies within a `MutualFixpointNode`. While a `MutualMember` defines the specific base and recursive plans for a predicate, the `CrossRefNode` identifies where one predicate's logic calls into another member of the recursive group. This structure is essential for the engine\u2019s semi-naive execution model, ensuring that recursive iterations correctly evaluate new tuples (deltas) across all related predicates until a fixpoint is reached.\n\nFor a detailed technical breakdown of recursive plan nodes in the C# target, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["mutual-recursion", "scc", "mutualfixpointnode", "crossrefnode"], "original_answer": "## Mutual Recursion in Query Runtime (v0.1)\n\nThe runtime handles strongly connected predicate groups.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### Key Plan Nodes\n\n- **`MutualFixpointNode`**: Orchestrates the group\n- **`MutualMember`**: Describes each predicate (base + recursive plans)\n- **`CrossRefNode`**: References another predicate in the SCC\n\n### Generated Plan\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Execution Model\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nOnly **new tuples** participate in each iteration (semi-naive).", "answer_tailored": true}
{"pair_id": "mutual-recursion-csharp_p3", "cluster_id": "mutual-recursion-csharp", "question": "How are SCCs evaluated in C#?", "question_type": "medium", "answer": "In the C# query engine, Strongly Connected Components (SCCs) are evaluated using a semi-naive fixpoint iteration orchestrated by the `MutualFixpointNode`. This node manages a group of mutually recursive predicates, where each predicate is represented as a `MutualMember` containing its specific base and recursive execution plans. \n\nThe evaluation process follows a structured loop:\n1. **Initialization**: The engine executes the base plans for each `MutualMember` to establish the starting set of tuples.\n2. **Iteration**: A `while` loop continues as long as new tuples (Deltas) are produced. In each pass, the recursive plans are evaluated using only the results from the previous iteration.\n3. **Integration**: New unique tuples are added to the total results and staged as the next set of deltas.\n4. **References**: Predicate dependencies within the SCC are managed via `CrossRefNode`.\n\nThis semi-naive approach ensures that only new data drives the computation, preventing infinite loops and redundant processing. For a comprehensive breakdown of the query engine's architecture and C# code generation for recursion, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["mutual-recursion", "scc", "mutualfixpointnode", "crossrefnode"], "original_answer": "## Mutual Recursion in Query Runtime (v0.1)\n\nThe runtime handles strongly connected predicate groups.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### Key Plan Nodes\n\n- **`MutualFixpointNode`**: Orchestrates the group\n- **`MutualMember`**: Describes each predicate (base + recursive plans)\n- **`CrossRefNode`**: References another predicate in the SCC\n\n### Generated Plan\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Execution Model\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nOnly **new tuples** participate in each iteration (semi-naive).", "answer_tailored": true}
