{"pair_id": "sql-join-001_p0", "cluster_id": "sql-join-001", "question": "How do JOINs work in the SQL target?", "question_type": "medium", "answer": "In the SQL target, JOINs are implemented either implicitly through variable sharing or explicitly via specialized predicates.\n\n**INNER JOINs**\nInner joins are handled implicitly by the compiler whenever two predicates in a rule share a common variable. For example:\n```prolog\ncustomer_orders(CustomerName, Product) :-\n    customers(CustId, CustomerName, _, _),\n    orders(_, CustId, Product, _, _).\n```\nThe shared `CustId` variable automatically generates a SQL `INNER JOIN` between the `customers` and `orders` tables on their respective ID columns.\n\n**OUTER JOINs**\nFor LEFT, RIGHT, or FULL OUTER JOINs, you must use explicit predicates to define the join behavior. A LEFT JOIN is represented as follows:\n```prolog\ncustomers_with_orders(Name, Product) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(_, CustId, Product, _, _)).\n```\n\nThis structure ensures that the compiler correctly maps Prolog's relational logic to the appropriate SQL join syntax. For further details and advanced usage, see the documentation in `education/book-10-sql-target/03_joins.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/03_joins.md", "topics": [], "original_answer": "INNER JOINs happen implicitly via shared variables:\n\n```prolog\ncustomer_orders(CustomerName, Product) :-\n    customers(CustId, CustomerName, _, _),\n    orders(_, CustId, Product, _, _).\n% Generates: SELECT ... FROM customers INNER JOIN orders ON orders.customer_id = customers.id\n```\n\nFor LEFT/RIGHT/FULL OUTER JOINs, use explicit predicates:\n```prolog\ncustomers_with_orders(Name, Product) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(_, CustId, Product, _, _)).\n```", "answer_tailored": true}
{"pair_id": "sql-join-001_p0", "cluster_id": "sql-join-001", "question": "What JOIN types does the SQL target support?", "question_type": "medium", "answer": "The UnifyWeaver SQL target supports four primary JOIN operations for combining relational data:\n\n*   **INNER JOIN**: Implicitly handled through the use of shared variables across different predicates.\n*   **LEFT JOIN**: Explicitly declared using the `sql_left_join(Relation)` wrapper.\n*   **RIGHT JOIN**: Triggered by the `sql_right_join(Relation)` predicate.\n*   **FULL OUTER JOIN**: Specified via the `sql_full_outer_join(Relation)` predicate.\n\nTo identify non-matching records, you can combine a `sql_left_join` with a null check using `sql_is_null`. For example, to find customers who haven't placed orders:\n\n```prolog\ncustomers_without_orders(Name) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(OrderId, CustId, _, _, _)),\n    sql_is_null(OrderId).\n```\n\nFor more detailed examples and implementation patterns, see `education/book-10-sql-target/03_joins.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/03_joins.md", "topics": [], "original_answer": "Four JOIN types:\n- **INNER JOIN**: Implicit via shared variables\n- **LEFT JOIN**: `sql_left_join(table(...))`\n- **RIGHT JOIN**: `sql_right_join(table(...))`\n- **FULL OUTER JOIN**: `sql_full_outer_join(table(...))`\n\nFind non-matching rows with LEFT JOIN + IS NULL:\n```prolog\ncustomers_without_orders(Name) :-\n    customers(CustId, Name, _, _),\n    sql_left_join(orders(OrderId, CustId, _, _, _)),\n    sql_is_null(OrderId).\n```", "answer_tailored": true}
{"pair_id": "sql-agg-001_p0", "cluster_id": "sql-agg-001", "question": "How do I use aggregations in the SQL target?", "question_type": "medium", "answer": "To implement aggregations in the SQL target, you combine aggregate functions with the `sql_group_by/1` predicate. You can also use `sql_having/1` to apply constraints to the grouped results.\n\n```prolog\n% Example of calculating sums by group\ndept_totals(Dept, Total) :-\n    employees(_, _, Dept, Salary, _),\n    Total = sql_sum(Salary),\n    sql_group_by([Dept]).\n\n% Example using HAVING to filter groups\nlarge_depts(Dept, Count) :-\n    employees(_, _, Dept, _, _),\n    Count = sql_count(*),\n    sql_group_by([Dept]),\n    sql_having(Count > 5).\n```\n\nSupported functions include `sql_count`, `sql_sum`, `sql_avg`, `sql_min`, and `sql_max`. For a full guide on SQL generation, see `education/book-10-sql-target/`.", "answer_variant": "default", "answer_source": "book-10-sql-target/04_aggregations.md", "topics": [], "original_answer": "Use aggregate functions with `sql_group_by/1` and optionally `sql_having/1`:\n\n```prolog\ndept_totals(Dept, Total) :-\n    employees(_, _, Dept, Salary, _),\n    Total = sql_sum(Salary),\n    sql_group_by([Dept]).\n\n% With HAVING\nlarge_depts(Dept, Count) :-\n    employees(_, _, Dept, _, _),\n    Count = sql_count(*),\n    sql_group_by([Dept]),\n    sql_having(Count > 5).\n```\n\nSupported: `sql_count`, `sql_sum`, `sql_avg`, `sql_min`, `sql_max`.", "answer_tailored": true}
