{"pair_id": "sql-practical-001_p0", "cluster_id": "sql-practical-001", "question": "How do I build a sales dashboard with the SQL target?", "question_type": "medium", "answer": "To build a sales dashboard using the SQL target, you can utilize UnifyWeaver's aggregation predicates and conditional logic to generate complex analytical queries. By combining `sql_group_by`, `sql_extract`, and `sql_case`, you can define comprehensive metrics like monthly revenue and customer segmentation directly in Prolog:\n\n```prolog\n% Monthly revenue summary\nmonthly_revenue(Year, Month, Revenue, OrderCount, AvgOrder) :-\n    orders(_, _, _, _, Amount, OrderDate, Status),\n    Status = 'completed',\n    Year = sql_extract(year, OrderDate),\n    Month = sql_extract(month, OrderDate),\n    sql_group_by([Year, Month]),\n    Revenue = sql_as(sql_sum(Amount), total_revenue),\n    OrderCount = sql_as(sql_count(*), order_count),\n    AvgOrder = sql_as(sql_avg(Amount), avg_order_value).\n\n% Customer segments with RFM logic\ncustomer_segments(CustomerId, CustomerName, Segment, TotalSpent, OrderCount) :-\n    customers(CustomerId, CustomerName, _, _, _),\n    orders(_, CustomerId, _, _, Amount, _, Status),\n    Status = 'completed',\n    sql_group_by([CustomerId, CustomerName]),\n    TotalSpent = sql_sum(Amount),\n    OrderCount = sql_count(*),\n    Segment = sql_case([\n        when((TotalSpent > 10000, OrderCount > 20), 'Platinum'),\n        when((TotalSpent > 5000, OrderCount > 10), 'Gold')\n    ], 'Bronze').\n```\n\nDetailed guidance on building analytics with the SQL target can be found in `education/book-10-sql-target/`.", "answer_variant": "default", "answer_source": "book-10-sql-target/12_practical_applications.md", "topics": [], "original_answer": "Combine aggregations, window functions, and CASE WHEN:\n\n```prolog\n% Monthly revenue summary\nmonthly_revenue(Year, Month, Revenue, OrderCount, AvgOrder) :-\n    orders(_, _, _, _, Amount, OrderDate, Status),\n    Status = 'completed',\n    Year = sql_extract(year, OrderDate),\n    Month = sql_extract(month, OrderDate),\n    sql_group_by([Year, Month]),\n    Revenue = sql_as(sql_sum(Amount), total_revenue),\n    OrderCount = sql_as(sql_count(*), order_count),\n    AvgOrder = sql_as(sql_avg(Amount), avg_order_value).\n\n% Customer segments with RFM\ncustomer_segments(CustomerId, CustomerName, Segment, TotalSpent, OrderCount) :-\n    customers(CustomerId, CustomerName, _, _, _),\n    orders(_, CustomerId, _, _, Amount, _, Status),\n    Status = 'completed',\n    sql_group_by([CustomerId, CustomerName]),\n    TotalSpent = sql_sum(Amount),\n    OrderCount = sql_count(*),\n    Segment = sql_case([\n        when((TotalSpent > 10000, OrderCount > 20), 'Platinum'),\n        when((TotalSpent > 5000, OrderCount > 10), 'Gold')\n    ], 'Bronze').\n```", "answer_tailored": true}
{"pair_id": "sql-practical-001_p0", "cluster_id": "sql-practical-001", "question": "How do I generate database views from Prolog predicates?", "question_type": "medium", "answer": "To generate database views from Prolog predicates, you use the `compile_predicate_to_sql/3` or `compile_recursive_cte/6` predicates provided by the SQL target, passing the `format(view)` and `view_name(Name)` options.\n\nFor example, you can generate views for standard predicates or recursive CTEs as follows:\n\n```prolog\n% Generate a standard view\ncompile_predicate_to_sql(monthly_revenue/5,\n    [format(view), view_name(v_monthly_revenue)], SQL1),\n\n% Generate a view from a recursive CTE\ncompile_recursive_cte(org_chart, [id, name, manager_id, level],\n    recursive_cte(org_base/4, org_recursive/4),\n    org_result/4,\n    [view_name(v_org_chart)], SQL2).\n```\n\nThe compiler transforms these calls into `CREATE VIEW IF NOT EXISTS view_name AS SELECT ...` statements. This allows you to encapsulate complex Prolog logic directly into the database layer. For further details on SQL target patterns, see `education/book-10-sql-target/`.", "answer_variant": "default", "answer_source": "book-10-sql-target/12_practical_applications.md", "topics": [], "original_answer": "Use the `format(view)` and `view_name(Name)` options:\n\n```prolog\ngenerate_views :-\n    % Revenue summary view\n    compile_predicate_to_sql(monthly_revenue/5,\n        [format(view), view_name(v_monthly_revenue)], SQL1),\n    write_sql_file('views/v_monthly_revenue.sql', SQL1),\n\n    % Customer segments view\n    compile_predicate_to_sql(customer_segments/5,\n        [format(view), view_name(v_customer_segments)], SQL2),\n    write_sql_file('views/v_customer_segments.sql', SQL2),\n\n    % Org chart using recursive CTE\n    compile_recursive_cte(org_chart, [id, name, manager_id, level],\n        recursive_cte(org_base/4, org_recursive/4),\n        org_result/4,\n        [view_name(v_org_chart)], SQL3),\n    write_sql_file('views/v_org_chart.sql', SQL3).\n```\n\nGenerates `CREATE VIEW IF NOT EXISTS v_monthly_revenue AS SELECT ...`", "answer_tailored": true}
{"pair_id": "sql-practical-002_p0", "cluster_id": "sql-practical-002", "question": "How do I create data quality reports with the SQL target?", "question_type": "medium", "answer": "To create data quality reports with the SQL target, you can write Prolog rules that leverage SQL-specific aggregations and subqueries to audit your datasets for duplicates, integrity issues, and freshness.\n\n```prolog\n% Identify duplicate records using group_by and having\nduplicate_emails(Email, Count) :-\n    users(_, Email, _, _),\n    sql_group_by([Email]),\n    Count = sql_count(*),\n    sql_having(Count > 1).\n\n% Detect orphaned records using not_exists subqueries\norphaned_orders(OrderId) :-\n    orders(OrderId, CustomerId, _, _, _, _, _),\n    sql_not_exists(customers(CustomerId, _, _, _, _)).\n\n% Categorize data freshness using max, date_diff, and case logic\ndata_freshness(LastUpdate, DaysOld, Status) :-\n    orders(_, _, _, _, _, OrderDate, _),\n    LastUpdate = sql_max(OrderDate),\n    DaysOld = sql_date_diff(sql_date('now'), LastUpdate),\n    Status = sql_case([\n        when(DaysOld < 1, 'Fresh'),\n        when(DaysOld < 7, 'Recent'),\n        when(DaysOld < 30, 'Stale')\n    ], 'Very Stale').\n```\n\nThese patterns allow you to push audit logic directly into the database engine for high-performance reporting. See `education/book-10-sql-target/` for more details on practical SQL application patterns.", "answer_variant": "default", "answer_source": "book-10-sql-target/12_practical_applications.md", "topics": [], "original_answer": "Use subqueries and aggregations to audit data:\n\n```prolog\n% Find duplicate emails\nduplicate_emails(Email, Count) :-\n    users(_, Email, _, _),\n    sql_group_by([Email]),\n    Count = sql_count(*),\n    sql_having(Count > 1).\n\n% Find orphaned records\norphaned_orders(OrderId) :-\n    orders(OrderId, CustomerId, _, _, _, _, _),\n    sql_not_exists(customers(CustomerId, _, _, _, _)).\n\n% Data freshness check\ndata_freshness(LastUpdate, DaysOld, Status) :-\n    orders(_, _, _, _, _, OrderDate, _),\n    LastUpdate = sql_max(OrderDate),\n    DaysOld = sql_date_diff(sql_date('now'), LastUpdate),\n    Status = sql_case([\n        when(DaysOld < 1, 'Fresh'),\n        when(DaysOld < 7, 'Recent'),\n        when(DaysOld < 30, 'Stale')\n    ], 'Very Stale').\n```", "answer_tailored": true}
