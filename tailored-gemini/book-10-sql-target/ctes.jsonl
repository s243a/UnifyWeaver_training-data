{"pair_id": "sql-cte-001_p0", "cluster_id": "sql-cte-001", "question": "How do I use Common Table Expressions (CTEs) in the SQL target?", "question_type": "medium", "answer": "To use Common Table Expressions (CTEs) in the SQL target, you employ the `compile_with_cte/4` predicate to generate `WITH` clauses. This allows you to define modular, reusable subqueries within your Prolog logic before compiling them into a single SQL statement.\n\nThe implementation follows a three-step pattern:\n1. **Define the CTE Logic**: Write a Prolog rule that represents the data for the CTE.\n2. **Define the Main Query**: Write the primary rule that references the CTE by its designated name.\n3. **Compile**: Use the `compile_with_cte/4` predicate to produce the final SQL string.\n\n```prolog\n% 1. Define the logic that will populate the CTE\nhigh_earner_data(Id, Name, Salary) :-\n    employees(Id, Name, _, Salary, _),\n    Salary > 100000.\n\n% 2. Define the main query referencing the CTE name 'high_earners'\nhigh_earner_result(Name, Salary) :-\n    high_earners(_, Name, Salary).\n\n% 3. Compile the predicates into a SQL WITH clause\n?- compile_with_cte(high_earners, high_earner_data/3, high_earner_result/2, SQL).\n```\n\nThe resulting SQL will be formatted as `WITH high_earners AS (SELECT ...) SELECT name, salary FROM high_earners`. For further details on complex and recursive CTEs, refer to `education/book-10-sql-target/07_common_table_expressions.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/07_common_table_expressions.md", "topics": [], "original_answer": "Use `compile_with_cte/4` to create WITH clauses:\n\n```prolog\n% Step 1: Define CTE content\nhigh_earner_data(Id, Name, Salary) :-\n    employees(Id, Name, _, Salary, _),\n    Salary > 100000.\n\n% Step 2: Define main query (references CTE by name)\nhigh_earner_result(Name, Salary) :-\n    high_earners(_, Name, Salary).  % References CTE name\n\n% Step 3: Compile\n?- compile_with_cte(high_earners, high_earner_data/3, high_earner_result/2, SQL).\n```\n\nGenerates: `WITH high_earners AS (SELECT ...) SELECT name, salary FROM high_earners`", "answer_tailored": true}
{"pair_id": "sql-cte-001_p0", "cluster_id": "sql-cte-001", "question": "Why use CTEs instead of subqueries?", "question_type": "medium", "answer": "In UnifyWeaver's SQL target, CTEs (Common Table Expressions) are preferred over subqueries because they offer superior structure, allow for filtering on window functions, and enable logic reuse.\n\n**1. Modular Readability**\nCTEs allow you to decompose complex queries into named, logical blocks. This makes the Prolog source code significantly cleaner than deeply nested subqueries:\n```prolog\nrich_depts_cte(DeptName) :-\n    departments(_, DeptName, Budget, _),\n    Budget > 1000000.\n\nemployees_result(Name) :-\n    employees(_, Name, Dept, _, _),\n    rich_depts(Dept).  % Clear, named reference\n```\n\n**2. Filtering Window Functions**\nStandard SQL prohibits using window function results in a `WHERE` clause. By defining the window function within a CTE, you can filter the output in subsequent predicates:\n```prolog\nranked_cte(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n\ntop_3_per_dept(Name, Dept, Salary, Rank) :-\n    ranked_employees(Name, Dept, Salary, Rank),\n    Rank =< 3.\n```\n\n**3. Internal Reusability**\nUnlike subqueries which must be redefined if needed multiple times, a CTE can be defined once and referenced repeatedly throughout the query, ensuring consistency and reducing code duplication.\n\nFor more details on how these are compiled to SQL, see `education/book-10-sql-target/07_common_table_expressions.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/07_common_table_expressions.md", "topics": [], "original_answer": "CTEs provide several advantages:\n\n**1. Improved readability** - Break complex queries into logical steps:\n```prolog\nrich_depts_cte(DeptName) :-\n    departments(_, DeptName, Budget, _),\n    Budget > 1000000.\n\nemployees_result(Name) :-\n    employees(_, Name, Dept, _, _),\n    rich_depts(Dept).  % Clear reference to CTE\n```\n\n**2. Filter window function results** - CTEs enable WHERE on window results:\n```prolog\nranked_cte(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n\ntop_3_per_dept(Name, Dept, Salary, Rank) :-\n    ranked_employees(Name, Dept, Salary, Rank),\n    Rank =< 3.\n```\n\n**3. Reuse within query** - Reference the same CTE multiple times.", "answer_tailored": true}
{"pair_id": "sql-cte-002_p0", "cluster_id": "sql-cte-002", "question": "How do I use recursive CTEs in the SQL target?", "question_type": "medium", "answer": "To implement recursive Common Table Expressions (CTEs) for hierarchical data in the SQL target, you use the `compile_recursive_cte/5` predicate. First, declare your recursive table schema with `sql_recursive_table/2`, then define your base case and a recursive case that joins back to the CTE table.\n\n```prolog\n% 1. Declare the recursive table schema\n:- sql_recursive_table(org_tree, [id-integer, name-text, manager_id-integer]).\n\n% 2. Base case: Select top-level nodes (e.g., employees without managers)\norg_base(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId).\n\n% 3. Recursive case: Join the base table to the CTE (org_tree)\norg_recursive(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    org_tree(ManagerId, _, _).\n\n% 4. Final query output\norg_result(Id, Name, ManagerId) :-\n    org_tree(Id, Name, ManagerId).\n\n% 5. Compile to SQL\n?- compile_recursive_cte(org_tree, [id, name, manager_id],\n    recursive_cte(org_base/3, org_recursive/3), org_result/3, SQL).\n```\n\nThis compilation generates a standard `WITH RECURSIVE` block using a `UNION ALL` operation between the base and recursive cases. For more detailed guidance on hierarchical query patterns, refer to `education/book-10-sql-target/08_recursive_ctes.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/08_recursive_ctes.md", "topics": [], "original_answer": "Use `compile_recursive_cte/5` for hierarchical data:\n\n```prolog\n% Declare recursive table schema\n:- sql_recursive_table(org_tree, [id-integer, name-text, manager_id-integer]).\n\n% Base case: Top-level employees (no manager)\norg_base(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId).\n\n% Recursive case: Employees whose manager is in org_tree\norg_recursive(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    org_tree(ManagerId, _, _).  % Join to CTE\n\n% Main query\norg_result(Id, Name, ManagerId) :-\n    org_tree(Id, Name, ManagerId).\n\n% Compile\n?- compile_recursive_cte(org_tree, [id, name, manager_id],\n    recursive_cte(org_base/3, org_recursive/3), org_result/3, SQL).\n```\n\nGenerates `WITH RECURSIVE ... UNION ALL ...`", "answer_tailored": true}
{"pair_id": "sql-cte-002_p0", "cluster_id": "sql-cte-002", "question": "What are common recursive CTE patterns?", "question_type": "medium", "answer": "Common recursive CTE patterns in UnifyWeaver facilitate the compilation of recursive Prolog predicates into SQL `WITH RECURSIVE` queries. The most frequently used patterns include:\n\n**1. Hierarchical Depth Tracking**\nThis pattern is used to calculate the generational level or depth within a tree-like structure, such as an organizational chart:\n```prolog\nlevel_base(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId),\n    Level = 0.\n\nlevel_recursive(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    org_levels(ManagerId, _, ParentLevel),\n    Level = ParentLevel + 1.\n```\n\n**2. Path Accumulation (Lineage)**\nThis pattern constructs a string representation (e.g., breadcrumbs or file paths) showing the traversal from a root node to the current record:\n```prolog\npath_base(Id, Path) :-\n    categories(Id, Name, ParentId),\n    sql_is_null(ParentId),\n    Path = Name.\n\npath_recursive(Id, Path) :-\n    categories(Id, Name, ParentId),\n    paths(ParentId, ParentPath),\n    Path = sql_concat([ParentPath, ' > ', Name]).\n```\n\n**3. Graph Reachability (Transitive Closure)**\nUsed to identify all nodes accessible from a specific starting point within a graph:\n```prolog\nreach_base(Node) :- edges(1, Node, _).\nreach_recursive(Node) :- reachable(From), edges(From, Node, _).\n```\n\nFor more detailed examples and technical specifications on how UnifyWeaver handles recursive SQL compilation, see `education/book-10-sql-target/08_recursive_ctes.md`.", "answer_variant": "default", "answer_source": "book-10-sql-target/08_recursive_ctes.md", "topics": [], "original_answer": "**1. Hierarchical depth tracking:**\n```prolog\nlevel_base(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId),\n    Level = 0.\n\nlevel_recursive(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    org_levels(ManagerId, _, ParentLevel),\n    Level = ParentLevel + 1.\n```\n\n**2. Path accumulation:**\n```prolog\npath_base(Id, Path) :-\n    categories(Id, Name, ParentId),\n    sql_is_null(ParentId),\n    Path = Name.\n\npath_recursive(Id, Path) :-\n    categories(Id, Name, ParentId),\n    paths(ParentId, ParentPath),\n    Path = sql_concat([ParentPath, ' > ', Name]).\n```\n\n**3. Graph reachability:**\n```prolog\nreach_base(Node) :- edges(1, Node, _).\nreach_recursive(Node) :- reachable(From), edges(From, Node, _).\n```", "answer_tailored": true}
