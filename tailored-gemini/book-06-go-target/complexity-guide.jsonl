{"pair_id": "b6-a2-mode-complexity_p0", "cluster_id": "b6-a2-mode-complexity", "question": "What is the complexity of Go target modes?", "question_type": "medium", "answer": "The complexity of Go target modes in UnifyWeaver depends on whether the code is executed in **Streaming Mode** or **Generator Mode (Fixpoint)**.\n\n### Streaming Mode\nStreaming mode is designed for high-efficiency data transformations with minimal memory overhead.\n*   **Simple Transformations:** O(n) time complexity and O(1) space.\n*   **Regex Matching:** O(n \u00d7 m) time complexity and O(1) space.\n*   **JSON Parsing:** O(n) time complexity, while space complexity is O(d) relative to the nesting depth.\n\n### Generator Mode (Fixpoint)\nGenerator mode supports stateful operations and recursive logic, requiring more memory to maintain the fact set.\n*   **Fixpoint Iteration:** O(n \u00d7 k) time (where *k* is the number of iterations) and O(n) space.\n*   **Joins:** Indexed joins provide O(1) lookup time, whereas unindexed joins scale at O(n\u00b2) time. Both require O(n) space.\n*   **Aggregation:** O(n) time complexity and O(g) space, where *g* represents the number of groups.\n\nFor comprehensive details on Go target performance and implementation strategies, see the documentation in `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["complexity", "big-o", "streaming-mode", "generator-mode"], "original_answer": "## Go Target Mode Complexity\n\n### Streaming Mode\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Simple transform | O(n) | O(1) |\n| Regex matching | O(n \u00d7 m) | O(1) |\n| JSON parsing | O(n) | O(d) |\n\n### Generator Mode (Fixpoint)\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Fixpoint iteration | O(n \u00d7 k) | O(n) |\n| Indexed join | O(1) lookup | O(n) |\n| Unindexed join | O(n\u00b2) | O(n) |\n| Aggregation | O(n) | O(g) |\n\nWhere: n = facts, k = iterations, g = groups, d = nesting depth", "answer_tailored": true}
{"pair_id": "b6-a2-mode-complexity_p1", "cluster_id": "b6-a2-mode-complexity", "question": "What is Big-O for streaming vs generator mode?", "question_type": "medium", "answer": "In the UnifyWeaver Go target, Big-O complexity varies based on whether the engine operates in streaming or generator (fixpoint) mode.\n\n### Streaming Mode\nStreaming mode is optimized for low-memory, single-pass processing:\n* **Simple Transform:** O(n) time and O(1) space.\n* **Regex Matching:** O(n \u00d7 m) time and O(1) space.\n* **JSON Parsing:** O(n) time, with space complexity scaling by nesting depth O(d).\n\n### Generator Mode (Fixpoint)\nGenerator mode manages state to support recursive logic and joins:\n* **Fixpoint Iteration:** O(n \u00d7 k) time and O(n) space, where k is the number of iterations.\n* **Indexed Join:** O(1) lookup time with O(n) space.\n* **Unindexed Join:** O(n\u00b2) time and O(n) space.\n* **Aggregation:** O(n) time and O(g) space, where g is the number of groups.\n\nFor a comprehensive breakdown of performance characteristics in the Go target, refer to `education/book-06-go-target/A2_complexity_guide.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["complexity", "big-o", "streaming-mode", "generator-mode"], "original_answer": "## Go Target Mode Complexity\n\n### Streaming Mode\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Simple transform | O(n) | O(1) |\n| Regex matching | O(n \u00d7 m) | O(1) |\n| JSON parsing | O(n) | O(d) |\n\n### Generator Mode (Fixpoint)\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Fixpoint iteration | O(n \u00d7 k) | O(n) |\n| Indexed join | O(1) lookup | O(n) |\n| Unindexed join | O(n\u00b2) | O(n) |\n| Aggregation | O(n) | O(g) |\n\nWhere: n = facts, k = iterations, g = groups, d = nesting depth", "answer_tailored": true}
{"pair_id": "b6-a2-mode-complexity_p2", "cluster_id": "b6-a2-mode-complexity", "question": "How does fixpoint iteration scale?", "question_type": "medium", "answer": "Fixpoint iteration scales linearly with respect to both the number of facts ($n$) and the number of iterations ($k$) required to reach convergence. In the Go target's Generator mode, this results in a time complexity of **$O(n \\times k)$** and a space complexity of **$O(n)$**, as the system must maintain the set of derived facts in memory to detect when no further changes occur. This $O(n)$ space requirement distinguishes fixpoint generation from basic streaming transformations, which often operate in $O(1)$ space. For a detailed breakdown of performance metrics and complexity for Go-based targets, see `education/book-06-go-target/A2_complexity_guide.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["complexity", "big-o", "streaming-mode", "generator-mode"], "original_answer": "## Go Target Mode Complexity\n\n### Streaming Mode\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Simple transform | O(n) | O(1) |\n| Regex matching | O(n \u00d7 m) | O(1) |\n| JSON parsing | O(n) | O(d) |\n\n### Generator Mode (Fixpoint)\n\n| Operation | Time | Space |\n|-----------|------|-------|\n| Fixpoint iteration | O(n \u00d7 k) | O(n) |\n| Indexed join | O(1) lookup | O(n) |\n| Unindexed join | O(n\u00b2) | O(n) |\n| Aggregation | O(n) | O(g) |\n\nWhere: n = facts, k = iterations, g = groups, d = nesting depth", "answer_tailored": true}
{"pair_id": "b6-a2-recursion-complexity_p0", "cluster_id": "b6-a2-recursion-complexity", "question": "What is the complexity of recursive compilation?", "question_type": "medium", "answer": "The complexity of recursive compilation in UnifyWeaver depends on the specific recursion pattern being mapped from Prolog to the target language.\n\n- **Tail Recursion:** Optimized into iterative `for` loops, resulting in $O(n)$ time complexity and $O(1)$ space complexity.\n- **BFS Transitive Closure:** Operates in $O(V + E)$ time with $O(V)$ space by utilizing a queue and a visited set (typically a `map[string]bool` in Go).\n- **Linear (Memoized) & Mutual Recursion:** These patterns achieve $O(n)$ time and $O(n)$ space complexity through map-based caching, where lookups are $O(1)$.\n\nThe generated code for memoization uses a map-based cache (e.g., `make(map[int]int)`) to store results, while BFS implementations manage state via a queue and a tracking set. For a deeper dive into these patterns and their performance characteristics, see `education/book-06-go-target/A2_complexity_guide.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["recursion-complexity", "bfs", "memoization", "tail-recursion"], "original_answer": "## Recursion Pattern Complexity\n\n| Pattern | Time | Space | Generated Code |\n|---------|------|-------|----------------|\n| BFS transitive closure | O(V + E) | O(V) | Queue + visited set |\n| Tail recursion | O(n) | O(1) | Iterative for-loop |\n| Linear (memoized) | O(n) | O(n) | Map-based cache |\n| Mutual recursion | O(n) | O(n) | Shared memo map |\n\n### BFS Implementation\n\n```go\nvisited := make(map[string]bool)  // O(V) space\nqueue := []string{start}          // O(V) max size\n```\n\n### Memoization\n\n```go\nvar memo = make(map[int]int)  // O(n) space\nif result, ok := memo[n]; ok { return result }  // O(1) lookup\n```", "answer_tailored": true}
{"pair_id": "b6-a2-recursion-complexity_p1", "cluster_id": "b6-a2-recursion-complexity", "question": "How does BFS transitive closure scale?", "question_type": "medium", "answer": "BFS transitive closure in the Go target scales linearly relative to the graph's size, specifically achieving O(V + E) time complexity and O(V) space complexity. The compiler generates an iterative implementation using a queue and a visited map (`map[string]bool`) to track explored nodes, ensuring that each vertex and edge is processed only once. This approach prevents stack overflow issues common in deep recursion and keeps the memory footprint proportional to the number of vertices. For more details on recursion pattern complexity in Go, refer to `education/book-06-go-target/A2_complexity_guide.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["recursion-complexity", "bfs", "memoization", "tail-recursion"], "original_answer": "## Recursion Pattern Complexity\n\n| Pattern | Time | Space | Generated Code |\n|---------|------|-------|----------------|\n| BFS transitive closure | O(V + E) | O(V) | Queue + visited set |\n| Tail recursion | O(n) | O(1) | Iterative for-loop |\n| Linear (memoized) | O(n) | O(n) | Map-based cache |\n| Mutual recursion | O(n) | O(n) | Shared memo map |\n\n### BFS Implementation\n\n```go\nvisited := make(map[string]bool)  // O(V) space\nqueue := []string{start}          // O(V) max size\n```\n\n### Memoization\n\n```go\nvar memo = make(map[int]int)  // O(n) space\nif result, ok := memo[n]; ok { return result }  // O(1) lookup\n```", "answer_tailored": true}
{"pair_id": "b6-a2-recursion-complexity_p2", "cluster_id": "b6-a2-recursion-complexity", "question": "What is the complexity of memoized recursion?", "question_type": "medium", "answer": "The complexity of memoized recursion within the Go target is **O(n) for both time and space**.\n\nUnifyWeaver achieves this efficiency by generating map-based caches that store results for previously calculated inputs. While the map lookup itself is O(1), the overall space complexity grows to O(n) to accommodate the cached values. This performance profile remains consistent for both standard linear recursion and mutual recursion patterns.\n\n**Implementation Logic:**\n```go\nvar memo = make(map[int]int)  // O(n) space overhead\nif result, ok := memo[n]; ok { return result }  // O(1) lookup\n```\n\nFor a comprehensive breakdown of recursion patterns and their performance characteristics in Go, refer to `education/book-06-go-target/A2_complexity_guide.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["recursion-complexity", "bfs", "memoization", "tail-recursion"], "original_answer": "## Recursion Pattern Complexity\n\n| Pattern | Time | Space | Generated Code |\n|---------|------|-------|----------------|\n| BFS transitive closure | O(V + E) | O(V) | Queue + visited set |\n| Tail recursion | O(n) | O(1) | Iterative for-loop |\n| Linear (memoized) | O(n) | O(n) | Map-based cache |\n| Mutual recursion | O(n) | O(n) | Shared memo map |\n\n### BFS Implementation\n\n```go\nvisited := make(map[string]bool)  // O(V) space\nqueue := []string{start}          // O(V) max size\n```\n\n### Memoization\n\n```go\nvar memo = make(map[int]int)  // O(n) space\nif result, ok := memo[n]; ok { return result }  // O(1) lookup\n```", "answer_tailored": true}
{"pair_id": "b6-a2-db-complexity_p0", "cluster_id": "b6-a2-db-complexity", "question": "What is the complexity of BoltDB queries?", "question_type": "medium", "answer": "BoltDB query complexity in UnifyWeaver's Go target depends on the alignment between your query pattern and the chosen key strategy. Because BoltDB uses a B+ tree, queries that leverage the key are highly efficient.\n\n### Performance by Query Pattern\n\n| Query Pattern | Strategy | Complexity |\n|---------------|----------|------------|\n| **Direct Lookup** (`key = value`) | Direct B+ tree search | **O(log n)** |\n| **Prefix Scan** (`key_prefix = value`) | Range scan (Composite keys) | **O(k log n)** |\n| **Non-Key Filter** (`field > value`) | Full bucket iteration | **O(n)** |\n\n### Key Strategy Complexity Matrix\n\n| Strategy | Point Lookup | Range Scan | Full Scan |\n|----------|--------------|------------|-----------|\n| **Single field key** | O(log n) | N/A | O(n) |\n| **Composite key** | O(log n) | O(k log n) | O(n) |\n| **Hash key** | O(log n) | N/A | O(n) |\n\nTo achieve the best performance, prioritize placing frequently filtered fields within the primary key to ensure O(log n) retrieval. For detailed implementation details and optimization techniques, refer to the complexity guide in `education/book-06-go-target/A2_complexity_guide.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["database-complexity", "boltdb", "key-lookup", "query-optimization"], "original_answer": "## Database Query Complexity\n\n### Key Strategy Performance\n\n| Strategy | Lookup | Range Scan | Full Scan |\n|----------|--------|------------|----------|\n| Single field key | O(log n) | N/A | O(n) |\n| Composite key | O(log n) | O(k log n) | O(n) |\n| Hash key | O(log n) | N/A | O(n) |\n\n### Query Optimization\n\n| Query Pattern | Strategy | Complexity |\n|---------------|----------|------------|\n| `key = value` | Direct lookup | O(log n) |\n| `key_prefix = value` | Prefix scan | O(k log n) |\n| `field > value` (non-key) | Full scan | O(n) |\n\n**Tip:** Put frequently queried fields in the key for O(log n) lookups.", "answer_tailored": true}
{"pair_id": "b6-a2-db-complexity_p1", "cluster_id": "b6-a2-db-complexity", "question": "How do key strategies affect performance?", "question_type": "medium", "answer": "Key strategies in UnifyWeaver directly determine the algorithmic complexity and performance of your data lookups. By selecting the appropriate key strategy, you can optimize for specific query patterns:\n\n*   **Direct Lookups (`key = value`):** Single field, composite, and hash key strategies all provide **O(log n)** performance.\n*   **Prefix Scans (`key_prefix = value`):** Composite keys are required to achieve **O(k log n)** complexity; other strategies will typically result in an **O(n)** full scan.\n*   **Full Scans:** Any query on a non-key field (e.g., `field > value`) defaults to **O(n)**, regardless of the key strategy.\n\nTo ensure optimal performance, frequently queried fields should be incorporated into the key to maintain **O(log n)** lookup speeds. For a detailed breakdown of performance metrics and complexity analysis for the Go target, refer to `education/book-06-go-target/A2_complexity_guide.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["database-complexity", "boltdb", "key-lookup", "query-optimization"], "original_answer": "## Database Query Complexity\n\n### Key Strategy Performance\n\n| Strategy | Lookup | Range Scan | Full Scan |\n|----------|--------|------------|----------|\n| Single field key | O(log n) | N/A | O(n) |\n| Composite key | O(log n) | O(k log n) | O(n) |\n| Hash key | O(log n) | N/A | O(n) |\n\n### Query Optimization\n\n| Query Pattern | Strategy | Complexity |\n|---------------|----------|------------|\n| `key = value` | Direct lookup | O(log n) |\n| `key_prefix = value` | Prefix scan | O(k log n) |\n| `field > value` (non-key) | Full scan | O(n) |\n\n**Tip:** Put frequently queried fields in the key for O(log n) lookups.", "answer_tailored": true}
{"pair_id": "b6-a2-db-complexity_p2", "cluster_id": "b6-a2-db-complexity", "question": "When is full scan vs direct lookup used?", "question_type": "medium", "answer": "Direct lookup is used for exact key matches, whereas a full scan is required when querying non-key fields. The choice between these strategies depends on how the data is indexed and the specific query pattern:\n\n*   **Direct Lookup ($O(\\log n)$):** Employed for `key = value` queries. This strategy provides efficient retrieval across single field, composite, and hash key configurations.\n*   **Prefix Scan ($O(k \\log n)$):** Used when matching a `key_prefix = value` on composite keys.\n*   **Full Scan ($O(n)$):** Triggered when a query targets a non-key field (e.g., `field > value`). Since the field is not indexed, the system must evaluate every record in the dataset.\n\nTo optimize performance, ensure that frequently queried fields are included in the key to leverage $O(\\log n)$ lookup speeds. For more detailed information on database query complexity, see `education/book-06-go-target/A2_complexity_guide.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A2_complexity_guide.md", "topics": ["database-complexity", "boltdb", "key-lookup", "query-optimization"], "original_answer": "## Database Query Complexity\n\n### Key Strategy Performance\n\n| Strategy | Lookup | Range Scan | Full Scan |\n|----------|--------|------------|----------|\n| Single field key | O(log n) | N/A | O(n) |\n| Composite key | O(log n) | O(k log n) | O(n) |\n| Hash key | O(log n) | N/A | O(n) |\n\n### Query Optimization\n\n| Query Pattern | Strategy | Complexity |\n|---------------|----------|------------|\n| `key = value` | Direct lookup | O(log n) |\n| `key_prefix = value` | Prefix scan | O(k log n) |\n| `field > value` (non-key) | Full scan | O(n) |\n\n**Tip:** Put frequently queried fields in the key for O(log n) lookups.", "answer_tailored": true}
