{"pair_id": "b6-a1-core-apis_p0", "cluster_id": "b6-a1-core-apis", "question": "What APIs does the Go target provide?", "question_type": "medium", "answer": "The Go target provides two primary Prolog predicates for compiling logic and data into Go source code: `compile_predicate_to_go/3` and `compile_facts_to_go/3`.\n\n`compile_predicate_to_go(+Predicate/Arity, +Options, -Code)` serves as the main compilation interface. It supports several execution modes and configurations:\n* **Modes**: `streaming` (default) for processing stdin to stdout, or `generator` for building a fixpoint Datalog engine.\n* **Input Handling**: Can be configured to parse JSONL from stdin using `json_input(true)`.\n* **Concurrency**: The `workers(N)` option allows specifying the number of parallel goroutines.\n* **Persistence**: Support for BoltDB storage can be enabled via `db_backend(bbolt)`.\n\n`compile_facts_to_go(+Functor, +Arity, -Code)` is used to export static Prolog facts as Go struct slices. This generates a set of utility functions for data access, including `GetAll<NAME>()`, `Stream<NAME>()`, and `Contains<NAME>()`.\n\nFor more detailed API documentation and usage examples, refer to `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-predicate-to-go", "compile-facts-to-go", "api-reference"], "original_answer": "## Go Target Core APIs\n\n### compile_predicate_to_go/3\n\nMain compilation predicate for streaming and generator modes.\n\n```prolog\ncompile_predicate_to_go(+Predicate/Arity, +Options, -Code)\n```\n\n**Options:**\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `mode(streaming)` | \u2713 | stdin\u2192stdout processor |\n| `mode(generator)` | - | Fixpoint Datalog engine |\n| `json_input(true)` | false | Read JSONL from stdin |\n| `workers(N)` | 1 | Parallel goroutines |\n| `db_backend(bbolt)` | - | BoltDB persistence |\n\n### compile_facts_to_go/3\n\nExports facts as Go struct slices.\n\n```prolog\ncompile_facts_to_go(+Functor, +Arity, -Code)\n```\n\nGenerates: `GetAll<NAME>()`, `Stream<NAME>()`, `Contains<NAME>()`", "answer_tailored": true}
{"pair_id": "b6-a1-core-apis_p1", "cluster_id": "b6-a1-core-apis", "question": "What is compile_predicate_to_go/3?", "question_type": "medium", "answer": "`compile_predicate_to_go/3` is the primary predicate for compiling Prolog logic into Go, supporting both stdin-to-stdout streaming processors and fixpoint Datalog generator engines. The predicate uses the signature `compile_predicate_to_go(+Predicate/Arity, +Options, -Code)`.\n\nAvailable options for the Go target include:\n- **mode**: Choose between `streaming` (default) for line-by-line processing or `generator` for Datalog execution.\n- **json_input**: Set to `true` to enable reading JSONL data from stdin.\n- **workers**: Defines the number of parallel goroutines allocated for the task.\n- **db_backend**: Configures persistence layers, such as `bbolt`.\n\nFor more information on Go target APIs, see `education/book-06-go-target/A1_api_reference.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-predicate-to-go", "compile-facts-to-go", "api-reference"], "original_answer": "## Go Target Core APIs\n\n### compile_predicate_to_go/3\n\nMain compilation predicate for streaming and generator modes.\n\n```prolog\ncompile_predicate_to_go(+Predicate/Arity, +Options, -Code)\n```\n\n**Options:**\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `mode(streaming)` | \u2713 | stdin\u2192stdout processor |\n| `mode(generator)` | - | Fixpoint Datalog engine |\n| `json_input(true)` | false | Read JSONL from stdin |\n| `workers(N)` | 1 | Parallel goroutines |\n| `db_backend(bbolt)` | - | BoltDB persistence |\n\n### compile_facts_to_go/3\n\nExports facts as Go struct slices.\n\n```prolog\ncompile_facts_to_go(+Functor, +Arity, -Code)\n```\n\nGenerates: `GetAll<NAME>()`, `Stream<NAME>()`, `Contains<NAME>()`", "answer_tailored": true}
{"pair_id": "b6-a1-core-apis_p2", "cluster_id": "b6-a1-core-apis", "question": "What options does compile_predicate_to_go accept?", "question_type": "medium", "answer": "The `compile_predicate_to_go/3` predicate accepts an options list that configures the execution model and input handling of the generated Go code. The supported options include:\n\n*   **mode(streaming | generator)**: Defines the execution style. `streaming` (the default) creates a stdin-to-stdout processor, while `generator` produces a fixpoint Datalog engine.\n*   **json_input(Boolean)**: When set to `true`, the generated code is configured to parse JSONL records from standard input. This defaults to `false`.\n*   **workers(N)**: Specifies the number of concurrent goroutines to use for parallel execution (defaults to `1`).\n*   **db_backend(Backend)**: Enables persistence for the Datalog engine, such as `db_backend(bbolt)` for BoltDB integration.\n\nDetailed API information and usage examples can be found in `education/book-06-go-target/A1_api_reference.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-predicate-to-go", "compile-facts-to-go", "api-reference"], "original_answer": "## Go Target Core APIs\n\n### compile_predicate_to_go/3\n\nMain compilation predicate for streaming and generator modes.\n\n```prolog\ncompile_predicate_to_go(+Predicate/Arity, +Options, -Code)\n```\n\n**Options:**\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `mode(streaming)` | \u2713 | stdin\u2192stdout processor |\n| `mode(generator)` | - | Fixpoint Datalog engine |\n| `json_input(true)` | false | Read JSONL from stdin |\n| `workers(N)` | 1 | Parallel goroutines |\n| `db_backend(bbolt)` | - | BoltDB persistence |\n\n### compile_facts_to_go/3\n\nExports facts as Go struct slices.\n\n```prolog\ncompile_facts_to_go(+Functor, +Arity, -Code)\n```\n\nGenerates: `GetAll<NAME>()`, `Stream<NAME>()`, `Contains<NAME>()`", "answer_tailored": true}
{"pair_id": "b6-a1-recursion-apis_p0", "cluster_id": "b6-a1-recursion-apis", "question": "What recursion APIs does Go target have?", "question_type": "medium", "answer": "The Go target in UnifyWeaver provides several specialized APIs for handling recursion, ranging from general transitive closures to optimized memoization strategies:\n\n*   **`compile_recursive/3`**: Executes a BFS-based transitive closure with O(V + E) complexity. It is invoked with the `target(go)` option: `compile_recursive(pred/2, [target(go)], Code)`.\n*   **`compile_tail_recursion_go/3`**: This API optimizes tail recursion by transforming it into efficient iterative loops, ensuring O(1) stack space.\n*   **`compile_linear_recursion_go/3`**: Provides O(n) time complexity by automatically implementing memoization using Go `map` structures for caching.\n*   **`compile_mutual_recursion_go/3`**: Specifically designed for mutually recursive predicates, this API coordinates a shared memoization map across the generated Go functions.\n\nFor more details on these and other Go-specific compilation tools, refer to the documentation in `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-recursive", "tail-recursion", "memoization", "mutual-recursion"], "original_answer": "## Go Target Recursion APIs\n\n### compile_recursive/3\n\nBFS-based transitive closure. O(V + E) complexity.\n\n```prolog\ncompile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### compile_tail_recursion_go/3\n\nConverts tail recursion to iterative loops. O(1) stack space.\n\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n### compile_linear_recursion_go/3\n\nAdds memoization with `map[int]int`. O(n) time via caching.\n\n```prolog\ncompile_linear_recursion_go(triangular/2, [], Code).\n```\n\n### compile_mutual_recursion_go/3\n\nShared memo map for mutually recursive predicates.\n\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a1-recursion-apis_p1", "cluster_id": "b6-a1-recursion-apis", "question": "How do I compile tail recursion to Go?", "question_type": "medium", "answer": "To compile tail recursion into Go, utilize the `compile_tail_recursion_go/3` predicate. This compiler optimization transforms recursive Prolog logic into iterative loops, ensuring the generated code maintains $O(1)$ stack space efficiency.\n\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\nFor other recursion patterns in the Go target, the following APIs are available:\n*   **Linear Recursion**: Use `compile_linear_recursion_go/3` to implement memoization via Go maps, achieving $O(n)$ time complexity.\n*   **Mutual Recursion**: Use `compile_mutual_recursion_go/3` to manage shared memoization maps across multiple interdependent predicates.\n*   **Transitive Closure**: Use `compile_recursive/3` for BFS-based recursion with $O(V + E)$ complexity.\n\nFurther details on these recursion strategies can be found in `education/book-06-go-target/A1_api_reference.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-recursive", "tail-recursion", "memoization", "mutual-recursion"], "original_answer": "## Go Target Recursion APIs\n\n### compile_recursive/3\n\nBFS-based transitive closure. O(V + E) complexity.\n\n```prolog\ncompile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### compile_tail_recursion_go/3\n\nConverts tail recursion to iterative loops. O(1) stack space.\n\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n### compile_linear_recursion_go/3\n\nAdds memoization with `map[int]int`. O(n) time via caching.\n\n```prolog\ncompile_linear_recursion_go(triangular/2, [], Code).\n```\n\n### compile_mutual_recursion_go/3\n\nShared memo map for mutually recursive predicates.\n\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a1-recursion-apis_p2", "cluster_id": "b6-a1-recursion-apis", "question": "What is compile_mutual_recursion_go/3?", "question_type": "medium", "answer": "`compile_mutual_recursion_go/3` is a specialized API for the Go target that facilitates the compilation of mutually recursive predicates by implementing a shared memoization map. This optimization allows multiple interdependent predicates to share cached results, preventing redundant computations and improving execution efficiency. \n\nIn addition to mutual recursion, the Go target recursion suite includes:\n- `compile_recursive/3`: Performs BFS-based transitive closure with O(V + E) complexity.\n- `compile_tail_recursion_go/3`: Transforms tail recursion into iterative loops to ensure O(1) constant stack space.\n- `compile_linear_recursion_go/3`: Adds memoization using a `map[int]int` to achieve O(n) time complexity via caching.\n\nExample usage for mutual recursion:\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nFor a full reference on Go recursion strategies, see `education/book-06-go-target/A1_api_reference.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["compile-recursive", "tail-recursion", "memoization", "mutual-recursion"], "original_answer": "## Go Target Recursion APIs\n\n### compile_recursive/3\n\nBFS-based transitive closure. O(V + E) complexity.\n\n```prolog\ncompile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### compile_tail_recursion_go/3\n\nConverts tail recursion to iterative loops. O(1) stack space.\n\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n### compile_linear_recursion_go/3\n\nAdds memoization with `map[int]int`. O(n) time via caching.\n\n```prolog\ncompile_linear_recursion_go(triangular/2, [], Code).\n```\n\n### compile_mutual_recursion_go/3\n\nShared memo map for mutually recursive predicates.\n\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a1-api-selection_p0", "cluster_id": "b6-a1-api-selection", "question": "Which Go target API should I use?", "question_type": "medium", "answer": "To determine which Go target API to use, you should match your logic's complexity and data flow requirements to the following compiler predicates:\n\n- **Fact Export:** Use `compile_facts_to_go/3` to generate Go structs from Prolog facts.\n- **Stream Processing:** Use `compile_predicate_to_go/3` in **streaming mode** for high-performance, O(1) memory ETL transforms.\n- **Datalog & Joins:** Use `compile_predicate_to_go/3` in **generator mode** for full fixpoint iteration and complex relational logic.\n- **Graph/Transitive Closure:** Use `compile_recursive/3` for breadth-first search patterns.\n- **Recursion Patterns:** Use `compile_tail_recursion_go/3` for accumulator-based loops, `compile_linear_recursion_go/3` for memoized recursive calls, or `compile_mutual_recursion_go/3` for mutually recursive predicates.\n\nChoosing between modes is critical: **Streaming** is best for O(n) single-pass data processing, while **Generator** mode supports more complex logic and fixpoint iteration at the cost of O(n) memory. For further details on these implementations, refer to `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["api-selection", "streaming-vs-generator", "when-to-use"], "original_answer": "## API Selection Guide\n\n| Use Case | API | Mode |\n|----------|-----|------|\n| Export facts to structs | `compile_facts_to_go/3` | - |\n| Simple stream transform | `compile_predicate_to_go/3` | streaming |\n| Full Datalog with joins | `compile_predicate_to_go/3` | generator |\n| Transitive closure (BFS) | `compile_recursive/3` | - |\n| Accumulator loops | `compile_tail_recursion_go/3` | - |\n| Memoized recursion | `compile_linear_recursion_go/3` | - |\n| Mutual recursion | `compile_mutual_recursion_go/3` | - |\n\n### Mode Selection\n\n- **Streaming**: O(n) single-pass, O(1) memory. For ETL pipelines.\n- **Generator**: Fixpoint iteration, O(n) memory. For recursion, joins, negation.", "answer_tailored": true}
{"pair_id": "b6-a1-api-selection_p1", "cluster_id": "b6-a1-api-selection", "question": "When do I use generator mode vs streaming?", "question_type": "medium", "answer": "Choose the mode based on your performance requirements and the complexity of your logic.\n\n*   **Streaming Mode**: Use this for simple ETL pipelines and single-pass transformations. It is highly efficient with **O(1) memory** usage and O(n) time complexity.\n*   **Generator Mode**: Use this for complex Datalog queries that require joins, negation, or fixpoint iteration. This mode requires **O(n) memory** to track state during evaluation.\n\nBoth modes are configured via the `compile_predicate_to_go/3` predicate. For a deeper dive into Go target selection and API details, refer to `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["api-selection", "streaming-vs-generator", "when-to-use"], "original_answer": "## API Selection Guide\n\n| Use Case | API | Mode |\n|----------|-----|------|\n| Export facts to structs | `compile_facts_to_go/3` | - |\n| Simple stream transform | `compile_predicate_to_go/3` | streaming |\n| Full Datalog with joins | `compile_predicate_to_go/3` | generator |\n| Transitive closure (BFS) | `compile_recursive/3` | - |\n| Accumulator loops | `compile_tail_recursion_go/3` | - |\n| Memoized recursion | `compile_linear_recursion_go/3` | - |\n| Mutual recursion | `compile_mutual_recursion_go/3` | - |\n\n### Mode Selection\n\n- **Streaming**: O(n) single-pass, O(1) memory. For ETL pipelines.\n- **Generator**: Fixpoint iteration, O(n) memory. For recursion, joins, negation.", "answer_tailored": true}
{"pair_id": "b6-a1-api-selection_p2", "cluster_id": "b6-a1-api-selection", "question": "How do I choose between recursion APIs?", "question_type": "medium", "answer": "To choose the appropriate recursion API for the Go target, evaluate the structure of your Prolog predicate and the desired execution strategy:\n\n- **Tail Recursion**: Use `compile_tail_recursion_go/3` for predicates that function as accumulator loops or iterative processes.\n- **Memoized/Linear Recursion**: Use `compile_linear_recursion_go/3` for standard recursive definitions where memoization is beneficial for performance.\n- **Mutual Recursion**: Use `compile_mutual_recursion_go/3` when two or more predicates depend on each other.\n- **Transitive Closure (BFS)**: Use `compile_recursive/3` for graph-like traversals and reachability problems.\n- **General Datalog/Joins**: Use `compile_predicate_to_go/3` in **Generator mode** for full fixpoint iteration.\n\n### Operational Modes\nThe choice of mode is determined by your memory and data requirements:\n- **Streaming Mode**: Use this for single-pass ETL transformations where O(1) memory is required and data is processed in one direction.\n- **Generator Mode**: Use this for complex recursion, joins, or negation where O(n) memory is acceptable to perform fixpoint iteration.\n\nFor a complete reference of these APIs and their parameters, consult `education/book-06-go-target/A1_api_reference.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A1_api_reference.md", "topics": ["api-selection", "streaming-vs-generator", "when-to-use"], "original_answer": "## API Selection Guide\n\n| Use Case | API | Mode |\n|----------|-----|------|\n| Export facts to structs | `compile_facts_to_go/3` | - |\n| Simple stream transform | `compile_predicate_to_go/3` | streaming |\n| Full Datalog with joins | `compile_predicate_to_go/3` | generator |\n| Transitive closure (BFS) | `compile_recursive/3` | - |\n| Accumulator loops | `compile_tail_recursion_go/3` | - |\n| Memoized recursion | `compile_linear_recursion_go/3` | - |\n| Mutual recursion | `compile_mutual_recursion_go/3` | - |\n\n### Mode Selection\n\n- **Streaming**: O(n) single-pass, O(1) memory. For ETL pipelines.\n- **Generator**: Fixpoint iteration, O(n) memory. For recursion, joins, negation.", "answer_tailored": true}
