{"pair_id": "b6-c1-go-overview_p0", "cluster_id": "b6-c1-go-overview", "question": "Why compile Prolog to Go?", "question_type": "medium", "answer": "Compiling Prolog to Go is primarily motivated by the need for high-performance, standalone executables that are easy to deploy across various platforms. By targeting Go, UnifyWeaver transforms Prolog logic into efficient, dependency-free binaries that excel at I/O-intensive ETL tasks and string processing.\n\nKey advantages include:\n- **Deployment Simplicity:** The compiler produces a single binary, meaning you can deploy the tool by simply copying the executable without worrying about external runtimes.\n- **Native Cross-Platform Support:** Go allows you to easily cross-compile for Linux, Windows, and macOS from a single development environment.\n- **Performance Gains:** Unlike shell-based targets like Bash, which depend on system tools, Go provides superior performance for complex logic and high-throughput data processing.\n\nFor a detailed overview of the Go target's capabilities, refer to `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/01_introduction.md", "topics": ["go-target", "native-binaries", "cross-platform"], "original_answer": "## Go Target Overview\n\nThe Go target compiles Prolog logic into standalone Go programs.\n\n### Key Benefits\n\n| Benefit | Description |\n|---------|-------------|\n| Single Binary | No runtime dependencies |\n| Cross-Platform | Linux, Windows, macOS from one source |\n| Performance | Excellent for string/I/O processing |\n| Deployment | Just copy the executable |\n\n### Cross-Compilation\n\n```bash\n# Build for Windows on Linux\nGOOS=windows GOARCH=amd64 go build -o tool.exe tool.go\n```\n\n### Comparison with Bash\n\n| Feature | Bash | Go |\n|---------|------|----|\n| Runtime | Bash 4.0+ | None |\n| Portability | Unix-like | All platforms |\n| Dependencies | System tools | None |\n| Use case | Shell scripts | High-performance ETL |", "answer_tailored": true}
{"pair_id": "b6-c1-go-overview_p1", "cluster_id": "b6-c1-go-overview", "question": "What are the advantages of the Go target?", "question_type": "medium", "answer": "The Go target provides several distinct advantages for compiling Prolog logic, primarily focused on deployment efficiency and cross-platform reliability.\n\nKey advantages include:\n- **Self-Contained Binaries**: It compiles into a single executable with no external runtime requirements, allowing for simple \"copy-and-run\" deployment.\n- **Native Cross-Platform Support**: You can easily target Linux, Windows, and macOS from the same source using standard Go environment variables (e.g., `GOOS` and `GOARCH`).\n- **Optimized Performance**: It delivers high-speed processing for string-heavy or I/O-intensive ETL tasks that may exceed the capabilities of traditional shell scripts.\n- **Independence from System Tools**: Unlike the Bash target, which relies on various system-level utilities, Go programs are self-sufficient and ensure consistent behavior across different environments.\n\nFor more information on setting up and utilizing this target, see the guides in `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/01_introduction.md", "topics": ["go-target", "native-binaries", "cross-platform"], "original_answer": "## Go Target Overview\n\nThe Go target compiles Prolog logic into standalone Go programs.\n\n### Key Benefits\n\n| Benefit | Description |\n|---------|-------------|\n| Single Binary | No runtime dependencies |\n| Cross-Platform | Linux, Windows, macOS from one source |\n| Performance | Excellent for string/I/O processing |\n| Deployment | Just copy the executable |\n\n### Cross-Compilation\n\n```bash\n# Build for Windows on Linux\nGOOS=windows GOARCH=amd64 go build -o tool.exe tool.go\n```\n\n### Comparison with Bash\n\n| Feature | Bash | Go |\n|---------|------|----|\n| Runtime | Bash 4.0+ | None |\n| Portability | Unix-like | All platforms |\n| Dependencies | System tools | None |\n| Use case | Shell scripts | High-performance ETL |", "answer_tailored": true}
{"pair_id": "b6-c1-go-overview_p2", "cluster_id": "b6-c1-go-overview", "question": "How does Go compare to Bash target?", "question_type": "medium", "answer": "While the Bash target is designed for Unix-like shell scripting and relies on Bash 4.0+ and system-level tools, the Go target compiles Prolog logic into standalone, high-performance binaries with no runtime dependencies. Go is particularly well-suited for cross-platform deployment (Linux, Windows, macOS) and high-performance ETL tasks where the overhead or environment constraints of a shell script might be limiting.\n\nKey comparisons include:\n* **Runtime & Dependencies:** Bash requires a shell environment and external system tools, whereas Go produces self-contained binaries.\n* **Portability:** Go supports all major platforms from a single source, while Bash is restricted to Unix-like systems.\n* **Performance:** Go offers significantly better performance for intensive string and I/O processing compared to interpreted shell scripts.\n* **Deployment:** Deploying a Go target is as simple as copying a single executable, whereas Bash targets require ensuring the target system has the necessary dependencies installed.\n\nFor more details on Go's architecture and cross-compilation features, refer to `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/01_introduction.md", "topics": ["go-target", "native-binaries", "cross-platform"], "original_answer": "## Go Target Overview\n\nThe Go target compiles Prolog logic into standalone Go programs.\n\n### Key Benefits\n\n| Benefit | Description |\n|---------|-------------|\n| Single Binary | No runtime dependencies |\n| Cross-Platform | Linux, Windows, macOS from one source |\n| Performance | Excellent for string/I/O processing |\n| Deployment | Just copy the executable |\n\n### Cross-Compilation\n\n```bash\n# Build for Windows on Linux\nGOOS=windows GOARCH=amd64 go build -o tool.exe tool.go\n```\n\n### Comparison with Bash\n\n| Feature | Bash | Go |\n|---------|------|----|\n| Runtime | Bash 4.0+ | None |\n| Portability | Unix-like | All platforms |\n| Dependencies | System tools | None |\n| Use case | Shell scripts | High-performance ETL |", "answer_tailored": true}
{"pair_id": "b6-c2-basic-compilation_p0", "cluster_id": "b6-c2-basic-compilation", "question": "How do I compile Prolog facts to Go?", "question_type": "medium", "answer": "To compile Prolog facts into Go with UnifyWeaver, use the `go_target:compile_facts_to_go/3` predicate. This converts Prolog predicates into Go structs and associated data access functions.\n\n**Prolog Command:**\n```prolog\n?- go_target:compile_facts_to_go(user, 2, Code).\n```\n\n**Generated Go Output:**\nThe compiler generates a struct representing the predicate and functions to retrieve or stream the data:\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\n// Retrieves all facts as a slice\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\n// Streams facts using a callback function\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n\n// Checks for the existence of a specific fact\nfunc ContainsUSER(target USER) bool { ... }\n```\n\nThis approach transforms static Prolog data into native Go types, providing both batch (`GetAll`) and iterator-style (`Stream`) access patterns. For more advanced compilation examples, including rule-to-stream processing, see the documentation in `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/02_basic_compilation.md", "topics": ["fact-export", "struct-generation", "streaming"], "original_answer": "## Basic Compilation\n\n### Compiling Facts\n\n```prolog\n?- go_target:compile_facts_to_go(user, 2, Code).\n```\n\n**Generated Go:**\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n\nfunc ContainsUSER(target USER) bool { ... }\n```\n\n### Compiling Rules\n\nRules generate stream processors (stdin \u2192 stdout):\n\n```bash\necho -e \"alice:bob\\ncharlie:david\" | ./swap\n# Output: bob:alice, david:charlie\n```", "answer_tailored": true}
{"pair_id": "b6-c2-basic-compilation_p1", "cluster_id": "b6-c2-basic-compilation", "question": "What does compile_facts_to_go generate?", "question_type": "medium", "answer": "`compile_facts_to_go` generates Go source code that transforms Prolog facts into native Go types and accessor functions. When compiling a predicate like `user/2`, the compiler produces:\n\n1.  **A Struct Definition:** A typed `struct` representing the fact's structure (e.g., `type USER struct`).\n2.  **Collection Access:** A `GetAll` function that returns a slice containing all instances of the fact.\n3.  **Streaming Interface:** A `Stream` function for iterating over the facts using a callback.\n4.  **Membership Testing:** A `Contains` function to check for the existence of a specific fact.\n\n**Example Generated Go:**\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n\nfunc ContainsUSER(target USER) bool { ... }\n```\n\nFor more details on Go target compilation, see `education/book-06-go-target/02_basic_compilation.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/02_basic_compilation.md", "topics": ["fact-export", "struct-generation", "streaming"], "original_answer": "## Basic Compilation\n\n### Compiling Facts\n\n```prolog\n?- go_target:compile_facts_to_go(user, 2, Code).\n```\n\n**Generated Go:**\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n\nfunc ContainsUSER(target USER) bool { ... }\n```\n\n### Compiling Rules\n\nRules generate stream processors (stdin \u2192 stdout):\n\n```bash\necho -e \"alice:bob\\ncharlie:david\" | ./swap\n# Output: bob:alice, david:charlie\n```", "answer_tailored": true}
{"pair_id": "b6-c2-basic-compilation_p2", "cluster_id": "b6-c2-basic-compilation", "question": "How do I compile rules for stream processing?", "question_type": "medium", "answer": "To compile rules for stream processing in the Go target, UnifyWeaver transforms Prolog logic into efficient processors that typically read from standard input and write to standard output. This architecture allows compiled rules to function as filters within standard Unix pipelines.\n\nFor example, a compiled Go processor for a field-swapping rule can be invoked directly in the shell:\n```bash\necho -e \"alice:bob\\ncharlie:david\" | ./swap\n# Output: bob:alice, david:charlie\n```\n\nThe compiler handles this by generating Go structs and specialized streaming functions (such as `StreamUSER`) that iterate through data using callbacks. This ensures high-performance processing with a minimal memory footprint:\n\n```go\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n```\n\nDetailed documentation on basic compilation and stream generation for the Go target can be found in `education/book-06-go-target/02_basic_compilation.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/02_basic_compilation.md", "topics": ["fact-export", "struct-generation", "streaming"], "original_answer": "## Basic Compilation\n\n### Compiling Facts\n\n```prolog\n?- go_target:compile_facts_to_go(user, 2, Code).\n```\n\n**Generated Go:**\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n\nfunc ContainsUSER(target USER) bool { ... }\n```\n\n### Compiling Rules\n\nRules generate stream processors (stdin \u2192 stdout):\n\n```bash\necho -e \"alice:bob\\ncharlie:david\" | ./swap\n# Output: bob:alice, david:charlie\n```", "answer_tailored": true}
