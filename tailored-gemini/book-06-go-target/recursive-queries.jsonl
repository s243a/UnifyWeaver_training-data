{"pair_id": "b6-c7-recursive-compilation_p0", "cluster_id": "b6-c7-recursive-compilation", "question": "How do I compile recursive predicates to Go?", "question_type": "medium", "answer": "To compile recursive predicates to Go, use UnifyWeaver's recursive compiler which generates a Breadth-First Search (BFS) implementation. This approach is particularly effective for transitive closures such as reachability or ancestry.\n\n### Compilation Command\n\nInvoke the `recursive_compiler` in Prolog and specify the Go target:\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### Generated Go BFS Pattern\n\nThe resulting Go code implements the recursive logic using a queue-based traversal:\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\n### Mapping of Logic to Go Constructs\n\n| Logic Feature | Go Implementation |\n|:---|:---|\n| Graph/Adjacency List | `map[string][]string` |\n| Traversal Queue | `[]string` slice |\n| Cycle Detection | `map[string]bool` |\n\nFor more details on Go-specific recursive query generation, see `education/book-06-go-target/07_recursive_queries.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["recursive-queries", "transitive-closure", "bfs"], "original_answer": "## Recursive Queries\n\n### Compiling Transitive Closure\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### Generated Go (BFS)\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\n### Go Constructs Used\n\n| Feature | Go Construct |\n|---------|-------------|\n| Adjacency List | `map[string][]string` |\n| BFS Queue | `[]string` slice |\n| Visited Set | `map[string]bool` |", "answer_tailored": true}
{"pair_id": "b6-c7-recursive-compilation_p1", "cluster_id": "b6-c7-recursive-compilation", "question": "What is compile_recursive/3?", "question_type": "medium", "answer": "`compile_recursive/3` is the core Prolog predicate in UnifyWeaver responsible for transforming recursive relations\u2014such as transitive closures\u2014into optimized source code for a specified target language.\n\n### Usage Example\nTo compile a recursive `ancestor/2` predicate into Go, the predicate is invoked with the target option:\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### Go Target Implementation\nWhen targeting Go, the predicate generates a Breadth-First Search (BFS) implementation to resolve the recursion. The generated code utilizes the following Go constructs:\n\n| Feature | Go Construct | Purpose |\n|---------|-------------|---------|\n| **Adjacency List** | `map[string][]string` | Stores the base relation data |\n| **BFS Queue** | `[]string` slice | Manages the frontier of nodes to visit |\n| **Visited Set** | `map[string]bool` | Prevents infinite loops and redundant processing |\n\nThe compiler produces a struct (e.g., `ANCESTORQuery`) with a `FindAll` method that executes the BFS traversal, ensuring idiomatic and performant Go code. For further details on recursive compilation for Go, refer to `education/book-06-go-target/07_recursive_queries.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["recursive-queries", "transitive-closure", "bfs"], "original_answer": "## Recursive Queries\n\n### Compiling Transitive Closure\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### Generated Go (BFS)\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\n### Go Constructs Used\n\n| Feature | Go Construct |\n|---------|-------------|\n| Adjacency List | `map[string][]string` |\n| BFS Queue | `[]string` slice |\n| Visited Set | `map[string]bool` |", "answer_tailored": true}
{"pair_id": "b6-c7-recursive-compilation_p2", "cluster_id": "b6-c7-recursive-compilation", "question": "How does BFS-based transitive closure work?", "question_type": "medium", "answer": "In UnifyWeaver, BFS-based transitive closure for the Go target works by compiling recursive Prolog predicates (such as `ancestor/2`) into an iterative Breadth-First Search. This approach avoids stack overflow issues associated with deep recursion by using a queue-based traversal to find all reachable nodes.\n\nThe compiled Go implementation typically uses three primary data structures:\n- **Adjacency List:** A `map[string][]string` representing the base facts of the relation.\n- **BFS Queue:** A slice (`[]string`) used to track nodes that need exploration.\n- **Visited Set:** A `map[string]bool` to track already processed nodes and prevent cycles.\n\nThe generated `FindAll` method operates by:\n1. Seeding a queue with the starting node.\n2. Looping until the queue is empty, dequeuing the current node.\n3. Looking up neighbors in the base relation map.\n4. Adding unvisited neighbors to both the results list and the queue for further expansion.\n\n```go\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\nDetailed information on the compilation of recursive relations to Go can be found in `education/book-06-go-target/07_recursive_queries.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["recursive-queries", "transitive-closure", "bfs"], "original_answer": "## Recursive Queries\n\n### Compiling Transitive Closure\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### Generated Go (BFS)\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\n### Go Constructs Used\n\n| Feature | Go Construct |\n|---------|-------------|\n| Adjacency List | `map[string][]string` |\n| BFS Queue | `[]string` slice |\n| Visited Set | `map[string]bool` |", "answer_tailored": true}
{"pair_id": "b6-c7-recursion-patterns_p0", "cluster_id": "b6-c7-recursion-patterns", "question": "How is tail recursion compiled to Go?", "question_type": "medium", "answer": "UnifyWeaver compiles tail-recursive Prolog predicates into iterative Go `for` loops to ensure O(1) space complexity. This transformation avoids stack overflow issues and optimizes performance by leveraging Go's efficient iteration.\n\nWhen using `go_target:compile_tail_recursion_go/3`, a predicate like `sum_list/3` is transformed as follows:\n\n```go\nfunc sum_list(items []int, acc int) int {\n    for _, item := range items {\n        acc += item\n    }\n    return acc\n}\n```\n\nBeyond tail recursion, the Go target also supports:\n\n*   **Linear Recursion**: Compiled using `go_target:compile_linear_recursion_go/3`, which implements memoization to store intermediate results.\n    ```go\n    var triangularMemo = make(map[int]int)\n    func triangular(n int) int {\n        if result, ok := triangularMemo[n]; ok { return result }\n        result := triangular(n-1) + n\n        triangularMemo[n] = result\n        return result\n    }\n    ```\n*   **Mutual Recursion**: Compiled via `go_target:compile_mutual_recursion_go/3`, which generates a shared `map` for memoization across multiple predicates (e.g., `is_even` and `is_odd`).\n\nFor further details on recursive query compilation in Go, refer to `education/book-06-go-target/07_recursive_queries.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["tail-recursion", "linear-recursion", "mutual-recursion", "memoization"], "original_answer": "## Recursion Patterns in Go\n\n### Tail Recursion (O(1) space)\n\n```prolog\n?- go_target:compile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n```go\nfunc sum_list(items []int, acc int) int {\n    for _, item := range items {\n        acc += item\n    }\n    return acc\n}\n```\n\n### Linear Recursion (Memoization)\n\n```prolog\n?- go_target:compile_linear_recursion_go(triangular/2, [], Code).\n```\n\n```go\nvar triangularMemo = make(map[int]int)\n\nfunc triangular(n int) int {\n    if result, ok := triangularMemo[n]; ok {\n        return result\n    }\n    result := triangular(n-1) + n\n    triangularMemo[n] = result\n    return result\n}\n```\n\n### Mutual Recursion (Shared Memo)\n\n```prolog\n?- go_target:compile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nGenerates shared `map[string]bool` for both predicates.", "answer_tailored": true}
{"pair_id": "b6-c7-recursion-patterns_p1", "cluster_id": "b6-c7-recursion-patterns", "question": "How does memoization work in Go target?", "question_type": "medium", "answer": "In UnifyWeaver\u2019s Go target, memoization is achieved by generating Go maps that cache the outputs of recursive predicates to prevent redundant computation. When compiling linear recursion using `go_target:compile_linear_recursion_go/3`, the compiler generates a dedicated cache (e.g., `var predicateMemo = make(map[K]V)`) and logic that checks this map before proceeding with recursive calls. If the result is already present, it is returned directly.\n\nExample of the generated memoization pattern:\n```go\nvar triangularMemo = make(map[int]int)\n\nfunc triangular(n int) int {\n    if result, ok := triangularMemo[n]; ok {\n        return result\n    }\n    // Perform calculation...\n    result := triangular(n-1) + n\n    triangularMemo[n] = result\n    return result\n}\n```\n\nFor mutual recursion, the `go_target:compile_mutual_recursion_go/3` predicate generates a shared memoization map accessible by all participating Go functions, allowing them to leverage a common cache for cross-predicate efficiency. Detailed implementation patterns can be found in `education/book-06-go-target/07_recursive_queries.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["tail-recursion", "linear-recursion", "mutual-recursion", "memoization"], "original_answer": "## Recursion Patterns in Go\n\n### Tail Recursion (O(1) space)\n\n```prolog\n?- go_target:compile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n```go\nfunc sum_list(items []int, acc int) int {\n    for _, item := range items {\n        acc += item\n    }\n    return acc\n}\n```\n\n### Linear Recursion (Memoization)\n\n```prolog\n?- go_target:compile_linear_recursion_go(triangular/2, [], Code).\n```\n\n```go\nvar triangularMemo = make(map[int]int)\n\nfunc triangular(n int) int {\n    if result, ok := triangularMemo[n]; ok {\n        return result\n    }\n    result := triangular(n-1) + n\n    triangularMemo[n] = result\n    return result\n}\n```\n\n### Mutual Recursion (Shared Memo)\n\n```prolog\n?- go_target:compile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nGenerates shared `map[string]bool` for both predicates.", "answer_tailored": true}
{"pair_id": "b6-c7-recursion-patterns_p2", "cluster_id": "b6-c7-recursion-patterns", "question": "How are mutually recursive predicates compiled?", "question_type": "medium", "answer": "Mutually recursive predicates are compiled in the Go target using the `go_target:compile_mutual_recursion_go/3` predicate. This process generates functions that utilize a shared memoization structure (typically a `map[string]bool`) to synchronize results across all interdependent predicates, such as `is_even/1` and `is_odd/1`. By sharing a common cache, the generated Go code ensures consistent state and prevents redundant evaluations during the recursive cycle. For comprehensive details on recursion patterns including tail-call optimization and linear memoization, see `education/book-06-go-target/07_recursive_queries.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["tail-recursion", "linear-recursion", "mutual-recursion", "memoization"], "original_answer": "## Recursion Patterns in Go\n\n### Tail Recursion (O(1) space)\n\n```prolog\n?- go_target:compile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n```go\nfunc sum_list(items []int, acc int) int {\n    for _, item := range items {\n        acc += item\n    }\n    return acc\n}\n```\n\n### Linear Recursion (Memoization)\n\n```prolog\n?- go_target:compile_linear_recursion_go(triangular/2, [], Code).\n```\n\n```go\nvar triangularMemo = make(map[int]int)\n\nfunc triangular(n int) int {\n    if result, ok := triangularMemo[n]; ok {\n        return result\n    }\n    result := triangular(n-1) + n\n    triangularMemo[n] = result\n    return result\n}\n```\n\n### Mutual Recursion (Shared Memo)\n\n```prolog\n?- go_target:compile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nGenerates shared `map[string]bool` for both predicates.", "answer_tailored": true}
