{"pair_id": "b6-c3-regex-constraints_p0", "cluster_id": "b6-c3-regex-constraints", "question": "How does Go target handle regex matching?", "question_type": "medium", "answer": "The Go target handles regex matching by compiling Prolog `match` predicates into efficient Go `regexp` package calls.\n\nFor simple substring or pattern filtering, use `match/2`:\n\n```prolog\n% Filter lines containing 'ERROR'\nerror_log(Line) :-\n    log(Line),\n    match(Line, 'ERROR').\n```\n\nFor extracting data using regex capture groups, use `match/4`:\n\n```prolog\n% Capture groups with match/4\n% The third argument 'auto' handles automatic type conversion\nparse_log(Date, Level) :-\n    log(Line),\n    match(Line, '^([0-9-]+) ([A-Z]+):', auto, [Date, Level]).\n```\n\nThese predicates are translated into Go code that leverages pre-compiled regex patterns for performance. For a deeper dive into Go-specific implementations and advanced pattern matching, see `education/book-06-go-target/`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/03_advanced_features.md", "topics": ["regex", "constraints", "aggregations"], "original_answer": "## Advanced Features\n\n### Regex Matching\n\n```prolog\n% Filter lines containing 'ERROR'\nerror_log(Line) :-\n    log(Line),\n    match(Line, 'ERROR').\n\n% Capture groups with match/4\nparse_log(Date, Level) :-\n    log(Line),\n    match(Line, '^([0-9-]+) ([A-Z]+):', auto, [Date, Level]).\n```\n\nCompiles to efficient Go `regexp` calls.\n\n### Constraints\n\nSupported operators: `>`, `<`, `>=`, `=<`, `==`, `\\=`\n\n```prolog\nadult(Name, Age) :-\n    person(Name, Age),\n    Age >= 18.\n```\n\n### Aggregations\n\nSupported: `sum`, `count`, `avg`, `min`, `max`\n\n```prolog\ntotal_score(Sum) :-\n    aggregation(sum),\n    score(Sum).\n```", "answer_tailored": true}
{"pair_id": "b6-c3-regex-constraints_p1", "cluster_id": "b6-c3-regex-constraints", "question": "What constraints are supported in Go target?", "question_type": "medium", "answer": "The Go target supports a variety of comparison and equality constraints for filtering data. The available operators include:\n\n*   Greater than: `>`\n*   Less than: `<`\n*   Greater than or equal: `>=`\n*   Less than or equal: `=<`\n*   Equality: `==`\n*   Inequality: `\\=`\n\nThese operators allow you to define rules with specific numeric or value-based conditions, as seen in this example:\n\n```prolog\nadult(Name, Age) :-\n    person(Name, Age),\n    Age >= 18.\n```\n\nWhen compiled, these Prolog constraints are transformed into efficient native Go conditional checks. For more information on advanced Go target capabilities, see education/book-06-go-target/03_advanced_features.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/03_advanced_features.md", "topics": ["regex", "constraints", "aggregations"], "original_answer": "## Advanced Features\n\n### Regex Matching\n\n```prolog\n% Filter lines containing 'ERROR'\nerror_log(Line) :-\n    log(Line),\n    match(Line, 'ERROR').\n\n% Capture groups with match/4\nparse_log(Date, Level) :-\n    log(Line),\n    match(Line, '^([0-9-]+) ([A-Z]+):', auto, [Date, Level]).\n```\n\nCompiles to efficient Go `regexp` calls.\n\n### Constraints\n\nSupported operators: `>`, `<`, `>=`, `=<`, `==`, `\\=`\n\n```prolog\nadult(Name, Age) :-\n    person(Name, Age),\n    Age >= 18.\n```\n\n### Aggregations\n\nSupported: `sum`, `count`, `avg`, `min`, `max`\n\n```prolog\ntotal_score(Sum) :-\n    aggregation(sum),\n    score(Sum).\n```", "answer_tailored": true}
{"pair_id": "b6-c3-regex-constraints_p2", "cluster_id": "b6-c3-regex-constraints", "question": "What aggregations can I use in Go?", "question_type": "medium", "answer": "When targeting Go with UnifyWeaver, you can utilize several built-in aggregation functions: `sum`, `count`, `avg` (average), `min` (minimum), and `max` (maximum). \n\nTo implement these, you use the `aggregation/1` predicate in your Prolog source. For example, to calculate a total sum:\n\n```prolog\ntotal_score(Sum) :-\n    aggregation(sum),\n    score(Sum).\n```\n\nThese aggregations are compiled into efficient Go code for processing your data streams. For more details on using these and other advanced features in the Go target, see `education/book-06-go-target/03_advanced_features.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/03_advanced_features.md", "topics": ["regex", "constraints", "aggregations"], "original_answer": "## Advanced Features\n\n### Regex Matching\n\n```prolog\n% Filter lines containing 'ERROR'\nerror_log(Line) :-\n    log(Line),\n    match(Line, 'ERROR').\n\n% Capture groups with match/4\nparse_log(Date, Level) :-\n    log(Line),\n    match(Line, '^([0-9-]+) ([A-Z]+):', auto, [Date, Level]).\n```\n\nCompiles to efficient Go `regexp` calls.\n\n### Constraints\n\nSupported operators: `>`, `<`, `>=`, `=<`, `==`, `\\=`\n\n```prolog\nadult(Name, Age) :-\n    person(Name, Age),\n    Age >= 18.\n```\n\n### Aggregations\n\nSupported: `sum`, `count`, `avg`, `min`, `max`\n\n```prolog\ntotal_score(Sum) :-\n    aggregation(sum),\n    score(Sum).\n```", "answer_tailored": true}
{"pair_id": "b6-c4-json-processing_p0", "cluster_id": "b6-c4-json-processing", "question": "How do I process JSON with the Go target?", "question_type": "medium", "answer": "To process JSON with the Go target in UnifyWeaver, you use specific Prolog predicates that the compiler translates into native Go JSON handling logic.\n\n### Field Extraction\nUse the `json_get/2` predicate to extract values by specifying a path of keys. To enable this functionality, include `json_input(true)` in your compilation options:\n\n```prolog\n% Example: Extracting name and city from a user object\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n\n% Compilation command\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\n### Array Iteration\nFor processing JSON lists, use `json_array_member/2` to iterate through elements:\n\n```prolog\n% Extracting names from a \"users\" array\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\n### JSON Output\nIf your Go program needs to return data in JSON format, set the `json_output(true)` flag during compilation:\n\n```prolog\ncompile_predicate_to_go(transform/2, [\n    json_input(true),\n    json_output(true)\n], Code).\n```\n\n### Schema Validation\nYou can enforce data integrity by defining a schema with the `json_schema/2` directive, which ensures the input matches expected types and constraints:\n\n```prolog\n:- json_schema(user, [\n    field(name, string, [required]),\n    field(age, integer, [min(0)])\n]).\n```\n\nFor more detailed examples and advanced configurations, see the documentation in `education/book-06-go-target/04_json_processing.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/04_json_processing.md", "topics": ["json", "field-extraction", "schema-validation"], "original_answer": "## JSON Processing\n\n### Field Extraction\n\n```prolog\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n```\n\nCompile with `json_input(true)`:\n\n```prolog\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\n### Array Iteration\n\n```prolog\n% Input: {\"users\": [{\"name\": \"alice\"}, {\"name\": \"bob\"}]}\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\n### JSON Output\n\n```prolog\ncompile_predicate_to_go(transform/2, [\n    json_input(true),\n    json_output(true)\n], Code).\n```\n\n### Schema Validation\n\n```prolog\n:- json_schema(user, [\n    field(name, string, [required]),\n    field(age, integer, [min(0)])\n]).\n```", "answer_tailored": true}
{"pair_id": "b6-c4-json-processing_p1", "cluster_id": "b6-c4-json-processing", "question": "How do I extract nested JSON fields?", "question_type": "medium", "answer": "To extract nested JSON fields in UnifyWeaver when targeting Go, you use the `json_get/2` predicate by providing a list of keys that represent the path to the nested value.\n\nFor example, to retrieve a city name nested within an address object, define your Prolog rule as follows:\n\n```prolog\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n```\n\nWhen generating the Go code, you must include the `json_input(true)` option in your compilation call:\n\n```prolog\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\nIf the nested data is inside an array, combine `json_get/2` with `json_array_member/2` to iterate through the elements:\n\n```prolog\n% Extracting names from a nested \"users\" array\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\nFor further details on JSON handling, including schema validation and output transformation, see `education/book-06-go-target/04_json_processing.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/04_json_processing.md", "topics": ["json", "field-extraction", "schema-validation"], "original_answer": "## JSON Processing\n\n### Field Extraction\n\n```prolog\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n```\n\nCompile with `json_input(true)`:\n\n```prolog\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\n### Array Iteration\n\n```prolog\n% Input: {\"users\": [{\"name\": \"alice\"}, {\"name\": \"bob\"}]}\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\n### JSON Output\n\n```prolog\ncompile_predicate_to_go(transform/2, [\n    json_input(true),\n    json_output(true)\n], Code).\n```\n\n### Schema Validation\n\n```prolog\n:- json_schema(user, [\n    field(name, string, [required]),\n    field(age, integer, [min(0)])\n]).\n```", "answer_tailored": true}
{"pair_id": "b6-c4-json-processing_p2", "cluster_id": "b6-c4-json-processing", "question": "What is json_array_member?", "question_type": "medium", "answer": "In UnifyWeaver, `json_array_member/2` is a predicate used for iterating through elements of a JSON array when compiling for the Go target. It allows you to take a list retrieved from a JSON structure and bind each individual member to a variable for element-wise processing.\n\nA typical usage pattern involves first extracting the array with `json_get/2` and then using `json_array_member/2` to access its contents:\n\n```prolog\n% Extracting names from a JSON input like {\"users\": [{\"name\": \"alice\"}, {\"name\": \"bob\"}]}\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\nWhen the predicate is compiled with the `json_input(true)` option, `json_array_member` ensures that the generated Go code correctly traverses the array structure. For more comprehensive details on handling JSON data and schema validation in Go, refer to `education/book-06-go-target/04_json_processing.md`.", "answer_variant": "default", "answer_source": "education/book-06-go-target/04_json_processing.md", "topics": ["json", "field-extraction", "schema-validation"], "original_answer": "## JSON Processing\n\n### Field Extraction\n\n```prolog\nuser_city(Name, City) :-\n    json_get([name], Name),\n    json_get([address, city], City).\n```\n\nCompile with `json_input(true)`:\n\n```prolog\ncompile_predicate_to_go(user_city/2, [json_input(true)], Code).\n```\n\n### Array Iteration\n\n```prolog\n% Input: {\"users\": [{\"name\": \"alice\"}, {\"name\": \"bob\"}]}\nuser_name(Name) :-\n    json_get([users], UserList),\n    json_array_member(UserList, User),\n    json_get(User, [name], Name).\n```\n\n### JSON Output\n\n```prolog\ncompile_predicate_to_go(transform/2, [\n    json_input(true),\n    json_output(true)\n], Code).\n```\n\n### Schema Validation\n\n```prolog\n:- json_schema(user, [\n    field(name, string, [required]),\n    field(age, integer, [min(0)])\n]).\n```", "answer_tailored": true}
