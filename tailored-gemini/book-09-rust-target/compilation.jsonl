{"pair_id": "rust-compile-001_p0", "cluster_id": "rust-compile-001", "question": "How do I compile Prolog facts to Rust?", "question_type": "medium", "answer": "To compile Prolog facts into Rust, use the `rust_target:compile_facts_to_rust/3` predicate, which exports facts as a struct-based implementation.\n\n```prolog\n% Define your facts\nuser(john, 25).\nuser(jane, 30).\n\n% Trigger the Rust compilation\n?- rust_target:compile_facts_to_rust(user, 2, Code).\n```\n\nThis generates a Rust struct that implements `get_all`, `stream`, and `contains` helper functions. To ensure compatibility with Rust's ownership model and standard traits, the generated code automatically derives `Debug`, `Clone`, `PartialEq`, and `Eq`. Detailed documentation on basic compilation can be found in `education/book-09-rust-target/02_basic_compilation.md`.", "answer_variant": "default", "answer_source": "book-09-rust-target/02_basic_compilation.md", "topics": [], "original_answer": "Use `compile_facts_to_rust/3` for struct-based export:\n\n```prolog\n% Define facts\nuser(john, 25).\nuser(jane, 30).\n\n% Compile\n?- rust_target:compile_facts_to_rust(user, 2, Code).\n```\n\nGenerates a Rust struct with `get_all`, `stream`, and `contains` helper functions. The struct derives Debug, Clone, PartialEq, Eq for easy use with Rust's ownership model.", "answer_tailored": true}
{"pair_id": "rust-compile-001_p0", "cluster_id": "rust-compile-001", "question": "How do I compile Prolog rules to Rust stream processors?", "question_type": "medium", "answer": "To compile Prolog rules to Rust stream processors, you use the `compile_predicate_to_rust/3` predicate to generate Rust code that reads from `stdin`.\n\nExample rule and compilation logic:\n```prolog\n% Filter rule definition\nadult(Name, Age) :- person(Name, Age), Age >= 18.\n\n% Compiling the rule\ncompile_rules :-\n    compile_predicate_to_rust(adult/2, [field_delimiter(colon)], Code),\n    write_rust_program(Code, 'adult.rs').\n```\n\nAfter generation, compile with `rustc` and execute the processor:\n```bash\nrustc adult.rs\necho -e \"alice:25\\nbob:10\" | ./adult\n# Output: alice:25\n```\n\nFor more comprehensive documentation, see `education/book-09-rust-target/` for details.", "answer_variant": "default", "answer_source": "book-09-rust-target/02_basic_compilation.md", "topics": [], "original_answer": "Rules compile to stream processors reading from stdin:\n\n```prolog\n% Rule: Filter adults\nadult(Name, Age) :- person(Name, Age), Age >= 18.\n\ncompile_rules :-\n    compile_predicate_to_rust(adult/2, [field_delimiter(colon)], Code),\n    write_rust_program(Code, 'adult.rs').\n```\n\nRun with:\n```bash\nrustc adult.rs\necho -e \"alice:25\\nbob:10\" | ./adult\n# Output: alice:25\n```", "answer_tailored": true}
{"pair_id": "rust-compile-002_p0", "cluster_id": "rust-compile-002", "question": "How does UnifyWeaver handle recursion patterns in Rust?", "question_type": "medium", "answer": "UnifyWeaver manages recursion patterns in Rust by mapping specific Prolog structures to optimized Rust implementations, preventing stack overflows and improving efficiency. The system supports three primary patterns:\n\n1.  **Tail Recursion**: Compiled via `compile_tail_recursion_rust/3` into iterative `for` loops, ensuring O(1) stack space complexity.\n2.  **Linear Recursion**: Uses `compile_linear_recursion_rust/3` to implement `HashMap` memoization, which caches intermediate results.\n3.  **Mutual Recursion**: Handled by `compile_mutual_recursion_rust/3`, which utilizes `thread_local!` HashMaps for safe, state-aware recursion across multiple functions.\n\nFor example, a `sum_list/3` predicate processed through the tail recursion API will generate efficient iterative Rust code instead of deep recursive calls. For further details on these compilation strategies, see the documentation in `education/book-09-rust-target/02_basic_compilation.md`.", "answer_variant": "default", "answer_source": "book-09-rust-target/02_basic_compilation.md", "topics": [], "original_answer": "Three recursion patterns:\n\n| Pattern | API | Generated Rust |\n|---------|-----|----------------|\n| Tail Recursion | `compile_tail_recursion_rust/3` | for loop (O(1) stack) |\n| Linear Recursion | `compile_linear_recursion_rust/3` | HashMap memoization |\n| Mutual Recursion | `compile_mutual_recursion_rust/3` | thread_local! HashMap |\n\nExample tail recursion:\n```prolog\n?- rust_target:compile_tail_recursion_rust(sum_list/3, [], Code).\n```\n\nGenerates efficient iterative Rust code instead of recursive calls.", "answer_tailored": true}
{"pair_id": "rust-compile-002_p0", "cluster_id": "rust-compile-002", "question": "How do I compile mutual recursion (is_even/is_odd) to Rust?", "question_type": "medium", "answer": "To compile mutually recursive predicates such as `is_even/1` and `is_odd/1` into Rust, use the `rust_target:compile_mutual_recursion_rust/3` predicate. This specific compiler entry point manages the dependency loop between the functions and generates Rust code that utilizes a `thread_local!` HashMap for shared memoization.\n\nFirst, define the mutually recursive logic in Prolog:\n\n```prolog\nassertx((is_even(0))).\nassertx((is_even(N) :- N > 0, N1 is N - 1, is_odd(N1))).\nassertx((is_odd(1))).\nassertx((is_odd(N) :- N > 1, N1 is N - 1, is_even(N1))).\n```\n\nThen, trigger the Rust compilation by passing the list of predicates to the compiler:\n\n```prolog\n?- rust_target:compile_mutual_recursion_rust([is_even/1, is_odd/1], [], Code).\n```\n\nThe resulting Rust implementation ensures that memoized results are shared across all involved functions to maintain efficiency. Further details on Rust-specific compilation can be found in `education/book-09-rust-target/`.", "answer_variant": "default", "answer_source": "book-09-rust-target/02_basic_compilation.md", "topics": [], "original_answer": "Use `compile_mutual_recursion_rust/3` for predicates that call each other:\n\n```prolog\nassertx((is_even(0))).\nassertx((is_even(N) :- N > 0, N1 is N - 1, is_odd(N1))).\nassertx((is_odd(1))).\nassertx((is_odd(N) :- N > 1, N1 is N - 1, is_even(N1))).\n\n?- rust_target:compile_mutual_recursion_rust([is_even/1, is_odd/1], [], Code).\n```\n\nGenerates Rust with thread_local! HashMap for shared memoization between the mutually recursive functions.", "answer_tailored": true}
