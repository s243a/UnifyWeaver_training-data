{"pair_id": "rust-project-001_p0", "cluster_id": "rust-project-001", "question": "When should I use project generation vs single-file compilation?", "question_type": "medium", "answer": "Single-file compilation (using `rustc`) is appropriate for predicates that rely exclusively on the Rust standard library. You should switch to project generation using `write_rust_project/2` whenever your code requires external crates like `regex` or `serde`. UnifyWeaver simplifies this by automatically detecting these dependencies and generating a complete `Cargo.toml` alongside the source files.\n\n```prolog\ncompile_project :-\n    compile_predicate_to_rust(valid_email/1, [], Code),\n    write_rust_project(Code, 'output/email_validator').\n```\n\nThis approach creates a standard Cargo project structure, enabling you to compile with `cargo build --release`. For a deeper dive into project generation and dependency management, refer to `education/book-09-rust-target/`.", "answer_variant": "default", "answer_source": "book-09-rust-target/03_project_generation.md", "topics": [], "original_answer": "Use single-file compilation (`rustc`) for standard library features only. Use project generation (`write_rust_project/2`) when you need external crates like regex or serde. UnifyWeaver automatically detects crate requirements and generates Cargo.toml:\n\n```prolog\ncompile_project :-\n    compile_predicate_to_rust(valid_email/1, [], Code),\n    write_rust_project(Code, 'output/email_validator').\n```\n\nThis creates Cargo.toml and src/main.rs, then build with `cargo build --release`.", "answer_tailored": true}
{"pair_id": "rust-project-001_p0", "cluster_id": "rust-project-001", "question": "How do I generate a Cargo project with UnifyWeaver?", "question_type": "medium", "answer": "To generate a Cargo project with UnifyWeaver, use the `write_rust_project/2` predicate. Unlike `write_rust_program/2`, which outputs a standalone file, this predicate scaffolds a complete Rust project directory.\n\n```prolog\n% Example: Compiling a regex validator into a Cargo project\nvalid_email(Line) :-\n    input(Line),\n    match(Line, \"^[a-z0-9]+ @[a-z0-9]+\\\\.[a-z]+$\").\n\ncompile_project :-\n    compile_predicate_to_rust(valid_email/1, [], Code),\n    write_rust_project(Code, 'output/email_validator').\n```\n\nThis operation creates:\n- `output/email_validator/Cargo.toml` (automatically includes dependencies like the `regex` crate)\n- `output/email_validator/src/main.rs` (the generated source code)\n\nTo compile the project, navigate to the directory and run:\n`cd output/email_validator && cargo build --release`\n\nFor more information on Rust project generation and configuration, see `education/book-09-rust-target/`.", "answer_variant": "default", "answer_source": "book-09-rust-target/03_project_generation.md", "topics": [], "original_answer": "Use `write_rust_project/2` instead of `write_rust_program/2`:\n\n```prolog\n% Rule using Regex\nvalid_email(Line) :-\n    input(Line),\n    match(Line, \"^[a-z0-9]+@[a-z0-9]+\\\\.[a-z]+$\").\n\ncompile_project :-\n    compile_predicate_to_rust(valid_email/1, [], Code),\n    write_rust_project(Code, 'output/email_validator').\n```\n\nCreates:\n- `output/email_validator/Cargo.toml` (with regex dependency)\n- `output/email_validator/src/main.rs`\n\nBuild: `cd output/email_validator && cargo build --release`", "answer_tailored": true}
{"pair_id": "rust-advanced-001_p0", "cluster_id": "rust-advanced-001", "question": "How do I use JSON processing in the Rust target?", "question_type": "medium", "answer": "To implement JSON processing within the Rust target, you utilize the `json_schema/2` directive along with specific compilation flags for handling input and output. \n\nFirst, define the expected JSON structure using a schema:\n```prolog\n:- json_schema(user, [field(name, string), field(age, integer)]).\n\nuser_info(Name, Age) :-\n    json_record([name-Name, age-Age]).\n```\n\nWhen compiling the predicate to Rust, enable JSON support by passing the `json_input(true)` and `json_schema(Name)` options to the compiler:\n```prolog\ncompile_json :-\n    compile_predicate_to_rust(user_info/2, [\n        json_input(true),\n        json_schema(user)\n    ], Code),\n    write_rust_project(Code, 'output/json_processor').\n```\n\nFor predicates that need to produce JSON output, use the `json_output(true)` flag:\n```prolog\ncompile_output :-\n    compile_predicate_to_rust(output_user/2, [json_output(true)], Code),\n    write_rust_project(Code, 'output/json_writer').\n```\n\nThe Rust backend automatically integrates `serde` and `serde_json` to provide type-safe, high-performance serialization. You can find more comprehensive examples and details in `education/book-09-rust-target/`.", "answer_variant": "default", "answer_source": "book-09-rust-target/04_advanced_features.md", "topics": [], "original_answer": "Use json_schema and json_input/json_output options:\n\n```prolog\n:- json_schema(user, [field(name, string), field(age, integer)]).\n\nuser_info(Name, Age) :-\n    json_record([name-Name, age-Age]).\n\ncompile_json :-\n    compile_predicate_to_rust(user_info/2, [\n        json_input(true),\n        json_schema(user)\n    ], Code),\n    write_rust_project(Code, 'output/json_processor').\n```\n\nFor JSON output:\n```prolog\ncompile_output :-\n    compile_predicate_to_rust(output_user/2, [json_output(true)], Code),\n    write_rust_project(Code, 'output/json_writer').\n```\n\nUses serde and serde_json for high-performance JSON processing.", "answer_tailored": true}
{"pair_id": "rust-advanced-001_p0", "cluster_id": "rust-advanced-001", "question": "What aggregations and constraints does the Rust target support?", "question_type": "medium", "answer": "The Rust target supports a core set of aggregations including `sum`, `count`, `min`, `max`, and `avg`. These are compiled into highly efficient Rust code:\n\n```prolog\ntotal_sales(Sum) :-\n    aggregation(sum),\n    sale(Sum).\n```\n\nIt also handles numeric constraints (e.g., `>`, `<`, `>=`, `=<`) by translating them into native Rust comparisons. This ensures that checks like `Val > 1000` generate optimized conditional logic without the overhead of runtime interpretation. Detailed implementation examples can be found in `education/book-09-rust-target/`.", "answer_variant": "default", "answer_source": "book-09-rust-target/04_advanced_features.md", "topics": [], "original_answer": "Aggregations compile to efficient Rust code:\n\n```prolog\ntotal_sales(Sum) :-\n    aggregation(sum),\n    sale(Sum).\n```\n\nSupported: `sum`, `count`, `min`, `max`, `avg`.\n\nNumeric constraints compile to native Rust comparisons:\n\n```prolog\nhigh_value(Val) :-\n    input(Val),\n    Val > 1000,\n    Val =< 5000.\n```\n\nGenerates efficient Rust conditionals without runtime interpretation overhead.", "answer_tailored": true}
