{"pair_id": "rust-001_p0", "cluster_id": "rust-001", "question": "Why use the Rust target in UnifyWeaver?", "question_type": "medium", "answer": "The Rust target is selected when an application requires high performance and guaranteed memory safety without garbage collection overhead. It leverages Rust\u2019s ownership model to ensure safety in resource-constrained or high-concurrency environments. Furthermore, UnifyWeaver implements zero-cost abstractions by mapping Prolog constructs to efficient native structures like HashSets for facts and iterators for stream processing. The target also integrates seamlessly with the Rust ecosystem, using `serde` for JSON serialization and `regex` for pattern matching. For system-level tools requiring low latency, Rust is the superior choice over targets like Go. Detailed documentation can be found in `education/book-09-rust-target/`.", "answer_variant": "default", "answer_source": "book-09-rust-target/01_introduction.md", "topics": [], "original_answer": "The Rust target offers three key advantages: (1) Memory safety - Rust's ownership model ensures safety without a garbage collector, suitable for high-performance and resource-constrained environments; (2) Zero-cost abstractions - UnifyWeaver maps Prolog constructs to efficient Rust equivalents (HashSet for facts, iterators for streams); (3) Ecosystem - generated code leverages serde for JSON and regex for pattern matching. Use Rust for high-performance system tools, Go for general-purpose ETL.", "answer_tailored": true}
{"pair_id": "rust-001_p0", "cluster_id": "rust-001", "question": "How does the Rust target compare to the Go target?", "question_type": "medium", "answer": "The Rust target and Go target in UnifyWeaver both generate standalone binaries but cater to different performance and development priorities. While Go offers significantly faster compilation and a garbage-collected runtime suitable for general-purpose ETL tasks, Rust focuses on maximum performance and strict memory and thread safety through its ownership model. Choosing between them depends on your requirements: Go is ideal for rapid development and simpler logic, whereas Rust is preferred for high-performance system tools where thread safety is paramount. Detailed comparisons and implementation details can be found in education/book-09-rust-target/.", "answer_variant": "default", "answer_source": "book-09-rust-target/01_introduction.md", "topics": [], "original_answer": "Key differences:\n| Feature | Go Target | Rust Target |\n|---------|-----------|-------------|\n| Compilation | Fast | Slower (optimizing) |\n| Runtime | Garbage collected | Manual/ownership |\n| Safety | Memory safe | Memory & thread safe |\n| Use case | General purpose, ETL | High performance, system tools |\n\nBoth produce single binaries. Choose Go for faster compilation and simpler code, Rust for maximum performance and thread safety.", "answer_tailored": true}
{"pair_id": "rust-002_p0", "cluster_id": "rust-002", "question": "What features does the UnifyWeaver Rust target support?", "question_type": "medium", "answer": "The UnifyWeaver Rust target supports several key features designed for performance and safety when compiling Prolog logic:\n\n- **Fact Exporting**: Exports facts as Rust struct vectors using `compile_facts_to_rust/3`.\n- **Recursive Queries**: Compiles recursive queries using BFS transitive closure with native `HashMap` and `VecDeque` structures via `compile_recursive/3`.\n- **Pipeline Mode**: Supports JSONL streaming combined with fixpoint evaluation for efficient data processing.\n- **Native JSON Processing**: Integrates directly with `serde_json` for high-performance JSON handling.\n- **Project Generation**: Automatically generates complete Cargo projects, including `Cargo.toml`, with `write_rust_project/2`.\n- **Recursion Optimizations**: Provides optimized patterns and memoization for tail, linear, and mutual recursion.\n\nDetailed guides and examples are available in `education/book-09-rust-target/`.", "answer_variant": "default", "answer_source": "book-09-rust-target/01_introduction.md", "topics": [], "original_answer": "Supported features:\n- **Fact Export** (`compile_facts_to_rust/3`) - Export facts as Rust struct Vecs\n- **Recursive Queries** (`compile_recursive/3`) - BFS transitive closure with HashMap/VecDeque\n- **Pipeline Mode** - JSONL streaming with fixpoint evaluation\n- **JSON Processing** - Native serde_json integration\n- **Project Generation** (`write_rust_project/2`) - Full Cargo.toml generation\n- **Tail/Linear/Mutual Recursion** - Optimized patterns with memoization", "answer_tailored": true}
