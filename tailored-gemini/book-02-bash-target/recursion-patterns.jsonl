{"pair_id": "tail-recursion_p0", "cluster_id": "tail-recursion", "question": "What is tail recursion optimization in UnifyWeaver?", "question_type": "medium", "answer": "Tail recursion optimization (TRO) in UnifyWeaver is a compilation strategy that detects recursive Prolog predicates where the recursive call is the final operation and transforms them into efficient iterative loops in the target language. This transformation is critical for performance and stability, particularly in resource-constrained environments like Bash.\n\n### Core Benefits\n- **Stack Safety:** By replacing recursion with iteration, the compiler eliminates the risk of stack overflow errors during deep recursions.\n- **Zero Stack Overhead:** Iterative loops avoid the memory and CPU costs associated with maintaining a call stack for every recursive step.\n- **Improved Performance:** The resulting code executes significantly faster than standard recursive calls in interpreted languages like Bash or Python.\n\n### The Accumulator Pattern\nUnifyWeaver utilizes the accumulator pattern to facilitate TRO, allowing state to be passed forward through each iteration without needing to \"unwind\" the stack:\n\n```prolog\n% Tail-recursive item counter\ncount_items([], Acc, Acc).\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N). % This tail call is optimized away\n```\n\n### Bash Target Implementation\nThe compiler generates a `while` loop to replace the recursive logic, ensuring high efficiency:\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # The compiler generates a loop to handle the recursion\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail and update current_list\n        # ... logic to strip head ...\n        \n        acc=$((acc + 1)) # Update the accumulator in-place\n    done\n    \n    echo \"$acc\"\n}\n```\n\nFor a comprehensive guide on how the compiler handles deep recursion across different targets, see the documentation in `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "accumulator", "optimization", "iterative-loop"], "original_answer": "## Tail Recursion Optimization\n\nTail recursion is when the recursive call is the last action in a function.\n\n### Why It Matters\n\nTail recursion can be converted to an iterative loop:\n- No stack overhead\n- No stack overflow risk\n- Much faster execution\n\n### The Accumulator Pattern\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Generated Bash: Iterative Loop\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Step: Acc1 is Acc + 1\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Usage\n\n```bash\nsource count_items.sh\ncount_items \"[a,b,c,d,e]\" 0 \"\"\n# Output: [a,b,c,d,e]:0:5\n```", "answer_tailored": true}
{"pair_id": "tail-recursion_p1", "cluster_id": "tail-recursion", "question": "How does UnifyWeaver compile tail-recursive predicates?", "question_type": "medium", "answer": "UnifyWeaver compiles tail-recursive predicates by transforming them into iterative `while` loops, a process known as Tail Call Optimization (TCO). This approach is essential for targets like Bash to prevent stack overflow errors and eliminate the performance overhead associated with deep recursion.\n\n### Compilation Strategy\nWhen the compiler identifies a predicate where the recursive call is the final action, it leverages the accumulator pattern. Instead of creating new stack frames, the generated code updates local state variables within a loop until the base case is satisfied.\n\n### Prolog Source Example\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: return the accumulated value\ncount_items([], Acc, Acc).\n\n% Recursive step: update accumulator and perform tail call\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).\n```\n\n### Generated Bash: Iterative Transformation\nThe compiler translates the logic above into an efficient loop that avoids recursive function overhead:\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # The while loop replaces standard recursion\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Logic to extract the tail of the list\n        if [[ \"$current_list\" =~ ^\\[[^,]+,(.+)]$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Iterative update: acc=$((acc + 1))\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\nBy converting these patterns into iterative structures, UnifyWeaver ensures that generated scripts can handle large datasets without exhausting shell limits. For more information on recursion handling in shell targets, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "accumulator", "optimization", "iterative-loop"], "original_answer": "## Tail Recursion Optimization\n\nTail recursion is when the recursive call is the last action in a function.\n\n### Why It Matters\n\nTail recursion can be converted to an iterative loop:\n- No stack overhead\n- No stack overflow risk\n- Much faster execution\n\n### The Accumulator Pattern\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Generated Bash: Iterative Loop\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Step: Acc1 is Acc + 1\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Usage\n\n```bash\nsource count_items.sh\ncount_items \"[a,b,c,d,e]\" 0 \"\"\n# Output: [a,b,c,d,e]:0:5\n```", "answer_tailored": true}
{"pair_id": "tail-recursion_p2", "cluster_id": "tail-recursion", "question": "What is an accumulator pattern?", "question_type": "medium", "answer": "The accumulator pattern is a technique in recursive programming where an extra argument\u2014the \"accumulator\"\u2014is used to carry partial results or state through recursive calls. In UnifyWeaver, this pattern is the foundation of tail recursion optimization, allowing the compiler to transform recursion into efficient iterative loops.\n\n### Why the Accumulator Matters\nBy moving the computation (such as incrementing a counter) before the recursive call, the call becomes the final action in the predicate. This allows UnifyWeaver to:\n- Eliminate stack overhead by discarding the current frame.\n- Prevent stack overflow errors during deep recursion.\n- Generate much faster execution in target languages like Bash.\n\n### Prolog Example\nIn this pattern, the base case typically returns the final value of the accumulator, while the recursive step updates it before recursing.\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\ncount_items([], Acc, Acc). % Base case: return the accumulated result\n\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,        % Step: Increment the accumulator\n    count_items(T, Acc1, N). % Tail call: Recursive step\n```\n\n### Generated Bash: Iterative Loop\nWhen UnifyWeaver compiles this pattern to Bash, it replaces the recursion with a `while` loop to maximize performance:\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Iterative loop replaces recursion to save memory\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of the list\n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Increment the accumulator state\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\nDetailed explanations of recursion types and optimization strategies can be found in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "accumulator", "optimization", "iterative-loop"], "original_answer": "## Tail Recursion Optimization\n\nTail recursion is when the recursive call is the last action in a function.\n\n### Why It Matters\n\nTail recursion can be converted to an iterative loop:\n- No stack overhead\n- No stack overflow risk\n- Much faster execution\n\n### The Accumulator Pattern\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Generated Bash: Iterative Loop\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Step: Acc1 is Acc + 1\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Usage\n\n```bash\nsource count_items.sh\ncount_items \"[a,b,c,d,e]\" 0 \"\"\n# Output: [a,b,c,d,e]:0:5\n```", "answer_tailored": true}
{"pair_id": "tail-recursion_p3", "cluster_id": "tail-recursion", "question": "How is tail recursion converted to a loop?", "question_type": "medium", "answer": "UnifyWeaver converts tail recursion into a loop by identifying predicates where the recursive call is the final action and transforming that logic into an iterative `while` structure in the target language. This optimization, known as Tail Call Optimization (TCO), is essential for languages like Bash that have limited stack depth, as it eliminates stack overhead and prevents overflow.\n\nThe transformation typically employs the **Accumulator Pattern** to maintain state across iterations. Consider this Prolog example for counting items in a list:\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: returns the accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: updates accumulator and performs tail call\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).\n```\n\nWhen targeting Bash, the compiler generates an iterative loop that replaces the recursive calls, efficiently updating the list and accumulator variables:\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Check base case immediately\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative while loop replaces recursion\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Logic to extract the tail of the list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Update accumulator state\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\nThis conversion ensures that even deep recursive calls are executed with high performance and minimal memory usage. For more detailed information on these transformations, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "accumulator", "optimization", "iterative-loop"], "original_answer": "## Tail Recursion Optimization\n\nTail recursion is when the recursive call is the last action in a function.\n\n### Why It Matters\n\nTail recursion can be converted to an iterative loop:\n- No stack overhead\n- No stack overflow risk\n- Much faster execution\n\n### The Accumulator Pattern\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Generated Bash: Iterative Loop\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Step: Acc1 is Acc + 1\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Usage\n\n```bash\nsource count_items.sh\ncount_items \"[a,b,c,d,e]\" 0 \"\"\n# Output: [a,b,c,d,e]:0:5\n```", "answer_tailored": true}
{"pair_id": "linear-recursion_p0", "cluster_id": "linear-recursion", "question": "How does UnifyWeaver compile linear recursion?", "question_type": "medium", "answer": "UnifyWeaver compiles linear recursion\u2014defined as predicates with exactly one recursive call per clause\u2014by transforming the recursive logic into a fold-based iterative process. This approach avoids stack overflow issues in targets like Bash and optimizes performance through memoization.\n\n### Compilation Components\nThe compiler decomposes linear recursion into three functional parts:\n1.  **Range Builder**: Generates the sequence of values required for the computation (e.g., `N, N-1, ..., 1`).\n2.  **Fold Operation**: A helper function that applies the recursive logic to an accumulator (e.g., multiplying for a factorial).\n3.  **Memoization**: An associative array or cache that stores previously computed results to speed up subsequent calls.\n\n### Example: Factorial Transformation\nFor a standard factorial predicate:\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :- N > 0, N1 is N - 1, factorial(N1, F1), F is N * F1.\n```\n\nIn the Bash target, UnifyWeaver generates a `fold_left` utility and a range generator using `seq`. The logic is implemented as follows:\n\n```bash\n# Generated range and fold logic\nfactorial_op() {\n    echo $(($1 * $2))\n}\n\nfactorial() {\n    local n=\"$1\"\n    # Memoization check\n    [[ -n \"${factorial_memo[$n]}\" ]] && echo \"$n:${factorial_memo[$n]}\" && return 0\n    \n    # Base case\n    [[ \"$n\" -eq 0 ]] && echo \"0:1\" && return 0\n    \n    # Iterative computation via fold\n    local range=$(seq \"$n\" -1 1)\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\nThis strategy ensures that linear recursive calls are converted into efficient loops. For more advanced details on recursion handling and the fold-based architecture, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["linear-recursion", "fold", "memoization", "factorial"], "original_answer": "## Linear Recursion with Fold-Based Compilation\n\nLinear recursion: exactly one recursive call per clause.\n\n### Example: Factorial\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Fold-Based Approach\n\nUnifyWeaver generates:\n1. **Range builder** - generates N, N-1, ..., 1\n2. **Fold operation** - multiplies accumulator\n3. **Memoization** - caches results\n\n### Generated Bash\n\n```bash\n# Fold helper\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Fold operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main with memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memo\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Fold computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```", "answer_tailored": true}
{"pair_id": "linear-recursion_p1", "cluster_id": "linear-recursion", "question": "What is fold-based compilation?", "question_type": "medium", "answer": "Fold-based compilation is a technique used by UnifyWeaver to transform linear recursive Prolog predicates (where there is exactly one recursive call per clause) into iterative structures in target languages like Bash. This approach avoids deep recursion limits by converting the recursive logic into a sequence generation and a reduction process.\n\nIn this strategy, the compiler generates three primary components:\n1. **Range Builder**: A function that generates the sequence of values (e.g., `seq $n -1 1` for a descending factorial).\n2. **Fold Operation**: A reduction function (like a left-fold) that iteratively applies a specific operation to an accumulator using the generated sequence.\n3. **Memoization**: A caching layer, typically using associative arrays, to store results and avoid redundant calculations.\n\nFor a predicate like `factorial(N, F)`, UnifyWeaver generates a Bash implementation that builds the numerical range and uses a `fold_left` helper to multiply the values. This ensures the computation remains efficient and safe within the shell environment.\n\nDetailed implementation examples and patterns can be found in `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["linear-recursion", "fold", "memoization", "factorial"], "original_answer": "## Linear Recursion with Fold-Based Compilation\n\nLinear recursion: exactly one recursive call per clause.\n\n### Example: Factorial\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Fold-Based Approach\n\nUnifyWeaver generates:\n1. **Range builder** - generates N, N-1, ..., 1\n2. **Fold operation** - multiplies accumulator\n3. **Memoization** - caches results\n\n### Generated Bash\n\n```bash\n# Fold helper\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Fold operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main with memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memo\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Fold computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```", "answer_tailored": true}
{"pair_id": "linear-recursion_p2", "cluster_id": "linear-recursion", "question": "How is factorial compiled to Bash?", "question_type": "medium", "answer": "I will read the source file `education/book-02-bash-target/06_advanced_recursion.md` to ensure I have all the necessary context for the rewrite.\nIn UnifyWeaver, the factorial predicate is compiled to Bash using a fold-based linear recursion strategy. This approach separates the structure building (generating the sequence of numbers) from the actual computation logic (multiplication), ensuring both clarity and performance.\n\n### Compilation Strategy\n1. **Range Building**: The compiler generates a `build_range_down` function that produces the sequence $N, N-1, \\dots, 1$.\n2. **Fold Operation**: A `fold_left` helper iterates through the sequence, applying a `factorial_op` (multiplication) at each step to build the result.\n3. **Memoization**: Computed results are cached in a global associative array (`factorial_memo`) to optimize repeated calls and prevent redundant recursion.\n\n### Prolog Source\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Generated Bash Implementation\n```bash\n# Fold helper for iterative accumulation\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder: generates N, N-1, ..., 1\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Core multiplication logic\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main function with integrated memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memoization cache\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Execute fold-based computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```\n\nFor more details on how UnifyWeaver optimizes linear recursion into folds, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["linear-recursion", "fold", "memoization", "factorial"], "original_answer": "## Linear Recursion with Fold-Based Compilation\n\nLinear recursion: exactly one recursive call per clause.\n\n### Example: Factorial\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Fold-Based Approach\n\nUnifyWeaver generates:\n1. **Range builder** - generates N, N-1, ..., 1\n2. **Fold operation** - multiplies accumulator\n3. **Memoization** - caches results\n\n### Generated Bash\n\n```bash\n# Fold helper\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Fold operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main with memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memo\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Fold computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```", "answer_tailored": true}
{"pair_id": "linear-recursion_p3", "cluster_id": "linear-recursion", "question": "What is memoization in generated code?", "question_type": "medium", "answer": "Memoization in UnifyWeaver's generated code is an optimization technique that caches the results of recursive function calls to prevent redundant computations. This is particularly useful in linear recursion scenarios where the compiler employs fold-based compilation.\n\nWhen targeting Bash, UnifyWeaver implements memoization using global associative arrays. The generated function follows a specific execution pattern:\n\n1.  **Cache Lookup:** The function first checks if a result for the given input already exists in a dedicated global array (e.g., `declare -gA factorial_memo`).\n2.  **Immediate Return:** If the value is present, it is returned immediately, bypassing the main logic.\n3.  **Computation and Storage:** If the value is not in the cache, the function proceeds with the computation (often involving a range builder and a fold operation). Once the result is calculated, it is saved into the associative array before the function exits.\n\nAn example of this structure in generated Bash code:\n\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memoization cache\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # ... logic for base cases and fold-based recursion ...\n    \n    # Store result for future calls\n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\nThis approach significantly improves performance for repetitive calculations. For more information on how the compiler handles advanced recursion and caching, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["linear-recursion", "fold", "memoization", "factorial"], "original_answer": "## Linear Recursion with Fold-Based Compilation\n\nLinear recursion: exactly one recursive call per clause.\n\n### Example: Factorial\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Fold-Based Approach\n\nUnifyWeaver generates:\n1. **Range builder** - generates N, N-1, ..., 1\n2. **Fold operation** - multiplies accumulator\n3. **Memoization** - caches results\n\n### Generated Bash\n\n```bash\n# Fold helper\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Fold operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main with memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memo\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Fold computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```", "answer_tailored": true}
{"pair_id": "tree-recursion_p0", "cluster_id": "tree-recursion", "question": "How does UnifyWeaver handle tree recursion?", "question_type": "medium", "answer": "UnifyWeaver handles tree recursion by decomposing Prolog clauses with multiple recursive calls into sequential executions within the target language. For Bash targets, this involves using command substitution to capture sub-call results and employing a depth-aware parser to correctly handle nested data structures.\n\n### Technical Implementation\n\nIn a tree structure like `[Value, Left, Right]`, the compiler generates logic to parse the components while tracking nesting levels to ensure subtrees are isolated correctly.\n\n**Prolog Definition:**\n```prolog\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n**Generated Bash Logic:**\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0; return 0\n    fi\n    \n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth to isolate nested subtrees\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    tree_str=\"${tree_str#[}\"; tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\nThis mechanism allows the system to process deep structural recursion by maintaining state via local variables and subshell execution. For further details on recursion patterns, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tree-recursion", "binary-tree", "structural-decomposition"], "original_answer": "## Tree Recursion\n\nTree recursion: multiple recursive calls per clause on structural parts.\n\n### Example: tree_sum\n\n```prolog\n% Tree as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth for nested structures\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\n### Usage\n\n```bash\n#       5\n#      / \\\n#     3   2\n#    /\n#   1\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```", "answer_tailored": true}
{"pair_id": "tree-recursion_p1", "cluster_id": "tree-recursion", "question": "How is tree_sum compiled to Bash?", "question_type": "medium", "answer": "In UnifyWeaver, the `tree_sum` predicate is compiled into a recursive Bash function that utilizes depth-aware string parsing to handle nested tree structures. The compiler transforms Prolog's structural matching into a shell function that executes subtrees in subshells and aggregates results via arithmetic expansion.\n\n### Prolog Definition\nThe source logic defines a tree as `[Value, LeftSubtree, RightSubtree]`:\n```prolog\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash Implementation\nThe Bash target uses a specialized `parse_tree` helper to track bracket depth, ensuring that nested sub-lists are correctly isolated before recursion.\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: map empty list to 0\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Destructure the tree string into components\n    local val left right\n    parse_tree \"$tree\" val left right\n    \n    # Recurse using command substitution\n    local ls=$(tree_sum \"$left\")\n    local rs=$(tree_sum \"$right\")\n    \n    # Combine results using $(( ))\n    echo $(( val + ls + rs ))\n}\n\n# Depth-aware parser for nested Prolog-style lists\nparse_tree() {\n    local str=\"${1#[}\"; str=\"${str%]}\"\n    local -n v=\"$2\" l=\"$3\" r=\"$4\"\n    local depth=0 part=0 current=\"\"\n    \n    for (( i=0; i<${#str}; i++ )); do\n        c=\"${str:i:1}\"\n        case \"$c\" in\n            '[') ((depth++)); current+=\"$c\" ;;\n            ']') ((depth--)); current+=\"$c\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    [ $part -eq 0 ] && v=\"$current\" || l=\"$current\"\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$c\"\n                fi ;;\n            *) current+=\"$c\" ;;\n        esac\n    done\n    r=\"$current\"\n}\n```\n\n### Usage Example\n```bash\n# Represents: [5,[3,[1,[],[]]],[2,[],[]]]\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```\n\nFor a deeper dive into how UnifyWeaver handles complex structural recursion in shell scripts, refer to `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tree-recursion", "binary-tree", "structural-decomposition"], "original_answer": "## Tree Recursion\n\nTree recursion: multiple recursive calls per clause on structural parts.\n\n### Example: tree_sum\n\n```prolog\n% Tree as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth for nested structures\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\n### Usage\n\n```bash\n#       5\n#      / \\\n#     3   2\n#    /\n#   1\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```", "answer_tailored": true}
{"pair_id": "tree-recursion_p2", "cluster_id": "tree-recursion", "question": "What is structural decomposition in recursion?", "question_type": "medium", "answer": "Structural decomposition in recursion is the process of breaking a complex data structure into its constituent parts\u2014such as the value, left subtree, and right subtree of a tree\u2014so that recursive operations can be applied to those individual components. In UnifyWeaver, this is expressed through Prolog pattern matching and compiled into target-specific parsing logic.\n\n### Example: Tree Recursion via Decomposition\nWhen summing a tree structured as `[Value, LeftSubtree, RightSubtree]`, the algorithm decomposes the structure to process the branches independently.\n\n**Prolog Implementation:**\n```prolog\n% Structural decomposition via pattern matching\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n**Compiled Bash Implementation:**\nIn the Bash target, structural decomposition requires manual parsing (often using a helper like `parse_tree`) to track bracket depth and correctly isolate the nested components.\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case for empty structure\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Decompose the tree string into value, left, and right parts\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on the decomposed parts\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    echo $(( $value + $left_result + $right_result ))\n}\n```\n\nThe `parse_tree` utility facilitates this decomposition by iterating through the input string and monitoring delimiter depth to ensure nested subtrees are extracted as valid units. For example, the structure `\"[5,[3,[],[]],[2,[],[]]]\"` is decomposed into value `5`, left subtree `[3,[],[]]`, and right subtree `[2,[],[]]`.\n\nFor further details on implementing complex recursion in shell environments, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tree-recursion", "binary-tree", "structural-decomposition"], "original_answer": "## Tree Recursion\n\nTree recursion: multiple recursive calls per clause on structural parts.\n\n### Example: tree_sum\n\n```prolog\n% Tree as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth for nested structures\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\n### Usage\n\n```bash\n#       5\n#      / \\\n#     3   2\n#    /\n#   1\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```", "answer_tailored": true}
{"pair_id": "tree-recursion_p3", "cluster_id": "tree-recursion", "question": "How are nested structures parsed in Bash?", "question_type": "medium", "answer": "In UnifyWeaver's Bash target, nested structures are parsed by tracking the nesting depth of brackets (e.g., `[` and `]`) within a string representation. The generated Bash code iterates through the input string character by character, maintaining a `depth` counter to identify structural boundaries. This ensures that commas are only treated as field separators when they appear at the current nesting level (depth 0), allowing the parser to correctly extract complex sub-structures for recursive processing.\n\nFor instance, when parsing a tree represented as `[Value, LeftSubtree, RightSubtree]`, the compiler implements a parsing loop similar to this:\n\n```bash\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Strip outer brackets\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    # Split into structural parts at depth 0\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\nThis structural decomposition allows recursive functions like `tree_sum` to isolate nested sub-trees (e.g., `tree_sum \"[5,[3,[],[]],[2,[],[]]]\"`) and pass them to subsequent function calls.\n\nFor more information on handling recursive structures in Bash, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tree-recursion", "binary-tree", "structural-decomposition"], "original_answer": "## Tree Recursion\n\nTree recursion: multiple recursive calls per clause on structural parts.\n\n### Example: tree_sum\n\n```prolog\n% Tree as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth for nested structures\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\n### Usage\n\n```bash\n#       5\n#      / \\\n#     3   2\n#    /\n#   1\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```", "answer_tailored": true}
{"pair_id": "mutual-recursion_p0", "cluster_id": "mutual-recursion", "question": "How does UnifyWeaver handle mutual recursion?", "question_type": "medium", "answer": "UnifyWeaver handles mutual recursion by identifying groups of interdependent predicates during the analysis phase and compiling them as a cohesive unit. This ensures that cyclic call patterns are managed efficiently across different target languages.\n\n### SCC Detection via Tarjan\u2019s Algorithm\nTo manage these cycles, the compiler identifies **Strongly Connected Components (SCCs)** in the program's call graph:\n1.  **Graph Construction:** It maps predicates as nodes and calls as directed edges.\n2.  **Cycle Discovery:** Using Tarjan's algorithm, it groups predicates that can reach one another into distinct SCCs.\n3.  **Unified Compilation:** Predicates within the same SCC are compiled together, allowing them to share state and recursion logic.\n\n### Implementation: Shared Memoization\nFor targets like Bash, UnifyWeaver implements a **Shared Memoization** strategy. Instead of isolated caches, all predicates in a mutually recursive group utilize a single, shared global associative array. This prevents redundant computations and ensures consistent results as the execution bounces between different functions in the cycle.\n\n**Example Logic (Bash):**\n```bash\n# Shared memo for the entire SCC\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local key=\"is_even:$1\"\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"true\" && return 0\n    fi\n    # Logic follows, potentially calling is_odd\n}\n\nis_odd() {\n    # Uses the same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why This Matters\n*   **Efficiency:** Prevents the \"explosion\" of redundant calls in complex recursive patterns.\n*   **Stability:** Provides a reliable mechanism for handling cyclic dependencies that might otherwise cause stack overflows in simple script environments.\n*   **Consistency:** Maintains a unified state for the entire recursive group.\n\nFor more detailed examples and implementation specifics, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["mutual-recursion", "scc", "even-odd", "shared-memoization"], "original_answer": "## Mutual Recursion\n\nMutual recursion: two or more functions call each other in a cycle.\n\n### Example: is_even / is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### SCC Detection\n\nUnifyWeaver uses Tarjan's algorithm to find Strongly Connected Components:\n1. Build call graph (predicates as nodes, calls as edges)\n2. Find SCCs (groups where every node reaches every other)\n3. Compile SCC members together with shared state\n\n### Generated Bash: Shared Memoization\n\n```bash\n# Shared memo for all predicates in group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared memo\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: call is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar structure, calls is_even\n    # Uses same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why Shared Memoization?\n\n- Prevents redundant computation across mutual calls\n- Consistent caching for the entire SCC\n- Correct handling of complex call patterns\n\n### Usage\n\n```bash\nis_even 0 && echo \"true\"  # true\nis_even 4 && echo \"true\"  # true (via is_odd(3)->is_even(2)->...)\nis_odd 3 && echo \"true\"   # true\nis_even 5 || echo \"false\" # false\n```", "answer_tailored": true}
{"pair_id": "mutual-recursion_p1", "cluster_id": "mutual-recursion", "question": "What is SCC detection for mutual recursion?", "question_type": "medium", "answer": "SCC detection in UnifyWeaver is the mechanism used to identify and compile mutual recursion, where two or more predicates call each other in a cycle. To handle these recursive dependencies efficiently, the compiler applies Tarjan\u2019s algorithm during the analysis phase.\n\nThe process follows these steps:\n1. **Call Graph Analysis**: The compiler builds a directed graph where predicates are nodes and calls are edges.\n2. **Component Identification**: Tarjan\u2019s algorithm identifies Strongly Connected Components (SCCs)\u2014groups of predicates where every node is reachable from every other node in the group.\n3. **Unified Compilation**: Members of an SCC are compiled together, sharing a common execution context and state.\n\nIn the Bash target, SCC detection triggers the generation of **Shared Memoization**. Instead of separate caches, all predicates in the SCC share a single global associative array (e.g., `declare -gA group_name_memo`). This ensures:\n- **Redundancy Elimination**: Results computed by one predicate (like `is_odd`) are immediately available to others in the cycle (like `is_even`).\n- **Consistent Caching**: The entire recursive group maintains a unified state, preventing redundant traversals of the same logic.\n- **Complexity Management**: Even highly complex, multi-node cycles are resolved into a single, efficient caching structure.\n\nFor more details on how mutual recursion is transformed into optimized shell scripts, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["mutual-recursion", "scc", "even-odd", "shared-memoization"], "original_answer": "## Mutual Recursion\n\nMutual recursion: two or more functions call each other in a cycle.\n\n### Example: is_even / is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### SCC Detection\n\nUnifyWeaver uses Tarjan's algorithm to find Strongly Connected Components:\n1. Build call graph (predicates as nodes, calls as edges)\n2. Find SCCs (groups where every node reaches every other)\n3. Compile SCC members together with shared state\n\n### Generated Bash: Shared Memoization\n\n```bash\n# Shared memo for all predicates in group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared memo\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: call is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar structure, calls is_even\n    # Uses same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why Shared Memoization?\n\n- Prevents redundant computation across mutual calls\n- Consistent caching for the entire SCC\n- Correct handling of complex call patterns\n\n### Usage\n\n```bash\nis_even 0 && echo \"true\"  # true\nis_even 4 && echo \"true\"  # true (via is_odd(3)->is_even(2)->...)\nis_odd 3 && echo \"true\"   # true\nis_even 5 || echo \"false\" # false\n```", "answer_tailored": true}
{"pair_id": "mutual-recursion_p2", "cluster_id": "mutual-recursion", "question": "How are is_even and is_odd compiled together?", "question_type": "medium", "answer": "UnifyWeaver compiles mutually recursive predicates like `is_even` and `is_odd` by identifying them as a Strongly Connected Component (SCC) and implementing a shared memoization strategy. This ensures that the functions work in tandem to avoid redundant calculations and handle cyclic calls efficiently.\n\n### SCC Detection and Grouping\nThe compiler uses Tarjan's algorithm to analyze the call graph of the Prolog source. When it detects that `is_even` calls `is_odd` and vice-versa, it groups them into a single SCC. Rather than compiling them as isolated functions, the compiler treats the entire group as a cohesive unit with shared state.\n\n### Shared Memoization in Bash\nIn the Bash target, this shared state is implemented using a single global associative array that stores results for every predicate in the group.\n\n1. **Shared Table**: A variable like `declare -gA is_even_is_odd_memo` is generated to serve the entire SCC.\n2. **Namespace Keys**: To prevent result collisions, the memoization keys include the predicate name (e.g., `is_even:$1` vs `is_odd:$1`).\n3. **Execution Flow**:\n    - `is_even` checks the shared memo table.\n    - If not found, it performs its logic, which includes calling `is_odd`.\n    - `is_odd` similarly checks the same shared memo table before proceeding.\n    - Both functions update the same table once a result is determined.\n\n```bash\n# Example of the shared memo lookup\nis_even() {\n    local key=\"is_even:$1\"\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"true\" && return 0\n    fi\n    # ... logic calling is_odd ...\n}\n```\n\nThis integrated approach prevents the exponential overhead often associated with naive mutual recursion and ensures consistent caching across the entire call cycle. For more technical details on recursion handling, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["mutual-recursion", "scc", "even-odd", "shared-memoization"], "original_answer": "## Mutual Recursion\n\nMutual recursion: two or more functions call each other in a cycle.\n\n### Example: is_even / is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### SCC Detection\n\nUnifyWeaver uses Tarjan's algorithm to find Strongly Connected Components:\n1. Build call graph (predicates as nodes, calls as edges)\n2. Find SCCs (groups where every node reaches every other)\n3. Compile SCC members together with shared state\n\n### Generated Bash: Shared Memoization\n\n```bash\n# Shared memo for all predicates in group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared memo\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: call is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar structure, calls is_even\n    # Uses same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why Shared Memoization?\n\n- Prevents redundant computation across mutual calls\n- Consistent caching for the entire SCC\n- Correct handling of complex call patterns\n\n### Usage\n\n```bash\nis_even 0 && echo \"true\"  # true\nis_even 4 && echo \"true\"  # true (via is_odd(3)->is_even(2)->...)\nis_odd 3 && echo \"true\"   # true\nis_even 5 || echo \"false\" # false\n```", "answer_tailored": true}
{"pair_id": "mutual-recursion_p3", "cluster_id": "mutual-recursion", "question": "What is shared memoization?", "question_type": "medium", "answer": "Shared memoization is an optimization technique used by UnifyWeaver to handle mutually recursive predicates by providing a single, unified cache for an entire Strongly Connected Component (SCC).\n\nWhen the compiler identifies a group of predicates that call each other in a cycle (detected using Tarjan\u2019s algorithm), it generates a shared memoization table\u2014such as a global associative array in Bash (`declare -gA`)\u2014instead of individual caches for each function. Each predicate within the SCC checks this common table using a composite key (e.g., `predicate_name:arguments`) before performing any computation.\n\nThis approach offers several advantages:\n- **Redundancy Elimination:** Prevents duplicate computations across the entire mutual recursion cycle.\n- **Consistent Caching:** Ensures that results are cached uniformly for the whole SCC group.\n- **Efficient Execution:** Correctly handles complex call patterns, such as the `is_even` / `is_odd` mutual recursion, by sharing state between functions.\n\nFor implementation details and Bash code examples, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["mutual-recursion", "scc", "even-odd", "shared-memoization"], "original_answer": "## Mutual Recursion\n\nMutual recursion: two or more functions call each other in a cycle.\n\n### Example: is_even / is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### SCC Detection\n\nUnifyWeaver uses Tarjan's algorithm to find Strongly Connected Components:\n1. Build call graph (predicates as nodes, calls as edges)\n2. Find SCCs (groups where every node reaches every other)\n3. Compile SCC members together with shared state\n\n### Generated Bash: Shared Memoization\n\n```bash\n# Shared memo for all predicates in group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared memo\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: call is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar structure, calls is_even\n    # Uses same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why Shared Memoization?\n\n- Prevents redundant computation across mutual calls\n- Consistent caching for the entire SCC\n- Correct handling of complex call patterns\n\n### Usage\n\n```bash\nis_even 0 && echo \"true\"  # true\nis_even 4 && echo \"true\"  # true (via is_odd(3)->is_even(2)->...)\nis_odd 3 && echo \"true\"   # true\nis_even 5 || echo \"false\" # false\n```", "answer_tailored": true}
