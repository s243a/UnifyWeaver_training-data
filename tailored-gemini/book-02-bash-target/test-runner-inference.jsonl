{"pair_id": "test-runner-inference_p0", "cluster_id": "test-runner-inference", "question": "How does UnifyWeaver generate tests automatically?", "question_type": "medium", "answer": "UnifyWeaver generates tests automatically through its **Test Runner Inference** system, which scans and analyzes compiled Bash scripts to build a comprehensive test suite. This feature eliminates the overhead of manual test maintenance by discovering function signatures and patterns directly from the generated output.\n\nThe automatic generation process follows these steps:\n1. **Directory Scanning:** The system identifies all `.sh` files within the specified output directory.\n2. **Signature Extraction:** It parses the scripts to extract function names, arities, and pattern types.\n3. **Case Inference:** Based on the extracted metadata, UnifyWeaver infers appropriate test cases for each function.\n4. **Runner Assembly:** It generates a complete Bash script (e.g., `test_runner.sh`) that executes the inferred tests and reports results.\n\nTo initiate test generation from the Prolog interface:\n```prolog\n% Load the inference module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate a test runner with optional configuration\n?- generate_test_runner_inferred('output/tests.sh', [mode(concise)]).\n```\n\nUsers can customize the output using different modes: `explicit` (readable, one block per file), `concise` (compact, using arrays), or `hybrid`. The resulting script is a standard shell script that can be run with `bash`. For further details on test discovery logic and configuration options, see `education/book-02-bash-target/08_test_runner_inference.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["testing", "automatic", "inference", "test-generation"], "original_answer": "## Test Runner Inference\n\nUnifyWeaver can automatically generate test scripts by analyzing compiled Bash code.\n\n### The Problem\n\nManual testing is tedious:\n- Must track all generated scripts\n- Need to know function arities\n- Easy to forget functions\n- Adding predicates requires updating tests\n\n### The Solution: Automatic Discovery\n\n```prolog\n% One command generates complete test suite\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\n### How It Works\n\n1. **Scan** output directory for `.sh` files\n2. **Extract** function signatures (name, arity, pattern type)\n3. **Infer** appropriate test cases\n4. **Generate** complete test runner script\n\n### Usage\n\n```prolog\n% Load module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate with defaults\n?- generate_test_runner_inferred.\n\n% Specify output path\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Use concise mode\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan different directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n### Running Generated Tests\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n--- Testing list_length.sh ---\nTest 1: Empty list\n[]:0\n\n=== All Tests Complete ===\n```\n\n### Output Modes\n\n| Mode | Description |\n|------|-------------|\n| explicit | One test block per file (default, readable) |\n| concise | Loop-based with arrays (compact) |\n| hybrid | Smart selection based on complexity |", "answer_tailored": true}
{"pair_id": "test-runner-inference_p1", "cluster_id": "test-runner-inference", "question": "What is test runner inference?", "question_type": "medium", "answer": "Test runner inference is an automated feature in UnifyWeaver that generates comprehensive test suites by analyzing compiled Bash code. Instead of manually tracking function arities and script names, the system dynamically discovers predicates and their requirements to ensure full test coverage.\n\n### Key Capabilities\n- **Automatic Discovery:** It scans output directories for `.sh` files and extracts function signatures, including arity and pattern types.\n- **Dynamic Generation:** Based on the inferred signatures, it produces a unified `test_runner.sh` script that executes test cases for all compiled functions.\n- **Reduced Maintenance:** Since tests are inferred from the code structure, adding new Prolog predicates doesn't require manual updates to the testing framework.\n\n### Usage in Prolog\nTo use this feature, load the inference module and invoke the generator:\n\n```prolog\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate a test runner with specific options\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/advanced'), mode(explicit)]).\n```\n\n### Output Modes\nThe inference engine supports different formatting styles for the generated runner:\n- **explicit:** Creates readable, individual test blocks for each file (default).\n- **concise:** Uses compact, loop-based arrays for high-density testing.\n- **hybrid:** Intelligently selects the format based on the complexity of the inferred functions.\n\nFor detailed examples and configuration strategies, see the documentation in `education/book-02-bash-target/08_test_runner_inference.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["testing", "automatic", "inference", "test-generation"], "original_answer": "## Test Runner Inference\n\nUnifyWeaver can automatically generate test scripts by analyzing compiled Bash code.\n\n### The Problem\n\nManual testing is tedious:\n- Must track all generated scripts\n- Need to know function arities\n- Easy to forget functions\n- Adding predicates requires updating tests\n\n### The Solution: Automatic Discovery\n\n```prolog\n% One command generates complete test suite\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\n### How It Works\n\n1. **Scan** output directory for `.sh` files\n2. **Extract** function signatures (name, arity, pattern type)\n3. **Infer** appropriate test cases\n4. **Generate** complete test runner script\n\n### Usage\n\n```prolog\n% Load module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate with defaults\n?- generate_test_runner_inferred.\n\n% Specify output path\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Use concise mode\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan different directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n### Running Generated Tests\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n--- Testing list_length.sh ---\nTest 1: Empty list\n[]:0\n\n=== All Tests Complete ===\n```\n\n### Output Modes\n\n| Mode | Description |\n|------|-------------|\n| explicit | One test block per file (default, readable) |\n| concise | Loop-based with arrays (compact) |\n| hybrid | Smart selection based on complexity |", "answer_tailored": true}
{"pair_id": "test-runner-inference_p2", "cluster_id": "test-runner-inference", "question": "How do I generate a test script for my compiled code?", "question_type": "medium", "answer": "You can generate test scripts for your compiled code by utilizing UnifyWeaver's automatic test runner inference. This system eliminates manual test creation by scanning your output directory for `.sh` files, extracting function signatures, and building a comprehensive test suite automatically.\n\nTo create a test runner, load the inference module and execute the generation predicate:\n\n```prolog\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate the default test runner (output/advanced/test_runner.sh)\n?- generate_test_runner_inferred.\n\n% Custom path and configuration\n?- generate_test_runner_inferred('custom_tests.sh', [mode(concise), output_dir('output/v1')]).\n```\n\nThe generator supports three primary output modes:\n- **explicit**: Generates readable, individual test blocks for each file (default).\n- **concise**: Uses compact loops and arrays for a smaller script footprint.\n- **hybrid**: Dynamically selects the best format based on the complexity of the inferred functions.\n\nOnce the script is generated, run the test suite directly from your terminal:\n```bash\n$ bash output/advanced/test_runner.sh\n```\n\nFor a deep dive into the inference engine and signature extraction, refer to the documentation in `education/book-02-bash-target/08_test_runner_inference.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["testing", "automatic", "inference", "test-generation"], "original_answer": "## Test Runner Inference\n\nUnifyWeaver can automatically generate test scripts by analyzing compiled Bash code.\n\n### The Problem\n\nManual testing is tedious:\n- Must track all generated scripts\n- Need to know function arities\n- Easy to forget functions\n- Adding predicates requires updating tests\n\n### The Solution: Automatic Discovery\n\n```prolog\n% One command generates complete test suite\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\n### How It Works\n\n1. **Scan** output directory for `.sh` files\n2. **Extract** function signatures (name, arity, pattern type)\n3. **Infer** appropriate test cases\n4. **Generate** complete test runner script\n\n### Usage\n\n```prolog\n% Load module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate with defaults\n?- generate_test_runner_inferred.\n\n% Specify output path\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Use concise mode\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan different directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n### Running Generated Tests\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n--- Testing list_length.sh ---\nTest 1: Empty list\n[]:0\n\n=== All Tests Complete ===\n```\n\n### Output Modes\n\n| Mode | Description |\n|------|-------------|\n| explicit | One test block per file (default, readable) |\n| concise | Loop-based with arrays (compact) |\n| hybrid | Smart selection based on complexity |", "answer_tailored": true}
{"pair_id": "test-runner-inference_p3", "cluster_id": "test-runner-inference", "question": "What is automatic test discovery?", "question_type": "medium", "answer": "Automatic test discovery is UnifyWeaver's capability to automatically generate comprehensive test runners by analyzing compiled Bash output. This feature eliminates the manual burden of tracking script locations, function arities, and predicate updates by programmatically scanning the output directory.\n\nThe discovery process works in four stages:\n1. **Scanning:** Locates `.sh` files in the specified output directory.\n2. **Extraction:** Identifies function signatures, including names and arities.\n3. **Inference:** Determines appropriate test cases based on the extracted metadata.\n4. **Generation:** Produces a unified Bash test runner script.\n\nTo use this feature, load the `unifyweaver(core/advanced/test_runner_inference)` module and call the `generate_test_runner_inferred` predicate. You can customize the generation with options such as `mode(concise)` for compact, loop-based tests or `output_dir(Path)` to target specific build artifacts. Supported output modes include `explicit` (one test block per file), `concise` (array-based loops), and `hybrid` (smart selection).\n\nFor a full guide on configuring test inference, refer to `education/book-02-bash-target/08_test_runner_inference.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["testing", "automatic", "inference", "test-generation"], "original_answer": "## Test Runner Inference\n\nUnifyWeaver can automatically generate test scripts by analyzing compiled Bash code.\n\n### The Problem\n\nManual testing is tedious:\n- Must track all generated scripts\n- Need to know function arities\n- Easy to forget functions\n- Adding predicates requires updating tests\n\n### The Solution: Automatic Discovery\n\n```prolog\n% One command generates complete test suite\n?- generate_test_runner_inferred.\nGenerated test runner: output/advanced/test_runner.sh\n```\n\n### How It Works\n\n1. **Scan** output directory for `.sh` files\n2. **Extract** function signatures (name, arity, pattern type)\n3. **Infer** appropriate test cases\n4. **Generate** complete test runner script\n\n### Usage\n\n```prolog\n% Load module\n?- use_module(unifyweaver(core/advanced/test_runner_inference)).\n\n% Generate with defaults\n?- generate_test_runner_inferred.\n\n% Specify output path\n?- generate_test_runner_inferred('my_tests.sh').\n\n% Use concise mode\n?- generate_test_runner_inferred('tests.sh', [mode(concise)]).\n\n% Scan different directory\n?- generate_test_runner_inferred('tests.sh', [output_dir('output/basic')]).\n```\n\n### Running Generated Tests\n\n```bash\n$ bash output/advanced/test_runner.sh\n\n=== Testing Generated Bash Scripts ===\n\n--- Testing factorial.sh ---\nTest 1: Base case 0\n0:1\n\nTest 2: Larger value\n5:120\n\n--- Testing list_length.sh ---\nTest 1: Empty list\n[]:0\n\n=== All Tests Complete ===\n```\n\n### Output Modes\n\n| Mode | Description |\n|------|-------------|\n| explicit | One test block per file (default, readable) |\n| concise | Loop-based with arrays (compact) |\n| hybrid | Smart selection based on complexity |", "answer_tailored": true}
{"pair_id": "test-inference-heuristics_p0", "cluster_id": "test-inference-heuristics", "question": "How does UnifyWeaver decide what tests to generate?", "question_type": "medium", "answer": "I will search for the source file to ensure I have the full context for the answer.\nI will read the contents of the source file to incorporate all relevant details into the rewritten answer.\nUnifyWeaver determines which tests to generate through an automated **test runner inference system** that analyzes compiled Bash scripts. The system scans for `.sh` files, extracts function signatures (including name, arity, and recursion pattern), and applies three primary heuristics:\n\n*   **Name-Based Inference:** It identifies keywords in function names to assign relevant inputs. For example, functions containing `list` or `length` receive list inputs (`[]`, `[a,b,c]`), while `factorial` or `fib` trigger numeric tests (`0`, `1`, `5`).\n*   **Pattern-Based Inference:** It uses the recursion type extracted from headers to guide the test structure. `tail_recursive` or `accumulator` patterns receive tests with initial zero-value accumulators, whereas `tree_recursive` patterns trigger structural tests like empty nodes and nested trees.\n*   **Arity-Based Inference:** The argument count dictates the test's shape. Arity 1 uses a single argument, Arity 2 (binary relations) uses input/output pairs, and Arity 3 (accumulators) uses input/accumulator/output triplets.\n\nFor example, a `factorial` function with arity 2 is inferred to need numeric tests with an input value and an empty string for the output capture (e.g., `factorial \"5\" \"\"`). For more details on these heuristics, see `education/book-02-bash-target/08_test_runner_inference.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["heuristics", "test-cases", "inference-rules"], "original_answer": "## Test Inference Heuristics\n\nUnifyWeaver uses multiple heuristics to generate appropriate tests.\n\n### Heuristic 1: Name-Based\n\n| Function Name Contains | Inferred Tests |\n|------------------------|----------------|\n| `length`, `list` | `[]`, `[a]`, `[a,b,c]` |\n| `factorial`, `fib`, `power` | `0`, `1`, `5` |\n| `sum`, `add` | `[]`, `[1,2,3]`, `[5,10,15]` |\n| `tree`, `binary` | `[]`, `[5,[],[]]`, nested tree |\n| `is_even`, `even` | `0`, `4`, `3` (should fail) |\n| `is_odd`, `odd` | `3`, `5`, `6` (should fail) |\n\n### Heuristic 2: Pattern-Based\n\n| Pattern Type | Inferred Tests |\n|--------------|----------------|\n| `tail_recursive` | Accumulator tests with initial 0 |\n| `linear_recursive` | Check name for specific patterns |\n| `mutual_recursive` | Complementary tests (even/odd) |\n| `tree_recursive` | Structural tests (empty, single, nested) |\n\n### Heuristic 3: Arity-Based\n\n| Arity | Typical Pattern | Test Structure |\n|-------|-----------------|----------------|\n| 1 | Unary predicates | Single argument |\n| 2 | Binary relations | Input + output (empty string) |\n| 3 | Accumulators | Input + acc(0) + output |\n\n### Example Inference\n\n```prolog\n% Signature extracted from factorial.sh\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion'),\n    file_path('factorial.sh')\n))\n```\n\n**Inferred tests:**\n- Name contains `factorial` -> numeric tests\n- Pattern is `linear_recursive` -> check name\n- Arity is 2 -> input + output\n\n**Result:**\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```", "answer_tailored": true}
{"pair_id": "test-inference-heuristics_p1", "cluster_id": "test-inference-heuristics", "question": "What heuristics are used for test inference?", "question_type": "medium", "answer": "UnifyWeaver employs three primary heuristics\u2014Name-Based, Pattern-Based, and Arity-Based\u2014to automatically infer and generate appropriate test cases for compiled code.\n\n### 1. Name-Based Heuristics\nThe system maps keywords within function names to specific sets of inferred test inputs:\n*   **List/Collection (`length`, `list`):** Inferred tests include `[]`, `[a]`, and `[a,b,c]`.\n*   **Numeric/Mathematical (`factorial`, `fib`, `power`):** Inputs like `0`, `1`, and `5`.\n*   **Summation (`sum`, `add`):** Sets such as `[]`, `[1,2,3]`, and `[5,10,15]`.\n*   **Structural (`tree`, `binary`):** Checks `[]`, single nodes `[5,[],[]]`, and nested trees.\n*   **Parity/Boolean (`even`, `odd`):** Generates both passing (e.g., `0`, `4` for even) and failing (e.g., `3`) cases to verify logic boundaries.\n\n### 2. Pattern-Based Heuristics\nTest generation is also influenced by the metadata describing the recursive structure of the predicate:\n*   **Tail Recursive:** Prioritizes accumulator-based tests with an initial value (typically `0`).\n*   **Linear Recursive:** Leverages the name-based pattern matching to determine input ranges.\n*   **Mutual Recursive:** Creates complementary tests (e.g., alternating between `even` and `odd` predicates).\n*   **Tree Recursive:** Exercises structural limits, focusing on empty, single-node, and deeply nested trees.\n\n### 3. Arity-Based Heuristics\nThe function's arity dictates the signature and format of the generated test call:\n*   **Arity 1:** Simple unary tests involving a single argument.\n*   **Arity 2:** Binary relations formatted as `Input + output_placeholder`.\n*   **Arity 3:** Accumulator patterns, typically formatted as `Input + acc(0) + output_placeholder`.\n\n### Inference Example\nWhen UnifyWeaver processes a `factorial/2` predicate identified as `linear_recursive`, it synthesizes these heuristics (name keyword, arity, and recursion pattern) to produce:\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```\n\nDetailed implementation notes on the test runner and its inference logic are available in `education/book-02-bash-target/08_test_runner_inference.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["heuristics", "test-cases", "inference-rules"], "original_answer": "## Test Inference Heuristics\n\nUnifyWeaver uses multiple heuristics to generate appropriate tests.\n\n### Heuristic 1: Name-Based\n\n| Function Name Contains | Inferred Tests |\n|------------------------|----------------|\n| `length`, `list` | `[]`, `[a]`, `[a,b,c]` |\n| `factorial`, `fib`, `power` | `0`, `1`, `5` |\n| `sum`, `add` | `[]`, `[1,2,3]`, `[5,10,15]` |\n| `tree`, `binary` | `[]`, `[5,[],[]]`, nested tree |\n| `is_even`, `even` | `0`, `4`, `3` (should fail) |\n| `is_odd`, `odd` | `3`, `5`, `6` (should fail) |\n\n### Heuristic 2: Pattern-Based\n\n| Pattern Type | Inferred Tests |\n|--------------|----------------|\n| `tail_recursive` | Accumulator tests with initial 0 |\n| `linear_recursive` | Check name for specific patterns |\n| `mutual_recursive` | Complementary tests (even/odd) |\n| `tree_recursive` | Structural tests (empty, single, nested) |\n\n### Heuristic 3: Arity-Based\n\n| Arity | Typical Pattern | Test Structure |\n|-------|-----------------|----------------|\n| 1 | Unary predicates | Single argument |\n| 2 | Binary relations | Input + output (empty string) |\n| 3 | Accumulators | Input + acc(0) + output |\n\n### Example Inference\n\n```prolog\n% Signature extracted from factorial.sh\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion'),\n    file_path('factorial.sh')\n))\n```\n\n**Inferred tests:**\n- Name contains `factorial` -> numeric tests\n- Pattern is `linear_recursive` -> check name\n- Arity is 2 -> input + output\n\n**Result:**\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```", "answer_tailored": true}
{"pair_id": "test-inference-heuristics_p2", "cluster_id": "test-inference-heuristics", "question": "How are test cases inferred from function signatures?", "question_type": "medium", "answer": "UnifyWeaver infers test cases by applying a series of heuristics to function signatures, specifically targeting the function's name, detected recursion pattern, and arity.\n\n### 1. Name-Based Heuristics\nThe system scans the function name for specific keywords to determine the appropriate domain for test inputs:\n*   **Numeric/Mathematical:** Names containing `factorial`, `fib`, or `power` trigger tests with values like `0`, `1`, and `5`.\n*   **Lists and Collections:** Keywords like `length` or `list` generate tests using `[]`, `[a]`, and `[a,b,c]`.\n*   **Aggregates:** `sum` or `add` trigger numeric list tests such as `[1,2,3]`.\n*   **Predicates:** `even` or `odd` generate a mix of passing and failing cases (e.g., `0`, `4`, and `3`).\n*   **Structures:** `tree` or `binary` trigger structural tests ranging from empty to nested trees.\n\n### 2. Pattern-Based Heuristics\nThe compiler utilizes implementation metadata to refine test generation:\n*   **Tail Recursive:** Suggests accumulator-based tests, typically initializing the accumulator at `0`.\n*   **Mutual Recursive:** Inferred for complementary logic, such as even/odd pairs.\n*   **Tree Recursive:** Focuses on structural variety, including empty, single-node, and nested branches.\n\n### 3. Arity-Based Heuristics\nThe number of arguments (arity) determines the structure of the generated test command:\n*   **Arity 1:** Single-argument unary predicates.\n*   **Arity 2:** Input/Output relations, structured as `Input + placeholder`.\n*   **Arity 3:** Accumulator patterns, structured as `Input + Acc(0) + Output`.\n\n### Example Inference\nWhen the compiler encounters a signature like `factorial/2` marked as `linear_recursive`, it combines these heuristics to produce the following test suite:\n- Keyword `factorial` -> numeric inputs.\n- Arity `2` -> Input + output placeholder.\n- Result: `factorial \"0\" \"\"`, `factorial \"1\" \"\"`, and `factorial \"5\" \"\"`.\n\nFor more details on the inference engine, refer to `education/book-02-bash-target/08_test_runner_inference.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["heuristics", "test-cases", "inference-rules"], "original_answer": "## Test Inference Heuristics\n\nUnifyWeaver uses multiple heuristics to generate appropriate tests.\n\n### Heuristic 1: Name-Based\n\n| Function Name Contains | Inferred Tests |\n|------------------------|----------------|\n| `length`, `list` | `[]`, `[a]`, `[a,b,c]` |\n| `factorial`, `fib`, `power` | `0`, `1`, `5` |\n| `sum`, `add` | `[]`, `[1,2,3]`, `[5,10,15]` |\n| `tree`, `binary` | `[]`, `[5,[],[]]`, nested tree |\n| `is_even`, `even` | `0`, `4`, `3` (should fail) |\n| `is_odd`, `odd` | `3`, `5`, `6` (should fail) |\n\n### Heuristic 2: Pattern-Based\n\n| Pattern Type | Inferred Tests |\n|--------------|----------------|\n| `tail_recursive` | Accumulator tests with initial 0 |\n| `linear_recursive` | Check name for specific patterns |\n| `mutual_recursive` | Complementary tests (even/odd) |\n| `tree_recursive` | Structural tests (empty, single, nested) |\n\n### Heuristic 3: Arity-Based\n\n| Arity | Typical Pattern | Test Structure |\n|-------|-----------------|----------------|\n| 1 | Unary predicates | Single argument |\n| 2 | Binary relations | Input + output (empty string) |\n| 3 | Accumulators | Input + acc(0) + output |\n\n### Example Inference\n\n```prolog\n% Signature extracted from factorial.sh\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion'),\n    file_path('factorial.sh')\n))\n```\n\n**Inferred tests:**\n- Name contains `factorial` -> numeric tests\n- Pattern is `linear_recursive` -> check name\n- Arity is 2 -> input + output\n\n**Result:**\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```", "answer_tailored": true}
{"pair_id": "test-inference-heuristics_p3", "cluster_id": "test-inference-heuristics", "question": "What test patterns does UnifyWeaver recognize?", "question_type": "medium", "answer": "I will read the source file `education/book-02-bash-target/08_test_runner_inference.md` to ensure all relevant technical details are captured.\nUnifyWeaver identifies test patterns through a tiered heuristic system that analyzes function names, recursion types, and arity to automate test generation.\n\n### Heuristic 1: Name-Based Detection\nThe system scans function names for keywords to assign relevant test data:\n*   **Lists:** Keywords like `length` or `list` trigger tests using `[]`, `[a]`, and `[a,b,c]`.\n*   **Math:** Functions named `factorial`, `fib`, or `power` generate numeric inputs such as `0`, `1`, and `5`.\n*   **Aggregates:** Names containing `sum` or `add` result in numeric list inputs like `[1,2,3]` or `[5,10,15]`.\n*   **Structures:** `tree` or `binary` keywords trigger structural tree tests, ranging from empty nodes to nested trees.\n*   **Parity:** `even` or `odd` prefixes generate both valid cases and failing cases (e.g., testing `3` against `is_even`) to verify logic.\n\n### Heuristic 2: Pattern-Based Inference\nTests are specialized based on the recursion strategy defined in the code's metadata:\n*   **Tail Recursive & Accumulator:** Automatically includes initial accumulator values (typically `0`).\n*   **Tree Recursive:** Ensures structural tests covering various depths and branch configurations.\n*   **Mutual Recursive:** Recognizes complementary function groups (like even/odd pairs) and tests them together.\n*   **Linear Recursive:** Matches the name against specific data patterns to determine the progression of test cases.\n\n### Heuristic 3: Arity-Based Structure\nThe number of arguments determines the physical structure of the generated test calls:\n*   **Arity 1:** Used for unary predicates requiring a single argument.\n*   **Arity 2:** Used for binary relations, typically structured as an input value and an output placeholder.\n*   **Arity 3:** Used for accumulator patterns, providing an input, an initial state (0), and an output variable.\n\nDetailed implementation details for these heuristics can be found in `education/book-02-bash-target/08_test_runner_inference.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/08_test_runner_inference.md", "topics": ["heuristics", "test-cases", "inference-rules"], "original_answer": "## Test Inference Heuristics\n\nUnifyWeaver uses multiple heuristics to generate appropriate tests.\n\n### Heuristic 1: Name-Based\n\n| Function Name Contains | Inferred Tests |\n|------------------------|----------------|\n| `length`, `list` | `[]`, `[a]`, `[a,b,c]` |\n| `factorial`, `fib`, `power` | `0`, `1`, `5` |\n| `sum`, `add` | `[]`, `[1,2,3]`, `[5,10,15]` |\n| `tree`, `binary` | `[]`, `[5,[],[]]`, nested tree |\n| `is_even`, `even` | `0`, `4`, `3` (should fail) |\n| `is_odd`, `odd` | `3`, `5`, `6` (should fail) |\n\n### Heuristic 2: Pattern-Based\n\n| Pattern Type | Inferred Tests |\n|--------------|----------------|\n| `tail_recursive` | Accumulator tests with initial 0 |\n| `linear_recursive` | Check name for specific patterns |\n| `mutual_recursive` | Complementary tests (even/odd) |\n| `tree_recursive` | Structural tests (empty, single, nested) |\n\n### Heuristic 3: Arity-Based\n\n| Arity | Typical Pattern | Test Structure |\n|-------|-----------------|----------------|\n| 1 | Unary predicates | Single argument |\n| 2 | Binary relations | Input + output (empty string) |\n| 3 | Accumulators | Input + acc(0) + output |\n\n### Example Inference\n\n```prolog\n% Signature extracted from factorial.sh\nfunction(factorial, 2, metadata(\n    pattern_type(linear_recursive),\n    description('fold-based linear recursion'),\n    file_path('factorial.sh')\n))\n```\n\n**Inferred tests:**\n- Name contains `factorial` -> numeric tests\n- Pattern is `linear_recursive` -> check name\n- Arity is 2 -> input + output\n\n**Result:**\n```bash\nfactorial \"0\" \"\"\nfactorial \"1\" \"\"\nfactorial \"5\" \"\"\n```", "answer_tailored": true}
