{"pair_id": "first-bash-program_p0", "cluster_id": "first-bash-program", "question": "How do I compile my first Prolog program to Bash?", "question_type": "medium", "answer": "Compiling your first Prolog program to Bash with UnifyWeaver is a multi-step process handled within the SWI-Prolog environment, where you generate executable shell scripts for your facts and rules.\n\n### 1. Initialize the SWI-Prolog Environment\nNavigate to the project root and launch the Prolog REPL, then load the initialization script:\n```bash\ncd UnifyWeaver\nswipl\n?- ['education/init'].\n```\n\n### 2. Load Compiler Modules and Source Logic\nLoad the necessary recursive and stream compiler modules, followed by the Prolog file you wish to compile (e.g., `family_tree`):\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\n?- use_module(unifyweaver(core/stream_compiler)).\n?- ['education/family_tree'].\n```\n\n### 3. Generate Bash Scripts for Facts and Rules\nYou must compile your facts and recursive rules into separate Bash files.\n\n**Compiling Facts:**\n```prolog\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n**Compiling Recursive Rules:**\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### 4. Execute the Compiled Code\nIn your terminal, source the generated scripts. Note that dependency scripts (like facts) must be sourced before the rules that rely on them:\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# You can now query the Bash function directly:\nancestor abraham\n```\n\n### Technical Summary\n- **Modular Compilation:** Facts and recursive rules are handled by different compiler modules (`stream_compiler` and `recursive_compiler` respectively).\n- **Execution:** The generated Bash functions support both streaming data and specific boolean relationship checks.\n- **Dependencies:** Always ensure that `parent.sh` is available to `ancestor.sh` at runtime.\n\nFor more detailed information on target compilation, see `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["tutorial", "compilation", "bash", "ancestor", "family-tree"], "original_answer": "## Your First UnifyWeaver Program\n\nHere's the complete step-by-step workflow:\n\n### Step 1: Start SWI-Prolog\n\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### Step 2: Initialize Environment\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n### Step 3: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Step 4: Load Your Program\n\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n### Step 5: Compile Facts First\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 6: Compile Recursive Rule\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 7: Run the Scripts\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Find all descendants of abraham\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n### Key Points\n\n- Facts and rules compile separately\n- Dependencies must be sourced first (`parent.sh` before `ancestor.sh`)\n- Generated functions support both streaming and lookup modes", "answer_tailored": true}
{"pair_id": "first-bash-program_p1", "cluster_id": "first-bash-program", "question": "What is the step-by-step process to use UnifyWeaver?", "question_type": "medium", "answer": "To use UnifyWeaver for compiling Prolog logic into executable scripts (such as Bash), follow this step-by-step workflow:\n\n### 1. Launch the Environment\nStart by navigating to the project root and launching SWI-Prolog:\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### 2. Initialize and Load the Compiler\nRun the initialization script and import the necessary recursive compiler modules:\n```prolog\n?- ['education/init'].\n?- use_module(unifyweaver(core/recursive_compiler)).\n```\n\n### 3. Load Your Prolog Source\nLoad the file containing the facts and rules you wish to compile:\n```prolog\n?- ['education/family_tree'].\n```\n\n### 4. Compile Facts to Bash\nUse the `stream_compiler` to transform Prolog facts into Bash functions and save the output:\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### 5. Compile Recursive Rules\nGenerate the Bash implementation for recursive predicates (like `ancestor/2`):\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### 6. Execute the Generated Code\nIn your terminal, source the scripts (ensuring facts are sourced before the rules that depend on them) and execute the generated functions:\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Example: Find all ancestors of a specific individual\nancestor abraham\n```\n\n### Summary of Key Principles\n*   **Separation of Concerns:** Facts and rules are typically compiled into separate script files.\n*   **Dependency Management:** Always source the dependency scripts (facts) before the main logic (rules).\n*   **Versatility:** The resulting Bash functions support both full-stream output and specific key lookups.\n\nFor more detailed examples and a deeper dive into target compilation, see the tutorials in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["tutorial", "compilation", "bash", "ancestor", "family-tree"], "original_answer": "## Your First UnifyWeaver Program\n\nHere's the complete step-by-step workflow:\n\n### Step 1: Start SWI-Prolog\n\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### Step 2: Initialize Environment\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n### Step 3: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Step 4: Load Your Program\n\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n### Step 5: Compile Facts First\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 6: Compile Recursive Rule\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 7: Run the Scripts\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Find all descendants of abraham\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n### Key Points\n\n- Facts and rules compile separately\n- Dependencies must be sourced first (`parent.sh` before `ancestor.sh`)\n- Generated functions support both streaming and lookup modes", "answer_tailored": true}
{"pair_id": "first-bash-program_p2", "cluster_id": "first-bash-program", "question": "How do I compile ancestor/2 to Bash?", "question_type": "medium", "answer": "To compile the recursive `ancestor/2` predicate into a Bash script, you follow a sequence of loading the necessary UnifyWeaver modules, loading your Prolog definitions, and then invoking the recursive compiler.\n\n### Implementation Steps\n\n1.  **Initialize SWI-Prolog**: From the project root, start `swipl` and initialize the environment:\n    ```prolog\n    ?- ['education/init'].\n    ```\n\n2.  **Load the Compiler and Source**: Load the recursive compiler module and your program file (e.g., `family_tree.pl`):\n    ```prolog\n    ?- use_module(unifyweaver(core/recursive_compiler)).\n    ?- ['education/family_tree'].\n    ```\n\n3.  **Generate Dependency Scripts**: Compile the base facts (like `parent/2`) that `ancestor/2` relies on using the stream compiler:\n    ```prolog\n    ?- use_module(unifyweaver(core/stream_compiler)).\n    ?- stream_compiler:compile_facts(parent, 2, [], Code),\n       open('education/output/parent.sh', write, S), write(S, Code), close(S).\n    ```\n\n4.  **Compile the Recursive Logic**: Use the `compile_recursive/3` predicate to generate the Bash code for the `ancestor/2` rule:\n    ```prolog\n    ?- compile_recursive(ancestor/2, [], BashCode),\n       open('education/output/ancestor.sh', write, S), write(S, BashCode), close(S).\n    ```\n\n5.  **Run the Resulting Code**: In your shell, source the files in the correct dependency order and execute the generated function:\n    ```bash\n    source education/output/parent.sh\n    source education/output/ancestor.sh\n\n    # Example: find all descendants of 'abraham'\n    ancestor abraham\n    ```\n\n### Key Considerations\n- **Dependency Sourcing**: The base fact scripts (e.g., `parent.sh`) must be sourced before the recursive script (`ancestor.sh`) to ensure the functions are correctly linked in the Bash environment.\n- **Modularity**: UnifyWeaver compiles facts and recursive rules as separate units to maintain performance and scalability in the target environment.\n\nFor a more detailed walkthrough of this process, refer to `education/book-02-bash-target/01_your_first_program.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["tutorial", "compilation", "bash", "ancestor", "family-tree"], "original_answer": "## Your First UnifyWeaver Program\n\nHere's the complete step-by-step workflow:\n\n### Step 1: Start SWI-Prolog\n\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### Step 2: Initialize Environment\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n### Step 3: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Step 4: Load Your Program\n\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n### Step 5: Compile Facts First\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 6: Compile Recursive Rule\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 7: Run the Scripts\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Find all descendants of abraham\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n### Key Points\n\n- Facts and rules compile separately\n- Dependencies must be sourced first (`parent.sh` before `ancestor.sh`)\n- Generated functions support both streaming and lookup modes", "answer_tailored": true}
{"pair_id": "first-bash-program_p3", "cluster_id": "first-bash-program", "question": "How do I run generated Bash scripts?", "question_type": "medium", "answer": "To run Bash scripts generated by UnifyWeaver, you must `source` the output files into your shell environment. This imports the compiled Prolog logic as standard Bash functions that can be invoked directly from the command line.\n\n### Execution Workflow\n\n1.  **Source the Scripts**: You must source the files in order of dependency, typically sourcing facts before the recursive rules that rely on them.\n    ```bash\n    source education/output/parent.sh\n    source education/output/ancestor.sh\n    ```\n\n2.  **Invoke the Functions**: Once sourced, you can call the generated functions like any other Bash command.\n    ```bash\n    # Retrieve all results (Streaming Mode)\n    ancestor abraham\n\n    # Verify a specific relationship (Lookup Mode)\n    ancestor isaac judah && echo \"Relationship confirmed\"\n    ```\n\n### Compilation Prerequisites\n\nBefore running the scripts, they are generated within the SWI-Prolog environment using the UnifyWeaver compilers:\n\n*   **Facts**: Compiled via `stream_compiler:compile_facts/4`.\n*   **Recursive Rules**: Compiled via `compile_recursive/3`.\n*   **File Output**: The resulting `BashCode` string is written to a `.sh` file using standard Prolog I/O predicates.\n\n### Key Technical Notes\n\n*   **Execution Modes**: Generated functions are polymorphic; providing one argument usually streams all matching pairs, while providing two arguments performs a lookup/verification.\n*   **Environment**: Ensure you are in a compatible shell (Bash) when sourcing the generated output.\n\nFor a complete walkthrough of the initialization and compilation process, refer to `education/book-02-bash-target/01_your_first_program.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["tutorial", "compilation", "bash", "ancestor", "family-tree"], "original_answer": "## Your First UnifyWeaver Program\n\nHere's the complete step-by-step workflow:\n\n### Step 1: Start SWI-Prolog\n\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### Step 2: Initialize Environment\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n### Step 3: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Step 4: Load Your Program\n\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n### Step 5: Compile Facts First\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 6: Compile Recursive Rule\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 7: Run the Scripts\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Find all descendants of abraham\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n### Key Points\n\n- Facts and rules compile separately\n- Dependencies must be sourced first (`parent.sh` before `ancestor.sh`)\n- Generated functions support both streaming and lookup modes", "answer_tailored": true}
{"pair_id": "compile-workflow_p0", "cluster_id": "compile-workflow", "question": "What's the difference between compile_recursive and compile_stream?", "question_type": "medium", "answer": "The primary difference between `compile_recursive/3` and `compile_stream/3` is whether the Prolog predicate being targeted contains recursion. \n\n### `compile_stream/3` (Non-Recursive)\nThis entry point is used for non-recursive predicates, such as simple joins, filters, or data transformations. For example, a `grandparent/2` predicate that joins two `parent/2` facts would use this compiler. It generates an efficient stream-based join pipeline in the target language.\n\n### `compile_recursive/3` (Recursive)\nThis is required for recursive predicates, such as transitive closures or logic utilizing accumulators. An `ancestor/2` predicate is a classic example. The compiler generates code that implements a Breadth-First Search (BFS) strategy equipped with visited tracking to prevent infinite loops and manage state across recursive calls.\n\n### Entry Point Summary\n| Predicate | Application | Logic Type |\n|-----------|-------------|------------|\n| `compile_stream/3` | Joins, Filters, Facts | Non-recursive |\n| `compile_recursive/3` | Transitive closures, Accumulators | Recursive |\n\nWhile you can manually select these compilers, it is generally recommended to use `compile_predicate/3`. This high-level entry point automatically analyzes your predicate's structure and routes it to the appropriate compiler (e.g., using the recursive compiler for `ancestor/2` and the stream compiler for `grandparent/2`).\n\nFor more details and code examples, see `education/book-02-bash-target/01_your_first_program.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["compile_recursive", "compile_stream", "compile_predicate", "workflow"], "original_answer": "## UnifyWeaver Compilation Predicates\n\n### Three Main Entry Points\n\n| Predicate | Purpose | When to Use |\n|-----------|---------|-------------|\n| `compile_predicate/3` | Auto-selects compiler | Recommended default |\n| `compile_recursive/3` | Recursive predicates | Transitive closures, accumulators |\n| `compile_stream/3` | Non-recursive predicates | Simple joins, filters |\n\n### How Auto-Selection Works\n\n```prolog\n% compile_predicate analyzes your predicate and routes accordingly\n?- compile_predicate(grandparent/2, [], Code).  % Uses stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Uses recursive_compiler\n```\n\n### Manual Selection\n\n```prolog\n% For non-recursive rules (joins, filters)\n?- compile_stream(grandparent/2, [], BashCode).\n\n% For recursive rules (transitive closures)\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% For facts only\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Example: grandparent/2 (Non-Recursive)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nCompiles to a stream join pipeline.\n\n### Example: ancestor/2 (Recursive)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nCompiles to BFS with visited tracking.", "answer_tailored": true}
{"pair_id": "compile-workflow_p1", "cluster_id": "compile-workflow", "question": "When should I use compile_predicate vs compile_recursive?", "question_type": "medium", "answer": "You should generally use **`compile_predicate/3`** as your primary entry point for compilation, as it intelligently analyzes your Prolog rules to determine the most efficient execution model. **`compile_recursive/3`** is used specifically when you need to manually force the recursive compiler for predicates involving transitive closures or accumulators.\n\n### Comparison of Compilation Entry Points\n\n| Predicate | Recommendation | Best Used For |\n|-----------|----------------|---------------|\n| `compile_predicate/3` | **Default Choice** | General use; automatically routes to stream or recursive compilers based on analysis. |\n| `compile_recursive/3` | **Explicit Recursive** | Transitive closures (e.g., `ancestor/2`), tree traversals, and predicates with accumulators. |\n| `compile_stream/3` | **Explicit Stream** | Non-recursive relational logic, simple joins, and filters. |\n\n### Automated Routing via `compile_predicate/3`\n\nInstead of manually choosing, `compile_predicate/3` performs static analysis of your code:\n\n```prolog\n% Routes to stream_compiler because grandparent/2 is non-recursive\n?- compile_predicate(grandparent/2, [], Code).\n\n% Routes to recursive_compiler because ancestor/2 is recursive\n?- compile_predicate(ancestor/2, [], Code).\n```\n\n### When to Select Manually\n\n*   **Recursive Rules:** Use `compile_recursive/3` for predicates like `ancestor/2`. This generates a BFS-based implementation with visited tracking to handle cycles and deep recursion safely.\n    ```prolog\n    ancestor(X, Y) :- parent(X, Y).\n    ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n    ```\n\n*   **Non-Recursive Joins:** Use `compile_stream/3` for rules that simply join data sources without calling themselves, resulting in a high-performance stream pipeline.\n    ```prolog\n    grandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n    ```\n\nFor detailed examples of building your first compiled programs, refer to the guides in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["compile_recursive", "compile_stream", "compile_predicate", "workflow"], "original_answer": "## UnifyWeaver Compilation Predicates\n\n### Three Main Entry Points\n\n| Predicate | Purpose | When to Use |\n|-----------|---------|-------------|\n| `compile_predicate/3` | Auto-selects compiler | Recommended default |\n| `compile_recursive/3` | Recursive predicates | Transitive closures, accumulators |\n| `compile_stream/3` | Non-recursive predicates | Simple joins, filters |\n\n### How Auto-Selection Works\n\n```prolog\n% compile_predicate analyzes your predicate and routes accordingly\n?- compile_predicate(grandparent/2, [], Code).  % Uses stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Uses recursive_compiler\n```\n\n### Manual Selection\n\n```prolog\n% For non-recursive rules (joins, filters)\n?- compile_stream(grandparent/2, [], BashCode).\n\n% For recursive rules (transitive closures)\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% For facts only\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Example: grandparent/2 (Non-Recursive)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nCompiles to a stream join pipeline.\n\n### Example: ancestor/2 (Recursive)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nCompiles to BFS with visited tracking.", "answer_tailored": true}
{"pair_id": "compile-workflow_p2", "cluster_id": "compile-workflow", "question": "How does UnifyWeaver decide which compiler to use?", "question_type": "medium", "answer": "UnifyWeaver decides which compiler to use by analyzing the structure of the Prolog predicate\u2014specifically checking for recursion\u2014via the `compile_predicate/3` entry point. This predicate acts as an intelligent router that inspects your code to determine the most efficient execution strategy for the target language.\n\n### Automatic Selection Logic\nWhen using the recommended `compile_predicate/3` default, the system follows these rules:\n*   **Recursive Predicates:** If the predicate involves recursion (such as transitive closures like `ancestor/2`), it selects the **recursive compiler**. This generates logic using Breadth-First Search (BFS) and visited-node tracking to ensure termination and correctness.\n*   **Non-Recursive Predicates:** For simple data transformations, joins, or filters (such as `grandparent/2`), it selects the **stream compiler**. This creates a high-performance pipeline optimized for streaming data.\n\n### Available Compilation Predicates\n| Predicate | Selection Method | Primary Use Case |\n|-----------|------------------|------------------|\n| `compile_predicate/3` | **Automatic** | Recommended default for all standard predicates. |\n| `compile_recursive/3` | **Manual** | Explicitly handles transitive closures and accumulators. |\n| `compile_stream/3` | **Manual** | Explicitly handles non-recursive joins and filters. |\n| `stream_compiler:compile_facts/4` | **Manual** | Specifically for converting Prolog facts into target code. |\n\nFor a step-by-step guide on how these selections affect your generated code, see the details in `education/book-02-bash-target/01_your_first_program.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["compile_recursive", "compile_stream", "compile_predicate", "workflow"], "original_answer": "## UnifyWeaver Compilation Predicates\n\n### Three Main Entry Points\n\n| Predicate | Purpose | When to Use |\n|-----------|---------|-------------|\n| `compile_predicate/3` | Auto-selects compiler | Recommended default |\n| `compile_recursive/3` | Recursive predicates | Transitive closures, accumulators |\n| `compile_stream/3` | Non-recursive predicates | Simple joins, filters |\n\n### How Auto-Selection Works\n\n```prolog\n% compile_predicate analyzes your predicate and routes accordingly\n?- compile_predicate(grandparent/2, [], Code).  % Uses stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Uses recursive_compiler\n```\n\n### Manual Selection\n\n```prolog\n% For non-recursive rules (joins, filters)\n?- compile_stream(grandparent/2, [], BashCode).\n\n% For recursive rules (transitive closures)\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% For facts only\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Example: grandparent/2 (Non-Recursive)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nCompiles to a stream join pipeline.\n\n### Example: ancestor/2 (Recursive)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nCompiles to BFS with visited tracking.", "answer_tailored": true}
{"pair_id": "compile-workflow_p3", "cluster_id": "compile-workflow", "question": "What are the main compilation predicates?", "question_type": "medium", "answer": "UnifyWeaver provides three primary entry points for transforming Prolog logic into target code, depending on the nature of the predicate being compiled:\n\n1.  **`compile_predicate/3`**: The recommended default for most tasks. It automatically analyzes the predicate to determine if it is recursive or non-recursive, then routes it to the appropriate specialized compiler.\n2.  **`compile_stream/3`**: Specifically designed for non-recursive predicates. It is used for rules involving simple joins and filters, such as a `grandparent/2` rule, compiling them into stream-based pipelines.\n3.  **`compile_recursive/3`**: Dedicated to recursive predicates (like `ancestor/2`). It handles transitive closures and accumulators by generating code that implements Breadth-First Search (BFS) with visited-node tracking to ensure termination.\n\nFor simple fact extraction without rules, you can also use `stream_compiler:compile_facts/4`.\n\nFor a deeper dive into how these predicates operate within the Bash target, refer to the documentation and examples in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/01_your_first_program.md", "topics": ["compile_recursive", "compile_stream", "compile_predicate", "workflow"], "original_answer": "## UnifyWeaver Compilation Predicates\n\n### Three Main Entry Points\n\n| Predicate | Purpose | When to Use |\n|-----------|---------|-------------|\n| `compile_predicate/3` | Auto-selects compiler | Recommended default |\n| `compile_recursive/3` | Recursive predicates | Transitive closures, accumulators |\n| `compile_stream/3` | Non-recursive predicates | Simple joins, filters |\n\n### How Auto-Selection Works\n\n```prolog\n% compile_predicate analyzes your predicate and routes accordingly\n?- compile_predicate(grandparent/2, [], Code).  % Uses stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Uses recursive_compiler\n```\n\n### Manual Selection\n\n```prolog\n% For non-recursive rules (joins, filters)\n?- compile_stream(grandparent/2, [], BashCode).\n\n% For recursive rules (transitive closures)\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% For facts only\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Example: grandparent/2 (Non-Recursive)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nCompiles to a stream join pipeline.\n\n### Example: ancestor/2 (Recursive)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nCompiles to BFS with visited tracking.", "answer_tailored": true}
