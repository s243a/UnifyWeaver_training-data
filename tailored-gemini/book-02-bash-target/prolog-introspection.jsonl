{"pair_id": "prolog-introspection_p0", "cluster_id": "prolog-introspection", "question": "How does UnifyWeaver analyze Prolog code?", "question_type": "medium", "answer": "UnifyWeaver analyzes Prolog code using **introspection**, which allows the compiler to programmatically examine and decompose Prolog structures. This process is essential for mapping dependencies, building call graphs, and identifying recursion patterns.\n\nThe analysis relies on two primary built-in predicates:\n\n*   **`clause(Head, Body)`**: This is used to retrieve the definition of a predicate. It splits the clause into its `Head` (the signature) and its `Body` (the logic). For facts, the body returns as `true`.\n*   **`functor(Term, Name, Arity)`**: This allows UnifyWeaver to extract the name and number of arguments from a term or to construct generic head templates for further inspection.\n\nBy combining these tools, UnifyWeaver can traverse the body of a clause to detect calls to other predicates. This enables the system to determine if a predicate is self-recursive or part of a larger mutual recursion chain, which is critical for choosing the correct compilation strategy in targets like Bash.\n\nDetailed implementation strategies and examples for code analysis can be found in **education/book-02-bash-target/**.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["introspection", "clause/2", "functor/3", "metaprogramming"], "original_answer": "## Prolog Introspection\n\n**Introspection** is the ability of Prolog programs to examine and analyze other Prolog code. UnifyWeaver uses this to detect recursion patterns automatically.\n\n### The clause/2 Predicate\n\nThe foundation of code analysis:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - the clause head (before `:-`)\n- `Body` - the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### The functor/3 Predicate\n\nExtract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Analyzing Predicates\n\n```prolog\n% Find what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Check if self-recursive\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver uses these techniques to build call graphs and detect recursion patterns.", "answer_tailored": true}
{"pair_id": "prolog-introspection_p1", "cluster_id": "prolog-introspection", "question": "What is Prolog introspection?", "question_type": "medium", "answer": "Prolog introspection is the meta-programming capability that allows Prolog programs to examine, analyze, and manipulate other Prolog code as data. UnifyWeaver leverages this functionality to perform static analysis of source predicates, specifically for detecting recursion patterns and generating optimized target code.\n\nThe primary tools for introspection include:\n\n*   **clause(Head, Body)**: This predicate retrieves the definition of a clause. `Head` represents the predicate signature, and `Body` contains the goals (returning `true` for facts). It is fundamental for traversing the logic of a program programmatically.\n*   **functor(Term, Name, Arity)**: This is used to extract the name and number of arguments from a term or to construct a new term template dynamically.\n\nBy utilizing these predicates, UnifyWeaver can analyze a predicate's structure to build call graphs and identify recursion. For instance, the compiler can programmatically determine if a predicate is self-recursive by inspecting the goals within its retrieved body.\n\nFor more details on how introspection facilitates target-language compilation, refer to the documentation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["introspection", "clause/2", "functor/3", "metaprogramming"], "original_answer": "## Prolog Introspection\n\n**Introspection** is the ability of Prolog programs to examine and analyze other Prolog code. UnifyWeaver uses this to detect recursion patterns automatically.\n\n### The clause/2 Predicate\n\nThe foundation of code analysis:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - the clause head (before `:-`)\n- `Body` - the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### The functor/3 Predicate\n\nExtract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Analyzing Predicates\n\n```prolog\n% Find what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Check if self-recursive\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver uses these techniques to build call graphs and detect recursion patterns.", "answer_tailored": true}
{"pair_id": "prolog-introspection_p2", "cluster_id": "prolog-introspection", "question": "How do I inspect predicate clauses in Prolog?", "question_type": "medium", "answer": "To inspect predicate clauses in Prolog, you primarily use the built-in **`clause/2`** predicate. This allows a program to examine its own definitions, a capability known as introspection that UnifyWeaver leverages to automatically detect recursion patterns and build call graphs.\n\n### The `clause/2` Predicate\nThe foundation of Prolog code analysis is the `clause(Head, Body)` predicate:\n- **`Head`**: Represents the predicate head (the part before the `:-`).\n- **`Body`**: Represents the logic or goals of the clause. For simple facts, the body returns as `true`.\n\n**Example:**\n```prolog\n% Defined predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Querying the clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### Supporting Introspection with `functor/3`\nWhen you need to analyze predicates dynamically, `functor(Term, Name, Arity)` is used to decompose terms or construct heads for `clause/2`:\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Application in UnifyWeaver\nUnifyWeaver combines these predicates to identify recursion and map dependencies. For instance, it can find all predicates called within a body to determine if a predicate like `ancestor/2` is self-recursive. \n\nFor more details on how introspection facilitates target-specific compilation, see the documentation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["introspection", "clause/2", "functor/3", "metaprogramming"], "original_answer": "## Prolog Introspection\n\n**Introspection** is the ability of Prolog programs to examine and analyze other Prolog code. UnifyWeaver uses this to detect recursion patterns automatically.\n\n### The clause/2 Predicate\n\nThe foundation of code analysis:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - the clause head (before `:-`)\n- `Body` - the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### The functor/3 Predicate\n\nExtract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Analyzing Predicates\n\n```prolog\n% Find what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Check if self-recursive\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver uses these techniques to build call graphs and detect recursion patterns.", "answer_tailored": true}
{"pair_id": "prolog-introspection_p3", "cluster_id": "prolog-introspection", "question": "What is clause/2 used for?", "question_type": "medium", "answer": "`clause/2` is a fundamental Prolog introspection predicate used to examine and analyze the program's own code structure. It allows you to programmatically retrieve the definition of any accessible predicate by matching its head and body.\n\nThe predicate is defined as `clause(Head, Body)`:\n*   **Head**: The clause head (the part before the `:-` operator).\n*   **Body**: The clause body (the part after the `:-` operator). If the predicate is a simple fact, the body is returned as `true`.\n\nIn the UnifyWeaver compiler, `clause/2` is essential for static analysis. It is used to:\n*   **Detect Recursion Patterns**: By inspecting the body of a predicate, the compiler can automatically identify self-recursive or mutually recursive calls.\n*   **Construct Call Graphs**: It helps map out dependencies between different predicates to ensure correct compilation into target languages like Bash, Python, or Go.\n*   **Code Analysis**: It enables tools to find where specific predicates are called or to verify logic constraints.\n\n**Example Query:**\n```prolog\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\nFor a deeper look at how UnifyWeaver utilizes these introspection techniques for recursion detection, refer to `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["introspection", "clause/2", "functor/3", "metaprogramming"], "original_answer": "## Prolog Introspection\n\n**Introspection** is the ability of Prolog programs to examine and analyze other Prolog code. UnifyWeaver uses this to detect recursion patterns automatically.\n\n### The clause/2 Predicate\n\nThe foundation of code analysis:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - the clause head (before `:-`)\n- `Body` - the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### The functor/3 Predicate\n\nExtract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Analyzing Predicates\n\n```prolog\n% Find what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Check if self-recursive\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver uses these techniques to build call graphs and detect recursion patterns.", "answer_tailored": true}
{"pair_id": "call-graph-construction_p0", "cluster_id": "call-graph-construction", "question": "What is a call graph in UnifyWeaver?", "question_type": "medium", "answer": "In UnifyWeaver, a **call graph** is a directed graph that maps the dependencies between predicates. It provides a structural visualization of the program's logic, where **nodes** represent individual predicates (identified by `Predicate/Arity`) and **edges** represent call relationships (an edge `A -> B` signifies that predicate A invokes predicate B).\n\n### What Call Graphs Reveal\nBy constructing these graphs, UnifyWeaver can analyze several critical aspects of the code:\n- **Recursion Types**: Identifies both self-recursion and complex mutual recursion cycles.\n- **Dependency Tracking**: Determines the correct compilation order based on predicate requirements.\n- **Reachability Analysis**: Ensures all necessary predicates are included in the target output.\n\n### Technical Implementation\nThe system generates these graphs by recursively walking through clause bodies, extracting calls from conjunctions `(A, B)`, disjunctions `(A; B)`, conditionals `(A -> B)`, and negations `\\+ A`.\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define recursive predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Build the graph for analysis\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\nFor further details on how introspection is used to build these structures, see the documentation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["call-graph", "dependency-analysis", "code-analysis"], "original_answer": "## Call Graph Construction\n\nA **call graph** is a directed graph showing predicate dependencies:\n- **Nodes**: Predicates (`Pred/Arity`)\n- **Edges**: Calls (`A -> B` means A calls B)\n\n### What Call Graphs Reveal\n\n- **Self-recursion**: Predicate calls itself\n- **Mutual recursion**: Cycle between predicates\n- **Dependencies**: Compilation order\n- **Reachability**: All predicates used\n\n### Building a Call Graph\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Get dependencies\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Build full graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\n### Extracting Calls from Bodies\n\nThe system handles:\n- Conjunctions: `(A, B)`\n- Disjunctions: `(A; B)`\n- Conditionals: `(A -> B)`\n- Negations: `\\+ A`\n\n```prolog\n% Recursively walks clause body\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```", "answer_tailored": true}
{"pair_id": "call-graph-construction_p1", "cluster_id": "call-graph-construction", "question": "How does UnifyWeaver build dependency graphs?", "question_type": "medium", "answer": "UnifyWeaver constructs dependency graphs, specifically directed **call graphs**, by analyzing the relationships and interactions between predicates. This process identifies self-recursion, mutual recursion, and the required compilation order by mapping how predicates call one another.\n\nIn these graphs:\n- **Nodes** represent predicates, identified by their `Name/Arity`.\n- **Edges** represent calls, where an edge `A -> B` indicates that predicate A depends on predicate B.\n\nThe system builds these graphs through several stages:\n1. **Dependency Analysis**: Using the `unifyweaver(core/advanced/call_graph)` module, the system uses `get_dependencies/2` to find all predicates linked to a starting goal.\n2. **Recursive Body Traversal**: The system employs `extract_calls/2` to recursively walk through clause bodies. It is designed to handle various Prolog constructs, including conjunctions (`,`), disjunctions (`;`), conditionals (`->`), and negations (`\\+`).\n3. **Graph Assembly**: Finally, `build_call_graph/2` assembles these relationships into a complete directed graph that confirms reachability and informs the compiler about the structure of the program.\n\nThis introspection ensures that all necessary code is included during compilation and that recursive structures are handled correctly in the target language. Detailed information on this process can be found in **education/book-02-bash-target/07_prolog_introspection.md**.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["call-graph", "dependency-analysis", "code-analysis"], "original_answer": "## Call Graph Construction\n\nA **call graph** is a directed graph showing predicate dependencies:\n- **Nodes**: Predicates (`Pred/Arity`)\n- **Edges**: Calls (`A -> B` means A calls B)\n\n### What Call Graphs Reveal\n\n- **Self-recursion**: Predicate calls itself\n- **Mutual recursion**: Cycle between predicates\n- **Dependencies**: Compilation order\n- **Reachability**: All predicates used\n\n### Building a Call Graph\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Get dependencies\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Build full graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\n### Extracting Calls from Bodies\n\nThe system handles:\n- Conjunctions: `(A, B)`\n- Disjunctions: `(A; B)`\n- Conditionals: `(A -> B)`\n- Negations: `\\+ A`\n\n```prolog\n% Recursively walks clause body\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```", "answer_tailored": true}
{"pair_id": "call-graph-construction_p2", "cluster_id": "call-graph-construction", "question": "How are predicate dependencies detected?", "question_type": "medium", "answer": "Predicate dependencies are detected by constructing a directed **call graph** where predicates (defined as `Pred/Arity`) serve as nodes and calls between them serve as edges. This analysis allows the compiler to determine the correct compilation order, verify reachability, and identify both self-recursive and mutually recursive patterns.\n\n### How Dependencies are Extracted\nThe system identifies dependencies by recursively \"walking\" through the bodies of Prolog clauses using introspection. The extraction logic specifically handles standard control structures to ensure no calls are missed:\n- **Conjunctions and Disjunctions**: `(A, B)` or `(A; B)`\n- **Conditionals**: `(A -> B)`\n- **Negations**: `\\+ A`\n\n### Analysis Tools\nUsing the `unifyweaver(core/advanced/call_graph)` module, the compiler programmatically retrieves these relationships:\n\n```prolog\n% Retrieve dependencies for a specific predicate\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Generate the directed edges of the call graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\nThis introspection logic ensures that the compiler maps the full relationship tree before generating target code. For a more detailed breakdown of how the call graph is constructed, see **education/book-02-bash-target/07_prolog_introspection.md**.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["call-graph", "dependency-analysis", "code-analysis"], "original_answer": "## Call Graph Construction\n\nA **call graph** is a directed graph showing predicate dependencies:\n- **Nodes**: Predicates (`Pred/Arity`)\n- **Edges**: Calls (`A -> B` means A calls B)\n\n### What Call Graphs Reveal\n\n- **Self-recursion**: Predicate calls itself\n- **Mutual recursion**: Cycle between predicates\n- **Dependencies**: Compilation order\n- **Reachability**: All predicates used\n\n### Building a Call Graph\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Get dependencies\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Build full graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\n### Extracting Calls from Bodies\n\nThe system handles:\n- Conjunctions: `(A, B)`\n- Disjunctions: `(A; B)`\n- Conditionals: `(A -> B)`\n- Negations: `\\+ A`\n\n```prolog\n% Recursively walks clause body\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```", "answer_tailored": true}
{"pair_id": "call-graph-construction_p3", "cluster_id": "call-graph-construction", "question": "What does call graph analysis reveal?", "question_type": "medium", "answer": "Call graph analysis in UnifyWeaver reveals the structural dependencies and execution flow of Prolog programs by mapping predicates as nodes and their calls as directed edges. By analyzing these graphs, you can identify:\n\n- **Recursion Types**: It distinguishes between self-recursion (a predicate calling itself) and mutual recursion (circular dependencies between multiple predicates).\n- **Compilation Order**: It establishes the necessary sequence for processing predicates based on their dependency chains.\n- **Reachability**: It verifies which predicates are actually used and accessible within the codebase.\n- **Structural Composition**: It uncovers dependencies nested within complex Prolog structures like conjunctions `(A, B)`, disjunctions `(A; B)`, conditionals `(A -> B)`, and negations `(\\+ A)`.\n\nThe system utilizes modules like `unifyweaver(core/advanced/call_graph)` to build these graphs, employing predicates such as `get_dependencies/2` and `build_call_graph/2`. For more details on how the compiler introspects clause bodies to extract these calls, refer to the documentation in `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["call-graph", "dependency-analysis", "code-analysis"], "original_answer": "## Call Graph Construction\n\nA **call graph** is a directed graph showing predicate dependencies:\n- **Nodes**: Predicates (`Pred/Arity`)\n- **Edges**: Calls (`A -> B` means A calls B)\n\n### What Call Graphs Reveal\n\n- **Self-recursion**: Predicate calls itself\n- **Mutual recursion**: Cycle between predicates\n- **Dependencies**: Compilation order\n- **Reachability**: All predicates used\n\n### Building a Call Graph\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Get dependencies\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Build full graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\n### Extracting Calls from Bodies\n\nThe system handles:\n- Conjunctions: `(A, B)`\n- Disjunctions: `(A; B)`\n- Conditionals: `(A -> B)`\n- Negations: `\\+ A`\n\n```prolog\n% Recursively walks clause body\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```", "answer_tailored": true}
{"pair_id": "scc-detection_p0", "cluster_id": "scc-detection", "question": "What is SCC detection in UnifyWeaver?", "question_type": "medium", "answer": "SCC detection in UnifyWeaver is the process of identifying **Strongly Connected Components** within a Prolog program's call graph to manage recursion\u2014specifically mutual recursion. An SCC represents a maximal set of predicates where every predicate is reachable from every other predicate in the set.\n\nBy detecting these components, UnifyWeaver can distinguish between simple self-recursion and complex mutual recursion (e.g., `is_even/1` calling `is_odd/1` and vice versa), ensuring the compiler generates the appropriate execution logic for the target language.\n\n### Technical Implementation\nThe system utilizes **Tarjan\u2019s Algorithm**, which operates in linear time $O(V+E)$, to analyze the call graph:\n1.  **DFS Traversal:** The algorithm performs a depth-first search across predicates.\n2.  **Metadata Tracking:** It tracks each node's `index` (order of discovery) and `lowlink` (the lowest index reachable from that node).\n3.  **Root Identification:** When a node's `index` equals its `lowlink`, that node is identified as the root of an SCC.\n\n### Analysis and Usage\nYou can utilize the `scc_detection` module to inspect your code's structure:\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Construct the call graph and extract SCCs\n?- build_call_graph([is_even/1, is_odd/1], Graph), find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].\n\n% Check for mutual recursion (non-trivial SCC)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse. % Returns false because it contains mutual recursion\n```\n\nA \"trivial\" SCC consists of a single predicate that is not self-recursive, whereas a non-trivial SCC indicates either self-recursion or a cluster of mutually recursive predicates.\n\nFor more details on how UnifyWeaver handles Prolog introspection and call graph analysis, refer to `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithms"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn **SCC** is a maximal set of nodes where every node is reachable from every other.\n\n### Why SCCs Matter\n\nMutual recursion forms cycles:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even/1 -> is_odd/1\nis_odd/1  -> is_even/1\n```\n\nBoth predicates are in the **same SCC** = mutual recursion!\n\n### Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm (O(V+E)):\n\n1. Perform depth-first search\n2. Track `index` (visit order) and `lowlink` (smallest reachable index)\n3. When `index == lowlink`, node is SCC root\n\n### Usage\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Build call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n\n% Find SCCs\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % One SCC!\n\n% Check if non-trivial (mutual recursion)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % More than one predicate = mutual recursion\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Single predicate = self-recursion only\n```", "answer_tailored": true}
{"pair_id": "scc-detection_p1", "cluster_id": "scc-detection", "question": "How does UnifyWeaver detect mutual recursion?", "question_type": "medium", "answer": "UnifyWeaver detects mutual recursion by identifying **Strongly Connected Components (SCCs)** within the predicate call graph. Mutual recursion is characterized by cycles where every predicate in a set is reachable from every other predicate in that same set.\n\nThe system employs **Tarjan\u2019s algorithm** (O(V+E)) to find these components through the following process:\n1. It performs a depth-first search on the call graph.\n2. It tracks an `index` (the visitation order) and a `lowlink` (the smallest index reachable from the current node) for each predicate.\n3. When a node's `index` equals its `lowlink`, it marks the root of an SCC.\n\nAn SCC containing multiple predicates\u2014such as a cycle between `is_even/1` and `is_odd/1`\u2014is considered a non-trivial component, signaling mutual recursion. In contrast, a single predicate that only calls itself forms a trivial SCC.\n\nTo utilize this detection in your own logic, use the `unifyweaver(core/advanced/scc_detection)` module:\n- `build_call_graph/2`: Constructs the relationship map for a list of predicates.\n- `find_sccs/2`: Identifies the distinct components.\n- `is_trivial_scc/1`: Returns `false` if the component represents mutual recursion.\n\nFor a deeper dive into call graph analysis, see `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithms"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn **SCC** is a maximal set of nodes where every node is reachable from every other.\n\n### Why SCCs Matter\n\nMutual recursion forms cycles:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even/1 -> is_odd/1\nis_odd/1  -> is_even/1\n```\n\nBoth predicates are in the **same SCC** = mutual recursion!\n\n### Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm (O(V+E)):\n\n1. Perform depth-first search\n2. Track `index` (visit order) and `lowlink` (smallest reachable index)\n3. When `index == lowlink`, node is SCC root\n\n### Usage\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Build call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n\n% Find SCCs\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % One SCC!\n\n% Check if non-trivial (mutual recursion)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % More than one predicate = mutual recursion\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Single predicate = self-recursion only\n```", "answer_tailored": true}
{"pair_id": "scc-detection_p2", "cluster_id": "scc-detection", "question": "What is Tarjan's algorithm?", "question_type": "medium", "answer": "Tarjan's algorithm is an efficient linear-time (O(V+E)) graph algorithm used to identify **Strongly Connected Components (SCCs)**\u2014sets of nodes where every node is reachable from every other node. In UnifyWeaver, this algorithm is specifically used to detect mutual recursion by analyzing the call graph of Prolog predicates.\n\n### How Tarjan's Algorithm Works\nThe algorithm performs a single depth-first search (DFS) and tracks two specific values for each node:\n1.  **Index**: The order in which the node was first visited.\n2.  **Lowlink**: The smallest index reachable from that node, including itself and its descendants in the DFS tree.\nA node is identified as the root of an SCC whenever its `index` matches its `lowlink`.\n\n### Usage in UnifyWeaver\nUnifyWeaver uses the `scc_detection` module to determine if predicates are mutually recursive, which is critical for generating correct code in target languages like Bash or Python.\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Identify SCCs in a call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph), find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].\n```\n\n### SCC Types\n- **Trivial SCC**: Contains a single predicate. This indicates either no recursion or simple self-recursion.\n- **Non-trivial SCC**: Contains multiple predicates, confirming the presence of mutual recursion (e.g., `is_even/1` calling `is_odd/1` and vice-versa).\n\nFor a deeper dive into how UnifyWeaver employs graph theory for code generation, see the documentation in `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithms"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn **SCC** is a maximal set of nodes where every node is reachable from every other.\n\n### Why SCCs Matter\n\nMutual recursion forms cycles:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even/1 -> is_odd/1\nis_odd/1  -> is_even/1\n```\n\nBoth predicates are in the **same SCC** = mutual recursion!\n\n### Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm (O(V+E)):\n\n1. Perform depth-first search\n2. Track `index` (visit order) and `lowlink` (smallest reachable index)\n3. When `index == lowlink`, node is SCC root\n\n### Usage\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Build call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n\n% Find SCCs\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % One SCC!\n\n% Check if non-trivial (mutual recursion)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % More than one predicate = mutual recursion\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Single predicate = self-recursion only\n```", "answer_tailored": true}
{"pair_id": "scc-detection_p3", "cluster_id": "scc-detection", "question": "How are strongly connected components found?", "question_type": "medium", "answer": "Strongly connected components (SCCs) are found using Tarjan's algorithm, an $O(V+E)$ approach that identifies maximal sets of mutually reachable nodes within a call graph. In UnifyWeaver, finding SCCs is the primary method for detecting mutual recursion.\n\nThe algorithm identifies these components by:\n1. Performing a depth-first search (DFS) across the call graph.\n2. Tracking an `index` (the visit order) and a `lowlink` (the smallest reachable index).\n3. Designating a node as an SCC root whenever its `index` matches its `lowlink`.\n\n### Usage Example\nYou can detect mutual recursion by utilizing the `scc_detection` module:\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Construct the call graph and find components\n?- build_call_graph([is_even/1, is_odd/1], Graph), find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].\n\n% Determine if the recursion is mutual\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse. % Non-trivial SCC indicates mutual recursion\n```\n\nIdentifying these components allows the compiler to handle complex cycles in the logic. For more details on call graph introspection and SCC analysis, see **education/book-02-bash-target/07_prolog_introspection.md**.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithms"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn **SCC** is a maximal set of nodes where every node is reachable from every other.\n\n### Why SCCs Matter\n\nMutual recursion forms cycles:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even/1 -> is_odd/1\nis_odd/1  -> is_even/1\n```\n\nBoth predicates are in the **same SCC** = mutual recursion!\n\n### Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm (O(V+E)):\n\n1. Perform depth-first search\n2. Track `index` (visit order) and `lowlink` (smallest reachable index)\n3. When `index == lowlink`, node is SCC root\n\n### Usage\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Build call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n\n% Find SCCs\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % One SCC!\n\n% Check if non-trivial (mutual recursion)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % More than one predicate = mutual recursion\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Single predicate = self-recursion only\n```", "answer_tailored": true}
{"pair_id": "pattern-matching-detection_p0", "cluster_id": "pattern-matching-detection", "question": "How does UnifyWeaver classify recursion patterns?", "question_type": "medium", "answer": "UnifyWeaver classifies recursion patterns using specialized pattern matchers that analyze the structure and call positions of predicates to determine the most efficient compilation strategy.\n\n### Primary Recursion Patterns\n*   **Tail Recursion:** Identified when the recursive call is in the final (tail) position. It typically uses an accumulator (e.g., `pred(Input, Acc, Result)`) to allow for stack-efficient execution.\n*   **Linear Recursion:** Classified by having exactly one recursive call per clause with arguments pre-computed before the call.\n*   **Tree Recursion:** Triggered by structural decomposition (such as `[Value, Left, Right]`) that requires multiple recursive calls within a single clause.\n*   **Mutual Recursion:** Detected through Strongly Connected Component (SCC) analysis for predicates that call each other in a cycle.\n*   **Basic Recursion:** A fallback pattern that uses Breadth-First Search (BFS) when no specialized optimization matches.\n\n### Pattern Priority\nThe compiler attempts to match patterns in the following order to maximize performance:\n1.  **Tail Recursion** (Highest priority/most efficient)\n2.  **Linear Recursion**\n3.  **Tree Recursion**\n4.  **Mutual Recursion**\n5.  **Basic Recursion** (Fallback)\n\n### Programmatic Introspection\nYou can verify how UnifyWeaver classifies a specific predicate using built-in introspection tools:\n```prolog\n% Check for tail recursion with an accumulator\n?- is_tail_recursive_accumulator(count/3, AccInfo).\n\n% Check for streamable linear recursion\n?- is_linear_recursive_streamable(factorial/2).\n```\n\nFor detailed technical specifications on pattern detection and introspection, refer to `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["pattern-detection", "tail-recursion", "linear-recursion", "classification"], "original_answer": "## Pattern Detection\n\nUnifyWeaver uses pattern matchers to classify predicates:\n\n### Pattern 1: Tail Recursion\n\n**Characteristics:**\n- Recursive call is LAST (tail position)\n- Uses accumulator\n- Typically arity 3: `pred(Input, Acc, Result)`\n\n```prolog\n% Tail position - recursive call is last\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- TAIL\n\n% NOT tail - work after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- NOT tail\n    N is N1 + 1.        % work happens after!\n```\n\n### Pattern 2: Linear Recursion\n\n- Exactly ONE recursive call per clause\n- Arguments pre-computed (not pattern matching)\n\n### Pattern 3: Tree Recursion\n\n- Structural decomposition `[V, L, R]`\n- Multiple recursive calls\n\n### Pattern Selection Priority\n\n1. **Tail recursion** (most efficient)\n2. **Linear recursion** (unless forbidden)\n3. **Tree recursion** (structural)\n4. **Mutual recursion** (via SCC)\n5. **Basic recursion** (fallback BFS)\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```", "answer_tailored": true}
{"pair_id": "pattern-matching-detection_p1", "cluster_id": "pattern-matching-detection", "question": "What patterns does UnifyWeaver detect?", "question_type": "medium", "answer": "UnifyWeaver's compiler employs specialized pattern matchers to classify Prolog predicates into several distinct categories, which dictates how they are transformed into target code. The primary patterns detected include:\n\n1.  **Tail Recursion:** This is the highest priority detection. It identifies predicates where the recursive call is in the final (tail) position, typically utilizing an accumulator (e.g., `count(List, Acc, Result)`). This pattern is favored because it allows for the most efficient loop-based execution.\n2.  **Linear Recursion:** Detected when a clause contains exactly one recursive call and the arguments are pre-computed rather than relying on complex structural pattern matching.\n3.  **Tree Recursion:** Identified by structural decomposition (such as `[Value, Left, Right]`) and the presence of multiple recursive calls within a clause.\n4.  **Mutual Recursion:** Detected through Strongly Connected Component (SCC) analysis of the predicate call graph.\n5.  **Basic Recursion:** A fallback classification that uses a Breadth-First Search (BFS) strategy when no higher-priority optimized pattern is identified.\n\nThe detection engine follows a strict priority order: Tail > Linear > Tree > Mutual > Basic. Developers can verify these classifications using introspection predicates like `is_tail_recursive_accumulator/2` or `is_linear_recursive_streamable/1`. For a deeper dive into the introspection logic, see `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["pattern-detection", "tail-recursion", "linear-recursion", "classification"], "original_answer": "## Pattern Detection\n\nUnifyWeaver uses pattern matchers to classify predicates:\n\n### Pattern 1: Tail Recursion\n\n**Characteristics:**\n- Recursive call is LAST (tail position)\n- Uses accumulator\n- Typically arity 3: `pred(Input, Acc, Result)`\n\n```prolog\n% Tail position - recursive call is last\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- TAIL\n\n% NOT tail - work after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- NOT tail\n    N is N1 + 1.        % work happens after!\n```\n\n### Pattern 2: Linear Recursion\n\n- Exactly ONE recursive call per clause\n- Arguments pre-computed (not pattern matching)\n\n### Pattern 3: Tree Recursion\n\n- Structural decomposition `[V, L, R]`\n- Multiple recursive calls\n\n### Pattern Selection Priority\n\n1. **Tail recursion** (most efficient)\n2. **Linear recursion** (unless forbidden)\n3. **Tree recursion** (structural)\n4. **Mutual recursion** (via SCC)\n5. **Basic recursion** (fallback BFS)\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```", "answer_tailored": true}
{"pair_id": "pattern-matching-detection_p2", "cluster_id": "pattern-matching-detection", "question": "How is tail recursion detected?", "question_type": "medium", "answer": "UnifyWeaver detects tail recursion through pattern matchers that classify predicates during the compilation process. A predicate is identified as tail-recursive when the recursive call is in the final (\"tail\") position, meaning no additional work is performed after the call returns. This pattern frequently utilizes an accumulator, often following an arity-3 structure: `pred(Input, Acc, Result)`.\n\nA classic example of detected tail recursion is an accumulator-based counter:\n```prolog\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N). % Recursive call is last\n```\n\nIf operations (such as arithmetic) occur after the recursive call, the system classifies it as linear recursion instead. The compiler internally validates this using the `is_tail_recursive_accumulator/2` introspection predicate. Tail recursion is given top priority in the selection hierarchy due to its execution efficiency in targets like Bash. Detailed implementation of these pattern matchers can be found in `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["pattern-detection", "tail-recursion", "linear-recursion", "classification"], "original_answer": "## Pattern Detection\n\nUnifyWeaver uses pattern matchers to classify predicates:\n\n### Pattern 1: Tail Recursion\n\n**Characteristics:**\n- Recursive call is LAST (tail position)\n- Uses accumulator\n- Typically arity 3: `pred(Input, Acc, Result)`\n\n```prolog\n% Tail position - recursive call is last\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- TAIL\n\n% NOT tail - work after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- NOT tail\n    N is N1 + 1.        % work happens after!\n```\n\n### Pattern 2: Linear Recursion\n\n- Exactly ONE recursive call per clause\n- Arguments pre-computed (not pattern matching)\n\n### Pattern 3: Tree Recursion\n\n- Structural decomposition `[V, L, R]`\n- Multiple recursive calls\n\n### Pattern Selection Priority\n\n1. **Tail recursion** (most efficient)\n2. **Linear recursion** (unless forbidden)\n3. **Tree recursion** (structural)\n4. **Mutual recursion** (via SCC)\n5. **Basic recursion** (fallback BFS)\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```", "answer_tailored": true}
{"pair_id": "pattern-matching-detection_p3", "cluster_id": "pattern-matching-detection", "question": "What is the pattern selection priority?", "question_type": "medium", "answer": "UnifyWeaver selects recursion patterns based on a specific hierarchy of efficiency and structural complexity. When classifying a Prolog predicate, the compiler applies the following priority:\n\n1.  **Tail Recursion**: This is the highest priority because it is the most efficient. It is identified when the recursive call is in the final (tail) position and typically utilizes an accumulator (e.g., `pred(Input, Acc, Result)`).\n2.  **Linear Recursion**: This is selected when a clause contains exactly one recursive call and the arguments are pre-computed, provided it hasn't been explicitly forbidden.\n3.  **Tree Recursion**: Used for structural decomposition (such as `[V, L, R]`) where multiple recursive calls are necessary to traverse the data.\n4.  **Mutual Recursion**: Identified through Strongly Connected Components (SCC) analysis when predicates depend on each other.\n5.  **Basic Recursion**: The final fallback strategy, which uses a standard Breadth-First Search (BFS) approach.\n\nBy prioritizing tail recursion first, the compiler ensures optimal performance for iterative processes before falling back to more complex structural patterns. For more information on how UnifyWeaver classifies these patterns and uses introspection predicates like `is_tail_recursive_accumulator/2`, see `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["pattern-detection", "tail-recursion", "linear-recursion", "classification"], "original_answer": "## Pattern Detection\n\nUnifyWeaver uses pattern matchers to classify predicates:\n\n### Pattern 1: Tail Recursion\n\n**Characteristics:**\n- Recursive call is LAST (tail position)\n- Uses accumulator\n- Typically arity 3: `pred(Input, Acc, Result)`\n\n```prolog\n% Tail position - recursive call is last\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- TAIL\n\n% NOT tail - work after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- NOT tail\n    N is N1 + 1.        % work happens after!\n```\n\n### Pattern 2: Linear Recursion\n\n- Exactly ONE recursive call per clause\n- Arguments pre-computed (not pattern matching)\n\n### Pattern 3: Tree Recursion\n\n- Structural decomposition `[V, L, R]`\n- Multiple recursive calls\n\n### Pattern Selection Priority\n\n1. **Tail recursion** (most efficient)\n2. **Linear recursion** (unless forbidden)\n3. **Tree recursion** (structural)\n4. **Mutual recursion** (via SCC)\n5. **Basic recursion** (fallback BFS)\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```", "answer_tailored": true}
