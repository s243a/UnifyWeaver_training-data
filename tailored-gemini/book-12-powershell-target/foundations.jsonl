{"pair_id": "ps-001_p0", "cluster_id": "ps-001", "question": "What is the PowerShell target and when should I use it?", "question_type": "medium", "answer": "The PowerShell target in UnifyWeaver transforms Prolog logic into executable PowerShell scripts, specifically designed for automation and integration within Windows ecosystems. You should choose this target when you need direct access to Windows-native features like the registry, Active Directory, or WMI/CIM data. It is also exceptionally useful for projects that rely on the .NET framework, as it allows compiled predicates to utilize NuGet packages and custom C# snippets via Add-Type. In enterprise settings, it excels due to its compatibility with PSRemoting and native Azure/Microsoft 365 modules.\n\nDetailed guidance can be found in `education/book-12-powershell-target/`.\n\n```prolog\n?- use_module(unifyweaver(core/powershell_compiler)).\n?- compile_to_powershell(grandparent/2, [], Code).\n```", "answer_variant": "default", "answer_source": "book-12-powershell-target/01_introduction.md", "topics": [], "original_answer": "The PowerShell target compiles Prolog predicates to PowerShell scripts. Use it for:\n\n**Windows Integration:**\n- Native Windows API, registry, services access\n- Active Directory and Group Policy management\n- WMI/CIM queries, Event Log access\n\n**.NET Access:**\n- Use any .NET library from compiled predicates\n- NuGet packages (JSON, XML, databases)\n- Inline C# code via Add-Type\n\n**Enterprise Environments:**\n- Pre-installed on Windows, IT-familiar\n- Remote execution via PSRemoting\n- Azure/Microsoft 365 integration\n\n```prolog\n?- use_module(unifyweaver(core/powershell_compiler)).\n?- compile_to_powershell(grandparent/2, [], Code).\n```", "answer_tailored": true}
{"pair_id": "ps-001_p0", "cluster_id": "ps-001", "question": "What compilation modes does the PowerShell target support?", "question_type": "medium", "answer": "The PowerShell target in UnifyWeaver supports three distinct compilation modes:\n\n**1. BaaS (Bash-as-a-Service) Mode**\nThis mode wraps Bash execution within a PowerShell environment. It requires Bash to be installed on the system and is invoked using:\n```prolog\n?- compile_to_powershell(pred/2, [powershell_mode(baas)], Code).\n```\n\n**2. Pure PowerShell Mode**\nGenerates native PowerShell scripts that take full advantage of PowerShell\u2019s object-based pipeline. It has no dependency on Bash.\n```prolog\n?- compile_to_powershell(pred/2, [powershell_mode(pure)], Code).\n```\n\n**3. Inline .NET Mode**\nAllows for the embedding of C# and direct access to .NET libraries via `Add-Type`. This mode supports DLL caching, which can provide a performance boost of up to 138x.\n```prolog\nConfig = [csharp_inline('... C# code ...')],\ndotnet_source:compile_source(my_pred/2, Config, [], PowerShellCode).\n```\n\nThe compiler is designed to auto-select the most efficient mode for your specific predicate, though manual overrides are supported. Detailed documentation can be found in `education/book-12-powershell-target/`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/01_introduction.md", "topics": [], "original_answer": "Three compilation modes:\n\n**1. BaaS Mode (Bash-as-a-Service):**\n```prolog\n?- compile_to_powershell(pred/2, [powershell_mode(baas)], Code).\n```\nWraps Bash in PowerShell. Requires Bash on system.\n\n**2. Pure PowerShell Mode:**\n```prolog\n?- compile_to_powershell(pred/2, [powershell_mode(pure)], Code).\n```\nNative PowerShell with object support. No Bash required.\n\n**3. Inline .NET Mode:**\n```prolog\nConfig = [csharp_inline('... C# code ...')],\ndotnet_source:compile_source(my_pred/2, Config, [], PowerShellCode).\n```\nFull .NET library access via Add-Type. Supports DLL caching for 138x speedup.\n\nThe compiler auto-selects best mode, but you can override.", "answer_tailored": true}
