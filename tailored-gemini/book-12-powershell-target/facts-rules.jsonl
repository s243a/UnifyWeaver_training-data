{"pair_id": "ps-facts-001_p0", "cluster_id": "ps-facts-001", "question": "How are Prolog facts compiled to PowerShell?", "question_type": "medium", "answer": "I will verify the existence of the source file to ensure the reference path is correct.\nUnifyWeaver compiles Prolog facts into PowerShell arrays, utilizing `PSCustomObject` for multi-argument predicates to maintain idiomatic PowerShell compatibility.\n\n**Unary Facts**\nFacts with a single argument are represented as simple string arrays:\n```prolog\ncolor(red). color(green). color(blue).\n```\nCompiles to:\n```powershell\n$facts = @('red', 'green', 'blue')\n```\n\n**Binary and Higher-Arity Facts**\nFacts with multiple arguments are compiled into arrays of `PSCustomObject` objects. Arguments are mapped to properties (typically `X`, `Y`, etc.):\n```prolog\nparent(anne, bob). parent(bob, charles).\n```\nCompiles to:\n```powershell\n$facts = @(\n    [PSCustomObject] @{ X='anne'; Y='bob' },\n    [PSCustomObject] @{ X='bob'; Y='charles' }\n)\n```\n\nRepresenting facts as `PSCustomObject` ensures they are:\n- **Pipeline-friendly:** Compatible with cmdlets like `Where-Object` and `Select-Object`.\n- **Accessible:** Supports named property access (e.g., `$fact.X`).\n- **Serializable:** Works natively with `ConvertTo-Json` for data exchange.\n\nFor more implementation details, refer to `education/book-12-powershell-target/02_facts_rules.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/02_facts_rules.md", "topics": [], "original_answer": "Facts become PowerShell arrays with PSCustomObject entries:\n\n**Unary facts:**\n```prolog\ncolor(red). color(green). color(blue).\n```\n\u2192\n```powershell\n$facts = @('red', 'green', 'blue')\n```\n\n**Binary facts:**\n```prolog\nparent(anne, bob). parent(bob, charles).\n```\n\u2192\n```powershell\n$facts = @(\n    [PSCustomObject]@{ X='anne'; Y='bob' },\n    [PSCustomObject]@{ X='bob'; Y='charles' }\n)\n```\n\nPSCustomObject provides:\n- Named property access (`.X`, `.Y`)\n- Pipeline-friendly (`Where-Object`, `Select-Object`)\n- JSON serialization (`ConvertTo-Json`)", "answer_tailored": true}
{"pair_id": "ps-facts-001_p0", "cluster_id": "ps-facts-001", "question": "How are Prolog rules compiled to PowerShell functions?", "question_type": "medium", "answer": "Prolog rules are compiled into PowerShell functions that resolve logic through nested loop joins. When multiple predicates exist in a rule's body, the compiler generates nested `foreach` blocks to iterate through the relations and evaluate join conditions.\n\n**Prolog:**\n```prolog\ngrandparent(X, Z) :- parent(X, Y), parent(Y, Z).\n```\n\n**Generated PowerShell:**\n```powershell\nfunction grandparent {\n    param([string]$X, [string]$Z)\n    \n    $rel1 = parent\n    $rel2 = parent\n    \n    $results = foreach ($r1 in $rel1) {\n        foreach ($r2 in $rel2) {\n            if ($r1.Y -eq $r2.X) {  # Join condition\n                [PSCustomObject] @{ X = $r1.X; Z = $r2.Y }\n            }\n        }\n    }\n    # ... additional filtering/projection\n}\n```\n\nFor negation operations (`\\+`), the compiler uses hashtable-based exclusion to ensure O(1) lookup efficiency during filtering. Further details on rule compilation can be found in `education/book-12-powershell-target/02_facts_rules.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/02_facts_rules.md", "topics": [], "original_answer": "Rules become functions with nested loop joins:\n\n**Prolog:**\n```prolog\ngrandparent(X, Z) :- parent(X, Y), parent(Y, Z).\n```\n\n**Generated PowerShell:**\n```powershell\nfunction grandparent {\n    param([string]$X, [string]$Z)\n    \n    $rel1 = parent\n    $rel2 = parent\n    \n    $results = foreach ($r1 in $rel1) {\n        foreach ($r2 in $rel2) {\n            if ($r1.Y -eq $r2.X) {  # Join condition\n                [PSCustomObject]@{ X = $r1.X; Z = $r2.Y }\n            }\n        }\n    }\n    # ... filtering logic\n}\n```\n\nNegation (`\\+`) uses hashtable-based exclusion for O(1) lookups.", "answer_tailored": true}
{"pair_id": "ps-facts-002_p0", "cluster_id": "ps-facts-002", "question": "How do I use compile_facts_to_powershell/3?", "question_type": "medium", "answer": "I will search for the definition and usage of `compile_facts_to_powershell/3` in the codebase to ensure technical accuracy.\nI will read the `src/unifyweaver/targets/powershell_target.pl` file to understand the implementation and verify the generated code details.\nI will check for the existence of `education/book-12-powershell-target/02_facts_rules.md` to ensure the reference is correct.\nI will read the `education/book-12-powershell-target/02_facts_rules.md` file to see if there is any additional relevant information to include in the response.\nTo use `compile_facts_to_powershell/3`, invoke the predicate with the predicate name, its arity, and a variable to capture the generated string. This tool exports Prolog facts into a structured PowerShell class, providing static methods for data retrieval and membership testing.\n\n**Prolog Usage:**\n```prolog\n?- powershell_target:compile_facts_to_powershell(parent, 2, Code).\n```\n\n**Generated PowerShell:**\n```powershell\nclass PARENT {\n    static [string[][]] $FACTS = @(\n        @(\"anne\", \"bob\"),\n        @(\"bob\", \"charles\")\n    )\n    \n    static [string[][]] GetAll() {\n        return [PARENT]::FACTS\n    }\n    \n    static [System.Collections.Generic.IEnumerable[string[]]] Stream() {\n        foreach ($fact in [PARENT]::FACTS) { $fact }\n    }\n    \n    static [bool] Contains([string[]]$target) {\n        # ... performs membership check\n    }\n}\n```\n\n**Key Features:**\n- **Self-Contained:** Encapsulates facts within a native PowerShell class.\n- **Built-in Methods:** Provides `GetAll()`, `Stream()`, and `Contains()` for easy fact management.\n- **Compatibility:** Generates code compatible with PowerShell 5.1 and later versions.\n\nFor a deeper dive into PowerShell fact and rule compilation, see `education/book-12-powershell-target/02_facts_rules.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/02_facts_rules.md", "topics": [], "original_answer": "For class-based fact export with static methods:\n\n```prolog\n?- powershell_target:compile_facts_to_powershell(parent, 2, Code).\n```\n\n**Generated:**\n```powershell\nclass PARENT {\n    static [string[][]] $FACTS = @(\n        @(\"anne\", \"bob\"),\n        @(\"bob\", \"charles\")\n    )\n    \n    static [string[][]] GetAll() {\n        return [PARENT]::FACTS\n    }\n    \n    static [bool] Contains([string[]]$target) {\n        # ... membership check\n    }\n}\n```\n\n**Benefits:**\n- Self-contained PowerShell class\n- `GetAll()`, `Stream()`, `Contains()` methods\n- Works with PowerShell 5.1+ class syntax", "answer_tailored": true}
