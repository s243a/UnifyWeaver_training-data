{"pair_id": "ps-cmdlet-001_p0", "cluster_id": "ps-cmdlet-001", "question": "How do I generate PowerShell cmdlets with CmdletBinding?", "question_type": "medium", "answer": "To generate PowerShell cmdlets that utilize the `CmdletBinding` attribute, include the `cmdlet_binding(true)` option within the `compile_to_powershell/3` predicate.\n\n```prolog\n?- compile_to_powershell(parent/2, [\n       cmdlet_name('Get-Parent'),\n       cmdlet_binding(true),\n       verbose_output(true)\n   ], Code).\n```\n\nThe resulting output will be an advanced function decorated with the `[CmdletBinding()]` attribute:\n\n```powershell\nfunction Get-Parent {\n    [CmdletBinding()]\n    param(\n        [Parameter(Position=0)]\n        [ValidateNotNullOrEmpty()]\n        [string]$Parent,\n        \n        [Parameter(Position=1, ValueFromPipeline=$true)]\n        [string]$Child\n    )\n    \n    begin { Write-Verbose \"Loading facts...\" }\n    process { # ... implementation }\n    end { Write-Verbose \"Query complete\" }\n}\n```\n\nEnabling `CmdletBinding` allows the generated cmdlet to support standard PowerShell common parameters such as `-Verbose`, `-Debug`, and `-ErrorAction`. For further details on advanced function generation, see `education/book-12-powershell-target/03_cmdlet_generation.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/03_cmdlet_generation.md", "topics": [], "original_answer": "Use `cmdlet_binding(true)` to generate advanced functions:\n\n```prolog\n?- compile_to_powershell(parent/2, [\n       cmdlet_name('Get-Parent'),\n       cmdlet_binding(true),\n       verbose_output(true)\n   ], Code).\n```\n\n**Generated:**\n```powershell\nfunction Get-Parent {\n    [CmdletBinding()]\n    param(\n        [Parameter(Position=0)]\n        [ValidateNotNullOrEmpty()]\n        [string]$Parent,\n        \n        [Parameter(Position=1, ValueFromPipeline=$true)]\n        [string]$Child\n    )\n    \n    begin { Write-Verbose \"Loading facts...\" }\n    process { # ... implementation }\n    end { Write-Verbose \"Query complete\" }\n}\n```\n\nCmdletBinding enables `-Verbose`, `-Debug`, `-ErrorAction` and other common parameters.", "answer_tailored": true}
{"pair_id": "ps-cmdlet-001_p0", "cluster_id": "ps-cmdlet-001", "question": "What parameter attributes can I use in generated cmdlets?", "question_type": "medium", "answer": "Generated cmdlets in UnifyWeaver support various PowerShell attributes that the compiler automatically maps from Prolog constraints.\n\n**Parameter Properties:**\nThe `[Parameter()]` attribute supports `Mandatory`, `Position`, `ValueFromPipeline`, `ValueFromPipelineByPropertyName`, and `HelpMessage`. You can also apply the `[Alias()]` attribute to define multiple names for a single parameter.\n\n**Validation Attributes:**\n| Attribute | Function |\n|-----------|----------|\n| `[ValidateNotNullOrEmpty()]` | Prevents null or empty string values. |\n| `[ValidateRange(min, max)]` | Restricts input to a specific numeric range. |\n| `[ValidateSet('val1','val2')]` | Restricts input to a specific set of strings. |\n| `[ValidatePattern('regex')]` | Validates input against a regular expression. |\n| `[ValidateScript({...})]` | Runs a custom PowerShell script block for validation. |\n\nFor more information on how the compiler generates these attributes, see `education/book-12-powershell-target/03_cmdlet_generation.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/03_cmdlet_generation.md", "topics": [], "original_answer": "Common validation attributes:\n\n| Attribute | Purpose |\n|-----------|---------|\n| `[ValidateNotNullOrEmpty()]` | Reject null/empty |\n| `[ValidateRange(1, 100)]` | Numeric bounds |\n| `[ValidateSet('a','b','c')]` | Allowed values |\n| `[ValidatePattern('^[A-Z]')]` | Regex match |\n| `[ValidateScript({...})]` | Custom validation |\n\n**Parameter options:**\n```powershell\n[Parameter(\n    Mandatory=$true,\n    Position=0,\n    ValueFromPipeline=$true,\n    ValueFromPipelineByPropertyName=$true,\n    HelpMessage='Enter a name'\n)]\n[Alias('N', 'PersonName')]\n[string]$Name\n```\n\nThe compiler maps Prolog constraints to these attributes.", "answer_tailored": true}
{"pair_id": "ps-cmdlet-002_p0", "cluster_id": "ps-cmdlet-002", "question": "How do Begin/Process/End blocks work in generated cmdlets?", "question_type": "medium", "answer": "In UnifyWeaver, the `begin`, `process`, and `end` blocks manage the execution lifecycle of generated PowerShell cmdlets to ensure efficient stream processing. This structure allows the cmdlet to perform setup once and then handle many items in the pipeline:\n\n*   **begin**: This block handles initialization before processing begins. It is typically used for script-scope setup, such as loading fact tables or building indexes for fast lookups.\n```powershell\nbegin {\n    $script:facts = Load-Facts\n    $script:index = @{}  # Build search structures\n}\n```\n\n*   **process**: This block runs for every item in the pipeline. It uses the input object (`$_`) to perform the core logic, such as querying the previously built indexes.\n```powershell\nprocess {\n    if ($script:index.ContainsKey($_)) {\n        $script:index[$_]  # Output matches\n    }\n}\n```\n\n*   **end**: This block executes once after the entire input stream has been processed. It is used to emit aggregated results or perform final cleanup operations.\n```powershell\nend {\n    # Finalization and aggregation\n}\n```\n\nThis pattern optimizes performance by isolating heavy setup tasks from the per-item processing logic. For more details on this implementation, see `education/book-12-powershell-target/03_cmdlet_generation.md`.", "answer_variant": "default", "answer_source": "book-12-powershell-target/03_cmdlet_generation.md", "topics": [], "original_answer": "Three execution phases for pipeline processing:\n\n**Begin** - Runs once before processing:\n```powershell\nbegin {\n    Write-Verbose \"Initializing...\"\n    $script:facts = Load-Facts  # Load once\n    $script:index = @{}  # Build indexes\n}\n```\n\n**Process** - Runs once per pipeline item:\n```powershell\nprocess {\n    Write-Verbose \"Processing: $_\"\n    if ($script:index.ContainsKey($_)) {\n        $script:index[$_]\n    }\n}\n```\n\n**End** - Runs after all input processed:\n```powershell\nend {\n    Write-Verbose \"Cleanup...\"\n    # Emit aggregated results, clean up\n}\n```\n\nThis pattern enables efficient batch processing: load facts once, process many items.", "answer_tailored": true}
