{"pair_id": "semantic-density-001_p0", "cluster_id": "semantic-density-001", "question": "What is flux-softmax density scoring?", "question_type": "medium", "answer": "Flux-softmax density scoring is a ranking mechanism in UnifyWeaver designed to favor search results located within semantically dense clusters, prioritizing \"consensus\" signals over isolated high-scoring outliers. By boosting results in regions where multiple relevant documents overlap, the system ensures that clustered information ranks higher than high-scoring but anomalous matches.\n\nThe scoring is calculated using the following formula:\n`P(i) = exp(s\u1d62/\u03c4) * (1 + w * d\u1d62) / Z`\n\nIn this equation:\n- **\u03c4 (temperature):** Controls the sharpness of the distribution.\n- **w (density weight):** Adjusts the influence of density (0 ignores density, while 1 applies it strongly).\n- **d\u1d62:** Represents the normalized density score for the result.\n\nThe implementation typically follows a two-stage pipeline:\n1. **Clustering:** Matches are grouped by similarity using greedy algorithms or HDBSCAN.\n2. **KDE Density Calculation:** Kernel Density Estimation (KDE) is performed within each cluster to determine localized density.\n3. **Softmax Application:** The flux-softmax formula is applied to produce the final probability distribution.\n\n```python\ndef flux_softmax(scores, densities, density_weight=0.3, temperature=1.0):\n    scaled = scores / temperature - scores.max()\n    flux_factor = 1.0 + density_weight * densities\n    exp_scores = np.exp(scaled) * flux_factor\n    return exp_scores / exp_scores.sum()\n```\n\nThis approach ensures that dense clusters representing a consensus of information receive a higher probability in the final retrieval set. For a deeper dive into these scoring mechanics, refer to `education/book-13-semantic-search/07_density_scoring.md`.", "answer_variant": "default", "answer_source": "book-13-semantic-search/07_density_scoring.md", "topics": [], "original_answer": "Density scoring boosts results in semantically dense regions (consensus signal):\n\n**Problem:** Naive max/sum ranks isolated high-scoring results above clustered consensus.\n\n**Flux-softmax formula:**\n```\nP(i) = exp(s\u1d62/\u03c4) * (1 + w * d\u1d62) / Z\n```\n- \u03c4 = temperature (sharpness)\n- w = density weight (0 = ignore, 1 = strong)\n- d\u1d62 = normalized density score\n\n```python\ndef flux_softmax(scores, densities, density_weight=0.3, temperature=1.0):\n    scaled = scores / temperature - scores.max()\n    flux_factor = 1.0 + density_weight * densities\n    exp_scores = np.exp(scaled) * flux_factor\n    return exp_scores / exp_scores.sum()\n```\n\n**Two-stage pipeline:**\n1. Cluster by similarity (greedy or HDBSCAN)\n2. Compute KDE density **within** each cluster\n3. Apply flux-softmax\n\nDense clusters = consensus = higher probability.", "answer_tailored": true}
{"pair_id": "semantic-density-001_p0", "cluster_id": "semantic-density-001", "question": "How do I configure density scoring in Prolog?", "question_type": "medium", "answer": "To configure density scoring in Prolog, you incorporate a `density_flux` aggregation within the `federation` section of your service definition. This allows you to tune weights and clustering behavior for semantic search results.\n\nExample Service Configuration:\n```prolog\nservice(semantic_search_node, [\n    transport(http('/kg', [port(8080)])),\n    federation([\n        aggregation(density_flux, [\n            density_weight(0.3),\n            clustering_enabled(true),\n            similarity_threshold(0.7),\n            min_cluster_size(2)\n        ]),\n        federation_k(5)\n    ])\n], [receive(Query), handle_federated_query(Query, Response), respond(Response)]).\n```\n\nYou can also implement validation predicates to ensure parameters like bandwidth and weights are within acceptable ranges:\n```prolog\nis_valid_density_option(bandwidth(auto)).\nis_valid_density_option(bandwidth(silverman)).\nis_valid_density_option(bandwidth(B)) :- number(B), B > 0.\nis_valid_density_option(density_weight(W)) :- number(W), W >= 0, W =< 1.\n```\n\nTuning Guidelines:\n- **High Precision:** Set `similarity_threshold` to 0.8 or higher for sensitive domains like legal or medical.\n- **Exploration:** Use a `similarity_threshold` between 0.5 and 0.6 for broader discovery.\n- **Consensus Focus:** Increase `density_weight` to 0.5 or above to favor dense result clusters.\n\nFor further details on density flux implementation and scoring algorithms, refer to `education/book-13-semantic-search/07_density_scoring.md`.", "answer_variant": "default", "answer_source": "book-13-semantic-search/07_density_scoring.md", "topics": [], "original_answer": "Configure via service definition:\n\n```prolog\nservice(semantic_search_node, [\n    transport(http('/kg', [port(8080)])),\n    federation([\n        aggregation(density_flux, [\n            density_weight(0.3),\n            clustering_enabled(true),\n            similarity_threshold(0.7),\n            min_cluster_size(2)\n        ]),\n        federation_k(5)\n    ])\n], [receive(Query), handle_federated_query(Query, Response), respond(Response)]).\n```\n\n**Validation predicates:**\n```prolog\nis_valid_density_option(bandwidth(auto)).\nis_valid_density_option(bandwidth(silverman)).\nis_valid_density_option(bandwidth(B)) :- number(B), B > 0.\nis_valid_density_option(density_weight(W)) :- number(W), W >= 0, W =< 1.\n```\n\n**Tuning:**\n- High precision (legal, medical): `similarity_threshold(0.8+)`\n- Exploratory: `similarity_threshold(0.5-0.6)`\n- Consensus-heavy: `density_weight(0.5+)`", "answer_tailored": true}
