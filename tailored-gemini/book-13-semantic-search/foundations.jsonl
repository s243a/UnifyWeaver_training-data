{"pair_id": "semantic-001_p0", "cluster_id": "semantic-001", "question": "What is the Python semantic target?", "question_type": "medium", "answer": "The Python semantic target is UnifyWeaver's specialized compilation path for building Intelligent Semantic Agents that merge Prolog's declarative reasoning with AI and machine learning tools. It provides a robust framework for RAG (Retrieval-Augmented Generation), vector databases, and automated data processing.\n\nKey technical components include:\n- **PtImporter**: Handles SQLite-based storage for objects, relationships, and vector data.\n- **PtCrawler**: Manages streaming XML/HTML parsing and link extraction.\n- **PtSearcher**: Executes vector similarity searches and graph traversals.\n- **LLMProvider**: Interfaces with external LLM command-line interfaces.\n- **OnnxEmbeddingProvider**: Generates local embeddings via the ONNX runtime.\n\n```prolog\n:- use_module(unifyweaver(targets/python_target)).\n\nsemantic_query(Query, Match) :-\n    embed(Query, Vec),\n    vector_search(Vec, 5, TopMatches),\n    member(Match, TopMatches).\n\n?- compile_python_semantic(semantic_query/2, [], PythonCode).\n```\n\nBy targeting Python, UnifyWeaver leverages the broader AI ecosystem, including local embedding models and large language models. For more information, refer to the documentation in `education/book-13-semantic-search/01_introduction.md`.", "answer_variant": "default", "answer_source": "book-13-semantic-search/01_introduction.md", "topics": [], "original_answer": "The Python target in UnifyWeaver builds **Intelligent Semantic Agents** that combine declarative logic with AI capabilities:\n\n**Key components:**\n- `PtImporter`: SQLite storage for objects, links, vectors\n- `PtCrawler`: XML/HTML streaming with link extraction\n- `PtSearcher`: Vector search and graph traversal\n- `LLMProvider`: Wraps LLM CLIs for RAG tasks\n- `OnnxEmbeddingProvider`: Local embeddings via ONNX\n\n```prolog\n:- use_module(unifyweaver(targets/python_target)).\n\nsearch(Query, Result) :-\n    embed(Query, Vector),\n    vector_search(Vector, 5, Matches),\n    member(Result, Matches).\n\n?- compile_python_semantic(search/2, [], Code).\n```\n\nPython enables access to the AI/ML ecosystem: LLMs, vector databases, data processing.", "answer_tailored": true}
{"pair_id": "semantic-001_p0", "cluster_id": "semantic-001", "question": "What is Graph RAG and how does it differ from standard RAG?", "question_type": "medium", "answer": "Graph RAG (Retrieval-Augmented Generation) is a retrieval method that prioritizes **relationships** between documents\u2014such as parent/child hierarchies, citations, and cross-references\u2014rather than relying strictly on vector similarity.\n\nIn contrast to **Standard RAG**, which retrieves independent text fragments based on vector distance, UnifyWeaver\u2019s Graph RAG uses an iterative process to build a richer context:\n1.  **Anchor**: Perform an initial vector search to find relevant entry points (e.g., a specific project page).\n2.  **Traverse**: Use the `links` table to navigate to neighboring nodes (e.g., related design specs or meeting notes).\n3.  **Synthesize**: Provide the combination of anchor nodes and their graph neighbors to the LLM for generation.\n\n```prolog\n% Standard RAG (vector similarity only)\nsemantic_search(Query, 5, Results).\n\n% Graph RAG (anchors + 1-hop expansion)\ngraph_search(Query, 3, 1, Results).\n\n% Example RAG Pipeline\nsummarize_topic(Topic, Summary) :-\n    graph_search(Topic, 3, 1, Context),\n    llm_ask('Summarize this topic using the provided context.', Context, Summary).\n```\n\nBy traversing explicit links, Graph RAG uncovers relevant information that flat search might miss (such as discovering a \"Budget 1968\" document because it is linked to an \"Apollo 11\" anchor). For a deeper dive into graph traversal strategies, see `education/book-13-semantic-search/`.", "answer_variant": "default", "answer_source": "book-13-semantic-search/02_graph_rag.md", "topics": [], "original_answer": "**Standard RAG**: Retrieves documents by vector similarity only.\n\n**Graph RAG**: Retrieves documents based on **relationships** (parent/child, citations, see-also), not just vector distance.\n\n**The UnifyWeaver approach:**\n1. **Anchor**: Vector search finds entry nodes (\"Apollo 11\" page)\n2. **Traverse**: Graph expansion finds neighbors via `links` table\n3. **Synthesize**: Feed Anchor + Neighbors to LLM\n\n```prolog\n% Standard vector search\nsemantic_search(Query, 5, Results).\n\n% Graph RAG - includes neighbors\ngraph_search(Query, 3, 1, Results).  % Top 3, expand 1 hop\n\n% Use in RAG\nsummarize(Topic, Summary) :-\n    graph_search(Topic, 3, 1, Context),\n    llm_ask('Summarize using context.', Context, Summary).\n```\n\nGraph RAG captures context that flat search misses (e.g., finding \"Budget 1968\" linked to Apollo).", "answer_tailored": true}
