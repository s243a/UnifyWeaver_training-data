{"pair_id": "semantic-dist-001_p0", "cluster_id": "semantic-dist-001", "question": "How does distributed semantic search work in UnifyWeaver?", "question_type": "medium", "answer": "Distributed semantic search in UnifyWeaver operates through a decentralized network of multi-interface nodes using Kleinberg routing to achieve small-world efficiency. Each expert system node manages diverse data interfaces\u2014such as CSV or JSON centroids\u2014mapping back to a shared Knowledge Graph database.\n\n**Routing Mechanisms:**\n*   **Greedy Forwarding:** Queries are automatically directed to the neighboring node exhibiting the highest similarity to the query embedding.\n*   **HTL (Hops-To-Live):** A safety mechanism that terminates queries after a set number of jumps to prevent infinite loops.\n*   **Path Folding:** This optimization records successful routes, creating shortcuts that accelerate subsequent searches across the network.\n\n```python\nrouter = KleinbergRouter(\n    discovery_client=create_discovery_client('consul'),\n    alpha=2.0, max_hops=10, path_folding_enabled=True\n)\nresults = router.route_query(query_embedding, envelope, top_k=5)\n```\n\nBy leveraging this architecture, UnifyWeaver ensures efficient retrieval with search path lengths scaling at O(log\u00b2n). For more details on network topology and node configuration, see `education/book-13-semantic-search/06_distributed_search.md`.", "answer_variant": "default", "answer_source": "book-13-semantic-search/06_distributed_search.md", "topics": [], "original_answer": "Multi-interface nodes with Kleinberg routing:\n\n**Architecture:**\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Expert System (Node)        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502  \u2502Interface\u2502 \u2502Interface\u2502 ...    \u2502\n\u2502  \u2502  \"CSV\"  \u2502 \u2502 \"JSON\" \u2502        \u2502\n\u2502  \u2502centroid \u2502 \u2502centroid\u2502        \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2502        Shared KG Database       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Kleinberg routing protocol:**\n- Greedy forwarding to node with highest similarity\n- HTL (Hops-To-Live) prevents infinite loops\n- Path folding creates shortcuts for future queries\n\n```python\nrouter = KleinbergRouter(\n    discovery_client=create_discovery_client('consul'),\n    alpha=2.0, max_hops=10, path_folding_enabled=True\n)\nresults = router.route_query(query_embedding, envelope, top_k=5)\n```\n\nProper small-world structure achieves O(log\u00b2n) path length.", "answer_tailored": true}
{"pair_id": "semantic-dist-001_p0", "cluster_id": "semantic-dist-001", "question": "How does federated query aggregation handle source diversity?", "question_type": "medium", "answer": "Federated query aggregation handles source diversity by utilizing a multi-tiered scoring mechanism designed to distinguish between genuine consensus and redundant \"echoes\" from overlapping datasets.\n\nTo ensure that results from similar nodes do not artificially inflate relevance scores, UnifyWeaver implements a **3-Tier diversity model**:\n\n*   **Tier 1 (Different Corpora):** Results originating from entirely different corpora are considered fully independent. Their scores are summed to reflect strong cross-corpus consensus.\n*   **Tier 2 (Same Corpus, Disjoint Sources):** If results come from the same corpus but represent disjoint data sources, a partial boost is applied to recognize the independent validation without full summation.\n*   **Tier 3 (Overlapping Sources):** When sources overlap significantly, the system identifies this as an echo and only retains the maximum score (`MAX`) to prevent redundancy bias.\n\n```python\ndef _diversity_merge(self, existing_score, new_score, existing_prov, new_prov):\n    # Tier 1: Different corpus = full independence = SUM\n    if existing_prov.corpus_id != new_prov.corpus_id:\n        return existing_score + new_score\n    \n    # Tier 2: Same corpus, disjoint sources = partial boost\n    if not existing_prov.data_sources.intersection(new_prov.data_sources):\n        return (existing_score + new_score + max(existing_score, new_score)) / 2\n    \n    # Tier 3: Overlapping sources = echo = MAX only\n    return max(existing_score, new_score)\n```\n\nIn the Prolog configuration, this is managed through specific aggregation predicates:\n\n```prolog\nfederation_k(5), aggregation(diversity), consensus_threshold(3)\n```\n\nFor more details on managing federated node results, refer to `education/book-13-semantic-search/06_distributed_search.md`.", "answer_variant": "default", "answer_source": "book-13-semantic-search/06_distributed_search.md", "topics": [], "original_answer": "Results from multiple nodes need diversity-aware aggregation:\n\n**The problem:** Two nodes trained on the same dataset returning similar answers - is that consensus or echo?\n\n**3-Tier diversity model:**\n```python\ndef _diversity_merge(self, existing_score, new_score, existing_prov, new_prov):\n    # Tier 1: Different corpus = full independence = SUM\n    if existing_prov.corpus_id != new_prov.corpus_id:\n        return existing_score + new_score\n    \n    # Tier 2: Same corpus, disjoint sources = partial boost\n    if not existing_prov.data_sources.intersection(new_prov.data_sources):\n        return (existing_score + new_score + max(existing_score, new_score)) / 2\n    \n    # Tier 3: Overlapping sources = echo = MAX only\n    return max(existing_score, new_score)\n```\n\n**Prolog config:**\n```prolog\nfederation_k(5), aggregation(diversity), consensus_threshold(3)\n```", "answer_tailored": true}
