{"pair_id": "semantic-polyglot-001_p0", "cluster_id": "semantic-polyglot-001", "question": "Why generate Go and Rust code from Prolog specs?", "question_type": "medium", "answer": "Generating Go and Rust from Prolog specifications allows UnifyWeaver to optimize for specific performance requirements and deployment constraints while maintaining a single logic definition. This approach ensures that different nodes in a distributed system use the language best suited for their operational role:\n\n| Metric | Python | Go | Rust |\n| :--- | :--- | :--- | :--- |\n| **Startup** | ~100ms | ~5ms | ~5ms |\n| **Memory** | High | Low | Lowest |\n| **Packaging** | Virtualenv | Single binary | Single binary |\n| **Concurrency** | GIL-limited | Goroutines | async/await |\n| **Ideal for** | Prototyping, ML | High-throughput aggregators | Resource-constrained edge |\n\nBy targeting multiple languages from the same Prolog spec, developers can deploy:\n- **Python** for development and ML-heavy processing.\n- **Go** for aggregator nodes requiring high concurrency.\n- **Rust** for edge nodes where memory efficiency and performance are critical.\n\nExample of compiling the same logic for different targets:\n```prolog\n?- compile_adaptive_federation_go([adaptive_k([base_k(5)])], GoCode).\n?- compile_adaptive_federation_rust([adaptive_k([base_k(5)])], RustCode).\n```\n\nFor more details on cross-language code generation strategies, see `education/book-13-semantic-search/`.", "answer_variant": "default", "answer_source": "book-13-semantic-search/10_go_rust_codegen.md", "topics": [], "original_answer": "Different languages for different deployment needs:\n\n| Aspect | Python | Go | Rust |\n|--------|--------|-------|------|\n| Startup | ~100ms | ~5ms | ~5ms |\n| Memory | High | Low | Lowest |\n| Deployment | Virtualenv | Single binary | Single binary |\n| Concurrency | GIL-limited | Goroutines | async/await |\n| Best for | Prototyping, ML | Microservices | Embedded, perf-critical |\n\n**Typical deployment:**\n- Python: Development, ML-heavy nodes\n- Go: High-throughput aggregator nodes\n- Rust: Edge nodes with constrained resources\n\n**Same Prolog spec \u2192 multiple targets:**\n```prolog\n?- compile_adaptive_federation_go([adaptive_k([base_k(5)])], GoCode).\n?- compile_adaptive_federation_rust([adaptive_k([base_k(5)])], RustCode).\n```", "answer_tailored": true}
{"pair_id": "semantic-polyglot-001_p0", "cluster_id": "semantic-polyglot-001", "question": "What Phase 5-8 code generation predicates are available?", "question_type": "medium", "answer": "UnifyWeaver provides a set of code generation predicates for Phases 5 through 8, focusing on advanced federation and network topology for Go and Rust targets:\n\n**Phase 5 (Advanced Federation)**\n- `compile_adaptive_federation_go/2` and `compile_adaptive_federation_rust/2`: Generates AdaptiveKCalculators using Goroutines or Tokio async.\n- `compile_query_planner_go/2`: Generates QueryPlanner and PlanExecutor code.\n- `compile_streaming_federation_go/2` and `compile_streaming_federation_rust/2`: Handles streaming partial results via channels or mpsc receivers.\n\n**Phase 7 (Proper Small-World)**\n- `compile_small_world_proper_go/2`: Generates Kleinberg routing logic to achieve O(log\u00b2n) path lengths.\n\n**Phase 8 (Scale-Free Nodes)**\n- `compile_multi_interface_node_rust/2`: Compiles nodes with power-law interface distributions.\n\nFor more details, see `education/book-13-semantic-search/10_go_rust_codegen.md`.", "answer_variant": "default", "answer_source": "book-13-semantic-search/10_go_rust_codegen.md", "topics": [], "original_answer": "**Phase 5: Advanced Federation**\n\n| Predicate | Generated Code |\n|-----------|----------------|\n| `compile_adaptive_federation_go/2` | AdaptiveKCalculator (goroutines) |\n| `compile_adaptive_federation_rust/2` | AdaptiveKCalculator (tokio async) |\n| `compile_query_planner_go/2` | QueryPlanner, PlanExecutor |\n| `compile_streaming_federation_go/2` | PartialResult, channels |\n| `compile_streaming_federation_rust/2` | mpsc::Receiver streaming |\n\n**Phase 7: Proper Small-World**\n```prolog\n?- compile_small_world_proper_go([k_local(10), k_long(5), alpha(2.0)], Code).\n```\nGenerates proper Kleinberg routing with O(log\u00b2n) path length.\n\n**Phase 8: Scale-Free Nodes**\n```prolog\n?- compile_multi_interface_node_rust([gamma(2.5), min_interfaces(1)], Code).\n```\nPower-law interface distribution: ~60% nodes have 1-2 interfaces, ~3% have 20+.", "answer_tailored": true}
