{"pair_id": "prolog-target-001_p0", "cluster_id": "prolog-target-001", "question": "What is the Prolog target and why transpile Prolog to Prolog?", "question_type": "medium", "answer": "The Prolog target is a specialized backend that transforms standard Prolog source into optimized, executable scripts. Transpiling Prolog to Prolog serves several essential functions:\n\n1.  **Dialect Translation**: It bridges the gap between different Prolog implementations (such as SWI-Prolog and GNU Prolog), automatically handling differences in module systems, initialization routines, and built-in predicates.\n2.  **Dependency Injection**: The compiler automatically identifies and injects required UnifyWeaver modules\u2014such as data source handlers or partitioners\u2014directly into the generated output.\n3.  **Compilation Support**: It enables flexible execution paths, supporting both interpreted scripts and the generation of native binaries via GNU Prolog's `gplc` utility.\n4.  **Security Integration**: It enforces fine-grained security and firewall policies during the code generation phase to ensure that the resulting script complies with project safety standards.\n\n```prolog\n:- use_module('src/unifyweaver/targets/prolog_target').\n\n?- generate_prolog_script([factorial/2],\n                         [dialect(gnu), compile(true)],\n                         Code),\n   write_prolog_script(Code, 'factorial', [dialect(gnu), compile(true)]).\n```\n\nFor more detailed information on these mechanisms, see `education/book-11-prolog-target/`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/01_introduction.md", "topics": [], "original_answer": "The Prolog target converts Prolog source into executable Prolog scripts for different dialects. Key purposes:\n\n**1. Dialect Translation**: Handle differences between SWI-Prolog and GNU Prolog (initialization, modules, built-ins)\n\n**2. Dependency Injection**: Automatically include required UnifyWeaver modules (partitioners, data sources)\n\n**3. Compilation Support**: Generate interpreted scripts or compiled binaries via GNU Prolog's `gplc`\n\n**4. Security**: Integration with firewall policies for code generation control\n\n```prolog\n:- use_module('src/unifyweaver/targets/prolog_target').\n\n?- generate_prolog_script([factorial/2],\n                         [dialect(gnu), compile(true)],\n                         Code),\n   write_prolog_script(Code, 'factorial', [dialect(gnu), compile(true)]).\n```", "answer_tailored": true}
{"pair_id": "prolog-target-001_p0", "cluster_id": "prolog-target-001", "question": "What is the Prolog target generation pipeline?", "question_type": "medium", "answer": "The Prolog target generation pipeline is implemented through the `generate_prolog_script/3` predicate, which follows a structured eight-step sequence to produce dialect-specific Prolog code:\n\n1. **Dialect Selection**: Validates the target environment using `option(dialect(D), Options, swi)`.\n2. **Dependency Analysis**: Identifies required predicate relationships via `analyze_dependencies/2`.\n3. **Shebang Generation**: Produces the correct execution header with `dialect_shebang/2`.\n4. **Header Generation**: Adds necessary metadata and descriptive comments.\n5. **Import Generation**: Resolves and writes module imports using `dialect_imports/3`.\n6. **User Code Transpilation**: Extracts the primary logic and predicate definitions.\n7. **Entry Point Generation**: Creates the `main` execution predicate via `generate_main_predicate/2`.\n8. **Initialization Code**: Appends dialect-specific startup goals using `dialect_initialization/4`.\n\nThe architecture is organized into three core modules: `prolog_target.pl` (main orchestrator), `prolog_dialects.pl` (dialect-specific code generation), and `prolog_service_target.pl` (service integration). For a complete technical breakdown, see `education/book-11-prolog-target/02_architecture.md`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/02_architecture.md", "topics": [], "original_answer": "The `generate_prolog_script/3` pipeline has 8 steps:\n\n1. **Dialect Selection**: Validate `option(dialect(D), Options, swi)`\n2. **Dependency Analysis**: `analyze_dependencies(Predicates, Deps)`\n3. **Shebang Generation**: `dialect_shebang(Dialect, Shebang)`\n4. **Header Generation**: Metadata comments\n5. **Import Generation**: `dialect_imports(Dialect, Deps, Imports)`\n6. **User Code Transpilation**: Extract predicate definitions\n7. **Entry Point Generation**: `generate_main_predicate(Options, Main)`\n8. **Initialization Code**: `dialect_initialization(Dialect, Goal, Opts, Init)`\n\nThree core modules:\n- `prolog_target.pl` - Main orchestrator\n- `prolog_dialects.pl` - Dialect-specific code generation\n- `prolog_service_target.pl` - Service integration", "answer_tailored": true}
