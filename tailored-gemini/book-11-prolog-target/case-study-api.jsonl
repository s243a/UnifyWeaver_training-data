{"pair_id": "prolog-case-001_p0", "cluster_id": "prolog-case-001", "question": "How do I compile a Prolog predicate to a standalone binary?", "question_type": "medium", "answer": "To compile a Prolog predicate into a standalone binary, use UnifyWeaver\u2019s `prolog_target` with the `compile(true)` option and specify a target dialect (like `gnu`). This process generates a script with the necessary initialization directives that can be compiled into a native executable by the underlying Prolog system.\n\n**Workflow Implementation:**\n\n1. **Define your predicates:**\nCreate your logic and an entry point predicate (e.g., `test_factorial/0`).\n```prolog\nfactorial(0, 1) :- !.\nfactorial(N, R) :- N > 0, N1 is N-1, factorial(N1, R1), R is N*R1.\n\ntest_factorial :- factorial(5, F), format('5! = ~w~n', [F]).\n```\n\n2. **Generate and compile:**\nUse the `prolog_target` module to generate the compiled script and write it to disk.\n```prolog\n:- use_module('src/unifyweaver/targets/prolog_target').\n\nmain :-\n    generate_prolog_script([factorial/2, test_factorial/0],\n        [dialect(gnu), compile(true), entry_point(test_factorial)], Code),\n    write_prolog_script(Code, 'factorial_bin',\n        [dialect(gnu), compile(true)]).\n```\n\n3. **Execute the binary:**\nThe resulting standalone file provides native-speed performance and rapid startup.\n```bash\n$ ./factorial_bin\n5! = 120\n\n$ time ./factorial_bin\nreal    0m0.002s  # ~2ms startup (native binary performance)\n```\n\nUnifyWeaver ensures the binary is self-starting by automatically generating the `:- initialization(test_factorial).` directive. For further details on dialect-specific compilation and optimization, see `education/book-11-prolog-target/15_case_study.md`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/15_case_study.md", "topics": [], "original_answer": "Complete workflow for factorial example:\n\n**1. Define predicates (factorial.pl):**\n```prolog\nfactorial(0, 1) :- !.\nfactorial(N, R) :- N > 0, N1 is N-1, factorial(N1, R1), R is N*R1.\n\ntest_factorial :- factorial(5, F), format('5! = ~w~n', [F]).\n```\n\n**2. Generate and compile:**\n```prolog\n:- use_module('src/unifyweaver/targets/prolog_target').\n\nmain :-\n    generate_prolog_script([factorial/2, test_factorial/0],\n        [dialect(gnu), compile(true), entry_point(test_factorial)], Code),\n    write_prolog_script(Code, 'factorial_gnu.pl',\n        [dialect(gnu), compile(true)]).\n```\n\n**3. Result:**\n```bash\n$ ./factorial_gnu\n5! = 120\n\n$ time ./factorial_gnu\nreal    0m0.002s  # ~2ms startup (native binary)\n```\n\nKey: UnifyWeaver generates `:- initialization(test_factorial).` for compiled mode.", "answer_tailored": true}
{"pair_id": "prolog-api-001_p0", "cluster_id": "prolog-api-001", "question": "What are the key Prolog target API predicates?", "question_type": "medium", "answer": "The key Prolog target API predicates in UnifyWeaver facilitate script generation, dialect configuration, and compilation.\n\n### Primary Entry Points\n* `generate_prolog_script(+Predicates, +Options, -Code)`: The central predicate for generating script code. Supported options include `dialect(D)`, `compile(Bool)`, and `entry_point(Goal)`.\n* `write_prolog_script(+Code, +Path, +Options)`: Writes generated code to a file, with options to handle compilation (`compile(Bool)`) and error reporting (`fail_on_compile_error(Bool)`).\n* `analyze_dependencies(+Predicates, -Dependencies)`: Identifies and returns the dependencies for a set of predicates.\n\n### Dialect and Validation Predicates\n* `supported_dialect(?Dialect)`: Identifies available Prolog dialects (e.g., `swi`, `gnu`).\n* `dialect_capabilities(+Dialect, -Caps)`: Retrieves the specific features and capabilities of a dialect.\n* `validate_for_dialect(+Dialect, +Preds, -Issues)`: Ensures that predicates are compatible with the target dialect before generation.\n* `dialect_shebang(+Dialect, -Shebang)` and `dialect_initialization(+Dialect, +Goal, +Opts, -Init)`: Manage environment-specific script headers and initialization sequences.\n\n### Compilation Tools\n* `compile_script(+Dialect, +ScriptPath)`: Executes dialect-specific compilation with built-in error checking.\n* `compile_script_safe(+Dialect, +Path, +Opts)`: Offers a resilient compilation path with graceful fallback mechanisms.\n\nFor a comprehensive list of all Prolog target predicates, refer to `education/book-11-prolog-target/appendix_a_api_reference.md`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/appendix_a_api_reference.md", "topics": [], "original_answer": "**Main entry points:**\n\n```prolog\n% Generate script code\ngenerate_prolog_script(+Predicates, +Options, -Code)\n% Options: dialect(D), compile(Bool), entry_point(Goal)\n\n% Write to file (with optional compilation)\nwrite_prolog_script(+Code, +Path)\nwrite_prolog_script(+Code, +Path, +Options)\n% Options: dialect(D), compile(Bool), fail_on_compile_error(Bool)\n\n% Analyze dependencies\nanalyze_dependencies(+Predicates, -Dependencies)\n```\n\n**Dialect predicates:**\n```prolog\nsupported_dialect(?Dialect)           % swi, gnu\ndialect_capabilities(+Dialect, -Caps)\ndialect_shebang(+Dialect, -Shebang)\ndialect_initialization(+Dialect, +Goal, +Opts, -Init)\nvalidate_for_dialect(+Dialect, +Preds, -Issues)\n```\n\n**Compilation:**\n```prolog\ncompile_script(+Dialect, +ScriptPath)      % With error checking\ncompile_script_safe(+Dialect, +Path, +Opts) % Graceful fallback\n```", "answer_tailored": true}
{"pair_id": "prolog-api-001_p0", "cluster_id": "prolog-api-001", "question": "What are common Prolog target usage patterns?", "question_type": "medium", "answer": "Common Prolog target usage patterns in UnifyWeaver range from basic script generation to complex, validated multi-dialect deployments.\n\n**1. Standard Script Generation**\nThis is the simplest approach for emitting Prolog code from source predicates:\n```prolog\ngenerate_prolog_script([my_pred/2], [], Code),\nwrite_prolog_script(Code, 'output.pl').\n```\n\n**2. Targeted Binary Compilation**\nUse this pattern to generate code for a specific dialect (e.g., GNU Prolog) while enabling compilation into a binary executable:\n```prolog\ngenerate_prolog_script(Preds, [dialect(gnu), compile(true)], Code),\nwrite_prolog_script(Code, 'app.pl', [dialect(gnu), compile(true)]).\n```\n\n**3. Cross-Dialect Deployment**\nThis pattern allows you to simultaneously generate separate files for different Prolog environments from a single set of predicates:\n```prolog\ngenerate_both(Preds, Base) :-\n    generate_prolog_script(Preds, [dialect(swi)], Swi),\n    atom_concat(Base, '_swi.pl', SwiPath),\n    write_prolog_script(Swi, SwiPath),\n    generate_prolog_script(Preds, [dialect(gnu)], Gnu),\n    atom_concat(Base, '_gnu.pl', GnuPath),\n    write_prolog_script(Gnu, GnuPath).\n```\n\n**4. Pre-Generation Validation**\nTo ensure compatibility, this pattern validates the source logic against the target dialect's constraints before proceeding with code generation:\n```prolog\nsafe_generate(Preds, Dialect, Code) :-\n    validate_for_dialect(Dialect, Preds, Issues),\n    Issues = [],  % Generation only proceeds if no issues are found\n    generate_prolog_script(Preds, [dialect(Dialect)], Code).\n```\n\nFor further information on the Prolog target API, see `education/book-11-prolog-target/appendix_a_api_reference.md`.", "answer_variant": "default", "answer_source": "book-11-prolog-target/appendix_a_api_reference.md", "topics": [], "original_answer": "**Pattern 1: Simple script generation**\n```prolog\ngenerate_prolog_script([my_pred/2], [], Code),\nwrite_prolog_script(Code, 'output.pl').\n```\n\n**Pattern 2: Compiled binary**\n```prolog\ngenerate_prolog_script(Preds, [dialect(gnu), compile(true)], Code),\nwrite_prolog_script(Code, 'app.pl', [dialect(gnu), compile(true)]).\n```\n\n**Pattern 3: Multi-dialect generation**\n```prolog\ngenerate_both(Preds, Base) :-\n    generate_prolog_script(Preds, [dialect(swi)], Swi),\n    atom_concat(Base, '_swi.pl', SwiPath),\n    write_prolog_script(Swi, SwiPath),\n    generate_prolog_script(Preds, [dialect(gnu)], Gnu),\n    atom_concat(Base, '_gnu.pl', GnuPath),\n    write_prolog_script(Gnu, GnuPath).\n```\n\n**Pattern 4: With validation first**\n```prolog\nsafe_generate(Preds, Dialect, Code) :-\n    validate_for_dialect(Dialect, Preds, Issues),\n    Issues = [],  % Fail if incompatible\n    generate_prolog_script(Preds, [dialect(Dialect)], Code).\n```", "answer_tailored": true}
