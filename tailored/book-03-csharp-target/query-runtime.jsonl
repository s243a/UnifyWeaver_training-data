{"pair_id": "query-runtime-overview_p0", "cluster_id": "query-runtime-overview", "question": "What is the C# Query Runtime?", "question_type": "medium", "answer": "The C# Query Runtime is the execution engine that processes Prolog queries compiled to an Intermediate Representation (IR). It translates Prolog rules into a query plan and executes them using a runtime engine:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\n**Why use IR?**\n- Enables **recursion** through fixpoint iteration\n- **Runtime optimization** independent of compilation\n- **Flexible execution** strategies\n\n**Key IR Operations:**\n\n| Operation | Function | SQL Analog |\n|-----------|----------|------------|\n| `RelationRef` | Retrieve tuples | `SELECT * FROM table` |\n| `Selection` | Apply filters | `WHERE condition` |\n| `Projection` | Select columns | `SELECT col1, col2` |\n| `Join` | Merge relations | `JOIN ON key` |\n| `Union` | Combine results | `UNION` |\n| `Distinct` | Deduplicate | `DISTINCT` |\n\n**Example Query Plan:**\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n**Executing Queries:**\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```\n\nSee education/book-03-csharp-target/03_query_engine_deep_dive.md for complete details.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["query-runtime", "ir", "intermediate-representation"], "original_answer": "## C# Query Runtime\n\nThe Query Runtime uses **Intermediate Representation (IR)**:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\n### Why IR?\n\n- **Supports recursion** via fixpoint iteration\n- **Shared runtime** can be optimized independently\n- **Flexible** query execution strategies\n\n### Core IR Components\n\n| Component | Purpose | SQL Equivalent |\n|-----------|---------|----------------|\n| `RelationRef` | Fetch tuples | `SELECT * FROM table` |\n| `Selection` | Filter rows | `WHERE condition` |\n| `Projection` | Reshape tuples | `SELECT col1, col2` |\n| `Join` | Combine tuples | `JOIN ON key` |\n| `Union` | Merge results | `UNION` |\n| `Distinct` | Remove duplicates | `DISTINCT` |\n\n### Example IR\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n### Execution\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```", "answer_tailored": true}
{"pair_id": "query-runtime-overview_p1", "cluster_id": "query-runtime-overview", "question": "What is IR (Intermediate Representation)?", "question_type": "medium", "answer": "IR (Intermediate Representation) is an abstract query plan format that sits between Prolog source code and the runtime execution engine. In UnifyWeaver's C# target, the compilation flow is:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\nThe IR acts as a platform-independent representation of queries, providing several key advantages:\n\n- **Recursion support** through fixpoint iteration algorithms\n- **Decoupled optimization** - the runtime can be improved without changing compilation\n- **Flexible execution** strategies (semi-naive evaluation, iterative refinement)\n\n### IR Node Types\n\nThe IR consists of relational algebra operators:\n\n| IR Node | Function | Maps to SQL |\n|---------|----------|-------------|\n| `RelationRef` | Retrieve tuples from a relation | `SELECT * FROM table` |\n| `Selection` | Apply filtering predicates | `WHERE condition` |\n| `Projection` | Transform tuple structure | `SELECT col1, col2` |\n| `Join` | Combine relations on keys | `JOIN ON key` |\n| `Union` | Aggregate multiple sources | `UNION` |\n| `Distinct` | Eliminate duplicate tuples | `DISTINCT` |\n\n### IR Example\n\nA simple query plan in C#:\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\nThe `QueryEngine` then interprets this IR to produce results:\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```\n\nFor implementation details, see education/book-03-csharp-target/03_query_engine_deep_dive.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["query-runtime", "ir", "intermediate-representation"], "original_answer": "## C# Query Runtime\n\nThe Query Runtime uses **Intermediate Representation (IR)**:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\n### Why IR?\n\n- **Supports recursion** via fixpoint iteration\n- **Shared runtime** can be optimized independently\n- **Flexible** query execution strategies\n\n### Core IR Components\n\n| Component | Purpose | SQL Equivalent |\n|-----------|---------|----------------|\n| `RelationRef` | Fetch tuples | `SELECT * FROM table` |\n| `Selection` | Filter rows | `WHERE condition` |\n| `Projection` | Reshape tuples | `SELECT col1, col2` |\n| `Join` | Combine tuples | `JOIN ON key` |\n| `Union` | Merge results | `UNION` |\n| `Distinct` | Remove duplicates | `DISTINCT` |\n\n### Example IR\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n### Execution\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```", "answer_tailored": true}
{"pair_id": "query-runtime-overview_p2", "cluster_id": "query-runtime-overview", "question": "How does Query Runtime differ from Stream Target?", "question_type": "medium", "answer": "The key difference is in **how queries are executed**:\n\n**Query Runtime (IR-based):**\n- Prolog compiles to an Intermediate Representation (IR) - a query plan with nodes like `RelationRef`, `Selection`, `Projection`, `Join`\n- A shared runtime engine executes the IR at runtime\n- Supports **recursive queries** through fixpoint iteration (semi-naive evaluation)\n- Runtime can be optimized independently of query structure\n\n**Stream Target (Direct code generation):**\n- Prolog compiles directly to target language code (C#, Python, etc.)\n- No runtime engine needed - generated code executes natively\n- More efficient for non-recursive queries\n- Limited recursion support (depends on target language capabilities)\n\n**When to use each:**\n- Query Runtime: Complex recursive queries, dynamic query optimization\n- Stream Target: Simple queries, maximum performance, minimal dependencies\n\nSee `education/book-03-csharp-target/03_query_engine_deep_dive.md` for Query Runtime details and `education/book-03-csharp-target/02_stream_target.md` for Stream Target compilation.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["query-runtime", "ir", "intermediate-representation"], "original_answer": "## C# Query Runtime\n\nThe Query Runtime uses **Intermediate Representation (IR)**:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\n### Why IR?\n\n- **Supports recursion** via fixpoint iteration\n- **Shared runtime** can be optimized independently\n- **Flexible** query execution strategies\n\n### Core IR Components\n\n| Component | Purpose | SQL Equivalent |\n|-----------|---------|----------------|\n| `RelationRef` | Fetch tuples | `SELECT * FROM table` |\n| `Selection` | Filter rows | `WHERE condition` |\n| `Projection` | Reshape tuples | `SELECT col1, col2` |\n| `Join` | Combine tuples | `JOIN ON key` |\n| `Union` | Merge results | `UNION` |\n| `Distinct` | Remove duplicates | `DISTINCT` |\n\n### Example IR\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n### Execution\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```", "answer_tailored": true}
{"pair_id": "query-runtime-overview_p3", "cluster_id": "query-runtime-overview", "question": "Why use IR instead of direct translation?", "question_type": "medium", "answer": "IR enables recursion and optimization that direct translation can't provide. UnifyWeaver translates Prolog \u2192 IR (Query Plan) \u2192 Runtime execution rather than directly to C# code because:\n\n**Key advantages:**\n- **Recursion support**: Fixpoint iteration handles recursive rules (direct translation would require complex code generation)\n- **Runtime optimization**: The execution engine can be tuned independently of query compilation\n- **Execution flexibility**: Different strategies (semi-naive, iterative) without regenerating code\n\n**IR Structure**\n\nThe query plan uses composable nodes:\n\n| IR Node | Function | SQL Analog |\n|---------|----------|------------|\n| `RelationRef` | Tuple source | `FROM table` |\n| `Selection` | Filtering | `WHERE` |\n| `Projection` | Column selection | `SELECT cols` |\n| `Join` | Tuple combination | `JOIN` |\n| `Union` | Result merging | `UNION` |\n| `Distinct` | Deduplication | `DISTINCT` |\n\n**Example:**\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```\n\nSee education/book-03-csharp-target/03_query_engine_deep_dive.md for complete IR details.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["query-runtime", "ir", "intermediate-representation"], "original_answer": "## C# Query Runtime\n\nThe Query Runtime uses **Intermediate Representation (IR)**:\n\n```\nProlog \u2192 IR (Query Plan) \u2192 Runtime Engine executes\n```\n\n### Why IR?\n\n- **Supports recursion** via fixpoint iteration\n- **Shared runtime** can be optimized independently\n- **Flexible** query execution strategies\n\n### Core IR Components\n\n| Component | Purpose | SQL Equivalent |\n|-----------|---------|----------------|\n| `RelationRef` | Fetch tuples | `SELECT * FROM table` |\n| `Selection` | Filter rows | `WHERE condition` |\n| `Projection` | Reshape tuples | `SELECT col1, col2` |\n| `Join` | Combine tuples | `JOIN ON key` |\n| `Union` | Merge results | `UNION` |\n| `Distinct` | Remove duplicates | `DISTINCT` |\n\n### Example IR\n\n```csharp\nvar plan = new QueryPlan {\n    Clauses = new[] {\n        new Clause {\n            Body = new RelationRef(\"parent\", 2)\n        }\n    }\n};\n```\n\n### Execution\n\n```csharp\nvar engine = new QueryEngine();\nvar results = engine.ExecuteSemiNaive(plan);\n```", "answer_tailored": true}
{"pair_id": "ir-components_p0", "cluster_id": "ir-components", "question": "What are the IR components in Query Runtime?", "question_type": "medium", "answer": "The Query Runtime uses five core IR (Intermediate Representation) components:\n\n**RelationRef** - Retrieves all tuples from a relation:\n```csharp\nnew RelationRef(\"parent\", 2)\n// Fetches all parent/2 tuples\n```\n\n**Selection** - Applies filtering conditions to tuples:\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Filter: Age >= 18\n)\n```\nThis corresponds to Prolog's: `adult(P) :- age(P, Age), Age >= 18.`\n\n**Projection** - Transforms tuple shape by selecting specific fields:\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Extract fields 1 and 3\n)\n```\n\n**Join** - Combines tuples from two sources based on matching keys:\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Match on P (child)\n    inner => inner.Item1,          // Match on P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // Output (GP, GC)\n)\n```\nEquivalent to: `grandparent(GP, GC) :- parent(GP, P), parent(P, GC).`\n\n**Union** - Merges results from multiple query clauses:\n```csharp\nnew Union(clause1, clause2)\n```\n\nThese components form the building blocks for translating Prolog queries into executable C# query plans. For implementation details, see education/book-03-csharp-target/.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["ir", "relationref", "selection", "join", "projection"], "original_answer": "## IR Components Explained\n\n### RelationRef - Fetch Tuples\n\n```csharp\nnew RelationRef(\"parent\", 2)\n// \u2192 All parent/2 tuples\n```\n\n### Selection - Filter Rows\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Age >= 18\n)\n```\n\n**Prolog equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\n### Projection - Reshape Tuples\n\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Keep fields 1 and 3\n)\n```\n\n### Join - Combine Tuples\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Key: P (child)\n    inner => inner.Item1,          // Key: P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n)\n```\n\n**Prolog equivalent:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n### Union - Merge Results\n\n```csharp\nnew Union(clause1, clause2)\n// Combines results from multiple clauses\n```", "answer_tailored": true}
{"pair_id": "ir-components_p1", "cluster_id": "ir-components", "question": "How does RelationRef work?", "question_type": "medium", "answer": "`RelationRef` is the fundamental IR component that fetches all tuples from a relation. It takes two parameters: the relation name and its arity.\n\n**Basic usage:**\n```csharp\nnew RelationRef(\"parent\", 2)\n// Returns all parent/2 tuples from the database\n```\n\nThis is equivalent to the Prolog query `parent(X, Y)` which retrieves all facts. The first parameter specifies which relation to access (e.g., \"parent\", \"age\", \"sibling\"), and the second parameter indicates how many arguments that relation has.\n\n`RelationRef` serves as the starting point for building more complex queries. It can be wrapped in other IR components like `Selection` (to filter tuples), `Projection` (to reshape them), or `Join` (to combine with other relations).\n\nFor example:\n```csharp\n// Get all parent relationships\nvar allParents = new RelationRef(\"parent\", 2);\n\n// Filter to find specific parents\nvar filteredParents = new Selection(\n    new RelationRef(\"parent\", 2),\n    tuple => tuple.Item1 == \"alice\"\n);\n```\n\nSee education/book-03-csharp-target/03_query_engine_deep_dive.md for complete details on the C# query engine architecture.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["ir", "relationref", "selection", "join", "projection"], "original_answer": "## IR Components Explained\n\n### RelationRef - Fetch Tuples\n\n```csharp\nnew RelationRef(\"parent\", 2)\n// \u2192 All parent/2 tuples\n```\n\n### Selection - Filter Rows\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Age >= 18\n)\n```\n\n**Prolog equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\n### Projection - Reshape Tuples\n\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Keep fields 1 and 3\n)\n```\n\n### Join - Combine Tuples\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Key: P (child)\n    inner => inner.Item1,          // Key: P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n)\n```\n\n**Prolog equivalent:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n### Union - Merge Results\n\n```csharp\nnew Union(clause1, clause2)\n// Combines results from multiple clauses\n```", "answer_tailored": true}
{"pair_id": "ir-components_p2", "cluster_id": "ir-components", "question": "How are joins represented in IR?", "question_type": "medium", "answer": "Joins in UnifyWeaver's IR use the `Join` operator to combine tuples from two relations based on matching keys:\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // Outer relation: parent(GP, P)\n    new RelationRef(\"parent\", 2),  // Inner relation: parent(P, GC)\n    outer => outer.Item2,          // Outer key: P (child in first relation)\n    inner => inner.Item1,          // Inner key: P (parent in second relation)\n    (outer, inner) => (outer.Item1, inner.Item2)  // Result projection: (GP, GC)\n)\n```\n\nThis represents the Prolog rule:\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\nThe Join operator takes:\n- Two source relations (outer and inner)\n- Key extractors for matching tuples (linking variable P)\n- A result selector that constructs output tuples from matched pairs\n\nThis corresponds to equi-joins in relational algebra, where tuples are combined when their join keys are equal. For more on IR operators and query compilation patterns, see education/book-03-csharp-target/03_query_engine_deep_dive.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["ir", "relationref", "selection", "join", "projection"], "original_answer": "## IR Components Explained\n\n### RelationRef - Fetch Tuples\n\n```csharp\nnew RelationRef(\"parent\", 2)\n// \u2192 All parent/2 tuples\n```\n\n### Selection - Filter Rows\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Age >= 18\n)\n```\n\n**Prolog equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\n### Projection - Reshape Tuples\n\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Keep fields 1 and 3\n)\n```\n\n### Join - Combine Tuples\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Key: P (child)\n    inner => inner.Item1,          // Key: P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n)\n```\n\n**Prolog equivalent:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n### Union - Merge Results\n\n```csharp\nnew Union(clause1, clause2)\n// Combines results from multiple clauses\n```", "answer_tailored": true}
{"pair_id": "ir-components_p3", "cluster_id": "ir-components", "question": "What is Selection in IR?", "question_type": "medium", "answer": "Selection is a filtering operation in UnifyWeaver's intermediate representation (IR) that restricts tuples based on a condition. It takes a source relation and applies a predicate function to each tuple, keeping only those that satisfy the condition.\n\n**C# Example:**\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Keep only rows where age >= 18\n)\n```\n\nThis filters the `age/2` relation to include only tuples where the second element (age value) is at least 18.\n\n**Prolog Equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\nSelection corresponds to Prolog's conditional filtering within clause bodies. Other IR operations include RelationRef (fetch tuples), Projection (reshape tuples), Join (combine relations), and Union (merge results). For complete details on C# query compilation, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["ir", "relationref", "selection", "join", "projection"], "original_answer": "## IR Components Explained\n\n### RelationRef - Fetch Tuples\n\n```csharp\nnew RelationRef(\"parent\", 2)\n// \u2192 All parent/2 tuples\n```\n\n### Selection - Filter Rows\n\n```csharp\nnew Selection(\n    new RelationRef(\"age\", 2),\n    tuple => tuple.Item2 >= 18  // Age >= 18\n)\n```\n\n**Prolog equivalent:**\n```prolog\nadult(P) :- age(P, Age), Age >= 18.\n```\n\n### Projection - Reshape Tuples\n\n```csharp\nnew Projection(\n    source,\n    tuple => (tuple.Item1, tuple.Item3)  // Keep fields 1 and 3\n)\n```\n\n### Join - Combine Tuples\n\n```csharp\nnew Join(\n    new RelationRef(\"parent\", 2),  // parent(GP, P)\n    new RelationRef(\"parent\", 2),  // parent(P, GC)\n    outer => outer.Item2,          // Key: P (child)\n    inner => inner.Item1,          // Key: P (parent)\n    (outer, inner) => (outer.Item1, inner.Item2)  // (GP, GC)\n)\n```\n\n**Prolog equivalent:**\n```prolog\ngrandparent(GP, GC) :- parent(GP, P), parent(P, GC).\n```\n\n### Union - Merge Results\n\n```csharp\nnew Union(clause1, clause2)\n// Combines results from multiple clauses\n```", "answer_tailored": true}
{"pair_id": "fixpoint-iteration_p0", "cluster_id": "fixpoint-iteration", "question": "What is fixpoint iteration?", "question_type": "medium", "answer": "Fixpoint iteration is the process used for recursive predicates where the query engine repeatedly evaluates rules until no new results are generated. \n\nWhen a recursive predicate like `ancestor/2` is compiled, the engine starts with base facts and iteratively applies recursive rules. Each iteration produces new tuples by joining existing data. The process continues until an iteration produces zero new tuples\u2014this stable state is called the \"fixpoint.\"\n\n**Example with ancestor/2:**\n\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\nStarting with `parent: (alice, bob), (bob, charlie), (charlie, dave)`:\n\n- **Iteration 1:** Produces `{(alice, bob), (bob, charlie), (charlie, dave)}`\n- **Iteration 2:** Adds `{(alice, charlie), (bob, dave)}`\n- **Iteration 3:** Adds `{(alice, dave)}`\n- **Iteration 4:** No new tuples \u2192 fixpoint reached\n\n**Semi-Naive Optimization:** Instead of re-joining all tuples every iteration (naive approach), semi-naive evaluation only joins with newly-produced tuples from the previous iteration. This dramatically reduces computational cost\u2014for example, iteration 3 performs only 3 joins instead of 45 with the naive approach.\n\nFor implementation details across different targets, see `education/book-03-csharp-target/03_query_engine_deep_dive.md`.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["fixpoint", "semi-naive", "recursion", "iteration"], "original_answer": "## Fixpoint Iteration\n\nFor recursive predicates, the engine iterates until no new tuples are produced.\n\n### Example: ancestor/2\n\n**Prolog:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\n### Iteration Trace\n\n**Iteration 0 (Base):**\n```\nparent: (alice, bob), (bob, charlie), (charlie, dave)\nancestor: {} (empty)\n```\n\n**Iteration 1:**\n```\nancestor = {(alice, bob), (bob, charlie), (charlie, dave)}\n```\n\n**Iteration 2:**\n```\nancestor += {(alice, charlie), (bob, dave)}\n```\n\n**Iteration 3:**\n```\nancestor += {(alice, dave)}\n```\n\n**Iteration 4:**\n```\nNo new tuples \u2192 Fixpoint reached!\n```\n\n### Semi-Naive Optimization\n\n**Naive:** Re-join ALL tuples every iteration (slow)\n\n**Semi-naive:** Only join with NEW tuples from last iteration (fast)\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**Much faster for deep recursion!**", "answer_tailored": true}
{"pair_id": "fixpoint-iteration_p1", "cluster_id": "fixpoint-iteration", "question": "How does semi-naive evaluation work?", "question_type": "medium", "answer": "Semi-naive evaluation is an optimization technique for recursive queries that significantly improves performance by avoiding redundant work during fixpoint iteration.\n\n**The Key Difference:**\n\n- **Naive approach:** Re-joins ALL existing tuples in every iteration\n- **Semi-naive approach:** Only joins with the NEW tuples produced in the previous iteration\n\n**Performance Impact:**\n\nFor the `ancestor/2` example (transitive closure of parent relationships), the difference is dramatic:\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\nAs the relation grows, naive evaluation performs exponentially more work, while semi-naive stays efficient by focusing only on the delta (newly derived facts) from each step.\n\n**Why It Works:**\n\nIn recursive rules like `ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z)`, if we've already computed all ancestors reachable through existing tuples, we only need to check what new ancestors become reachable through the tuples we just added. This eliminates redundant computation.\n\nThis optimization is essential for deep recursion scenarios. For implementation details in C#, see education/book-03-csharp-target/03_query_engine_deep_dive.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["fixpoint", "semi-naive", "recursion", "iteration"], "original_answer": "## Fixpoint Iteration\n\nFor recursive predicates, the engine iterates until no new tuples are produced.\n\n### Example: ancestor/2\n\n**Prolog:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\n### Iteration Trace\n\n**Iteration 0 (Base):**\n```\nparent: (alice, bob), (bob, charlie), (charlie, dave)\nancestor: {} (empty)\n```\n\n**Iteration 1:**\n```\nancestor = {(alice, bob), (bob, charlie), (charlie, dave)}\n```\n\n**Iteration 2:**\n```\nancestor += {(alice, charlie), (bob, dave)}\n```\n\n**Iteration 3:**\n```\nancestor += {(alice, dave)}\n```\n\n**Iteration 4:**\n```\nNo new tuples \u2192 Fixpoint reached!\n```\n\n### Semi-Naive Optimization\n\n**Naive:** Re-join ALL tuples every iteration (slow)\n\n**Semi-naive:** Only join with NEW tuples from last iteration (fast)\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**Much faster for deep recursion!**", "answer_tailored": true}
{"pair_id": "fixpoint-iteration_p2", "cluster_id": "fixpoint-iteration", "question": "Why is semi-naive faster than naive?", "question_type": "medium", "answer": "Semi-naive evaluation is faster because it only joins with **new tuples** from the previous iteration, while naive evaluation re-joins **all tuples** every time.\n\n### Performance Comparison\n\nFor the `ancestor/2` example with recursive rules:\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**The difference grows exponentially:** By iteration 4, naive performs 135 joins while semi-naive is already done with 0 additional joins needed.\n\n### Why This Matters\n\nIn naive evaluation, each iteration re-processes all previously computed tuples, leading to redundant work. Semi-naive tracks which tuples are new (the \"delta\") and only joins those against existing relations. This avoids recomputing facts already established in earlier iterations.\n\n**Result:** Semi-naive achieves the same fixpoint much faster, especially critical for deeply recursive queries like transitive closures.\n\nFor implementation details, see `education/book-03-csharp-target/03_query_engine_deep_dive.md` section on fixpoint iteration.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["fixpoint", "semi-naive", "recursion", "iteration"], "original_answer": "## Fixpoint Iteration\n\nFor recursive predicates, the engine iterates until no new tuples are produced.\n\n### Example: ancestor/2\n\n**Prolog:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\n### Iteration Trace\n\n**Iteration 0 (Base):**\n```\nparent: (alice, bob), (bob, charlie), (charlie, dave)\nancestor: {} (empty)\n```\n\n**Iteration 1:**\n```\nancestor = {(alice, bob), (bob, charlie), (charlie, dave)}\n```\n\n**Iteration 2:**\n```\nancestor += {(alice, charlie), (bob, dave)}\n```\n\n**Iteration 3:**\n```\nancestor += {(alice, dave)}\n```\n\n**Iteration 4:**\n```\nNo new tuples \u2192 Fixpoint reached!\n```\n\n### Semi-Naive Optimization\n\n**Naive:** Re-join ALL tuples every iteration (slow)\n\n**Semi-naive:** Only join with NEW tuples from last iteration (fast)\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**Much faster for deep recursion!**", "answer_tailored": true}
{"pair_id": "fixpoint-iteration_p3", "cluster_id": "fixpoint-iteration", "question": "When does fixpoint iteration terminate?", "question_type": "medium", "answer": "Fixpoint iteration terminates when no new tuples are produced in an iteration. The engine continues looping through recursive predicates until a complete iteration yields zero additions to the result set.\n\nFor example, with the `ancestor/2` predicate:\n- **Iteration 1**: Produces direct parent relationships as ancestors\n- **Iteration 2**: Derives grandparent relationships  \n- **Iteration 3**: Derives great-grandparent relationships\n- **Iteration 4**: Attempts to find new ancestors but produces nothing \u2192 **iteration stops**\n\nThis \"fixpoint\" is the stable state where the recursive computation is complete. The semi-naive optimization speeds this up by only joining new tuples from the previous iteration rather than re-processing the entire relation each time, dramatically reducing redundant work in deep recursion scenarios.\n\nSee `education/book-03-csharp-target/03_query_engine_deep_dive.md` for the full iteration trace and optimization details.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["fixpoint", "semi-naive", "recursion", "iteration"], "original_answer": "## Fixpoint Iteration\n\nFor recursive predicates, the engine iterates until no new tuples are produced.\n\n### Example: ancestor/2\n\n**Prolog:**\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n```\n\n### Iteration Trace\n\n**Iteration 0 (Base):**\n```\nparent: (alice, bob), (bob, charlie), (charlie, dave)\nancestor: {} (empty)\n```\n\n**Iteration 1:**\n```\nancestor = {(alice, bob), (bob, charlie), (charlie, dave)}\n```\n\n**Iteration 2:**\n```\nancestor += {(alice, charlie), (bob, dave)}\n```\n\n**Iteration 3:**\n```\nancestor += {(alice, dave)}\n```\n\n**Iteration 4:**\n```\nNo new tuples \u2192 Fixpoint reached!\n```\n\n### Semi-Naive Optimization\n\n**Naive:** Re-join ALL tuples every iteration (slow)\n\n**Semi-naive:** Only join with NEW tuples from last iteration (fast)\n\n| Iteration | Naive Joins | Semi-Naive Joins |\n|-----------|-------------|------------------|\n| 1 | 3 | 3 |\n| 2 | 15 | 6 |\n| 3 | 45 | 3 |\n| 4 | 135 | 0 (done) |\n\n**Much faster for deep recursion!**", "answer_tailored": true}
{"pair_id": "mutual-recursion-csharp_p0", "cluster_id": "mutual-recursion-csharp", "question": "How does C# Query Runtime handle mutual recursion?", "question_type": "medium", "answer": "The C# Query Runtime uses a semi-naive evaluation strategy with specialized plan nodes to handle mutual recursion between predicates.\n\n### Specialized Plan Nodes\n\nThe runtime introduces three key node types for mutually recursive predicates:\n\n- **`MutualFixpointNode`**: Coordinates the entire strongly connected component (SCC)\n- **`MutualMember`**: Represents each predicate with its base and recursive plans\n- **`CrossRefNode`**: Allows one predicate to reference another within the SCC\n\n### Execution Strategy\n\nThe runtime computes fixpoints iteratively, tracking delta sets for each predicate:\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nThis semi-naive approach ensures only newly derived tuples participate in each iteration, avoiding redundant computation.\n\n### Example: Even/Odd Predicates\n\nFor mutually recursive predicates like `is_even/1` and `is_odd/1`, the planner generates:\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\nThe runtime evaluates both predicates together, propagating facts between them until no new tuples are derived.\n\nFor implementation details, see education/book-03-csharp-target/03_query_engine_deep_dive.md.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["mutual-recursion", "scc", "mutualfixpointnode", "crossrefnode"], "original_answer": "## Mutual Recursion in Query Runtime (v0.1)\n\nThe runtime handles strongly connected predicate groups.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### Key Plan Nodes\n\n- **`MutualFixpointNode`**: Orchestrates the group\n- **`MutualMember`**: Describes each predicate (base + recursive plans)\n- **`CrossRefNode`**: References another predicate in the SCC\n\n### Generated Plan\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Execution Model\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nOnly **new tuples** participate in each iteration (semi-naive).", "answer_tailored": true}
{"pair_id": "mutual-recursion-csharp_p1", "cluster_id": "mutual-recursion-csharp", "question": "What is MutualFixpointNode?", "question_type": "medium", "answer": "**MutualFixpointNode** is a query plan node that orchestrates the evaluation of mutually recursive predicates within a strongly connected component (SCC). It coordinates the iterative, semi-naive evaluation of all predicates in the group.\n\n### Structure\n\nA `MutualFixpointNode` contains:\n- **Members**: An array of `MutualMember` objects, each representing one predicate in the SCC with its base and recursive plans\n- **Target predicate**: The specific predicate being queried from the group\n\n### Example Usage\n\nFor mutually recursive `is_even/1` and `is_odd/1` predicates:\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Evaluation Strategy\n\nThe node iterates until no new tuples are derived, using delta sets to track only new results from each iteration:\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Recursive plans use deltas; new tuples added to next delta\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nThis semi-naive approach ensures efficient computation by avoiding redundant work. See education/book-03-csharp-target/03_query_engine_deep_dive.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["mutual-recursion", "scc", "mutualfixpointnode", "crossrefnode"], "original_answer": "## Mutual Recursion in Query Runtime (v0.1)\n\nThe runtime handles strongly connected predicate groups.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### Key Plan Nodes\n\n- **`MutualFixpointNode`**: Orchestrates the group\n- **`MutualMember`**: Describes each predicate (base + recursive plans)\n- **`CrossRefNode`**: References another predicate in the SCC\n\n### Generated Plan\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Execution Model\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nOnly **new tuples** participate in each iteration (semi-naive).", "answer_tailored": true}
{"pair_id": "mutual-recursion-csharp_p2", "cluster_id": "mutual-recursion-csharp", "question": "What is CrossRefNode?", "question_type": "medium", "answer": "`CrossRefNode` is a plan node used within mutually recursive predicate groups to reference another predicate in the same strongly connected component (SCC). When one predicate needs to call another predicate that's part of the same mutual recursion group, the query planner inserts a `CrossRefNode` to handle that cross-reference.\n\nFor example, in a mutual recursion between `is_even` and `is_odd`:\n\n```prolog\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nThe recursive plan for `is_even` contains a `CrossRefNode` pointing to `is_odd`, and vice versa. These nodes work together with `MutualFixpointNode` (which orchestrates the entire SCC) and `MutualMember` (which describes each predicate's base and recursive plans).\n\nDuring execution, `CrossRefNode` instances enable the semi-naive evaluation loop to properly track and propagate new tuples between mutually dependent predicates. See education/book-03-csharp-target/03_query_engine_deep_dive.md for the complete execution model.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["mutual-recursion", "scc", "mutualfixpointnode", "crossrefnode"], "original_answer": "## Mutual Recursion in Query Runtime (v0.1)\n\nThe runtime handles strongly connected predicate groups.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### Key Plan Nodes\n\n- **`MutualFixpointNode`**: Orchestrates the group\n- **`MutualMember`**: Describes each predicate (base + recursive plans)\n- **`CrossRefNode`**: References another predicate in the SCC\n\n### Generated Plan\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Execution Model\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nOnly **new tuples** participate in each iteration (semi-naive).", "answer_tailored": true}
{"pair_id": "mutual-recursion-csharp_p3", "cluster_id": "mutual-recursion-csharp", "question": "How are SCCs evaluated in C#?", "question_type": "medium", "answer": "In C#, strongly connected components (SCCs) are evaluated using a fixpoint iteration with semi-naive evaluation. The runtime employs three specialized plan nodes:\n\n- **`MutualFixpointNode`**: Coordinates the entire SCC evaluation\n- **`MutualMember`**: Represents each predicate with its base and recursive plans\n- **`CrossRefNode`**: Handles cross-references between predicates in the SCC\n\nFor mutually recursive predicates like `is_even/1` and `is_odd/1`, the compiler generates a `MutualFixpointNode` containing both predicates as members. During execution, the runtime iterates until no new tuples are produced:\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nThe semi-naive approach ensures that only newly derived tuples (deltas) participate in each iteration, avoiding redundant computation. See `education/book-03-csharp-target/03_query_engine_deep_dive.md` for the complete implementation details.", "answer_variant": "default", "answer_source": "education/book-03-csharp-target/03_query_engine_deep_dive.md", "topics": ["mutual-recursion", "scc", "mutualfixpointnode", "crossrefnode"], "original_answer": "## Mutual Recursion in Query Runtime (v0.1)\n\nThe runtime handles strongly connected predicate groups.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### Key Plan Nodes\n\n- **`MutualFixpointNode`**: Orchestrates the group\n- **`MutualMember`**: Describes each predicate (base + recursive plans)\n- **`CrossRefNode`**: References another predicate in the SCC\n\n### Generated Plan\n\n```csharp\nnew MutualFixpointNode(new[] {\n    new MutualMember(isEvenId, evenBasePlan, evenRecursivePlans),\n    new MutualMember(isOddId, oddBasePlan, oddRecursivePlans)\n}, isEvenId);\n```\n\n### Execution Model\n\n```csharp\nwhile (context.Deltas.Values.Any(delta => delta.Count > 0))\n{\n    foreach (var member in node.Members)\n    {\n        // Evaluate recursive plans using deltas\n        foreach (var tuple in Evaluate(plan, context))\n        {\n            if (TryAddRow(totals[pred], tuple))\n                nextDeltas[pred].Add(tuple);\n        }\n    }\n    context.Deltas = nextDeltas;\n}\n```\n\nOnly **new tuples** participate in each iteration (semi-naive).", "answer_tailored": true}
