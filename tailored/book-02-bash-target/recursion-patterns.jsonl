{"pair_id": "tail-recursion_p0", "cluster_id": "tail-recursion", "question": "What is tail recursion optimization in UnifyWeaver?", "question_type": "medium", "answer": "Tail recursion optimization is UnifyWeaver's ability to convert recursive calls into efficient iterative loops when the recursive call appears as the final operation in a predicate.\n\n## Key Benefits\n\nWhen UnifyWeaver detects tail recursion, it generates loop-based code instead of recursive functions:\n- Eliminates stack frame overhead\n- Prevents stack overflow errors\n- Significantly improves execution speed\n\n## The Accumulator Technique\n\nTail recursion typically uses an accumulator parameter to carry intermediate results:\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base: empty list returns the accumulated count\ncount_items([], Acc, Acc).\n\n% Step: increment accumulator and recurse (tail position)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % Final operation = tail call\n```\n\n## Bash Translation: While Loop\n\nUnifyWeaver transforms this into an iterative loop:\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iteration replaces recursion\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Get list tail\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Increment accumulator\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\nSee education/book-02-bash-target/06_advanced_recursion.md for complete examples and additional recursion patterns.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "accumulator", "optimization", "iterative-loop"], "original_answer": "## Tail Recursion Optimization\n\nTail recursion is when the recursive call is the last action in a function.\n\n### Why It Matters\n\nTail recursion can be converted to an iterative loop:\n- No stack overhead\n- No stack overflow risk\n- Much faster execution\n\n### The Accumulator Pattern\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Generated Bash: Iterative Loop\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Step: Acc1 is Acc + 1\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Usage\n\n```bash\nsource count_items.sh\ncount_items \"[a,b,c,d,e]\" 0 \"\"\n# Output: [a,b,c,d,e]:0:5\n```", "answer_tailored": true}
{"pair_id": "tail-recursion_p1", "cluster_id": "tail-recursion", "question": "How does UnifyWeaver compile tail-recursive predicates?", "question_type": "medium", "answer": "UnifyWeaver detects when a recursive call is in tail position (the last operation in a clause) and transforms it into an iterative loop instead of a recursive function call. This optimization eliminates stack frames and prevents stack overflow.\n\n## Tail Position Detection\n\nThe compiler identifies tail recursion when the recursive predicate call is the final goal in a clause, with no operations following it:\n\n```prolog\ncount_items([], Acc, Acc).\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % Tail position - nothing after this\n```\n\n## Loop Conversion Strategy\n\nInstead of generating recursive function calls, UnifyWeaver emits a `while` loop that:\n- Uses local variables to track the changing parameters\n- Continues until the base case condition is met\n- Updates variables in place rather than creating new stack frames\n\n## Generated Code Example\n\nFor the tail-recursive `count_items/3` predicate above, the Bash target produces:\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop replaces tail recursion\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Destructure list to get tail\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Increment accumulator\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n## Benefits\n\nThis transformation provides constant stack space usage, eliminates recursion depth limits, and significantly improves performance for large inputs. See education/book-02-bash-target/06_advanced_recursion.md for complete examples across different target languages.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "accumulator", "optimization", "iterative-loop"], "original_answer": "## Tail Recursion Optimization\n\nTail recursion is when the recursive call is the last action in a function.\n\n### Why It Matters\n\nTail recursion can be converted to an iterative loop:\n- No stack overhead\n- No stack overflow risk\n- Much faster execution\n\n### The Accumulator Pattern\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Generated Bash: Iterative Loop\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Step: Acc1 is Acc + 1\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Usage\n\n```bash\nsource count_items.sh\ncount_items \"[a,b,c,d,e]\" 0 \"\"\n# Output: [a,b,c,d,e]:0:5\n```", "answer_tailored": true}
{"pair_id": "tail-recursion_p2", "cluster_id": "tail-recursion", "question": "What is an accumulator pattern?", "question_type": "medium", "answer": "The accumulator pattern is a technique used with tail recursion where you pass an extra parameter to accumulate results as you recurse through a data structure.\n\n### How It Works\n\nInstead of building up the result on the way back from recursive calls, you carry the result forward in an accumulator parameter:\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Key Benefits\n\n- Enables tail recursion optimization since the recursive call is the last operation\n- UnifyWeaver can convert this to an iterative loop in target languages\n- Eliminates stack overhead and prevents stack overflow\n- Results in much faster execution\n\n### Generated Code\n\nUnifyWeaver recognizes the accumulator pattern and generates efficient iterative loops instead of recursive functions. For example, in Bash:\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; then\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\nFor more on tail recursion optimization, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "accumulator", "optimization", "iterative-loop"], "original_answer": "## Tail Recursion Optimization\n\nTail recursion is when the recursive call is the last action in a function.\n\n### Why It Matters\n\nTail recursion can be converted to an iterative loop:\n- No stack overhead\n- No stack overflow risk\n- Much faster execution\n\n### The Accumulator Pattern\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Generated Bash: Iterative Loop\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Step: Acc1 is Acc + 1\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Usage\n\n```bash\nsource count_items.sh\ncount_items \"[a,b,c,d,e]\" 0 \"\"\n# Output: [a,b,c,d,e]:0:5\n```", "answer_tailored": true}
{"pair_id": "tail-recursion_p3", "cluster_id": "tail-recursion", "question": "How is tail recursion converted to a loop?", "question_type": "medium", "answer": "## Converting Tail Recursion to Loops\n\nWhen a recursive call is the final operation in a Prolog clause, UnifyWeaver can transform it into an iterative loop instead of using actual recursion.\n\n### The Transformation Process\n\n**Tail-recursive Prolog:**\n```prolog\ncount_items([], Acc, Acc).\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % Last operation - tail call\n```\n\n**Generated Bash (loop-based):**\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Loop replaces recursive calls\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Update accumulator\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Key Conversion Steps\n\n1. **Identify tail position** - The recursive call must be the last action\n2. **Use accumulator pattern** - Carry intermediate results forward\n3. **Replace recursion with while loop** - Iterate instead of calling self\n4. **Update loop variables** - What would be new arguments become reassignments\n\n### Benefits\n\n- Eliminates stack frames (no call overhead)\n- Prevents stack overflow on deep recursion\n- Significantly faster execution\n\nSee education/book-02-bash-target/06_advanced_recursion.md for complete examples and patterns.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tail-recursion", "accumulator", "optimization", "iterative-loop"], "original_answer": "## Tail Recursion Optimization\n\nTail recursion is when the recursive call is the last action in a function.\n\n### Why It Matters\n\nTail recursion can be converted to an iterative loop:\n- No stack overhead\n- No stack overflow risk\n- Much faster execution\n\n### The Accumulator Pattern\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Generated Bash: Iterative Loop\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Step: Acc1 is Acc + 1\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Usage\n\n```bash\nsource count_items.sh\ncount_items \"[a,b,c,d,e]\" 0 \"\"\n# Output: [a,b,c,d,e]:0:5\n```", "answer_tailored": true}
{"pair_id": "linear-recursion_p0", "cluster_id": "linear-recursion", "question": "How does UnifyWeaver compile linear recursion?", "question_type": "medium", "answer": "UnifyWeaver compiles linear recursion (where each clause has exactly one recursive call) using a fold-based approach that transforms the recursion into iterative operations.\n\n## Compilation Strategy\n\nThe compiler generates three key components:\n\n1. **Range Builder** - Creates a sequence of values from N down to the base case (e.g., N, N-1, ..., 1)\n2. **Fold Operation** - Applies the recursive computation as an accumulator function\n3. **Memoization Layer** - Caches computed results to avoid redundant calculations\n\n## Example: Factorial Compilation\n\nGiven the Prolog definition:\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\nUnifyWeaver generates Bash code with:\n\n```bash\n# Generic fold operation\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Generates descending sequence\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Per-iteration operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main predicate with caching\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    [[ -n \"${factorial_memo[$n]}\" ]] && {\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    }\n    \n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\nThis approach eliminates stack growth while preserving the logical semantics of the recursive definition. See education/book-02-bash-target/06_advanced_recursion.md for more recursion patterns.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["linear-recursion", "fold", "memoization", "factorial"], "original_answer": "## Linear Recursion with Fold-Based Compilation\n\nLinear recursion: exactly one recursive call per clause.\n\n### Example: Factorial\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Fold-Based Approach\n\nUnifyWeaver generates:\n1. **Range builder** - generates N, N-1, ..., 1\n2. **Fold operation** - multiplies accumulator\n3. **Memoization** - caches results\n\n### Generated Bash\n\n```bash\n# Fold helper\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Fold operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main with memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memo\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Fold computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```", "answer_tailored": true}
{"pair_id": "linear-recursion_p1", "cluster_id": "linear-recursion", "question": "What is fold-based compilation?", "question_type": "medium", "answer": "Fold-based compilation is UnifyWeaver's approach to transforming linear recursive Prolog predicates (those with exactly one recursive call per clause) into iterative loop-based code using functional programming patterns.\n\nFor a linear recursive predicate like factorial, UnifyWeaver generates three components:\n\n1. **Range builder** - Creates the sequence of values to iterate over (e.g., N down to 1)\n2. **Fold operation** - Defines how to combine each value with an accumulator\n3. **Memoization layer** - Caches computed results to avoid redundant calculations\n\nIn Bash, this translates to a `fold_left` helper function that processes a sequence by repeatedly applying an operation function to update an accumulator. For factorial(N), the range builder uses `seq \"$n\" -1 1` to generate descending integers, and the fold operation multiplies each value with the running product.\n\nThis technique converts potentially stack-intensive recursion into efficient iteration while preserving the declarative semantics of the original Prolog code. The generated code includes memoization via associative arrays to optimize repeated queries.\n\nSee education/book-02-bash-target/06_advanced_recursion.md for complete implementation details and examples showing factorial computations with memoization.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["linear-recursion", "fold", "memoization", "factorial"], "original_answer": "## Linear Recursion with Fold-Based Compilation\n\nLinear recursion: exactly one recursive call per clause.\n\n### Example: Factorial\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Fold-Based Approach\n\nUnifyWeaver generates:\n1. **Range builder** - generates N, N-1, ..., 1\n2. **Fold operation** - multiplies accumulator\n3. **Memoization** - caches results\n\n### Generated Bash\n\n```bash\n# Fold helper\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Fold operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main with memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memo\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Fold computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```", "answer_tailored": true}
{"pair_id": "linear-recursion_p2", "cluster_id": "linear-recursion", "question": "How is factorial compiled to Bash?", "question_type": "medium", "answer": "UnifyWeaver compiles factorial to Bash using a fold-based approach for linear recursion. The Prolog predicate `factorial(N, F)` with base case `factorial(0, 1)` transforms into three components:\n\n**1. Range Builder**\nGenerates the sequence N, N-1, ..., 1 using `seq`:\n```bash\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n```\n\n**2. Fold Operation**\nMultiplies each value with the accumulator:\n```bash\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n```\n\n**3. Main Function with Memoization**\nUses associative arrays to cache results and applies the fold:\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\nThe `fold_left` helper iterates through the range, applying the operation to build the final result. This approach avoids deep call stacks while preserving the recursive semantics. See education/book-02-bash-target/06_advanced_recursion.md for complete details on linear recursion patterns.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["linear-recursion", "fold", "memoization", "factorial"], "original_answer": "## Linear Recursion with Fold-Based Compilation\n\nLinear recursion: exactly one recursive call per clause.\n\n### Example: Factorial\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Fold-Based Approach\n\nUnifyWeaver generates:\n1. **Range builder** - generates N, N-1, ..., 1\n2. **Fold operation** - multiplies accumulator\n3. **Memoization** - caches results\n\n### Generated Bash\n\n```bash\n# Fold helper\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Fold operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main with memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memo\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Fold computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```", "answer_tailored": true}
{"pair_id": "linear-recursion_p3", "cluster_id": "linear-recursion", "question": "What is memoization in generated code?", "question_type": "medium", "answer": "Memoization in generated code is a caching technique where UnifyWeaver stores previously computed results to avoid redundant calculations. When a function is called with the same arguments again, the cached result is returned immediately instead of recomputing.\n\nIn Bash target code, memoization uses associative arrays (hash maps) to cache results:\n\n```bash\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check if result already cached\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Compute and cache result\n    # ... computation logic ...\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\nThis optimization is particularly valuable for recursive predicates where the same subproblems may be encountered multiple times. The compiler automatically generates memoization logic for linear recursive clauses when using fold-based compilation.\n\nFor example, computing `factorial(5)` caches intermediate results, so subsequent calls like `factorial(3)` return instantly from the memo table rather than recalculating.\n\nSee education/book-02-bash-target/06_advanced_recursion.md for complete examples of memoization in fold-based recursive compilation.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["linear-recursion", "fold", "memoization", "factorial"], "original_answer": "## Linear Recursion with Fold-Based Compilation\n\nLinear recursion: exactly one recursive call per clause.\n\n### Example: Factorial\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Fold-Based Approach\n\nUnifyWeaver generates:\n1. **Range builder** - generates N, N-1, ..., 1\n2. **Fold operation** - multiplies accumulator\n3. **Memoization** - caches results\n\n### Generated Bash\n\n```bash\n# Fold helper\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Fold operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main with memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memo\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Fold computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```", "answer_tailored": true}
{"pair_id": "tree-recursion_p0", "cluster_id": "tree-recursion", "question": "How does UnifyWeaver handle tree recursion?", "question_type": "medium", "answer": "UnifyWeaver handles tree recursion by supporting multiple recursive calls per clause on structural components. This pattern processes hierarchical data structures like binary trees.\n\nFor a tree sum example, the Prolog representation uses `[Value, LeftSubtree, RightSubtree]`:\n\n```prolog\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\nThe Bash compilation generates code that:\n1. Handles the base case (empty tree returns 0)\n2. Parses the tree structure to extract value and subtrees\n3. Makes recursive calls on left and right subtrees\n4. Combines results arithmetically\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    echo $(( $value + $left_result + $right_result ))\n}\n```\n\nThe key challenge is parsing nested bracket structures, which requires tracking depth to correctly split the tree components. The `parse_tree` helper function manages this by counting bracket levels and splitting on commas only at depth 0.\n\nExample: `tree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"` computes 5+3+1+2 = 11.\n\nSee education/book-02-bash-target/06_advanced_recursion.md for complete implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tree-recursion", "binary-tree", "structural-decomposition"], "original_answer": "## Tree Recursion\n\nTree recursion: multiple recursive calls per clause on structural parts.\n\n### Example: tree_sum\n\n```prolog\n% Tree as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth for nested structures\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\n### Usage\n\n```bash\n#       5\n#      / \\\n#     3   2\n#    /\n#   1\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```", "answer_tailored": true}
{"pair_id": "tree-recursion_p1", "cluster_id": "tree-recursion", "question": "How is tree_sum compiled to Bash?", "question_type": "medium", "answer": "The `tree_sum` predicate compiles to Bash with recursive function calls and a helper parser. For a tree represented as `[Value, LeftSubtree, RightSubtree]`, the compilation generates:\n\n**Main Function:**\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n```\n\n**Parser Helper:**\n```bash\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\nThe Prolog clauses map to: (1) a base case check returning 0 for empty trees, (2) structure parsing via bracket-depth tracking, (3) recursive evaluation of left and right subtrees, and (4) arithmetic combination. Example: `tree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"` outputs `11`. More recursion patterns in education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tree-recursion", "binary-tree", "structural-decomposition"], "original_answer": "## Tree Recursion\n\nTree recursion: multiple recursive calls per clause on structural parts.\n\n### Example: tree_sum\n\n```prolog\n% Tree as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth for nested structures\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\n### Usage\n\n```bash\n#       5\n#      / \\\n#     3   2\n#    /\n#   1\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```", "answer_tailored": true}
{"pair_id": "tree-recursion_p2", "cluster_id": "tree-recursion", "question": "What is structural decomposition in recursion?", "question_type": "medium", "answer": "Structural decomposition in recursion means breaking down complex data structures into their constituent parts and recursively processing each part. In tree recursion, for example, a tree node is decomposed into its value and subtrees, with separate recursive calls handling each structural component.\n\nHere's how it works in practice with `tree_sum`, which computes the sum of all values in a binary tree:\n\n```prolog\n% Tree represented as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),    % Decompose: process left subtree\n    tree_sum(R, RS),    % Decompose: process right subtree\n    Sum is V + LS + RS. % Combine results\n```\n\nThe Bash translation maintains this structural decomposition pattern:\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Decompose tree into value and subtrees\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on decomposed parts\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + left_result + right_result ))\n}\n\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\nExample usage:\n```bash\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"  # Tree: 5 with left child 3 (with left child 1) and right child 2\n# Output: 11\n```\n\nFor more on advanced recursion patterns, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tree-recursion", "binary-tree", "structural-decomposition"], "original_answer": "## Tree Recursion\n\nTree recursion: multiple recursive calls per clause on structural parts.\n\n### Example: tree_sum\n\n```prolog\n% Tree as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth for nested structures\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\n### Usage\n\n```bash\n#       5\n#      / \\\n#     3   2\n#    /\n#   1\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```", "answer_tailored": true}
{"pair_id": "tree-recursion_p3", "cluster_id": "tree-recursion", "question": "How are nested structures parsed in Bash?", "question_type": "medium", "answer": "In Bash-compiled Prolog, nested structures are parsed by tracking bracket depth to correctly identify structural boundaries. The `parse_tree` function demonstrates this approach:\n\n```bash\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    # Track depth while parsing\n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    # Only split on commas at depth 0\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\nThe parser increments depth on `[`, decrements on `]`, and only treats commas as delimiters when depth is zero. This ensures nested substructures like `[3,[1,[],[]]]` are kept intact rather than incorrectly split.\n\nThis technique enables tree recursion patterns where multiple recursive calls operate on structural components:\n\n```prolog\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\nSee education/book-02-bash-target/06_advanced_recursion.md for complete tree recursion examples.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["tree-recursion", "binary-tree", "structural-decomposition"], "original_answer": "## Tree Recursion\n\nTree recursion: multiple recursive calls per clause on structural parts.\n\n### Example: tree_sum\n\n```prolog\n% Tree as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth for nested structures\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\n### Usage\n\n```bash\n#       5\n#      / \\\n#     3   2\n#    /\n#   1\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```", "answer_tailored": true}
{"pair_id": "mutual-recursion_p0", "cluster_id": "mutual-recursion", "question": "How does UnifyWeaver handle mutual recursion?", "question_type": "medium", "answer": "UnifyWeaver handles mutual recursion by detecting Strongly Connected Components (SCCs) in the call graph and generating shared memoization structures.\n\n## SCC Detection with Tarjan's Algorithm\n\nWhen two or more predicates call each other in a cycle, UnifyWeaver:\n1. Constructs a call graph with predicates as nodes and calls as edges\n2. Applies Tarjan's algorithm to identify SCCs (groups where every predicate can reach every other)\n3. Compiles all SCC members together using a shared memoization table\n\n## Example: Mutually Recursive is_even/is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n## Generated Code with Shared Memo Table\n\n```bash\n# Single memo table for the entire SCC\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared cache first\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive case: calls is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar implementation\n    # Accesses same is_even_is_odd_memo table\n    ...\n}\n```\n\n## Benefits of Shared Memoization\n\n- Eliminates redundant computations across the entire cycle\n- Maintains consistent caching for all mutually recursive predicates\n- Handles complex call patterns correctly\n\nFor more details on recursive compilation strategies, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["mutual-recursion", "scc", "even-odd", "shared-memoization"], "original_answer": "## Mutual Recursion\n\nMutual recursion: two or more functions call each other in a cycle.\n\n### Example: is_even / is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### SCC Detection\n\nUnifyWeaver uses Tarjan's algorithm to find Strongly Connected Components:\n1. Build call graph (predicates as nodes, calls as edges)\n2. Find SCCs (groups where every node reaches every other)\n3. Compile SCC members together with shared state\n\n### Generated Bash: Shared Memoization\n\n```bash\n# Shared memo for all predicates in group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared memo\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: call is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar structure, calls is_even\n    # Uses same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why Shared Memoization?\n\n- Prevents redundant computation across mutual calls\n- Consistent caching for the entire SCC\n- Correct handling of complex call patterns\n\n### Usage\n\n```bash\nis_even 0 && echo \"true\"  # true\nis_even 4 && echo \"true\"  # true (via is_odd(3)->is_even(2)->...)\nis_odd 3 && echo \"true\"   # true\nis_even 5 || echo \"false\" # false\n```", "answer_tailored": true}
{"pair_id": "mutual-recursion_p1", "cluster_id": "mutual-recursion", "question": "What is SCC detection for mutual recursion?", "question_type": "medium", "answer": "SCC (Strongly Connected Component) detection is UnifyWeaver's approach to handling mutual recursion, where predicates call each other in cycles.\n\n### Detection Process\n\nUnifyWeaver uses Tarjan's algorithm to identify mutually recursive predicates:\n1. Construct a call graph with predicates as nodes and calls as directed edges\n2. Identify SCCs\u2014groups where every predicate can reach every other predicate\n3. Compile all predicates in an SCC together with shared state management\n\n### Shared Memoization for SCCs\n\nWhen predicates belong to the same SCC, they share a single memoization table to prevent redundant computation:\n\n```bash\n# Single shared memo table for the entire SCC\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local key=\"is_even:$*\"\n    \n    # Check shared cache\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base and recursive cases populate the same table\n    # that is_odd also uses\n    ...\n}\n\nis_odd() {\n    # Uses the same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Benefits\n\n- Avoids recomputing results across mutually recursive calls\n- Maintains cache consistency for the entire component\n- Correctly handles complex cyclic call patterns\n\nFor a complete example with is_even/is_odd implementation, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["mutual-recursion", "scc", "even-odd", "shared-memoization"], "original_answer": "## Mutual Recursion\n\nMutual recursion: two or more functions call each other in a cycle.\n\n### Example: is_even / is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### SCC Detection\n\nUnifyWeaver uses Tarjan's algorithm to find Strongly Connected Components:\n1. Build call graph (predicates as nodes, calls as edges)\n2. Find SCCs (groups where every node reaches every other)\n3. Compile SCC members together with shared state\n\n### Generated Bash: Shared Memoization\n\n```bash\n# Shared memo for all predicates in group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared memo\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: call is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar structure, calls is_even\n    # Uses same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why Shared Memoization?\n\n- Prevents redundant computation across mutual calls\n- Consistent caching for the entire SCC\n- Correct handling of complex call patterns\n\n### Usage\n\n```bash\nis_even 0 && echo \"true\"  # true\nis_even 4 && echo \"true\"  # true (via is_odd(3)->is_even(2)->...)\nis_odd 3 && echo \"true\"   # true\nis_even 5 || echo \"false\" # false\n```", "answer_tailored": true}
{"pair_id": "mutual-recursion_p2", "cluster_id": "mutual-recursion", "question": "How are is_even and is_odd compiled together?", "question_type": "medium", "answer": "## Compilation of Mutually Recursive Predicates\n\nWhen `is_even` and `is_odd` call each other, UnifyWeaver detects they form a **Strongly Connected Component (SCC)** and compiles them as a unit with shared memoization.\n\n### Detection Process\n\nUnifyWeaver uses Tarjan's algorithm to identify mutual recursion:\n1. Constructs a call graph (predicates as nodes, calls as edges)\n2. Identifies SCCs where predicates mutually reference each other\n3. Groups `is_even` and `is_odd` together for joint compilation\n\n### Shared Memoization Table\n\nBoth functions share a single memo table to cache results across mutual calls:\n\n```bash\n# Single memo table for the entire SCC\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared cache\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: calls is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Mirrors is_even structure\n    # Uses the same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Benefits\n\n- **Eliminates redundant work**: Results cached across both predicates\n- **Handles complex cycles**: Any call pattern within the SCC benefits from shared state\n- **Performance**: `is_even(4)` \u2192 `is_odd(3)` \u2192 `is_even(2)` \u2192 `is_odd(1)` reuses cached intermediate results\n\nSee education/book-02-bash-target/06_advanced_recursion.md for the complete implementation.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["mutual-recursion", "scc", "even-odd", "shared-memoization"], "original_answer": "## Mutual Recursion\n\nMutual recursion: two or more functions call each other in a cycle.\n\n### Example: is_even / is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### SCC Detection\n\nUnifyWeaver uses Tarjan's algorithm to find Strongly Connected Components:\n1. Build call graph (predicates as nodes, calls as edges)\n2. Find SCCs (groups where every node reaches every other)\n3. Compile SCC members together with shared state\n\n### Generated Bash: Shared Memoization\n\n```bash\n# Shared memo for all predicates in group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared memo\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: call is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar structure, calls is_even\n    # Uses same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why Shared Memoization?\n\n- Prevents redundant computation across mutual calls\n- Consistent caching for the entire SCC\n- Correct handling of complex call patterns\n\n### Usage\n\n```bash\nis_even 0 && echo \"true\"  # true\nis_even 4 && echo \"true\"  # true (via is_odd(3)->is_even(2)->...)\nis_odd 3 && echo \"true\"   # true\nis_even 5 || echo \"false\" # false\n```", "answer_tailored": true}
{"pair_id": "mutual-recursion_p3", "cluster_id": "mutual-recursion", "question": "What is shared memoization?", "question_type": "medium", "answer": "Shared memoization is a caching strategy used when mutually recursive predicates (functions that call each other in a cycle) are compiled together. Instead of each function maintaining its own separate memo table, all predicates in the same Strongly Connected Component (SCC) share a single memoization table.\n\nFor example, in the `is_even`/`is_odd` mutual recursion:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nUnifyWeaver's Bash target generates a single shared associative array:\n\n```bash\ndeclare -gA is_even_is_odd_memo\n```\n\nBoth `is_even()` and `is_odd()` check and update this same table using keys like `\"is_even:$*\"` or `\"is_odd:$*\"`. This approach prevents redundant computation across the mutual calls and ensures consistent caching for the entire SCC, correctly handling complex call patterns where `is_even(4)` might call `is_odd(3)`, which calls `is_even(2)`, and so on.\n\nUnifyWeaver detects these SCCs using Tarjan's algorithm during compilation, then generates the shared memo structure automatically. See education/book-02-bash-target/06_advanced_recursion.md for the complete implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["mutual-recursion", "scc", "even-odd", "shared-memoization"], "original_answer": "## Mutual Recursion\n\nMutual recursion: two or more functions call each other in a cycle.\n\n### Example: is_even / is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### SCC Detection\n\nUnifyWeaver uses Tarjan's algorithm to find Strongly Connected Components:\n1. Build call graph (predicates as nodes, calls as edges)\n2. Find SCCs (groups where every node reaches every other)\n3. Compile SCC members together with shared state\n\n### Generated Bash: Shared Memoization\n\n```bash\n# Shared memo for all predicates in group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared memo\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: call is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar structure, calls is_even\n    # Uses same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why Shared Memoization?\n\n- Prevents redundant computation across mutual calls\n- Consistent caching for the entire SCC\n- Correct handling of complex call patterns\n\n### Usage\n\n```bash\nis_even 0 && echo \"true\"  # true\nis_even 4 && echo \"true\"  # true (via is_odd(3)->is_even(2)->...)\nis_odd 3 && echo \"true\"   # true\nis_even 5 || echo \"false\" # false\n```", "answer_tailored": true}
