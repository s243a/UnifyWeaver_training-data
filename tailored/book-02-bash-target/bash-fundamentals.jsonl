{"pair_id": "bash-subshells_p0", "cluster_id": "bash-subshells", "question": "What is a bash subshell and why do pipes create one?", "question_type": "medium", "answer": "A bash subshell is a child process that runs its own copy of the bash shell. When you use a pipe (`|`), bash creates a subshell to execute the command on the right side of the pipe, which causes a common gotcha with variable modifications.\n\n## Why Pipes Create Subshells\n\nPipes enable parallel execution\u2014both sides of the pipe run simultaneously with data flowing between them. This parallelism requires separate processes, so bash spawns a subshell for the right-hand command.\n\n## The Variable Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\nThe subshell receives a **copy** of the parent's variables. When `count` is incremented inside the `while` loop, those changes happen in the subshell's copy. Once the pipe completes, the subshell exits and its modified variables are discarded\u2014the parent's `count` remains 0.\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (modifications)\n   count still 0                  (lost on exit)\n```\n\n## Verifying Subshell Creation\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs confirm separate processes\n```\n\n## Workarounds\n\n- **Process substitution** - bypasses the pipe subshell issue\n- **Here-strings** - works for straightforward scenarios  \n- **Temporary files** - explicitly persist state\n- **lastpipe shell option** - available in bash 4.2+\n\nFor detailed solutions, see education/book-02-bash-target/04_variable_scope_and_process_substitution.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["subshell", "pipes", "variable-scope", "child-process"], "original_answer": "## Bash Subshells\n\nA subshell is a child process running a copy of bash.\n\n### The Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\n### Why This Happens\n\nPipes (`|`) create a subshell for the right side:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (changes here)\n   count still 0                  (discarded when done)\n```\n\nThe subshell gets a **copy** of variables. Changes don't affect the parent.\n\n### Why Bash Does This\n\nPipes enable parallelism:\n- Both sides run simultaneously\n- Data flows through the pipe\n- Requires separate processes\n\n### Detecting Subshells\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs = different processes\n```\n\n### Solutions\n\n1. **Process Substitution** - avoid pipe subshell\n2. **Here-string** - for simple cases\n3. **Temp files** - explicit state passing\n4. **lastpipe option** - bash 4.2+ only\n\nSee: Process substitution training for solution details.", "answer_tailored": true}
{"pair_id": "bash-subshells_p1", "cluster_id": "bash-subshells", "question": "Why don't variables persist after a pipe?", "question_type": "medium", "answer": "In Bash, pipes (`|`) create a subshell (separate child process) for the command on the right side. When you write something like:\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Still shows 0, not 3!\n```\n\nThe `while` loop runs in a subshell that receives a **copy** of the parent's variables. Any modifications to `count` inside the loop happen in the subshell's memory space and are discarded when the subshell exits.\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count gets modified\n   count remains 0                changes lost on exit\n```\n\nBash uses subshells for pipes because it enables parallelism\u2014both sides of the pipe can run simultaneously with data streaming between them. This requires separate processes.\n\nYou can verify this by checking process IDs:\n\n```bash\necho \"Parent: $$\"\necho \"test\" | echo \"Subshell: $BASHPID\"  # Different PID\n```\n\n**Workarounds include:**\n- Process substitution (avoids the pipe subshell)\n- Here-strings for simple cases\n- Temporary files for explicit state sharing\n- The `lastpipe` shell option (Bash 4.2+)\n\nFor detailed solutions, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["subshell", "pipes", "variable-scope", "child-process"], "original_answer": "## Bash Subshells\n\nA subshell is a child process running a copy of bash.\n\n### The Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\n### Why This Happens\n\nPipes (`|`) create a subshell for the right side:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (changes here)\n   count still 0                  (discarded when done)\n```\n\nThe subshell gets a **copy** of variables. Changes don't affect the parent.\n\n### Why Bash Does This\n\nPipes enable parallelism:\n- Both sides run simultaneously\n- Data flows through the pipe\n- Requires separate processes\n\n### Detecting Subshells\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs = different processes\n```\n\n### Solutions\n\n1. **Process Substitution** - avoid pipe subshell\n2. **Here-string** - for simple cases\n3. **Temp files** - explicit state passing\n4. **lastpipe option** - bash 4.2+ only\n\nSee: Process substitution training for solution details.", "answer_tailored": true}
{"pair_id": "bash-subshells_p2", "cluster_id": "bash-subshells", "question": "What is the pipe subshell problem?", "question_type": "medium", "answer": "The pipe subshell problem occurs when the right side of a pipe operates in a separate subprocess, preventing variable changes from propagating back to the parent shell.\n\n**The Issue:**\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Prints: 0 (not 3!)\n```\n\n**Root Cause:**\n\nWhen you use a pipe (`|`), Bash spawns a subshell for the command on the right side. This subshell receives a copy of the parent's variables, but modifications within the subshell are isolated and discarded when it exits:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count increments to 3\n                                  (lost on exit)\n   count remains 0\n```\n\n**Why Pipes Work This Way:**\n\nPipes enable concurrent execution\u2014both sides of the pipe run simultaneously with data streaming between them. This requires separate processes, which means separate memory spaces.\n\n**Verification:**\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs confirm separate processes\n```\n\n**Common Solutions:**\n\n1. **Process substitution** - eliminates the pipe subshell entirely\n2. **Here-strings** - for straightforward scenarios\n3. **Temporary files** - when explicit state persistence is needed\n4. **`lastpipe` shell option** - available in Bash 4.2 and later\n\nFor implementation details, see education/book-02-bash-target/04_variable_scope_and_process_substitution.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["subshell", "pipes", "variable-scope", "child-process"], "original_answer": "## Bash Subshells\n\nA subshell is a child process running a copy of bash.\n\n### The Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\n### Why This Happens\n\nPipes (`|`) create a subshell for the right side:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (changes here)\n   count still 0                  (discarded when done)\n```\n\nThe subshell gets a **copy** of variables. Changes don't affect the parent.\n\n### Why Bash Does This\n\nPipes enable parallelism:\n- Both sides run simultaneously\n- Data flows through the pipe\n- Requires separate processes\n\n### Detecting Subshells\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs = different processes\n```\n\n### Solutions\n\n1. **Process Substitution** - avoid pipe subshell\n2. **Here-string** - for simple cases\n3. **Temp files** - explicit state passing\n4. **lastpipe option** - bash 4.2+ only\n\nSee: Process substitution training for solution details.", "answer_tailored": true}
{"pair_id": "bash-subshells_p3", "cluster_id": "bash-subshells", "question": "How do pipes affect variable scope in bash?", "question_type": "medium", "answer": "In Bash, pipes create subshells that isolate variable modifications. When you use a pipe (`|`), the command on the right side runs in a separate child process with its own copy of variables.\n\n## The Core Issue\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Prints: 0 (not 3!)\n```\n\nThe `count` variable increments inside the while loop, but those changes occur in a subshell and are lost when the pipe completes.\n\n## How Pipes Affect Scope\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count gets copied\n                                  modifications happen here\n   count unchanged                changes discarded on exit\n```\n\nVariables are **copied** to the subshell, not shared. Any modifications in the subshell disappear when it terminates.\n\n## Why Bash Creates Subshells\n\nPipes enable concurrent execution - both pipeline stages run simultaneously with data streaming between them. This requires separate processes, which means separate variable scopes.\n\n## Verification\n\nCheck process IDs to confirm separate shells:\n```bash\necho \"Parent: $$\"\necho \"test\" | echo \"Subshell: $BASHPID\"\n# Different PIDs prove different processes\n```\n\n## Workarounds\n\n- Process substitution to avoid the pipe subshell\n- Here-strings for simpler scenarios  \n- Temporary files for explicit state transfer\n- `lastpipe` shell option (Bash 4.2+)\n\nFor implementation details, see education/book-02-bash-target/04_variable_scope_and_process_substitution.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["subshell", "pipes", "variable-scope", "child-process"], "original_answer": "## Bash Subshells\n\nA subshell is a child process running a copy of bash.\n\n### The Problem\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (not 3!)\n```\n\n### Why This Happens\n\nPipes (`|`) create a subshell for the right side:\n\n```\n[Parent Shell]  -->  pipe  -->  [Subshell]\n   count=0                        count=1,2,3\n                                  (changes here)\n   count still 0                  (discarded when done)\n```\n\nThe subshell gets a **copy** of variables. Changes don't affect the parent.\n\n### Why Bash Does This\n\nPipes enable parallelism:\n- Both sides run simultaneously\n- Data flows through the pipe\n- Requires separate processes\n\n### Detecting Subshells\n\n```bash\necho \"Parent PID: $$\"\necho \"test\" | echo \"Subshell PID: $BASHPID\"\n# Different PIDs = different processes\n```\n\n### Solutions\n\n1. **Process Substitution** - avoid pipe subshell\n2. **Here-string** - for simple cases\n3. **Temp files** - explicit state passing\n4. **lastpipe option** - bash 4.2+ only\n\nSee: Process substitution training for solution details.", "answer_tailored": true}
{"pair_id": "process-substitution_p0", "cluster_id": "process-substitution", "question": "What is process substitution in bash?", "question_type": "medium", "answer": "Process substitution is a Bash feature that treats command output as a file, allowing you to read from or write to a command as if it were a file descriptor.\n\n## Syntax\n\n```bash\n< <(command)   # Treats command output as an input file\n> >(command)   # Treats command input as an output file\n```\n\n## Key Advantage: Avoiding Subshells\n\nUnlike pipes, process substitution keeps your loop in the current shell, so variable assignments persist:\n\n```bash\n# With pipe - variables lost (subshell)\ncommand | while read line; do ((count++)); done\necho \"$count\"  # Empty!\n\n# With process substitution - variables preserved\nwhile read line; do ((count++)); done < <(command)\necho \"$count\"  # Works correctly\n```\n\n## How It Works\n\nThe `< <(...)` syntax creates a file descriptor (like `/dev/fd/63`) that your shell can read from:\n\n```bash\necho <(echo hello)\n# Output: /dev/fd/63\n\n# Conceptually similar to:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n## Example from UnifyWeaver\n\nGenerated transitive closure code uses process substitution to maintain the `visited` array across iterations:\n\n```bash\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```\n\nFor more details on Bash target generation, see `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["process-substitution", "file-descriptor", "redirection"], "original_answer": "## Process Substitution\n\nProcess substitution runs a command and makes its output available as a file.\n\n### Syntax\n\n```bash\n< <(command)   # Input from command output\n> >(command)   # Output to command input\n```\n\n### How It Works\n\n```bash\n# Pipe (creates subshell for while loop)\ncommand | while read line; do ...; done\n\n# Process substitution (loop runs in current shell)\nwhile read line; do ...; done < <(command)\n```\n\n### Why It Solves the Subshell Problem\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\nThe `< <(...)` creates a file descriptor that the current shell reads from. No subshell is created for the loop.\n\n### Under the Hood\n\n```bash\n# Process substitution creates /dev/fd/N\necho <(echo hello)\n# Output: /dev/fd/63 (or similar)\n\n# It's like:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Comparison\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\n### UnifyWeaver Usage\n\n```bash\n# From generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```", "answer_tailored": true}
{"pair_id": "process-substitution_p1", "cluster_id": "process-substitution", "question": "How does < <(...) work?", "question_type": "medium", "answer": "The `< <(...)` syntax in Bash is called process substitution. It runs a command and makes its output available as if it were a file that can be redirected into another command.\n\nThe key advantage is that it avoids the subshell problem that occurs with pipes. When you use `command | while read`, the while loop runs in a subshell, so variables modified inside the loop don't persist. With `< <(command)`, the loop runs in the current shell:\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 - variable persists!\n```\n\nBehind the scenes, `<(command)` creates a file descriptor (typically something like `/dev/fd/63`) that streams the command's output. It's functionally similar to creating a named pipe, running the command in the background, and reading from that pipe.\n\n**Comparison:**\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\nUnifyWeaver's generated Bash code uses this pattern to preserve variables across loop iterations, such as in transitive closure operations where a `visited` array needs to track state across multiple reads from an edge stream.\n\nFor more details on Bash target compilation, see education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["process-substitution", "file-descriptor", "redirection"], "original_answer": "## Process Substitution\n\nProcess substitution runs a command and makes its output available as a file.\n\n### Syntax\n\n```bash\n< <(command)   # Input from command output\n> >(command)   # Output to command input\n```\n\n### How It Works\n\n```bash\n# Pipe (creates subshell for while loop)\ncommand | while read line; do ...; done\n\n# Process substitution (loop runs in current shell)\nwhile read line; do ...; done < <(command)\n```\n\n### Why It Solves the Subshell Problem\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\nThe `< <(...)` creates a file descriptor that the current shell reads from. No subshell is created for the loop.\n\n### Under the Hood\n\n```bash\n# Process substitution creates /dev/fd/N\necho <(echo hello)\n# Output: /dev/fd/63 (or similar)\n\n# It's like:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Comparison\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\n### UnifyWeaver Usage\n\n```bash\n# From generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```", "answer_tailored": true}
{"pair_id": "process-substitution_p2", "cluster_id": "process-substitution", "question": "Why use process substitution instead of pipes?", "question_type": "medium", "answer": "Process substitution avoids the subshell problem that occurs with pipes. When you use `command | while read`, the pipe creates a subshell for the while loop, meaning any variables you modify inside the loop won't persist after it exits.\n\nWith process substitution `while read line; do ...; done < <(command)`, the loop runs in the current shell, so variable changes are preserved:\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (works!)\n\n# Compare to pipe version:\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (variables lost!)\n```\n\nThe `< <(...)` syntax creates a file descriptor (like `/dev/fd/63`) that the current shell reads from, similar to using a temporary named pipe but without the complexity. Since there's no subshell boundary, variables modified in the loop remain accessible afterward.\n\n| Method | Loop Context | Variables Persist? |\n|--------|--------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current shell | Yes |\n\nIn UnifyWeaver's generated Bash code, this pattern appears when maintaining state across loop iterations, such as tracking visited nodes in graph traversal algorithms (see education/book-02-bash-target/ for implementation details).", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["process-substitution", "file-descriptor", "redirection"], "original_answer": "## Process Substitution\n\nProcess substitution runs a command and makes its output available as a file.\n\n### Syntax\n\n```bash\n< <(command)   # Input from command output\n> >(command)   # Output to command input\n```\n\n### How It Works\n\n```bash\n# Pipe (creates subshell for while loop)\ncommand | while read line; do ...; done\n\n# Process substitution (loop runs in current shell)\nwhile read line; do ...; done < <(command)\n```\n\n### Why It Solves the Subshell Problem\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\nThe `< <(...)` creates a file descriptor that the current shell reads from. No subshell is created for the loop.\n\n### Under the Hood\n\n```bash\n# Process substitution creates /dev/fd/N\necho <(echo hello)\n# Output: /dev/fd/63 (or similar)\n\n# It's like:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Comparison\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\n### UnifyWeaver Usage\n\n```bash\n# From generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```", "answer_tailored": true}
{"pair_id": "process-substitution_p3", "cluster_id": "process-substitution", "question": "What's the difference between | and < <(...)?", "question_type": "medium", "answer": "The key difference is **subshell creation and variable scope**:\n\n**Pipe (`|`)**: Creates a subshell for the right side of the pipe. Variables modified inside the loop won't persist after the loop ends.\n\n```bash\ncount=0\necho -e \"a\\nb\\nc\" | while read line; do\n    ((count++))\ndone\necho \"Count: $count\"  # Outputs: 0 (variables lost!)\n```\n\n**Process substitution (`< <(...)`)**: Runs the command in a background process but keeps the `while` loop in the current shell. Variables persist correctly.\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\n**How it works**: `< <(command)` creates a file descriptor (like `/dev/fd/63`) that your shell reads from, similar to redirecting from a temporary named pipe but without the cleanup hassle.\n\n**Summary**:\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\nUnifyWeaver's generated Bash code uses `< <(...)` when variable accumulation is needed, such as building visited sets during graph traversal. See education/book-02-bash-target/04_variable_scope_and_process_substitution.md for detailed examples.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["process-substitution", "file-descriptor", "redirection"], "original_answer": "## Process Substitution\n\nProcess substitution runs a command and makes its output available as a file.\n\n### Syntax\n\n```bash\n< <(command)   # Input from command output\n> >(command)   # Output to command input\n```\n\n### How It Works\n\n```bash\n# Pipe (creates subshell for while loop)\ncommand | while read line; do ...; done\n\n# Process substitution (loop runs in current shell)\nwhile read line; do ...; done < <(command)\n```\n\n### Why It Solves the Subshell Problem\n\n```bash\ncount=0\nwhile read line; do\n    ((count++))\ndone < <(echo -e \"a\\nb\\nc\")\necho \"Count: $count\"  # Outputs: 3 (correct!)\n```\n\nThe `< <(...)` creates a file descriptor that the current shell reads from. No subshell is created for the loop.\n\n### Under the Hood\n\n```bash\n# Process substitution creates /dev/fd/N\necho <(echo hello)\n# Output: /dev/fd/63 (or similar)\n\n# It's like:\ncommand > /tmp/fifo &\nwhile read line; do ...; done < /tmp/fifo\n```\n\n### Comparison\n\n| Approach | Loop Shell | Variables Persist? |\n|----------|------------|-------------------|\n| `cmd \\| while` | Subshell | No |\n| `while ... < <(cmd)` | Current | Yes |\n\n### UnifyWeaver Usage\n\n```bash\n# From generated transitive closure code\nwhile IFS=\":\" read -r from to; do\n    if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n        visited[\"$to\"]=1\n        echo \"$to\"\n    fi\ndone < <(edge_stream | grep \"^$current:\")\n```", "answer_tailored": true}
{"pair_id": "bash-arrays_p0", "cluster_id": "bash-arrays", "question": "How do bash associative arrays work?", "question_type": "medium", "answer": "Bash associative arrays are hash maps that use string keys instead of numeric indices. They must be declared with the `-A` flag:\n\n```bash\n# Declaration required\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n```\n\n**Key Operations:**\n\n```bash\n# Get all keys\necho ${!colors[@]}    # sky grass sun\n\n# Get all values\necho ${colors[@]}     # blue green yellow\n\n# Check if key exists\n[[ -v colors[sky] ]]\n\n# Check if value is non-empty\n[[ -n \"${colors[sky]}\" ]]\n\n# Delete a key\nunset colors[sky]\n\n# Get size\necho ${#colors[@]}\n```\n\n**Why UnifyWeaver Uses Them:**\n\n1. **O(1) lookup** - Constant-time key access for fact retrieval\n2. **Deduplication** - Track visited nodes in graph traversal:\n   ```bash\n   declare -A visited\n   if [[ -z \"${visited[$node]}\" ]]; then\n       visited[$node]=1\n       process \"$node\"\n   fi\n   ```\n3. **Fact storage** - Map Prolog facts to key-value pairs:\n   ```bash\n   declare -A parent_data=(\n       [alice:bob]=1\n       [bob:charlie]=1\n   )\n   ```\n\n**Scope Control:**\n\n```bash\n# Global (accessible everywhere)\ndeclare -gA memo_table\n\n# Local (function-scoped only)\nmy_func() {\n    local -A temp_array\n}\n```\n\nUnlike indexed arrays (which use numeric indices like `fruits[0]`), associative arrays enable semantic lookups with meaningful keys. See education/book-02-bash-target/04_variable_scope_and_process_substitution.md for more on Bash data structures.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["associative-arrays", "declare", "hash-table", "indexed-arrays"], "original_answer": "## Bash Arrays\n\nBash supports two types of arrays: indexed and associative.\n\n### Indexed Arrays\n\n```bash\n# Declare and initialize\nfruits=(apple banana cherry)\n\n# Access by index\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\n\n# All elements\necho ${fruits[@]}    # apple banana cherry\n```\n\n### Associative Arrays\n\n```bash\n# MUST declare with -A\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n\n# All keys\necho ${!colors[@]}    # sky grass sun\n\n# All values\necho ${colors[@]}     # blue green yellow\n```\n\n### Why UnifyWeaver Uses Associative Arrays\n\n**1. O(1) Lookup**\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Deduplication (visited tracking)**\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Fact Storage**\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\n### Global vs Local Arrays\n\n```bash\n# Global (persists across functions)\ndeclare -gA memo_table\n\n# Local (only in function)\nmy_func() {\n    local -A temp_array\n}\n```\n\n### Common Operations\n\n```bash\n# Check if key exists\n[[ -v array[$key] ]]\n\n# Check if value is non-empty\n[[ -n \"${array[$key]}\" ]]\n\n# Delete key\nunset array[$key]\n\n# Array size\necho ${#array[@]}\n```", "answer_tailored": true}
{"pair_id": "bash-arrays_p1", "cluster_id": "bash-arrays", "question": "What's the difference between indexed and associative arrays?", "question_type": "medium", "answer": "Bash has two array types with different indexing mechanisms:\n\n**Indexed Arrays** use numeric indices (0, 1, 2, ...):\n```bash\nfruits=(apple banana cherry)\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\necho ${fruits[@]}    # all elements\n```\n\n**Associative Arrays** use string keys and require declaration with `-A`:\n```bash\ndeclare -A colors\ncolors[sky]=blue\ncolors[grass]=green\n\necho ${colors[sky]}    # blue\necho ${!colors[@]}     # all keys: sky grass\necho ${colors[@]}      # all values: blue green\n```\n\nThe key difference: indexed arrays access elements by position number, while associative arrays access elements by named keys (like dictionaries/hash maps in other languages).\n\nUnifyWeaver primarily uses associative arrays because they provide:\n- **O(1) lookup** for checking membership: `[[ -v array[$key] ]]`\n- **Deduplication** via visited tracking: `visited[$node]=1`\n- **Fact storage** with compound keys: `parent_data[alice:bob]=1`\n\nBoth types support common operations like checking existence (`[[ -v array[$key] ]]`), getting size (`${#array[@]}`), and deletion (`unset array[$key]`). You can make them global with `-gA` or local within functions using `local -A`.\n\nSee education/book-02-bash-target/04_variable_scope_and_process_substitution.md for more details on array handling in the Bash target.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["associative-arrays", "declare", "hash-table", "indexed-arrays"], "original_answer": "## Bash Arrays\n\nBash supports two types of arrays: indexed and associative.\n\n### Indexed Arrays\n\n```bash\n# Declare and initialize\nfruits=(apple banana cherry)\n\n# Access by index\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\n\n# All elements\necho ${fruits[@]}    # apple banana cherry\n```\n\n### Associative Arrays\n\n```bash\n# MUST declare with -A\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n\n# All keys\necho ${!colors[@]}    # sky grass sun\n\n# All values\necho ${colors[@]}     # blue green yellow\n```\n\n### Why UnifyWeaver Uses Associative Arrays\n\n**1. O(1) Lookup**\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Deduplication (visited tracking)**\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Fact Storage**\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\n### Global vs Local Arrays\n\n```bash\n# Global (persists across functions)\ndeclare -gA memo_table\n\n# Local (only in function)\nmy_func() {\n    local -A temp_array\n}\n```\n\n### Common Operations\n\n```bash\n# Check if key exists\n[[ -v array[$key] ]]\n\n# Check if value is non-empty\n[[ -n \"${array[$key]}\" ]]\n\n# Delete key\nunset array[$key]\n\n# Array size\necho ${#array[@]}\n```", "answer_tailored": true}
{"pair_id": "bash-arrays_p2", "cluster_id": "bash-arrays", "question": "How do I declare an associative array in bash?", "question_type": "medium", "answer": "To declare an associative array in Bash, you **must** use `declare -A`:\n\n```bash\ndeclare -A colors\n```\n\nThis creates an empty associative array. You can then set key-value pairs using string keys:\n\n```bash\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n```\n\nTo access values by key:\n\n```bash\necho ${colors[sky]}      # blue\necho ${colors[@]}        # All values: blue green yellow\necho ${!colors[@]}       # All keys: sky grass sun\n```\n\n**Scope Options:**\n\n```bash\n# Global (accessible everywhere)\ndeclare -gA global_map\n\n# Local (function-scoped only)\nmy_function() {\n    local -A local_map\n}\n```\n\n**Why This Matters in UnifyWeaver:**\n\nUnifyWeaver's Bash target uses associative arrays extensively for:\n- **Fact storage** with compound keys like `parent_data[alice:bob]=1`\n- **O(1) lookups** when checking relationships\n- **Deduplication** via visited tracking during recursive queries\n\n**Common Checks:**\n\n```bash\n# Key exists?\n[[ -v colors[sky] ]]\n\n# Value non-empty?\n[[ -n \"${colors[sky]}\" ]]\n\n# Number of entries\necho ${#colors[@]}\n```\n\nWithout the `-A` flag, Bash creates an indexed array instead, which won't work with string keys. For more on arrays and variable scoping, see `education/book-02-bash-target/04_variable_scope_and_process_substitution.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["associative-arrays", "declare", "hash-table", "indexed-arrays"], "original_answer": "## Bash Arrays\n\nBash supports two types of arrays: indexed and associative.\n\n### Indexed Arrays\n\n```bash\n# Declare and initialize\nfruits=(apple banana cherry)\n\n# Access by index\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\n\n# All elements\necho ${fruits[@]}    # apple banana cherry\n```\n\n### Associative Arrays\n\n```bash\n# MUST declare with -A\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n\n# All keys\necho ${!colors[@]}    # sky grass sun\n\n# All values\necho ${colors[@]}     # blue green yellow\n```\n\n### Why UnifyWeaver Uses Associative Arrays\n\n**1. O(1) Lookup**\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Deduplication (visited tracking)**\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Fact Storage**\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\n### Global vs Local Arrays\n\n```bash\n# Global (persists across functions)\ndeclare -gA memo_table\n\n# Local (only in function)\nmy_func() {\n    local -A temp_array\n}\n```\n\n### Common Operations\n\n```bash\n# Check if key exists\n[[ -v array[$key] ]]\n\n# Check if value is non-empty\n[[ -n \"${array[$key]}\" ]]\n\n# Delete key\nunset array[$key]\n\n# Array size\necho ${#array[@]}\n```", "answer_tailored": true}
{"pair_id": "bash-arrays_p3", "cluster_id": "bash-arrays", "question": "Why does UnifyWeaver use associative arrays?", "question_type": "medium", "answer": "UnifyWeaver uses associative arrays in Bash for three key reasons:\n\n**1. Constant-Time Lookups (O(1))**\nAssociative arrays provide fast key-based access, which is critical for performance:\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Efficient Deduplication**\nThey enable tracking visited nodes during graph traversal without linear searches:\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Natural Fact Representation**\nAssociative arrays map directly to Prolog's fact storage patterns:\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\nThese arrays must be declared with `declare -A` before use. UnifyWeaver often uses them globally with `declare -gA` for memoization tables that persist across function calls, ensuring efficient query execution.\n\nFor more details on Bash target compilation patterns, see education/book-02-bash-target/04_variable_scope_and_process_substitution.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["associative-arrays", "declare", "hash-table", "indexed-arrays"], "original_answer": "## Bash Arrays\n\nBash supports two types of arrays: indexed and associative.\n\n### Indexed Arrays\n\n```bash\n# Declare and initialize\nfruits=(apple banana cherry)\n\n# Access by index\necho ${fruits[0]}    # apple\necho ${fruits[1]}    # banana\n\n# All elements\necho ${fruits[@]}    # apple banana cherry\n```\n\n### Associative Arrays\n\n```bash\n# MUST declare with -A\ndeclare -A colors\n\n# Set values with string keys\ncolors[sky]=blue\ncolors[grass]=green\ncolors[sun]=yellow\n\n# Access by key\necho ${colors[sky]}   # blue\n\n# All keys\necho ${!colors[@]}    # sky grass sun\n\n# All values\necho ${colors[@]}     # blue green yellow\n```\n\n### Why UnifyWeaver Uses Associative Arrays\n\n**1. O(1) Lookup**\n```bash\n# Check if key exists - constant time\n[[ -n \"${parent_data[$key]}\" ]] && echo \"exists\"\n```\n\n**2. Deduplication (visited tracking)**\n```bash\ndeclare -A visited\nvisited[\"node_a\"]=1\n\n# Check if already visited\nif [[ -z \"${visited[$node]}\" ]]; then\n    visited[$node]=1\n    process \"$node\"\nfi\n```\n\n**3. Fact Storage**\n```bash\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n)\n```\n\n### Global vs Local Arrays\n\n```bash\n# Global (persists across functions)\ndeclare -gA memo_table\n\n# Local (only in function)\nmy_func() {\n    local -A temp_array\n}\n```\n\n### Common Operations\n\n```bash\n# Check if key exists\n[[ -v array[$key] ]]\n\n# Check if value is non-empty\n[[ -n \"${array[$key]}\" ]]\n\n# Delete key\nunset array[$key]\n\n# Array size\necho ${#array[@]}\n```", "answer_tailored": true}
{"pair_id": "bash-redirections_p0", "cluster_id": "bash-redirections", "question": "How do bash redirections and file descriptors work?", "question_type": "medium", "answer": "## File Descriptors and Redirections in Bash\n\nBash uses file descriptors (FDs) as integer references to open files and streams. Understanding how to redirect these is essential for controlling input/output flow.\n\n### Standard File Descriptors\n\nThree file descriptors are always available:\n\n| FD | Purpose | Default Target |\n|----|---------|----------------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Error messages to terminal |\n\n### Redirection Syntax\n\n```bash\n# Send stdout to a file\ncommand > output.txt\n\n# Read stdin from a file\ncommand < input.txt\n\n# Send stderr to a file\ncommand 2> errors.txt\n\n# Combine stdout and stderr to one file\ncommand > output.txt 2>&1\n# Modern syntax (bash 4+)\ncommand &> output.txt\n```\n\n### Overwrite vs Append\n\n```bash\n# Overwrite existing file\necho \"replace\" > file.txt\n\n# Append to existing file\necho \"add\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document - multi-line input\ncat <<EOF\nFirst line\nSecond line\nEOF\n\n# Here string - inline string as stdin\nread variable <<< \"input text\"\n```\n\n### Process Substitution with File Descriptors\n\nProcess substitution creates temporary file descriptors for command output:\n\n```bash\n# <(...) creates a file descriptor path\necho <(echo test)\n# Shows: /dev/fd/63\n\n# Redirect stdin from process output\nwhile read line; do\n    echo \"Line: $line\"\ndone < <(echo -e \"x\\ny\\nz\")\n```\n\n### UnifyWeaver Usage\n\nThe Bash target generator leverages these redirection patterns extensively:\n\n```bash\n# Avoid subshell variable issues\nwhile IFS=\":\" read -r source dest; do\n    handle \"$source\" \"$dest\"\ndone < <(generate_edges)\n\n# Suppress error output\nvalue=$(run_command 2>/dev/null)\n```\n\nFor more on Bash code generation patterns, see education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["file-descriptors", "redirection", "stdin", "stdout", "stderr"], "original_answer": "## Bash Redirections and File Descriptors\n\nFile descriptors are integer references to open files/streams.\n\n### Standard Descriptors\n\n| FD | Name | Default |\n|----|------|--------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Terminal (errors) |\n\n### Basic Redirections\n\n```bash\n# Redirect stdout to file\ncommand > output.txt\n\n# Redirect stdin from file\ncommand < input.txt\n\n# Redirect stderr to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or (bash 4+)\ncommand &> output.txt\n```\n\n### Append vs Overwrite\n\n```bash\n# Overwrite\necho \"new\" > file.txt\n\n# Append\necho \"more\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document (multi-line input)\ncat <<EOF\nLine 1\nLine 2\nEOF\n\n# Here string (single string as input)\nread var <<< \"hello world\"\n```\n\n### Process Substitution and FDs\n\n```bash\n# <(...) creates a file descriptor\necho <(echo hello)\n# Output: /dev/fd/63\n\n# < <(...) redirects stdin from that FD\nwhile read line; do\n    echo \"Got: $line\"\ndone < <(echo -e \"a\\nb\\nc\")\n```\n\n### Why This Matters for UnifyWeaver\n\nGenerated code uses these patterns:\n```bash\n# Read from command output without subshell\nwhile IFS=\":\" read -r from to; do\n    process \"$from\" \"$to\"\ndone < <(edge_stream)\n\n# Suppress errors\nresult=$(command 2>/dev/null)\n```", "answer_tailored": true}
{"pair_id": "bash-redirections_p1", "cluster_id": "bash-redirections", "question": "What are file descriptors 0, 1, and 2?", "question_type": "medium", "answer": "File descriptors 0, 1, and 2 are the standard streams in Unix-like systems:\n\n- **FD 0 (stdin)**: Standard input - by default reads from keyboard input\n- **FD 1 (stdout)**: Standard output - by default writes to terminal output  \n- **FD 2 (stderr)**: Standard error - by default writes error messages to terminal\n\nThese can be redirected using shell syntax:\n\n```bash\n# Redirect stdout (FD 1) to file\ncommand > output.txt\n\n# Redirect stderr (FD 2) to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or in bash 4+:\ncommand &> output.txt\n\n# Redirect stdin (FD 0) from file\ncommand < input.txt\n```\n\n**UnifyWeaver Usage**: Generated Bash code frequently redirects these descriptors, such as suppressing errors with `2>/dev/null` or using process substitution with stdin redirection like `done < <(command)` to avoid subshell limitations.\n\nFor complete coverage of redirections, process substitution, and variable scope in Bash target compilation, see education/book-02-bash-target/04_variable_scope_and_process_substitution.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["file-descriptors", "redirection", "stdin", "stdout", "stderr"], "original_answer": "## Bash Redirections and File Descriptors\n\nFile descriptors are integer references to open files/streams.\n\n### Standard Descriptors\n\n| FD | Name | Default |\n|----|------|--------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Terminal (errors) |\n\n### Basic Redirections\n\n```bash\n# Redirect stdout to file\ncommand > output.txt\n\n# Redirect stdin from file\ncommand < input.txt\n\n# Redirect stderr to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or (bash 4+)\ncommand &> output.txt\n```\n\n### Append vs Overwrite\n\n```bash\n# Overwrite\necho \"new\" > file.txt\n\n# Append\necho \"more\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document (multi-line input)\ncat <<EOF\nLine 1\nLine 2\nEOF\n\n# Here string (single string as input)\nread var <<< \"hello world\"\n```\n\n### Process Substitution and FDs\n\n```bash\n# <(...) creates a file descriptor\necho <(echo hello)\n# Output: /dev/fd/63\n\n# < <(...) redirects stdin from that FD\nwhile read line; do\n    echo \"Got: $line\"\ndone < <(echo -e \"a\\nb\\nc\")\n```\n\n### Why This Matters for UnifyWeaver\n\nGenerated code uses these patterns:\n```bash\n# Read from command output without subshell\nwhile IFS=\":\" read -r from to; do\n    process \"$from\" \"$to\"\ndone < <(edge_stream)\n\n# Suppress errors\nresult=$(command 2>/dev/null)\n```", "answer_tailored": true}
{"pair_id": "bash-redirections_p2", "cluster_id": "bash-redirections", "question": "What does < and > mean in bash?", "question_type": "medium", "answer": "## Bash Redirection Operators\n\nIn bash, `<` and `>` are redirection operators that control where input comes from and where output goes.\n\n### The `>` Operator (Output Redirection)\n\nRedirects a command's output to a file:\n\n```bash\n# Send output to file (overwrites existing content)\necho \"hello\" > output.txt\n\n# Append to file instead\necho \"more text\" >> output.txt\n\n# Redirect error messages (file descriptor 2)\ncommand 2> errors.txt\n\n# Redirect both regular output and errors\ncommand > output.txt 2>&1\n# Or in bash 4+:\ncommand &> output.txt\n```\n\n### The `<` Operator (Input Redirection)\n\nRedirects a file's contents as input to a command:\n\n```bash\n# Read from file instead of keyboard\ncommand < input.txt\n\n# Here strings (redirect a string as input)\nread variable <<< \"some text\"\n\n# Here documents (multi-line input)\ncat <<EOF\nMultiple lines\nof input\nEOF\n```\n\n### Process Substitution with `< <(...)`\n\nA special pattern combining both operators:\n\n```bash\n# < <(...) treats command output as an input file\nwhile read line; do\n    echo \"Line: $line\"\ndone < <(some_command)\n```\n\nThis avoids subshells while reading command output line-by-line.\n\n### UnifyWeaver Usage\n\nGenerated bash code uses these patterns extensively:\n\n```bash\n# Process streaming data without pipeline subshells\nwhile IFS=\":\" read -r field1 field2; do\n    # Processing happens in main shell\ndone < <(data_source)\n\n# Suppress error output\nresult=$(fallible_command 2>/dev/null)\n```\n\nFor complete coverage of bash I/O patterns, see education/book-02-bash-target/04_variable_scope_and_process_substitution.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["file-descriptors", "redirection", "stdin", "stdout", "stderr"], "original_answer": "## Bash Redirections and File Descriptors\n\nFile descriptors are integer references to open files/streams.\n\n### Standard Descriptors\n\n| FD | Name | Default |\n|----|------|--------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Terminal (errors) |\n\n### Basic Redirections\n\n```bash\n# Redirect stdout to file\ncommand > output.txt\n\n# Redirect stdin from file\ncommand < input.txt\n\n# Redirect stderr to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or (bash 4+)\ncommand &> output.txt\n```\n\n### Append vs Overwrite\n\n```bash\n# Overwrite\necho \"new\" > file.txt\n\n# Append\necho \"more\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document (multi-line input)\ncat <<EOF\nLine 1\nLine 2\nEOF\n\n# Here string (single string as input)\nread var <<< \"hello world\"\n```\n\n### Process Substitution and FDs\n\n```bash\n# <(...) creates a file descriptor\necho <(echo hello)\n# Output: /dev/fd/63\n\n# < <(...) redirects stdin from that FD\nwhile read line; do\n    echo \"Got: $line\"\ndone < <(echo -e \"a\\nb\\nc\")\n```\n\n### Why This Matters for UnifyWeaver\n\nGenerated code uses these patterns:\n```bash\n# Read from command output without subshell\nwhile IFS=\":\" read -r from to; do\n    process \"$from\" \"$to\"\ndone < <(edge_stream)\n\n# Suppress errors\nresult=$(command 2>/dev/null)\n```", "answer_tailored": true}
{"pair_id": "bash-redirections_p3", "cluster_id": "bash-redirections", "question": "How does redirection relate to process substitution?", "question_type": "medium", "answer": "## Process Substitution and Redirection\n\nProcess substitution (`<(command)`) creates a temporary file descriptor that looks like a file, which can then be used with redirection operators.\n\n### How They Work Together\n\n```bash\n# Process substitution creates an FD\n<(echo hello)\n# Returns: /dev/fd/63 (a file descriptor)\n\n# Redirection reads from that FD\nwhile read line; do\n    echo \"Processing: $line\"\ndone < <(generate_data)\n```\n\nThe `<` redirection operator connects stdin to the file descriptor created by `<(...)`.\n\n### Breaking Down the Syntax\n\n```bash\n# Step 1: Process substitution runs command in background\n<(command)  # Creates /dev/fd/N\n\n# Step 2: Redirection connects it to stdin\n< <(command)\n# \u2191 stdin redirect\n#   \u2191 process substitution\n```\n\n### Why Both Are Needed\n\nWithout redirection, process substitution just gives you a path:\n```bash\necho <(ls)\n# Output: /dev/fd/63\n```\n\nWith redirection, you can read the command's output:\n```bash\nwhile read file; do\n    echo \"File: $file\"\ndone < <(ls)\n```\n\n### Comparison with Pipes\n\n```bash\n# Using pipe (creates subshell)\nls | while read file; do\n    count=$((count + 1))  # Lost after loop!\ndone\n\n# Using process substitution + redirection (no subshell)\nwhile read file; do\n    count=$((count + 1))  # Preserved!\ndone < <(ls)\n```\n\n### UnifyWeaver Applications\n\nGenerated Bash code uses this combination to avoid subshell variable scope issues:\n```bash\n# Reading query results without losing variables\nwhile IFS=\":\" read -r key value; do\n    results+=(\"$key=$value\")\ndone < <(query_processor)\n```\n\nFor more on variable scoping and why this matters, see education/book-02-bash-target/04_variable_scope_and_process_substitution.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["file-descriptors", "redirection", "stdin", "stdout", "stderr"], "original_answer": "## Bash Redirections and File Descriptors\n\nFile descriptors are integer references to open files/streams.\n\n### Standard Descriptors\n\n| FD | Name | Default |\n|----|------|--------|\n| 0 | stdin | Keyboard input |\n| 1 | stdout | Terminal output |\n| 2 | stderr | Terminal (errors) |\n\n### Basic Redirections\n\n```bash\n# Redirect stdout to file\ncommand > output.txt\n\n# Redirect stdin from file\ncommand < input.txt\n\n# Redirect stderr to file\ncommand 2> errors.txt\n\n# Redirect both stdout and stderr\ncommand > output.txt 2>&1\n# Or (bash 4+)\ncommand &> output.txt\n```\n\n### Append vs Overwrite\n\n```bash\n# Overwrite\necho \"new\" > file.txt\n\n# Append\necho \"more\" >> file.txt\n```\n\n### Here Documents and Here Strings\n\n```bash\n# Here document (multi-line input)\ncat <<EOF\nLine 1\nLine 2\nEOF\n\n# Here string (single string as input)\nread var <<< \"hello world\"\n```\n\n### Process Substitution and FDs\n\n```bash\n# <(...) creates a file descriptor\necho <(echo hello)\n# Output: /dev/fd/63\n\n# < <(...) redirects stdin from that FD\nwhile read line; do\n    echo \"Got: $line\"\ndone < <(echo -e \"a\\nb\\nc\")\n```\n\n### Why This Matters for UnifyWeaver\n\nGenerated code uses these patterns:\n```bash\n# Read from command output without subshell\nwhile IFS=\":\" read -r from to; do\n    process \"$from\" \"$to\"\ndone < <(edge_stream)\n\n# Suppress errors\nresult=$(command 2>/dev/null)\n```", "answer_tailored": true}
{"pair_id": "bash-trap_p0", "cluster_id": "bash-trap", "question": "What does the trap command do in bash?", "question_type": "medium", "answer": "The `trap` command in Bash registers handlers that execute specific commands when signals or events occur. This is essential for cleanup operations and error handling.\n\n### How It Works\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\nWhen the specified signal is received, Bash executes the given commands before proceeding with the signal's default action.\n\n### Key Signals for UnifyWeaver\n\n| Signal | Triggered By |\n|--------|--------------|\n| EXIT | Script termination (normal, error, or Ctrl+C) |\n| INT | Interrupt signal (Ctrl+C) |\n| TERM | Termination signal (kill command) |\n| PIPE | Broken pipe when reader closes early |\n| ERR | Command fails (non-zero exit status) |\n\n### Cleanup Use Case\n\nThe most common pattern uses `trap` with EXIT to guarantee cleanup:\n\n```bash\ntmp_file=$(mktemp)\ntrap \"rm -f $tmp_file\" EXIT\n\n# Work with temp file\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# File removed automatically when script exits\n```\n\n### UnifyWeaver's BFS Implementation\n\nIn graph traversal functions, UnifyWeaver traps both EXIT and PIPE:\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # BFS logic with temporary files...\n}\n```\n\n**Why PIPE?** If the output is piped to `head -1` or another command that exits early, the pipe breaks. Without a PIPE trap, temp files might persist.\n\n### Additional Operations\n\n```bash\n# Reset a trap to default behavior\ntrap - EXIT\n\n# Ignore a signal entirely\ntrap '' INT  # Ctrl+C now ignored\n```\n\nSee education/book-02-bash-target/04_variable_scope_and_process_substitution.md for more on Bash process handling patterns.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["trap", "signals", "cleanup", "EXIT", "PIPE"], "original_answer": "## Bash Trap Command\n\nThe `trap` command registers handlers for signals and events.\n\n### Basic Syntax\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\n### Common Signals\n\n| Signal | When Triggered |\n|--------|---------------|\n| EXIT | Script exits (any reason) |\n| INT | Ctrl+C pressed |\n| TERM | Kill signal received |\n| PIPE | Broken pipe (reader closed) |\n| ERR | Command returns non-zero |\n\n### Cleanup Pattern\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Why EXIT and PIPE?\n\n- **EXIT**: Normal termination, errors, Ctrl+C\n- **PIPE**: Reader closes pipe early (e.g., `head -1`)\n\nWithout PIPE trap:\n```bash\nreaches_all \"a\" | head -1\n# Temp files might not be cleaned up!\n```\n\n### Multiple Traps\n\n```bash\n# Add to existing trap (don't replace)\ntrap 'echo \"Cleaning up...\"; rm -f $tmp' EXIT\n\n# Reset trap\ntrap - EXIT\n\n# Ignore signal\ntrap '' INT  # Ctrl+C ignored\n```", "answer_tailored": true}
{"pair_id": "bash-trap_p1", "cluster_id": "bash-trap", "question": "How do I clean up temp files on exit?", "question_type": "medium", "answer": "To clean up temporary files when your script exits, use the `trap` command to register a cleanup handler for the EXIT signal:\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup handler\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\nThe EXIT signal triggers when the script terminates for any reason\u2014normal completion, errors, or Ctrl+C. This ensures your temp files are always removed.\n\n### Handling Broken Pipes\n\nIf your script might be piped to commands like `head` that close early, also trap PIPE:\n\n```bash\ntrap \"rm -f $tmp_file\" EXIT PIPE\n```\n\nWithout the PIPE trap, temp files may persist when the reader closes the pipe before your script finishes.\n\n### UnifyWeaver Example\n\nUnifyWeaver's graph traversal functions use this pattern with multiple temp files:\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup both files on exit or broken pipe\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Additional Trap Operations\n\n```bash\n# Reset trap to default behavior\ntrap - EXIT\n\n# Ignore a signal\ntrap '' INT  # Ignores Ctrl+C\n```\n\nFor more details on Bash target patterns, see education/book-02-bash-target/04_variable_scope_and_process_substitution.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["trap", "signals", "cleanup", "EXIT", "PIPE"], "original_answer": "## Bash Trap Command\n\nThe `trap` command registers handlers for signals and events.\n\n### Basic Syntax\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\n### Common Signals\n\n| Signal | When Triggered |\n|--------|---------------|\n| EXIT | Script exits (any reason) |\n| INT | Ctrl+C pressed |\n| TERM | Kill signal received |\n| PIPE | Broken pipe (reader closed) |\n| ERR | Command returns non-zero |\n\n### Cleanup Pattern\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Why EXIT and PIPE?\n\n- **EXIT**: Normal termination, errors, Ctrl+C\n- **PIPE**: Reader closes pipe early (e.g., `head -1`)\n\nWithout PIPE trap:\n```bash\nreaches_all \"a\" | head -1\n# Temp files might not be cleaned up!\n```\n\n### Multiple Traps\n\n```bash\n# Add to existing trap (don't replace)\ntrap 'echo \"Cleaning up...\"; rm -f $tmp' EXIT\n\n# Reset trap\ntrap - EXIT\n\n# Ignore signal\ntrap '' INT  # Ctrl+C ignored\n```", "answer_tailored": true}
{"pair_id": "bash-trap_p2", "cluster_id": "bash-trap", "question": "Why use trap with EXIT and PIPE?", "question_type": "medium", "answer": "The `trap` command with EXIT and PIPE ensures cleanup happens in different termination scenarios:\n\n**EXIT trap** handles cleanup when the script terminates normally, encounters errors, or receives Ctrl+C. This catches most common exit paths.\n\n**PIPE trap** handles a specific edge case: when a downstream process closes its pipe early. For example:\n\n```bash\nreaches_all \"a\" | head -1\n```\n\nHere, `head -1` closes the pipe after reading one line. Without the PIPE trap, the script terminates via SIGPIPE, and temporary files might not be cleaned up.\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\nThe combination ensures robust cleanup:\n- **EXIT**: normal exits, errors, interrupts\n- **PIPE**: broken pipe scenarios\n\nThis prevents temporary file leaks in pipeline operations where consumers might close their input stream before the script completes. See education/book-02-bash-target/04_variable_scope_and_process_substitution.md for details on Bash signal handling patterns.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["trap", "signals", "cleanup", "EXIT", "PIPE"], "original_answer": "## Bash Trap Command\n\nThe `trap` command registers handlers for signals and events.\n\n### Basic Syntax\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\n### Common Signals\n\n| Signal | When Triggered |\n|--------|---------------|\n| EXIT | Script exits (any reason) |\n| INT | Ctrl+C pressed |\n| TERM | Kill signal received |\n| PIPE | Broken pipe (reader closed) |\n| ERR | Command returns non-zero |\n\n### Cleanup Pattern\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Why EXIT and PIPE?\n\n- **EXIT**: Normal termination, errors, Ctrl+C\n- **PIPE**: Reader closes pipe early (e.g., `head -1`)\n\nWithout PIPE trap:\n```bash\nreaches_all \"a\" | head -1\n# Temp files might not be cleaned up!\n```\n\n### Multiple Traps\n\n```bash\n# Add to existing trap (don't replace)\ntrap 'echo \"Cleaning up...\"; rm -f $tmp' EXIT\n\n# Reset trap\ntrap - EXIT\n\n# Ignore signal\ntrap '' INT  # Ctrl+C ignored\n```", "answer_tailored": true}
{"pair_id": "bash-trap_p3", "cluster_id": "bash-trap", "question": "What signals can trap handle?", "question_type": "medium", "answer": "The `trap` command in Bash can handle various signals and events:\n\n**Common Signals:**\n- **EXIT** - Triggered when the script exits for any reason (normal termination, errors, Ctrl+C)\n- **INT** - Triggered when Ctrl+C is pressed\n- **TERM** - Triggered when a kill signal is received\n- **PIPE** - Triggered when a pipe breaks (reader closes early)\n- **ERR** - Triggered when a command returns a non-zero exit code\n\n**Signal Numbers:**\nYou can also use numeric signal values (e.g., `SIGINT` is signal 2, `SIGTERM` is signal 15).\n\n**Example Usage:**\n\n```bash\n# Handle cleanup on multiple signals\ntrap 'rm -f $tmp_file' EXIT INT TERM\n\n# Handle broken pipes separately\ntrap 'echo \"Pipe broken\"' PIPE\n\n# Ignore a signal\ntrap '' INT  # Ctrl+C will be ignored\n```\n\n**UnifyWeaver Pattern:**\n\nIn UnifyWeaver's Bash compilation, cleanup handlers typically trap EXIT and PIPE:\n\n```bash\ntrap \"rm -f $queue_file $next_queue\" EXIT PIPE\n```\n\nThis ensures temporary files are removed whether the script exits normally, encounters an error, or has its output pipe closed early (like when piped to `head -1`).\n\nSee `education/book-02-bash-target/04_variable_scope_and_process_substitution.md` for complete details on signal handling patterns.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/04_variable_scope_and_process_substitution.md", "topics": ["trap", "signals", "cleanup", "EXIT", "PIPE"], "original_answer": "## Bash Trap Command\n\nThe `trap` command registers handlers for signals and events.\n\n### Basic Syntax\n\n```bash\ntrap 'commands' SIGNAL [SIGNAL ...]\n```\n\n### Common Signals\n\n| Signal | When Triggered |\n|--------|---------------|\n| EXIT | Script exits (any reason) |\n| INT | Ctrl+C pressed |\n| TERM | Kill signal received |\n| PIPE | Broken pipe (reader closed) |\n| ERR | Command returns non-zero |\n\n### Cleanup Pattern\n\n```bash\n# Create temp file\ntmp_file=$(mktemp)\n\n# Register cleanup\ntrap \"rm -f $tmp_file\" EXIT\n\n# Use temp file safely...\necho \"data\" > \"$tmp_file\"\nprocess \"$tmp_file\"\n\n# Cleanup happens automatically on exit\n```\n\n### UnifyWeaver's Pattern\n\n```bash\nreaches_all() {\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    local next_queue=\"/tmp/reaches_next_$$\"\n    \n    # Cleanup on EXIT or PIPE\n    trap \"rm -f $queue_file $next_queue\" EXIT PIPE\n    \n    # ... BFS logic using temp files ...\n}\n```\n\n### Why EXIT and PIPE?\n\n- **EXIT**: Normal termination, errors, Ctrl+C\n- **PIPE**: Reader closes pipe early (e.g., `head -1`)\n\nWithout PIPE trap:\n```bash\nreaches_all \"a\" | head -1\n# Temp files might not be cleaned up!\n```\n\n### Multiple Traps\n\n```bash\n# Add to existing trap (don't replace)\ntrap 'echo \"Cleaning up...\"; rm -f $tmp' EXIT\n\n# Reset trap\ntrap - EXIT\n\n# Ignore signal\ntrap '' INT  # Ctrl+C ignored\n```", "answer_tailored": true}
{"pair_id": "bash-string-ops_p0", "cluster_id": "bash-string-ops", "question": "What do ${string#pattern} and ${string%pattern} do?", "question_type": "medium", "answer": "The `${string#pattern}` operator removes the shortest match of `pattern` from the **beginning** of the string, while `${string%pattern}` removes the shortest match from the **end** of the string.\n\n## Examples\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove [ from start\necho ${str#[}     # a,b,c]\n\n# Remove ] from end\necho ${str%]}     # [a,b,c\n```\n\n## Practical Use in UnifyWeaver\n\nThese operators are particularly useful for parsing list notation:\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Strip opening bracket\nlist=\"${list%]}\"   # Strip closing bracket\n# Result: a,b,c\n```\n\n## Longest Match Variants\n\nFor more aggressive pattern removal, use the doubled operators:\n\n- `${string##pattern}` - Remove **longest** match from start (useful for stripping directory paths)\n- `${string%%pattern}` - Remove **longest** match from end (useful for removing file extensions)\n\n```bash\npath=\"/usr/local/bin/script.sh\"\necho ${path##*/}   # script.sh (remove longest prefix ending with /)\necho ${path%%/*}   # (empty - removes everything from first /)\n```\n\nFor more advanced string manipulation techniques, see `education/book-02-bash-target/06_advanced_recursion.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["string-manipulation", "parameter-expansion", "substring", "pattern-matching"], "original_answer": "## Bash String Operations\n\nBash has powerful string manipulation via parameter expansion.\n\n### Remove Prefix/Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from start\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from start\necho ${str##*/}   # (for paths)\n\n# Remove longest match from end\necho ${str%%/*}   # (for paths)\n```\n\n### UnifyWeaver List Parsing\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove [\nlist=\"${list%]}\"   # Remove ]\n# Result: a,b,c\n```\n\n### Substring Extraction\n\n```bash\nstr=\"hello world\"\n\n# From position 0, length 5\necho ${str:0:5}    # hello\n\n# From position 6\necho ${str:6}      # world\n\n# Single character at position\necho ${str:0:1}    # h\n```\n\n### String Length\n\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n### Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first occurrence\necho ${str/world/there}   # hello there world\n\n# Replace all occurrences\necho ${str//world/there}  # hello there there\n```\n\n### Pattern Matching in Conditions\n\n```bash\n# Regex match\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob match\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n### UnifyWeaver Tree Parsing\n\n```bash\n# Character-by-character iteration\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```", "answer_tailored": true}
{"pair_id": "bash-string-ops_p1", "cluster_id": "bash-string-ops", "question": "How does bash string manipulation work?", "question_type": "medium", "answer": "Bash provides powerful string manipulation through parameter expansion, which UnifyWeaver uses extensively for parsing Prolog terms.\n\n## Parameter Expansion Basics\n\n**Prefix/Suffix Removal:**\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from beginning\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from beginning\necho ${str##*/}   # useful for paths\n\n# Remove longest match from end\necho ${str%%/*}   # useful for paths\n```\n\n**List Parsing in UnifyWeaver:**\n```bash\n# Strip Prolog list brackets\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Strip opening bracket\nlist=\"${list%]}\"   # Strip closing bracket\n# Result: a,b,c\n```\n\n## Substring Operations\n\n**Extract portions of strings:**\n```bash\nstr=\"hello world\"\n\n# Extract from position with length\necho ${str:0:5}    # hello\n\n# Extract from position to end\necho ${str:6}      # world\n\n# Single character extraction\necho ${str:0:1}    # h\n```\n\n**Get string length:**\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n## Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first match\necho ${str/world/there}   # hello there world\n\n# Replace all matches\necho ${str//world/there}  # hello there there\n```\n\n## Pattern Matching\n\n**In conditional tests:**\n```bash\n# Regex pattern\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob pattern\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n## Character-by-Character Processing\n\n**Used for tree/term parsing:**\n```bash\n# Iterate through each character\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```\n\nThese techniques enable UnifyWeaver to parse and transform Prolog data structures directly in Bash. For comprehensive examples, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["string-manipulation", "parameter-expansion", "substring", "pattern-matching"], "original_answer": "## Bash String Operations\n\nBash has powerful string manipulation via parameter expansion.\n\n### Remove Prefix/Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from start\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from start\necho ${str##*/}   # (for paths)\n\n# Remove longest match from end\necho ${str%%/*}   # (for paths)\n```\n\n### UnifyWeaver List Parsing\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove [\nlist=\"${list%]}\"   # Remove ]\n# Result: a,b,c\n```\n\n### Substring Extraction\n\n```bash\nstr=\"hello world\"\n\n# From position 0, length 5\necho ${str:0:5}    # hello\n\n# From position 6\necho ${str:6}      # world\n\n# Single character at position\necho ${str:0:1}    # h\n```\n\n### String Length\n\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n### Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first occurrence\necho ${str/world/there}   # hello there world\n\n# Replace all occurrences\necho ${str//world/there}  # hello there there\n```\n\n### Pattern Matching in Conditions\n\n```bash\n# Regex match\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob match\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n### UnifyWeaver Tree Parsing\n\n```bash\n# Character-by-character iteration\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```", "answer_tailored": true}
{"pair_id": "bash-string-ops_p2", "cluster_id": "bash-string-ops", "question": "How do I remove prefixes and suffixes in bash?", "question_type": "medium", "answer": "Bash provides built-in parameter expansion for removing prefixes and suffixes from strings:\n\n## Remove Prefix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest matching prefix\necho ${str#[}     # Output: a,b,c]\n\n# Remove longest matching prefix\necho ${str##*/}   # Useful for paths, removes up to last /\n```\n\n## Remove Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest matching suffix\necho ${str%]}     # Output: [a,b,c\n\n# Remove longest matching suffix\necho ${str%%/*}   # Useful for paths, removes from first /\n```\n\n## Common Use Case: List Parsing\n\nIn UnifyWeaver, this is frequently used to strip brackets from Prolog list syntax:\n\n```bash\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove opening bracket\nlist=\"${list%]}\"   # Remove closing bracket\n# Result: a,b,c\n```\n\nThe `#` operator removes from the start, while `%` removes from the end. Single operators (`#`, `%`) match the shortest pattern, while doubled operators (`##`, `%%`) match the longest pattern.\n\nFor additional string manipulation techniques including substring extraction and search/replace, see education/book-02-bash-target/06_advanced_recursion.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["string-manipulation", "parameter-expansion", "substring", "pattern-matching"], "original_answer": "## Bash String Operations\n\nBash has powerful string manipulation via parameter expansion.\n\n### Remove Prefix/Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from start\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from start\necho ${str##*/}   # (for paths)\n\n# Remove longest match from end\necho ${str%%/*}   # (for paths)\n```\n\n### UnifyWeaver List Parsing\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove [\nlist=\"${list%]}\"   # Remove ]\n# Result: a,b,c\n```\n\n### Substring Extraction\n\n```bash\nstr=\"hello world\"\n\n# From position 0, length 5\necho ${str:0:5}    # hello\n\n# From position 6\necho ${str:6}      # world\n\n# Single character at position\necho ${str:0:1}    # h\n```\n\n### String Length\n\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n### Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first occurrence\necho ${str/world/there}   # hello there world\n\n# Replace all occurrences\necho ${str//world/there}  # hello there there\n```\n\n### Pattern Matching in Conditions\n\n```bash\n# Regex match\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob match\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n### UnifyWeaver Tree Parsing\n\n```bash\n# Character-by-character iteration\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```", "answer_tailored": true}
{"pair_id": "bash-string-ops_p3", "cluster_id": "bash-string-ops", "question": "What string operations does UnifyWeaver's generated code use?", "question_type": "medium", "answer": "UnifyWeaver's generated Bash code leverages several string operations through parameter expansion:\n\n**Prefix/Suffix Removal** - Used for parsing structured data like lists:\n```bash\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Strip opening bracket\nlist=\"${list%]}\"   # Strip closing bracket\n```\n\nThe `#` operator removes the shortest prefix match, while `%` removes the shortest suffix match. Doubled versions (`##` and `%%`) remove longest matches, useful for path manipulation.\n\n**Substring Extraction** - Enables positional character access:\n```bash\nstr:position:length   # Extract substring\nstr:0:1              # First character\nstr:6                # From position 6 onward\n```\n\n**String Length** - Retrieved via `${#str}`, critical for iteration bounds when parsing complex structures.\n\n**Character-by-Character Processing** - Combined with C-style loops for tree parsing:\n```bash\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    # Process each character\ndone\n```\n\n**Search/Replace Operations** - Available but less commonly used in core compilation output:\n```bash\n${str/pattern/replacement}    # Replace first match\n${str//pattern/replacement}   # Replace all matches\n```\n\n**Pattern Matching** - For validation in conditional logic:\n```bash\n[[ \"$str\" =~ ^[0-9]+$ ]]     # Regex matching\n[[ \"$str\" == *pattern* ]]     # Glob matching\n```\n\nThese operations appear throughout UnifyWeaver's Bash target output, particularly in recursive predicate handlers and data structure manipulation. See education/book-02-bash-target/06_advanced_recursion.md for detailed examples of string parsing in recursive contexts.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/06_advanced_recursion.md", "topics": ["string-manipulation", "parameter-expansion", "substring", "pattern-matching"], "original_answer": "## Bash String Operations\n\nBash has powerful string manipulation via parameter expansion.\n\n### Remove Prefix/Suffix\n\n```bash\nstr=\"[a,b,c]\"\n\n# Remove shortest match from start\necho ${str#[}     # a,b,c]\n\n# Remove shortest match from end\necho ${str%]}     # [a,b,c\n\n# Remove longest match from start\necho ${str##*/}   # (for paths)\n\n# Remove longest match from end\necho ${str%%/*}   # (for paths)\n```\n\n### UnifyWeaver List Parsing\n\n```bash\n# Parse [a,b,c] format\nlist=\"[a,b,c]\"\nlist=\"${list#[}\"   # Remove [\nlist=\"${list%]}\"   # Remove ]\n# Result: a,b,c\n```\n\n### Substring Extraction\n\n```bash\nstr=\"hello world\"\n\n# From position 0, length 5\necho ${str:0:5}    # hello\n\n# From position 6\necho ${str:6}      # world\n\n# Single character at position\necho ${str:0:1}    # h\n```\n\n### String Length\n\n```bash\nstr=\"hello\"\necho ${#str}       # 5\n```\n\n### Search and Replace\n\n```bash\nstr=\"hello world world\"\n\n# Replace first occurrence\necho ${str/world/there}   # hello there world\n\n# Replace all occurrences\necho ${str//world/there}  # hello there there\n```\n\n### Pattern Matching in Conditions\n\n```bash\n# Regex match\nif [[ \"$str\" =~ ^[0-9]+$ ]]; then\n    echo \"All digits\"\nfi\n\n# Glob match\nif [[ \"$str\" == *world* ]]; then\n    echo \"Contains world\"\nfi\n```\n\n### UnifyWeaver Tree Parsing\n\n```bash\n# Character-by-character iteration\nfor (( i=0; i<${#tree_str}; i++ )); do\n    char=\"${tree_str:$i:1}\"\n    case \"$char\" in\n        '[') ((depth++)) ;;\n        ']') ((depth--)) ;;\n    esac\ndone\n```", "answer_tailored": true}
