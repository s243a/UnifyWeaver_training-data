{"pair_id": "prolog-introspection_p0", "cluster_id": "prolog-introspection", "question": "How does UnifyWeaver analyze Prolog code?", "question_type": "medium", "answer": "UnifyWeaver analyzes Prolog code through **introspection** - the ability to examine and inspect Prolog programs programmatically. This capability enables automatic detection of recursion patterns and call graph construction.\n\nThe core mechanism is the `clause/2` predicate, which retrieves clause definitions:\n\n```prolog\nclause(Head, Body)\n```\n\nWhere `Head` is the clause head (before `:-`) and `Body` is the clause body (after `:-`), or `true` for facts.\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\nUnifyWeaver also uses `functor/3` to decompose and construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\nThese primitives enable predicate analysis:\n\n```prolog\n% Discover what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Detect self-recursion\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nBy combining `clause/2` and `functor/3`, UnifyWeaver builds call graphs and identifies recursion patterns needed for compilation. See education/book-02-bash-target/07_prolog_introspection.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["introspection", "clause/2", "functor/3", "metaprogramming"], "original_answer": "## Prolog Introspection\n\n**Introspection** is the ability of Prolog programs to examine and analyze other Prolog code. UnifyWeaver uses this to detect recursion patterns automatically.\n\n### The clause/2 Predicate\n\nThe foundation of code analysis:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - the clause head (before `:-`)\n- `Body` - the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### The functor/3 Predicate\n\nExtract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Analyzing Predicates\n\n```prolog\n% Find what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Check if self-recursive\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver uses these techniques to build call graphs and detect recursion patterns.", "answer_tailored": true}
{"pair_id": "prolog-introspection_p1", "cluster_id": "prolog-introspection", "question": "What is Prolog introspection?", "question_type": "medium", "answer": "Prolog introspection refers to the capability of Prolog programs to examine and analyze their own code structure. In UnifyWeaver, this introspective ability enables automatic detection of recursion patterns during compilation.\n\nThe primary tool for introspection is the `clause/2` predicate, which retrieves clause definitions:\n\n```prolog\nclause(Head, Body)\n```\n\nHere, `Head` represents the clause head (the part before `:-`), while `Body` contains the clause body (after `:-`), or `true` for facts.\n\n**Example usage:**\n\n```prolog\n% Sample predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Introspect the clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\nAnother key predicate is `functor/3`, which extracts or builds terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\nThese introspection mechanisms allow UnifyWeaver to analyze predicate definitions programmatically:\n\n```prolog\n% Discover which predicates are invoked\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Determine if a predicate calls itself\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nThrough these introspection techniques, UnifyWeaver constructs call graphs and identifies recursion patterns for optimized code generation. For more details on how this integrates with target compilation, see education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["introspection", "clause/2", "functor/3", "metaprogramming"], "original_answer": "## Prolog Introspection\n\n**Introspection** is the ability of Prolog programs to examine and analyze other Prolog code. UnifyWeaver uses this to detect recursion patterns automatically.\n\n### The clause/2 Predicate\n\nThe foundation of code analysis:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - the clause head (before `:-`)\n- `Body` - the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### The functor/3 Predicate\n\nExtract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Analyzing Predicates\n\n```prolog\n% Find what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Check if self-recursive\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver uses these techniques to build call graphs and detect recursion patterns.", "answer_tailored": true}
{"pair_id": "prolog-introspection_p2", "cluster_id": "prolog-introspection", "question": "How do I inspect predicate clauses in Prolog?", "question_type": "medium", "answer": "To inspect predicate clauses in Prolog, use the `clause/2` predicate, which retrieves both the head and body of defined clauses:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` matches the clause head (the part before `:-`)\n- `Body` unifies with the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define some facts and rules\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Inspect the clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### Additional Introspection Tools\n\nThe `functor/3` predicate helps you extract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Practical Analysis\n\nYou can combine these to analyze predicate behavior:\n\n```prolog\n% Discover what predicates are invoked\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Detect self-recursion\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver leverages these introspection capabilities to automatically build call graphs and identify recursion patterns for compilation. See education/book-02-bash-target/07_prolog_introspection.md for the complete guide.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["introspection", "clause/2", "functor/3", "metaprogramming"], "original_answer": "## Prolog Introspection\n\n**Introspection** is the ability of Prolog programs to examine and analyze other Prolog code. UnifyWeaver uses this to detect recursion patterns automatically.\n\n### The clause/2 Predicate\n\nThe foundation of code analysis:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - the clause head (before `:-`)\n- `Body` - the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### The functor/3 Predicate\n\nExtract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Analyzing Predicates\n\n```prolog\n% Find what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Check if self-recursive\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver uses these techniques to build call graphs and detect recursion patterns.", "answer_tailored": true}
{"pair_id": "prolog-introspection_p3", "cluster_id": "prolog-introspection", "question": "What is clause/2 used for?", "question_type": "medium", "answer": "The `clause/2` predicate is Prolog's fundamental tool for examining the structure of defined clauses. It takes two arguments:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - matches the clause head (the part before `:-`)\n- `Body` - unifies with the clause body (the part after `:-`), or `true` for facts\n\n**Usage example:**\n\n```prolog\n% Given these facts\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query their structure\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\nIn UnifyWeaver, `clause/2` is essential for **introspection** - analyzing Prolog code programmatically. The compiler uses it to automatically detect recursion patterns and build call graphs. Combined with `functor/3`, it enables sophisticated code analysis:\n\n```prolog\n% Discover what predicates a rule calls\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n```\n\nThis introspection capability allows UnifyWeaver to transform recursive Prolog predicates into efficient loops in target languages like Bash, Python, Go, Rust, C#, PowerShell, and SQL.\n\nSee education/book-02-bash-target/07_prolog_introspection.md for complete details on introspection techniques.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["introspection", "clause/2", "functor/3", "metaprogramming"], "original_answer": "## Prolog Introspection\n\n**Introspection** is the ability of Prolog programs to examine and analyze other Prolog code. UnifyWeaver uses this to detect recursion patterns automatically.\n\n### The clause/2 Predicate\n\nThe foundation of code analysis:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - the clause head (before `:-`)\n- `Body` - the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### The functor/3 Predicate\n\nExtract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Analyzing Predicates\n\n```prolog\n% Find what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Check if self-recursive\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver uses these techniques to build call graphs and detect recursion patterns.", "answer_tailored": true}
{"pair_id": "call-graph-construction_p0", "cluster_id": "call-graph-construction", "question": "What is a call graph in UnifyWeaver?", "question_type": "medium", "answer": "A **call graph** in UnifyWeaver is a directed graph that maps out how predicates depend on each other. Each node represents a predicate (written as `Pred/Arity`), and edges show calling relationships\u2014if predicate A calls predicate B, there's an edge `A -> B`.\n\nCall graphs help identify important code patterns:\n- **Self-recursion** when a predicate calls itself\n- **Mutual recursion** shown as cycles between predicates  \n- **Dependency chains** that determine compilation order\n- **Reachability** to find all predicates actually used\n\nTo build a call graph in UnifyWeaver:\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define your predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Extract dependencies for a predicate\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Construct the complete graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\nThe call graph builder analyzes clause bodies to extract calls from conjunctions `(A, B)`, disjunctions `(A; B)`, conditionals `(A -> B)`, and negations `\\+ A`. For more on Prolog introspection features, see education/book-02-bash-target/07_prolog_introspection.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["call-graph", "dependency-analysis", "code-analysis"], "original_answer": "## Call Graph Construction\n\nA **call graph** is a directed graph showing predicate dependencies:\n- **Nodes**: Predicates (`Pred/Arity`)\n- **Edges**: Calls (`A -> B` means A calls B)\n\n### What Call Graphs Reveal\n\n- **Self-recursion**: Predicate calls itself\n- **Mutual recursion**: Cycle between predicates\n- **Dependencies**: Compilation order\n- **Reachability**: All predicates used\n\n### Building a Call Graph\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Get dependencies\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Build full graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\n### Extracting Calls from Bodies\n\nThe system handles:\n- Conjunctions: `(A, B)`\n- Disjunctions: `(A; B)`\n- Conditionals: `(A -> B)`\n- Negations: `\\+ A`\n\n```prolog\n% Recursively walks clause body\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```", "answer_tailored": true}
{"pair_id": "call-graph-construction_p1", "cluster_id": "call-graph-construction", "question": "How does UnifyWeaver build dependency graphs?", "question_type": "medium", "answer": "UnifyWeaver constructs dependency graphs by analyzing predicate relationships within Prolog code. The system builds a **call graph** - a directed graph where nodes represent predicates (in `Pred/Arity` format) and edges represent calling relationships (if predicate A calls predicate B, there's an edge A \u2192 B).\n\nThe dependency analysis process:\n\n1. **Extract dependencies** using `get_dependencies/2` to find all predicates called by a target predicate\n2. **Build the complete graph** with `build_call_graph/2`, which creates edge lists showing all calling relationships\n3. **Parse clause bodies** by recursively walking through Prolog constructs including conjunctions `(A, B)`, disjunctions `(A; B)`, conditionals `(A -> B)`, and negations `\\+ A`\n\nExample workflow:\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% After defining predicates like ancestor/2\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\nThese dependency graphs reveal critical information: self-recursion (predicates calling themselves), mutual recursion (cycles between predicates), proper compilation ordering, and complete reachability analysis showing all predicates actually used.\n\nFor implementation details, see education/book-02-bash-target/07_prolog_introspection.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["call-graph", "dependency-analysis", "code-analysis"], "original_answer": "## Call Graph Construction\n\nA **call graph** is a directed graph showing predicate dependencies:\n- **Nodes**: Predicates (`Pred/Arity`)\n- **Edges**: Calls (`A -> B` means A calls B)\n\n### What Call Graphs Reveal\n\n- **Self-recursion**: Predicate calls itself\n- **Mutual recursion**: Cycle between predicates\n- **Dependencies**: Compilation order\n- **Reachability**: All predicates used\n\n### Building a Call Graph\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Get dependencies\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Build full graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\n### Extracting Calls from Bodies\n\nThe system handles:\n- Conjunctions: `(A, B)`\n- Disjunctions: `(A; B)`\n- Conditionals: `(A -> B)`\n- Negations: `\\+ A`\n\n```prolog\n% Recursively walks clause body\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```", "answer_tailored": true}
{"pair_id": "call-graph-construction_p2", "cluster_id": "call-graph-construction", "question": "How are predicate dependencies detected?", "question_type": "medium", "answer": "UnifyWeaver detects predicate dependencies by analyzing clause bodies and building a call graph. The system recursively walks through different control structures:\n\n- **Conjunctions** (`A, B`): Checks both branches\n- **Disjunctions** (`A; B`): Examines all alternatives  \n- **Conditionals** (`A -> B`): Inspects condition and consequence\n- **Negations** (`\\+ A`): Looks inside negated goals\n\nThe `extract_calls/2` predicate handles this traversal:\n\n```prolog\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```\n\nThis analysis feeds into `get_dependencies/2`, which returns all predicates that a given predicate calls:\n\n```prolog\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n```\n\nThe full call graph shows the complete dependency structure, revealing self-recursion (predicate calls itself), mutual recursion (cycles), and compilation order requirements. See education/book-02-bash-target/07_prolog_introspection.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["call-graph", "dependency-analysis", "code-analysis"], "original_answer": "## Call Graph Construction\n\nA **call graph** is a directed graph showing predicate dependencies:\n- **Nodes**: Predicates (`Pred/Arity`)\n- **Edges**: Calls (`A -> B` means A calls B)\n\n### What Call Graphs Reveal\n\n- **Self-recursion**: Predicate calls itself\n- **Mutual recursion**: Cycle between predicates\n- **Dependencies**: Compilation order\n- **Reachability**: All predicates used\n\n### Building a Call Graph\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Get dependencies\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Build full graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\n### Extracting Calls from Bodies\n\nThe system handles:\n- Conjunctions: `(A, B)`\n- Disjunctions: `(A; B)`\n- Conditionals: `(A -> B)`\n- Negations: `\\+ A`\n\n```prolog\n% Recursively walks clause body\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```", "answer_tailored": true}
{"pair_id": "call-graph-construction_p3", "cluster_id": "call-graph-construction", "question": "What does call graph analysis reveal?", "question_type": "medium", "answer": "Call graph analysis reveals several critical aspects of predicate relationships:\n\n**Self-recursion**: When a predicate calls itself directly, which affects compilation strategy and termination analysis.\n\n**Mutual recursion**: Cycles between multiple predicates that call each other, important for understanding predicate dependencies.\n\n**Compilation order**: The proper sequence for compiling predicates based on their dependencies, ensuring called predicates are available before their callers.\n\n**Reachability**: Which predicates are actually used in the program, helping identify dead code and required compilation units.\n\nThe call graph is constructed as a directed graph where nodes represent predicates (`Pred/Arity`) and edges represent calls (`A -> B` means predicate A calls predicate B). The system extracts calls by recursively walking clause bodies, handling conjunctions `(A, B)`, disjunctions `(A; B)`, conditionals `(A -> B)`, and negations `\\+ A`.\n\nFor practical usage, see `unifyweaver/core/advanced/call_graph` which provides `get_dependencies/2` to find what a predicate calls and `build_call_graph/2` to construct the full dependency graph. More details on introspection capabilities are in education/book-02-bash-target/07_prolog_introspection.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["call-graph", "dependency-analysis", "code-analysis"], "original_answer": "## Call Graph Construction\n\nA **call graph** is a directed graph showing predicate dependencies:\n- **Nodes**: Predicates (`Pred/Arity`)\n- **Edges**: Calls (`A -> B` means A calls B)\n\n### What Call Graphs Reveal\n\n- **Self-recursion**: Predicate calls itself\n- **Mutual recursion**: Cycle between predicates\n- **Dependencies**: Compilation order\n- **Reachability**: All predicates used\n\n### Building a Call Graph\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Get dependencies\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Build full graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\n### Extracting Calls from Bodies\n\nThe system handles:\n- Conjunctions: `(A, B)`\n- Disjunctions: `(A; B)`\n- Conditionals: `(A -> B)`\n- Negations: `\\+ A`\n\n```prolog\n% Recursively walks clause body\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```", "answer_tailored": true}
{"pair_id": "scc-detection_p0", "cluster_id": "scc-detection", "question": "What is SCC detection in UnifyWeaver?", "question_type": "medium", "answer": "**SCC detection** in UnifyWeaver identifies **Strongly Connected Components** in predicate call graphs to detect mutual recursion. An SCC is a maximal set of predicates where every predicate can reach every other through calls.\n\n**Why It Matters:**\n\nWhen predicates call each other cyclically (mutual recursion), they form an SCC:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nBoth predicates are in the same SCC since `is_even/1` calls `is_odd/1` and vice versa.\n\n**Implementation:**\n\nUnifyWeaver uses **Tarjan's algorithm** (O(V+E) complexity) which performs depth-first search while tracking visit order (`index`) and the smallest reachable index (`lowlink`). When these values match, the node is an SCC root.\n\n**Example Usage:**\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % Mutual recursion detected\n\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % Non-trivial: multiple predicates\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Trivial: single predicate (self-recursion)\n```\n\nSee education/book-02-bash-target/07_prolog_introspection.md for full details on SCC detection and call graph analysis.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithms"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn **SCC** is a maximal set of nodes where every node is reachable from every other.\n\n### Why SCCs Matter\n\nMutual recursion forms cycles:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even/1 -> is_odd/1\nis_odd/1  -> is_even/1\n```\n\nBoth predicates are in the **same SCC** = mutual recursion!\n\n### Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm (O(V+E)):\n\n1. Perform depth-first search\n2. Track `index` (visit order) and `lowlink` (smallest reachable index)\n3. When `index == lowlink`, node is SCC root\n\n### Usage\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Build call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n\n% Find SCCs\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % One SCC!\n\n% Check if non-trivial (mutual recursion)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % More than one predicate = mutual recursion\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Single predicate = self-recursion only\n```", "answer_tailored": true}
{"pair_id": "scc-detection_p1", "cluster_id": "scc-detection", "question": "How does UnifyWeaver detect mutual recursion?", "question_type": "medium", "answer": "UnifyWeaver detects mutual recursion by identifying **Strongly Connected Components (SCCs)** in the call graph using **Tarjan's algorithm**.\n\nWhen predicates call each other in a cycle, they form an SCC. For example:\n\n```prolog\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nThis creates a cycle: `is_even/1 \u2192 is_odd/1 \u2192 is_even/1`\n\nTarjan's algorithm (O(V+E) complexity) finds these cycles by:\n1. Traversing the call graph depth-first\n2. Tracking each node's `index` (visit order) and `lowlink` (smallest reachable index)\n3. Identifying SCC roots where `index == lowlink`\n\nWhen an SCC contains multiple predicates, that's mutual recursion:\n\n```prolog\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].\n\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % Non-trivial SCC = mutual recursion detected\n```\n\nThe detection is implemented in `unifyweaver(core/advanced/scc_detection)`. See education/book-02-bash-target/07_prolog_introspection.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithms"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn **SCC** is a maximal set of nodes where every node is reachable from every other.\n\n### Why SCCs Matter\n\nMutual recursion forms cycles:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even/1 -> is_odd/1\nis_odd/1  -> is_even/1\n```\n\nBoth predicates are in the **same SCC** = mutual recursion!\n\n### Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm (O(V+E)):\n\n1. Perform depth-first search\n2. Track `index` (visit order) and `lowlink` (smallest reachable index)\n3. When `index == lowlink`, node is SCC root\n\n### Usage\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Build call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n\n% Find SCCs\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % One SCC!\n\n% Check if non-trivial (mutual recursion)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % More than one predicate = mutual recursion\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Single predicate = self-recursion only\n```", "answer_tailored": true}
{"pair_id": "scc-detection_p2", "cluster_id": "scc-detection", "question": "What is Tarjan's algorithm?", "question_type": "medium", "answer": "Tarjan's algorithm is a graph traversal technique used to find strongly connected components (SCCs) in linear O(V+E) time. UnifyWeaver employs it to detect mutual recursion in Prolog predicates.\n\nThe algorithm works by:\n1. Performing a depth-first search through the call graph\n2. Maintaining two values per node: `index` (the order visited) and `lowlink` (the smallest index reachable from that node)\n3. Identifying an SCC root when `index == lowlink` for a node\n\nWhen two predicates call each other (like `is_even/1` and `is_odd/1`), they form a cycle in the call graph and belong to the same SCC\u2014this indicates mutual recursion. The algorithm efficiently identifies these groups.\n\nYou can use it via `unifyweaver(core/advanced/scc_detection)`:\n\n```prolog\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % Mutual recursion detected\n```\n\nFor implementation details and examples, see `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithms"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn **SCC** is a maximal set of nodes where every node is reachable from every other.\n\n### Why SCCs Matter\n\nMutual recursion forms cycles:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even/1 -> is_odd/1\nis_odd/1  -> is_even/1\n```\n\nBoth predicates are in the **same SCC** = mutual recursion!\n\n### Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm (O(V+E)):\n\n1. Perform depth-first search\n2. Track `index` (visit order) and `lowlink` (smallest reachable index)\n3. When `index == lowlink`, node is SCC root\n\n### Usage\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Build call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n\n% Find SCCs\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % One SCC!\n\n% Check if non-trivial (mutual recursion)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % More than one predicate = mutual recursion\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Single predicate = self-recursion only\n```", "answer_tailored": true}
{"pair_id": "scc-detection_p3", "cluster_id": "scc-detection", "question": "How are strongly connected components found?", "question_type": "medium", "answer": "UnifyWeaver finds strongly connected components using **Tarjan's algorithm**, which runs in O(V+E) time complexity.\n\nThe algorithm works by:\n\n1. **Depth-first search traversal** - Visit each node in the call graph\n2. **Index tracking** - Assign each node a visit order number (`index`)\n3. **Lowlink computation** - Track the smallest index reachable from each node (`lowlink`)\n4. **SCC identification** - When a node's `index == lowlink`, it's an SCC root and all nodes on the stack up to that point form one SCC\n\nThis detects mutual recursion patterns like `is_even/1` \u2194 `is_odd/1`, which end up in the same strongly connected component since every predicate in the cycle is reachable from every other.\n\n**Implementation:**\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].\n```\n\nFor more on call graph analysis and recursion patterns, see `education/book-02-bash-target/07_prolog_introspection.md`.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithms"], "original_answer": "## Strongly Connected Components (SCC)\n\nAn **SCC** is a maximal set of nodes where every node is reachable from every other.\n\n### Why SCCs Matter\n\nMutual recursion forms cycles:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even/1 -> is_odd/1\nis_odd/1  -> is_even/1\n```\n\nBoth predicates are in the **same SCC** = mutual recursion!\n\n### Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm (O(V+E)):\n\n1. Perform depth-first search\n2. Track `index` (visit order) and `lowlink` (smallest reachable index)\n3. When `index == lowlink`, node is SCC root\n\n### Usage\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Build call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n\n% Find SCCs\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % One SCC!\n\n% Check if non-trivial (mutual recursion)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % More than one predicate = mutual recursion\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Single predicate = self-recursion only\n```", "answer_tailored": true}
{"pair_id": "pattern-matching-detection_p0", "cluster_id": "pattern-matching-detection", "question": "How does UnifyWeaver classify recursion patterns?", "question_type": "medium", "answer": "UnifyWeaver classifies recursion patterns using specialized pattern matchers that analyze predicate structure and recursive call placement:\n\n**Classification Categories (in priority order):**\n\n1. **Tail Recursion** - Highest priority\n   - Recursive call appears in tail position (last operation)\n   - Uses accumulator pattern\n   - Common signature: `pred(Input, Acc, Result)` with arity 3\n\n2. **Linear Recursion** - Second priority\n   - Contains exactly one recursive call per clause\n   - Arguments are pre-computed rather than pattern-matched\n\n3. **Tree Recursion** - Structural patterns\n   - Handles tree-like structures `[V, L, R]`\n   - Multiple recursive calls for left/right branches\n\n4. **Mutual Recursion** - Detected via SCC analysis\n   - Predicates that call each other cyclically\n\n5. **Basic Recursion** - Fallback pattern\n   - Uses breadth-first search when specialized patterns don't apply\n\n**Key Distinction: Tail vs Non-Tail**\n\n```prolog\n% TAIL: recursive call is final operation\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- tail position\n\n% NON-TAIL: work happens after recursive call  \nlength([_|T], N) :-\n    length(T, N1),      % <- not tail\n    N is N1 + 1.        % computation follows\n```\n\nThe classifier exposes predicates like `is_tail_recursive_accumulator/2` and `is_linear_recursive_streamable/1` for pattern detection. See education/book-02-bash-target/07_prolog_introspection.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["pattern-detection", "tail-recursion", "linear-recursion", "classification"], "original_answer": "## Pattern Detection\n\nUnifyWeaver uses pattern matchers to classify predicates:\n\n### Pattern 1: Tail Recursion\n\n**Characteristics:**\n- Recursive call is LAST (tail position)\n- Uses accumulator\n- Typically arity 3: `pred(Input, Acc, Result)`\n\n```prolog\n% Tail position - recursive call is last\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- TAIL\n\n% NOT tail - work after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- NOT tail\n    N is N1 + 1.        % work happens after!\n```\n\n### Pattern 2: Linear Recursion\n\n- Exactly ONE recursive call per clause\n- Arguments pre-computed (not pattern matching)\n\n### Pattern 3: Tree Recursion\n\n- Structural decomposition `[V, L, R]`\n- Multiple recursive calls\n\n### Pattern Selection Priority\n\n1. **Tail recursion** (most efficient)\n2. **Linear recursion** (unless forbidden)\n3. **Tree recursion** (structural)\n4. **Mutual recursion** (via SCC)\n5. **Basic recursion** (fallback BFS)\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```", "answer_tailored": true}
{"pair_id": "pattern-matching-detection_p1", "cluster_id": "pattern-matching-detection", "question": "What patterns does UnifyWeaver detect?", "question_type": "medium", "answer": "UnifyWeaver detects several recursion and structural patterns to optimize compilation:\n\n**Tail Recursion Pattern**\n- Recursive call in tail position (last operation in clause)\n- Uses accumulator parameter\n- Common signature: `pred(Input, Acc, Result)`\n- Most efficient for loop generation\n\n**Linear Recursion Pattern**\n- Single recursive call per clause\n- Arguments computed before the call (not via pattern matching)\n- Suitable for sequential processing\n\n**Tree Recursion Pattern**\n- Structural decomposition like `[Value, Left, Right]`\n- Multiple recursive calls navigating tree structure\n- Used for hierarchical data\n\n**Mutual Recursion Pattern**\n- Detected via Strongly Connected Components (SCC) analysis\n- Multiple predicates calling each other cyclically\n\n**Pattern Selection Priority:**\nThe compiler prefers tail recursion (generates efficient loops), then linear recursion (if not forbidden), tree recursion (for structural decomposition), mutual recursion (via SCC), and finally basic recursion using breadth-first search as fallback.\n\nExample detection:\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```\n\nSee education/book-02-bash-target/07_prolog_introspection.md for complete pattern detection details.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["pattern-detection", "tail-recursion", "linear-recursion", "classification"], "original_answer": "## Pattern Detection\n\nUnifyWeaver uses pattern matchers to classify predicates:\n\n### Pattern 1: Tail Recursion\n\n**Characteristics:**\n- Recursive call is LAST (tail position)\n- Uses accumulator\n- Typically arity 3: `pred(Input, Acc, Result)`\n\n```prolog\n% Tail position - recursive call is last\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- TAIL\n\n% NOT tail - work after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- NOT tail\n    N is N1 + 1.        % work happens after!\n```\n\n### Pattern 2: Linear Recursion\n\n- Exactly ONE recursive call per clause\n- Arguments pre-computed (not pattern matching)\n\n### Pattern 3: Tree Recursion\n\n- Structural decomposition `[V, L, R]`\n- Multiple recursive calls\n\n### Pattern Selection Priority\n\n1. **Tail recursion** (most efficient)\n2. **Linear recursion** (unless forbidden)\n3. **Tree recursion** (structural)\n4. **Mutual recursion** (via SCC)\n5. **Basic recursion** (fallback BFS)\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```", "answer_tailored": true}
{"pair_id": "pattern-matching-detection_p2", "cluster_id": "pattern-matching-detection", "question": "How is tail recursion detected?", "question_type": "medium", "answer": "UnifyWeaver detects tail recursion by analyzing predicate structure with pattern matchers. A predicate qualifies as tail-recursive when:\n\n**Key Detection Criteria:**\n- The recursive call appears in tail position (last operation in clause body)\n- Uses an accumulator pattern\n- Typically has arity 3: `pred(Input, Accumulator, Result)`\n\n**Example of Tail Position:**\n```prolog\n% TAIL RECURSIVE - recursive call is final operation\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- In tail position\n\n% NOT TAIL RECURSIVE - computation after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- Not in tail position\n    N is N1 + 1.        % Additional work follows\n```\n\nThe system queries predicates using `is_tail_recursive_accumulator/2`:\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n```\n\nTail recursion receives highest priority during pattern selection since it compiles to efficient loops in target languages. When detected, UnifyWeaver can optimize the code to avoid stack growth.\n\nFor implementation details on recursion pattern detection, see education/book-02-bash-target/07_prolog_introspection.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["pattern-detection", "tail-recursion", "linear-recursion", "classification"], "original_answer": "## Pattern Detection\n\nUnifyWeaver uses pattern matchers to classify predicates:\n\n### Pattern 1: Tail Recursion\n\n**Characteristics:**\n- Recursive call is LAST (tail position)\n- Uses accumulator\n- Typically arity 3: `pred(Input, Acc, Result)`\n\n```prolog\n% Tail position - recursive call is last\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- TAIL\n\n% NOT tail - work after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- NOT tail\n    N is N1 + 1.        % work happens after!\n```\n\n### Pattern 2: Linear Recursion\n\n- Exactly ONE recursive call per clause\n- Arguments pre-computed (not pattern matching)\n\n### Pattern 3: Tree Recursion\n\n- Structural decomposition `[V, L, R]`\n- Multiple recursive calls\n\n### Pattern Selection Priority\n\n1. **Tail recursion** (most efficient)\n2. **Linear recursion** (unless forbidden)\n3. **Tree recursion** (structural)\n4. **Mutual recursion** (via SCC)\n5. **Basic recursion** (fallback BFS)\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```", "answer_tailored": true}
{"pair_id": "pattern-matching-detection_p3", "cluster_id": "pattern-matching-detection", "question": "What is the pattern selection priority?", "question_type": "medium", "answer": "Pattern selection in UnifyWeaver follows a specific priority order to optimize code generation:\n\n1. **Tail recursion** - Highest priority, most efficient pattern. Detected when the recursive call is in tail position with an accumulator.\n2. **Linear recursion** - Second choice (unless explicitly forbidden). Single recursive call per clause with pre-computed arguments.\n3. **Tree recursion** - Selected for structural decomposition cases (e.g., `[V, L, R]` patterns) with multiple recursive calls.\n4. **Mutual recursion** - Handles mutually recursive predicates through strongly connected component (SCC) analysis.\n5. **Basic recursion** - Fallback strategy using breadth-first search when other patterns don't match.\n\nThe compiler automatically detects which pattern applies using introspection predicates like `is_tail_recursive_accumulator/2` and `is_linear_recursive_streamable/1`. This prioritization ensures the most efficient target code generation, with tail recursion preferred when possible.\n\nFor implementation details, see education/book-02-bash-target/07_prolog_introspection.md.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/07_prolog_introspection.md", "topics": ["pattern-detection", "tail-recursion", "linear-recursion", "classification"], "original_answer": "## Pattern Detection\n\nUnifyWeaver uses pattern matchers to classify predicates:\n\n### Pattern 1: Tail Recursion\n\n**Characteristics:**\n- Recursive call is LAST (tail position)\n- Uses accumulator\n- Typically arity 3: `pred(Input, Acc, Result)`\n\n```prolog\n% Tail position - recursive call is last\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- TAIL\n\n% NOT tail - work after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- NOT tail\n    N is N1 + 1.        % work happens after!\n```\n\n### Pattern 2: Linear Recursion\n\n- Exactly ONE recursive call per clause\n- Arguments pre-computed (not pattern matching)\n\n### Pattern 3: Tree Recursion\n\n- Structural decomposition `[V, L, R]`\n- Multiple recursive calls\n\n### Pattern Selection Priority\n\n1. **Tail recursion** (most efficient)\n2. **Linear recursion** (unless forbidden)\n3. **Tree recursion** (structural)\n4. **Mutual recursion** (via SCC)\n5. **Basic recursion** (fallback BFS)\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```", "answer_tailored": true}
