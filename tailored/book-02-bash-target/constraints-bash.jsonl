{"pair_id": "bash-constraints_p0", "cluster_id": "bash-constraints", "question": "How do constraints affect Bash code generation?", "question_type": "medium", "answer": "Constraints directly influence which deduplication strategy UnifyWeaver uses when generating Bash code from Prolog rules.\n\n### Three Deduplication Approaches\n\nThe combination of `unique` and `unordered` constraint flags determines the output strategy:\n\n**1. Sort & Unique Pipeline (`unique(true), unordered(true)`)**\n```bash\ngrandparent() {\n    parent_stream | parent_join | sort -u\n}\n```\nThis is the default and most efficient approach. Results are piped through `sort -u` for fast deduplication, though order isn't guaranteed.\n\n**2. Hash-Based Deduplication (`unique(true), ordered`)**\n```bash\nevent_log_stream() {\n    declare -A seen\n    for key in \"${event_log_data[@]}\"; do\n        if [[ -z \"${seen[$key]}\" ]]; then\n            seen[$key]=1\n            echo \"$key\"\n        fi\n    done\n}\n```\nWhen order matters, UnifyWeaver generates a loop with an associative array to track seen values. This preserves insertion order at the cost of memory overhead.\n\n**3. No Deduplication (`unique(false)`)**\n```bash\nraw_log_stream() {\n    for key in \"${raw_log_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n```\nRaw iteration without any deduplication\u2014useful for counting occurrences or processing unfiltered logs.\n\n### Practical Impact\n\nFor a predicate like `user_action/3` with constraint `[unique, ordered]`, timeline events maintain chronological sequence while filtering duplicates:\n\n```prolog\n:- constraint(user_action/3, [unique, ordered]).\n```\n\nThis ensures actions like `login`, `read_file` appear in the correct temporal order without repetition.\n\nFor more details on Bash target compilation, see education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/03_advanced_constraints.md", "topics": ["constraints", "unique", "ordered", "deduplication", "bash"], "original_answer": "## Constraints and Bash Code Generation\n\nConstraints control deduplication strategy in generated Bash code.\n\n### Deduplication Strategy Matrix\n\n| unique | unordered | Strategy | Bash Code |\n|--------|-----------|----------|----------|\n| true | true | Sort & Unique | `... \\| sort -u` |\n| true | false | Hash Dedup | `declare -A seen` loop |\n| false | * | None | Raw output |\n\n### Strategy 1: Sort & Unique (Default)\n\n```prolog\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n```\n\n**Generated:**\n```bash\ngrandparent() {\n    parent_stream | parent_join | sort -u\n}\n```\n\n**Pros:** Fast, efficient  \n**Cons:** Changes order\n\n### Strategy 2: Hash Deduplication\n\n```prolog\n:- constraint(event_log/3, [unique(true), ordered]).\n```\n\n**Generated:**\n```bash\nevent_log_stream() {\n    declare -A seen\n    for key in \"${event_log_data[@]}\"; do\n        if [[ -z \"${seen[$key]}\" ]]; then\n            seen[$key]=1\n            echo \"$key\"\n        fi\n    done\n}\n```\n\n**Pros:** Preserves original order  \n**Cons:** Uses memory for seen hash\n\n### Strategy 3: No Deduplication\n\n```prolog\n:- constraint(raw_log/3, [unique(false), ordered]).\n```\n\n**Generated:**\n```bash\nraw_log_stream() {\n    for key in \"${raw_log_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n```\n\n**Use case:** Counting, raw log processing\n\n### Example: Timeline Events\n\n```prolog\n:- constraint(user_action/3, [unique, ordered]).\n\nuser_action(100, alice, login).\nuser_action(101, bob, login).\nuser_action(102, alice, read_file).\n```\n\nWith `[unique, ordered]`, duplicate actions are removed but chronological order is preserved.", "answer_tailored": true}
{"pair_id": "bash-constraints_p1", "cluster_id": "bash-constraints", "question": "What deduplication strategies does UnifyWeaver use for Bash?", "question_type": "medium", "answer": "UnifyWeaver implements three deduplication strategies for Bash target code, controlled by constraint declarations:\n\n**1. Sort & Unique (sort -u)**\nWhen both `unique(true)` and `unordered(true)` are specified, the compiler generates `sort -u` pipeline commands. This is the default and most efficient approach, though it reorders results alphabetically.\n\n```prolog\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n```\nGenerates: `parent_stream | parent_join | sort -u`\n\n**2. Hash-based Deduplication**\nFor `unique(true)` with ordered results, UnifyWeaver generates Bash associative arrays (`declare -A seen`) to track encountered values while maintaining insertion order. This preserves chronological sequence for time-series data like event logs.\n\n```prolog\n:- constraint(event_log/3, [unique(true), ordered]).\n```\nGenerates a loop checking `seen[$key]` before output.\n\n**3. No Deduplication**\nSetting `unique(false)` generates straightforward iteration with no filtering\u2014useful for counting occurrences or processing raw logs where duplicates are meaningful.\n\nThe strategy selection is automatic based on your constraint annotations. For timeline events requiring both uniqueness and temporal order, use `[unique, ordered]` to get hash-based deduplication. See education/book-02-bash-target/03_advanced_constraints.md for complete examples and performance trade-offs.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/03_advanced_constraints.md", "topics": ["constraints", "unique", "ordered", "deduplication", "bash"], "original_answer": "## Constraints and Bash Code Generation\n\nConstraints control deduplication strategy in generated Bash code.\n\n### Deduplication Strategy Matrix\n\n| unique | unordered | Strategy | Bash Code |\n|--------|-----------|----------|----------|\n| true | true | Sort & Unique | `... \\| sort -u` |\n| true | false | Hash Dedup | `declare -A seen` loop |\n| false | * | None | Raw output |\n\n### Strategy 1: Sort & Unique (Default)\n\n```prolog\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n```\n\n**Generated:**\n```bash\ngrandparent() {\n    parent_stream | parent_join | sort -u\n}\n```\n\n**Pros:** Fast, efficient  \n**Cons:** Changes order\n\n### Strategy 2: Hash Deduplication\n\n```prolog\n:- constraint(event_log/3, [unique(true), ordered]).\n```\n\n**Generated:**\n```bash\nevent_log_stream() {\n    declare -A seen\n    for key in \"${event_log_data[@]}\"; do\n        if [[ -z \"${seen[$key]}\" ]]; then\n            seen[$key]=1\n            echo \"$key\"\n        fi\n    done\n}\n```\n\n**Pros:** Preserves original order  \n**Cons:** Uses memory for seen hash\n\n### Strategy 3: No Deduplication\n\n```prolog\n:- constraint(raw_log/3, [unique(false), ordered]).\n```\n\n**Generated:**\n```bash\nraw_log_stream() {\n    for key in \"${raw_log_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n```\n\n**Use case:** Counting, raw log processing\n\n### Example: Timeline Events\n\n```prolog\n:- constraint(user_action/3, [unique, ordered]).\n\nuser_action(100, alice, login).\nuser_action(101, bob, login).\nuser_action(102, alice, read_file).\n```\n\nWith `[unique, ordered]`, duplicate actions are removed but chronological order is preserved.", "answer_tailored": true}
{"pair_id": "bash-constraints_p2", "cluster_id": "bash-constraints", "question": "What is the difference between sort -u and hash deduplication?", "question_type": "medium", "answer": "The key difference lies in **order preservation and implementation**:\n\n**`sort -u` (Sort & Unique)**\n- Deduplicates by sorting then removing adjacent duplicates\n- **Changes the order** of results (alphabetical or numerical sorting)\n- Fast and efficient, minimal memory overhead\n- Used when `[unique(true), unordered(true)]`\n\n```bash\nparent_stream | parent_join | sort -u\n```\n\n**Hash Deduplication**\n- Deduplicates using a `declare -A seen` associative array\n- **Preserves original order** of first occurrence\n- Higher memory usage (stores all seen keys)\n- Used when `[unique(true), ordered]` or `[unique(true), unordered(false)]`\n\n```bash\ndeclare -A seen\nfor key in \"${event_log_data[@]}\"; do\n    if [[ -z \"${seen[$key]}\" ]]; then\n        seen[$key]=1\n        echo \"$key\"\n    fi\ndone\n```\n\n**When to use which:**\n- Use `sort -u` when order doesn't matter and you want speed/efficiency\n- Use hash dedup when preserving chronological or insertion order is required (e.g., timeline events, ordered logs)\n\nSee `education/book-02-bash-target/03_advanced_constraints.md` for the complete deduplication strategy matrix and constraint syntax.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/03_advanced_constraints.md", "topics": ["constraints", "unique", "ordered", "deduplication", "bash"], "original_answer": "## Constraints and Bash Code Generation\n\nConstraints control deduplication strategy in generated Bash code.\n\n### Deduplication Strategy Matrix\n\n| unique | unordered | Strategy | Bash Code |\n|--------|-----------|----------|----------|\n| true | true | Sort & Unique | `... \\| sort -u` |\n| true | false | Hash Dedup | `declare -A seen` loop |\n| false | * | None | Raw output |\n\n### Strategy 1: Sort & Unique (Default)\n\n```prolog\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n```\n\n**Generated:**\n```bash\ngrandparent() {\n    parent_stream | parent_join | sort -u\n}\n```\n\n**Pros:** Fast, efficient  \n**Cons:** Changes order\n\n### Strategy 2: Hash Deduplication\n\n```prolog\n:- constraint(event_log/3, [unique(true), ordered]).\n```\n\n**Generated:**\n```bash\nevent_log_stream() {\n    declare -A seen\n    for key in \"${event_log_data[@]}\"; do\n        if [[ -z \"${seen[$key]}\" ]]; then\n            seen[$key]=1\n            echo \"$key\"\n        fi\n    done\n}\n```\n\n**Pros:** Preserves original order  \n**Cons:** Uses memory for seen hash\n\n### Strategy 3: No Deduplication\n\n```prolog\n:- constraint(raw_log/3, [unique(false), ordered]).\n```\n\n**Generated:**\n```bash\nraw_log_stream() {\n    for key in \"${raw_log_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n```\n\n**Use case:** Counting, raw log processing\n\n### Example: Timeline Events\n\n```prolog\n:- constraint(user_action/3, [unique, ordered]).\n\nuser_action(100, alice, login).\nuser_action(101, bob, login).\nuser_action(102, alice, read_file).\n```\n\nWith `[unique, ordered]`, duplicate actions are removed but chronological order is preserved.", "answer_tailored": true}
{"pair_id": "bash-constraints_p3", "cluster_id": "bash-constraints", "question": "How do I preserve order while removing duplicates in Bash?", "question_type": "medium", "answer": "To preserve order while removing duplicates in Bash, use the hash deduplication strategy by setting `unique(true)` with `ordered` in your constraint:\n\n```prolog\n:- constraint(your_predicate/2, [unique(true), ordered]).\n```\n\nThis generates Bash code that uses an associative array to track seen values:\n\n```bash\nyour_predicate_stream() {\n    declare -A seen\n    for key in \"${data[@]}\"; do\n        if [[ -z \"${seen[$key]}\" ]]; then\n            seen[$key]=1\n            echo \"$key\"\n        fi\n    done\n}\n```\n\n**How it works:** The `seen` hash tracks which values have been output. Each value is checked before emitting - if not yet seen, it's marked and echoed. This preserves the original order while eliminating duplicates.\n\n**Trade-off:** Uses memory to store the seen hash, unlike `sort -u` which is faster but reorders output.\n\n**Alternative:** If order doesn't matter, use `[unique(true), unordered(true)]` to generate `sort -u` for better performance.\n\n**Example use case:**\n```prolog\n:- constraint(user_action/3, [unique, ordered]).\n\nuser_action(100, alice, login).\nuser_action(102, alice, read_file).\nuser_action(103, alice, login).  % Duplicate removed, order preserved\n```\n\nSee education/book-02-bash-target/03_advanced_constraints.md for the complete deduplication strategy matrix.", "answer_variant": "default", "answer_source": "education/book-02-bash-target/03_advanced_constraints.md", "topics": ["constraints", "unique", "ordered", "deduplication", "bash"], "original_answer": "## Constraints and Bash Code Generation\n\nConstraints control deduplication strategy in generated Bash code.\n\n### Deduplication Strategy Matrix\n\n| unique | unordered | Strategy | Bash Code |\n|--------|-----------|----------|----------|\n| true | true | Sort & Unique | `... \\| sort -u` |\n| true | false | Hash Dedup | `declare -A seen` loop |\n| false | * | None | Raw output |\n\n### Strategy 1: Sort & Unique (Default)\n\n```prolog\n:- constraint(grandparent/2, [unique(true), unordered(true)]).\n```\n\n**Generated:**\n```bash\ngrandparent() {\n    parent_stream | parent_join | sort -u\n}\n```\n\n**Pros:** Fast, efficient  \n**Cons:** Changes order\n\n### Strategy 2: Hash Deduplication\n\n```prolog\n:- constraint(event_log/3, [unique(true), ordered]).\n```\n\n**Generated:**\n```bash\nevent_log_stream() {\n    declare -A seen\n    for key in \"${event_log_data[@]}\"; do\n        if [[ -z \"${seen[$key]}\" ]]; then\n            seen[$key]=1\n            echo \"$key\"\n        fi\n    done\n}\n```\n\n**Pros:** Preserves original order  \n**Cons:** Uses memory for seen hash\n\n### Strategy 3: No Deduplication\n\n```prolog\n:- constraint(raw_log/3, [unique(false), ordered]).\n```\n\n**Generated:**\n```bash\nraw_log_stream() {\n    for key in \"${raw_log_data[@]}\"; do\n        echo \"$key\"\n    done\n}\n```\n\n**Use case:** Counting, raw log processing\n\n### Example: Timeline Events\n\n```prolog\n:- constraint(user_action/3, [unique, ordered]).\n\nuser_action(100, alice, login).\nuser_action(101, bob, login).\nuser_action(102, alice, read_file).\n```\n\nWith `[unique, ordered]`, duplicate actions are removed but chronological order is preserved.", "answer_tailored": true}
