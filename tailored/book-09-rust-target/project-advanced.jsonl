{"pair_id": "rust-project-001_p0", "cluster_id": "rust-project-001", "question": "When should I use project generation vs single-file compilation?", "question_type": "medium", "answer": "The choice depends on your dependencies. For queries that only use Rust's standard library (basic data structures, I/O, control flow), single-file compilation with `rustc` is sufficient and simpler. However, when your Prolog code translates to Rust that requires external crates\u2014such as regex for pattern matching, serde for serialization, or tokio for async operations\u2014you must use project generation.\n\nCall `write_rust_project/2` to automatically generate a complete Cargo project structure. UnifyWeaver analyzes your code, detects which external crates are needed, and creates the appropriate Cargo.toml alongside src/main.rs:\n\n```prolog\ncompile_project :-\n    compile_predicate_to_rust(valid_email/1, [], Code),\n    write_rust_project(Code, 'output/email_validator').\n```\n\nThen build the project with `cargo build --release`. See education/book-09-rust-target/03_project_generation.md for complete details on the project generation workflow.", "answer_variant": "default", "answer_source": "book-09-rust-target/03_project_generation.md", "topics": [], "original_answer": "Use single-file compilation (`rustc`) for standard library features only. Use project generation (`write_rust_project/2`) when you need external crates like regex or serde. UnifyWeaver automatically detects crate requirements and generates Cargo.toml:\n\n```prolog\ncompile_project :-\n    compile_predicate_to_rust(valid_email/1, [], Code),\n    write_rust_project(Code, 'output/email_validator').\n```\n\nThis creates Cargo.toml and src/main.rs, then build with `cargo build --release`.", "answer_tailored": true}
{"pair_id": "rust-project-001_p0", "cluster_id": "rust-project-001", "question": "How do I generate a Cargo project with UnifyWeaver?", "question_type": "medium", "answer": "To generate a Cargo project, use `write_rust_project/2` which creates a complete Rust workspace with `Cargo.toml` and source files:\n\n```prolog\n% Example: Email validation with regex\nvalid_email(Line) :-\n    input(Line),\n    match(Line, \"^[a-z0-9]+@[a-z0-9]+\\\\.[a-z]+$\").\n\ncompile_project :-\n    compile_predicate_to_rust(valid_email/1, [], Code),\n    write_rust_project(Code, 'output/email_validator').\n```\n\nThis generates:\n- `output/email_validator/Cargo.toml` (automatically includes the regex dependency)\n- `output/email_validator/src/main.rs`\n\nBuild with: `cd output/email_validator && cargo build --release`\n\nFor standalone programs without project structure, use `write_rust_program/2` instead. See education/book-09-rust-target/03_project_generation.md for more details.", "answer_variant": "default", "answer_source": "book-09-rust-target/03_project_generation.md", "topics": [], "original_answer": "Use `write_rust_project/2` instead of `write_rust_program/2`:\n\n```prolog\n% Rule using Regex\nvalid_email(Line) :-\n    input(Line),\n    match(Line, \"^[a-z0-9]+@[a-z0-9]+\\\\.[a-z]+$\").\n\ncompile_project :-\n    compile_predicate_to_rust(valid_email/1, [], Code),\n    write_rust_project(Code, 'output/email_validator').\n```\n\nCreates:\n- `output/email_validator/Cargo.toml` (with regex dependency)\n- `output/email_validator/src/main.rs`\n\nBuild: `cd output/email_validator && cargo build --release`", "answer_tailored": true}
{"pair_id": "rust-advanced-001_p0", "cluster_id": "rust-advanced-001", "question": "How do I use JSON processing in the Rust target?", "question_type": "medium", "answer": "The Rust target provides JSON processing through the `json_schema` directive and `json_input`/`json_output` compilation options, leveraging serde and serde_json for efficient serialization.\n\nFirst, define your JSON schema:\n\n```prolog\n:- json_schema(user, [field(name, string), field(age, integer)]).\n```\n\nThen create predicates that work with JSON records:\n\n```prolog\nuser_info(Name, Age) :-\n    json_record([name-Name, age-Age]).\n```\n\nFor reading JSON input, compile with the `json_input` option:\n\n```prolog\ncompile_json :-\n    compile_predicate_to_rust(user_info/2, [\n        json_input(true),\n        json_schema(user)\n    ], Code),\n    write_rust_project(Code, 'output/json_processor').\n```\n\nFor generating JSON output, use the `json_output` option:\n\n```prolog\ncompile_output :-\n    compile_predicate_to_rust(output_user/2, [json_output(true)], Code),\n    write_rust_project(Code, 'output/json_writer').\n```\n\nThe generated Rust code uses serde and serde_json crates for high-performance JSON handling. For more details on Rust target features, see education/book-09-rust-target/.", "answer_variant": "default", "answer_source": "book-09-rust-target/04_advanced_features.md", "topics": [], "original_answer": "Use json_schema and json_input/json_output options:\n\n```prolog\n:- json_schema(user, [field(name, string), field(age, integer)]).\n\nuser_info(Name, Age) :-\n    json_record([name-Name, age-Age]).\n\ncompile_json :-\n    compile_predicate_to_rust(user_info/2, [\n        json_input(true),\n        json_schema(user)\n    ], Code),\n    write_rust_project(Code, 'output/json_processor').\n```\n\nFor JSON output:\n```prolog\ncompile_output :-\n    compile_predicate_to_rust(output_user/2, [json_output(true)], Code),\n    write_rust_project(Code, 'output/json_writer').\n```\n\nUses serde and serde_json for high-performance JSON processing.", "answer_tailored": true}
{"pair_id": "rust-advanced-001_p0", "cluster_id": "rust-advanced-001", "question": "What aggregations and constraints does the Rust target support?", "question_type": "medium", "answer": "The Rust target supports five aggregation operations: `sum`, `count`, `min`, `max`, and `avg`. These compile to efficient native Rust code. For example:\n\n```prolog\ntotal_sales(Sum) :-\n    aggregation(sum),\n    sale(Sum).\n```\n\nFor constraints, the Rust target handles numeric comparisons by compiling them directly to Rust's native comparison operators. This includes operations like `>`, `<`, `>=`, `=<`, and `=:=`. For instance:\n\n```prolog\nhigh_value(Val) :-\n    input(Val),\n    Val > 1000,\n    Val =< 5000.\n```\n\nThis generates efficient Rust conditionals with no runtime interpretation overhead. See education/book-09-rust-target/04_advanced_features.md for complete details on advanced Rust compilation features.", "answer_variant": "default", "answer_source": "book-09-rust-target/04_advanced_features.md", "topics": [], "original_answer": "Aggregations compile to efficient Rust code:\n\n```prolog\ntotal_sales(Sum) :-\n    aggregation(sum),\n    sale(Sum).\n```\n\nSupported: `sum`, `count`, `min`, `max`, `avg`.\n\nNumeric constraints compile to native Rust comparisons:\n\n```prolog\nhigh_value(Val) :-\n    input(Val),\n    Val > 1000,\n    Val =< 5000.\n```\n\nGenerates efficient Rust conditionals without runtime interpretation overhead.", "answer_tailored": true}
