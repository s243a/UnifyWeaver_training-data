{"pair_id": "rust-compile-001_p0", "cluster_id": "rust-compile-001", "question": "How do I compile Prolog facts to Rust?", "question_type": "medium", "answer": "To compile Prolog facts to Rust, use the `compile_facts_to_rust/3` predicate:\n\n```prolog\n% First define your facts\nuser(john, 25).\nuser(jane, 30).\n\n% Then compile them\n?- rust_target:compile_facts_to_rust(user, 2, Code).\n```\n\nThis generates a Rust struct representation of your facts. The generated code includes helper methods like `get_all`, `stream`, and `contains` for convenient access. The struct automatically derives Debug, Clone, PartialEq, and Eq traits, making it compatible with Rust's ownership and type system. For more details on Rust target compilation, see education/book-09-rust-target/.", "answer_variant": "default", "answer_source": "book-09-rust-target/02_basic_compilation.md", "topics": [], "original_answer": "Use `compile_facts_to_rust/3` for struct-based export:\n\n```prolog\n% Define facts\nuser(john, 25).\nuser(jane, 30).\n\n% Compile\n?- rust_target:compile_facts_to_rust(user, 2, Code).\n```\n\nGenerates a Rust struct with `get_all`, `stream`, and `contains` helper functions. The struct derives Debug, Clone, PartialEq, Eq for easy use with Rust's ownership model.", "answer_tailored": true}
{"pair_id": "rust-compile-001_p0", "cluster_id": "rust-compile-001", "question": "How do I compile Prolog rules to Rust stream processors?", "question_type": "medium", "answer": "To compile Prolog rules to Rust stream processors, use `compile_predicate_to_rust/3` to generate Rust code that processes input from stdin. For example:\n\n```prolog\n% Define your rule - this filters people 18 or older\nadult(Name, Age) :- person(Name, Age), Age >= 18.\n\n% Compile to Rust stream processor\ncompile_rules :-\n    compile_predicate_to_rust(adult/2, [field_delimiter(colon)], Code),\n    write_rust_program(Code, 'adult.rs').\n```\n\nThe generated Rust program reads delimited records from standard input and outputs matching records:\n\n```bash\nrustc adult.rs\necho -e \"alice:25\\nbob:10\" | ./adult\n# Output: alice:25\n```\n\nThe second argument to `compile_predicate_to_rust/3` lets you specify options like field delimiters. More compilation examples are available in education/book-09-rust-target/.", "answer_variant": "default", "answer_source": "book-09-rust-target/02_basic_compilation.md", "topics": [], "original_answer": "Rules compile to stream processors reading from stdin:\n\n```prolog\n% Rule: Filter adults\nadult(Name, Age) :- person(Name, Age), Age >= 18.\n\ncompile_rules :-\n    compile_predicate_to_rust(adult/2, [field_delimiter(colon)], Code),\n    write_rust_program(Code, 'adult.rs').\n```\n\nRun with:\n```bash\nrustc adult.rs\necho -e \"alice:25\\nbob:10\" | ./adult\n# Output: alice:25\n```", "answer_tailored": true}
{"pair_id": "rust-compile-002_p0", "cluster_id": "rust-compile-002", "question": "How does UnifyWeaver handle recursion patterns in Rust?", "question_type": "medium", "answer": "UnifyWeaver transforms Prolog recursion into optimized Rust code through three distinct compilation strategies. For tail-recursive predicates, the `compile_tail_recursion_rust/3` API generates efficient for-loop iterations with O(1) stack usage, avoiding recursive function calls entirely. Linear recursion uses `compile_linear_recursion_rust/3` to produce HashMap-based memoization, caching intermediate results. Mutual recursion is handled via `compile_mutual_recursion_rust/3`, which creates thread_local! HashMap storage for safe cross-function state management.\n\nFor example, compiling a tail-recursive sum_list/3 predicate:\n```prolog\n?- rust_target:compile_tail_recursion_rust(sum_list/3, [], Code).\n```\n\nThis produces iterative Rust code that eliminates recursion overhead while preserving the original Prolog semantics. See education/book-09-rust-target/02_basic_compilation.md for implementation details.", "answer_variant": "default", "answer_source": "book-09-rust-target/02_basic_compilation.md", "topics": [], "original_answer": "Three recursion patterns:\n\n| Pattern | API | Generated Rust |\n|---------|-----|----------------|\n| Tail Recursion | `compile_tail_recursion_rust/3` | for loop (O(1) stack) |\n| Linear Recursion | `compile_linear_recursion_rust/3` | HashMap memoization |\n| Mutual Recursion | `compile_mutual_recursion_rust/3` | thread_local! HashMap |\n\nExample tail recursion:\n```prolog\n?- rust_target:compile_tail_recursion_rust(sum_list/3, [], Code).\n```\n\nGenerates efficient iterative Rust code instead of recursive calls.", "answer_tailored": true}
{"pair_id": "rust-compile-002_p0", "cluster_id": "rust-compile-002", "question": "How do I compile mutual recursion (is_even/is_odd) to Rust?", "question_type": "medium", "answer": "To compile mutually recursive predicates like is_even/is_odd to Rust, use `compile_mutual_recursion_rust/3` with a list of the predicates that reference each other:\n\n```prolog\nassertx((is_even(0))).\nassertx((is_even(N) :- N > 0, N1 is N - 1, is_odd(N1))).\nassertx((is_odd(1))).\nassertx((is_odd(N) :- N > 1, N1 is N - 1, is_even(N1))).\n\n?- rust_target:compile_mutual_recursion_rust([is_even/1, is_odd/1], [], Code).\n```\n\nThis produces Rust code with thread_local! HashMap for memoization shared across both functions in the mutual recursion group.", "answer_variant": "default", "answer_source": "book-09-rust-target/02_basic_compilation.md", "topics": [], "original_answer": "Use `compile_mutual_recursion_rust/3` for predicates that call each other:\n\n```prolog\nassertx((is_even(0))).\nassertx((is_even(N) :- N > 0, N1 is N - 1, is_odd(N1))).\nassertx((is_odd(1))).\nassertx((is_odd(N) :- N > 1, N1 is N - 1, is_even(N1))).\n\n?- rust_target:compile_mutual_recursion_rust([is_even/1, is_odd/1], [], Code).\n```\n\nGenerates Rust with thread_local! HashMap for shared memoization between the mutually recursive functions.", "answer_tailored": true}
