{"pair_id": "b4-c4-cost-speed-quality_p0", "cluster_id": "b4-c4-cost-speed-quality", "question": "How does UnifyWeaver handle cost/speed/quality trade-offs?", "question_type": "medium", "answer": "UnifyWeaver manages cost/speed/quality trade-offs through configurable priority weights and context-aware optimization strategies. The compiler balances three key dimensions: cost (resource consumption like memory/CPU), speed (execution latency and throughput), and quality (result accuracy).\n\nWorkflows specify priorities using declarative options:\n```prolog\nworkflow_options([\n    priority(speed, 3),\n    priority(cost, 2),\n    priority(quality, 1)\n]).\n```\n\nThese priorities influence compilation decisions including parallelism level, caching approach, target language selection, and optimization flags. The system applies context-based heuristics: batch processing workflows prioritize throughput, interactive applications optimize for low latency, and critical data operations favor accuracy over performance.\n\nFor detailed workflow configuration patterns, see education/book-04-workflows/04_economic_decisions.md.", "answer_variant": "default", "answer_source": "education/book-04-workflows/04_economic_decisions.md", "topics": ["economic-decisions", "trade-offs", "optimization"], "original_answer": "## Economic Decision-Making\n\nUnifyWeaver optimizes compilation based on cost, speed, and quality trade-offs.\n\n### Trade-off Dimensions\n\n| Dimension | Optimizes For | Example |\n|-----------|--------------|----------|\n| Cost | Resource usage | Less memory/CPU |\n| Speed | Latency/throughput | Faster execution |\n| Quality | Accuracy | Better results |\n\n### Context-Based Decisions\n\n- **Batch jobs**: Optimize throughput\n- **Interactive**: Optimize latency\n- **Critical data**: Optimize accuracy\n\n### Priority Weights\n\nWorkflows can specify priorities:\n```prolog\nworkflow_options([\n    priority(speed, 3),\n    priority(cost, 2),\n    priority(quality, 1)\n]).\n```\n\n### Parameters Affected\n\n- Parallelism level\n- Caching strategy\n- Target language\n- Optimization flags", "answer_tailored": true}
{"pair_id": "b4-c4-cost-speed-quality_p1", "cluster_id": "b4-c4-cost-speed-quality", "question": "What is economic decision-making in pipelines?", "question_type": "medium", "answer": "Economic decision-making in pipelines refers to UnifyWeaver's ability to optimize compilation by balancing cost, speed, and quality considerations. The system evaluates trade-offs across three dimensions: cost (minimizing resource usage like memory/CPU), speed (optimizing for latency or throughput), and quality (maximizing accuracy of results).\n\nThese decisions are context-aware. For batch processing jobs, UnifyWeaver prioritizes throughput; for interactive workflows, it optimizes latency; and for critical data operations, it emphasizes accuracy. Developers can explicitly configure these priorities in their workflows using the `workflow_options/1` predicate with priority weights for each dimension.\n\nThe economic model influences several compilation parameters including parallelism levels, caching strategies, target language selection, and optimization flags. By adjusting these based on declared priorities, UnifyWeaver ensures the compiled pipeline aligns with the specific performance and resource constraints of your use case. For more details on workflow configuration, see education/book-04-workflows/.", "answer_variant": "default", "answer_source": "education/book-04-workflows/04_economic_decisions.md", "topics": ["economic-decisions", "trade-offs", "optimization"], "original_answer": "## Economic Decision-Making\n\nUnifyWeaver optimizes compilation based on cost, speed, and quality trade-offs.\n\n### Trade-off Dimensions\n\n| Dimension | Optimizes For | Example |\n|-----------|--------------|----------|\n| Cost | Resource usage | Less memory/CPU |\n| Speed | Latency/throughput | Faster execution |\n| Quality | Accuracy | Better results |\n\n### Context-Based Decisions\n\n- **Batch jobs**: Optimize throughput\n- **Interactive**: Optimize latency\n- **Critical data**: Optimize accuracy\n\n### Priority Weights\n\nWorkflows can specify priorities:\n```prolog\nworkflow_options([\n    priority(speed, 3),\n    priority(cost, 2),\n    priority(quality, 1)\n]).\n```\n\n### Parameters Affected\n\n- Parallelism level\n- Caching strategy\n- Target language\n- Optimization flags", "answer_tailored": true}
{"pair_id": "b4-c4-cost-speed-quality_p2", "cluster_id": "b4-c4-cost-speed-quality", "question": "How do you balance performance vs accuracy?", "question_type": "medium", "answer": "Performance vs accuracy is balanced through configurable priority weights in your workflow options. You can specify relative importance using terms like `priority(speed, 3)` and `priority(quality, 1)` in Prolog workflow configurations.\n\nThe system considers three dimensions:\n- **Speed**: Latency and throughput optimization\n- **Cost**: Resource usage (memory/CPU)\n- **Quality**: Result accuracy\n\nYour context determines the right balance. Batch processing favors throughput, interactive queries need low latency, and critical data operations prioritize accuracy over speed.\n\nThese priorities influence concrete decisions like parallelism level, caching strategy, target language selection, and optimization flags. For example, high-speed priorities might enable aggressive caching and parallelization, while quality-focused workflows use more conservative optimizations.\n\nSee education/book-04-workflows/04_economic_decisions.md for the complete trade-off framework.", "answer_variant": "default", "answer_source": "education/book-04-workflows/04_economic_decisions.md", "topics": ["economic-decisions", "trade-offs", "optimization"], "original_answer": "## Economic Decision-Making\n\nUnifyWeaver optimizes compilation based on cost, speed, and quality trade-offs.\n\n### Trade-off Dimensions\n\n| Dimension | Optimizes For | Example |\n|-----------|--------------|----------|\n| Cost | Resource usage | Less memory/CPU |\n| Speed | Latency/throughput | Faster execution |\n| Quality | Accuracy | Better results |\n\n### Context-Based Decisions\n\n- **Batch jobs**: Optimize throughput\n- **Interactive**: Optimize latency\n- **Critical data**: Optimize accuracy\n\n### Priority Weights\n\nWorkflows can specify priorities:\n```prolog\nworkflow_options([\n    priority(speed, 3),\n    priority(cost, 2),\n    priority(quality, 1)\n]).\n```\n\n### Parameters Affected\n\n- Parallelism level\n- Caching strategy\n- Target language\n- Optimization flags", "answer_tailored": true}
{"pair_id": "b4-c4-decision-heuristics_p0", "cluster_id": "b4-c4-decision-heuristics", "question": "What heuristics guide target selection in workflows?", "question_type": "medium", "answer": "Target selection in workflows is guided by several categories of heuristics:\n\n**Size-Based Selection**\nLines of data determine the target: under 1,000 lines \u2192 AWK; 1,000-100,000 lines \u2192 Python; over 100,000 lines \u2192 Go. This is captured in Prolog rules like:\n\n```prolog\ntarget_heuristic(Lines, Target) :-\n    Lines < 1000 -> Target = awk ;\n    Lines < 100000 -> Target = python ;\n    Target = go.\n```\n\n**Characteristic-Based Selection**\n- Data volume: small datasets \u2192 AWK, large datasets \u2192 Go\n- Schema structure: simple schemas \u2192 streaming targets, complex schemas \u2192 batch processing\n- Resource constraints: limited resources \u2192 lightweight targets\n\n**Policy-Driven Selection**\nThree main policies control target choice:\n- **Greedy**: Select the fastest available target\n- **Conservative**: Choose well-tested, proven targets\n- **Adaptive**: Learn from execution history to improve future selections\n\n**Automated Selection Logic**\nHeuristics are encoded directly as Prolog rules that examine predicate characteristics:\n\n```prolog\nselect_target(Pred, Options, Target) :-\n    is_recursive(Pred) ->\n        Target = csharp_query ;\n        Target = csharp_stream.\n```\n\nThis allows UnifyWeaver to automatically choose appropriate targets based on query properties. For workflow implementation details, see education/book-04-workflows/.", "answer_variant": "default", "answer_source": "education/book-04-workflows/04_economic_decisions.md", "topics": ["heuristics", "automation", "policy"], "original_answer": "## Decision Heuristics\n\n### Size-Based Rules\n\n```prolog\ntarget_heuristic(Lines, Target) :-\n    Lines < 1000 -> Target = awk ;\n    Lines < 100000 -> Target = python ;\n    Target = go.\n```\n\n### Characteristic Checks\n\n- **Data size**: Small \u2192 AWK, Large \u2192 Go\n- **Schema complexity**: Simple \u2192 streaming, Complex \u2192 batch\n- **Resource limits**: Constrained \u2192 lightweight target\n\n### Policies\n\n| Policy | Behavior |\n|--------|----------|\n| Greedy | Pick fastest available |\n| Conservative | Prefer proven paths |\n| Adaptive | Learn from past runs |\n\n### Automation\n\nHeuristics encoded as Prolog rules:\n```prolog\nselect_target(Pred, Options, Target) :-\n    is_recursive(Pred) ->\n        Target = csharp_query ;\n        Target = csharp_stream.\n```", "answer_tailored": true}
{"pair_id": "b4-c4-decision-heuristics_p1", "cluster_id": "b4-c4-decision-heuristics", "question": "How do you automate compilation decisions?", "question_type": "medium", "answer": "UnifyWeaver automates compilation decisions through Prolog-based heuristics that evaluate query characteristics and select optimal targets. The system uses encoded rules to analyze factors like data volume, schema complexity, and recursion patterns.\n\n**Size-Based Selection**\n```prolog\ntarget_heuristic(Lines, Target) :-\n    Lines < 1000 -> Target = awk ;\n    Lines < 100000 -> Target = python ;\n    Target = go.\n```\n\n**Decision Criteria**\n- Data volume: lightweight targets (AWK) for small datasets, compiled targets (Go) for large\n- Schema structure: streaming pipelines for flat data, batch processing for complex schemas\n- Resource constraints: memory-efficient targets when resources are limited\n\n**Policy Strategies**\n- Greedy: Select the fastest available target\n- Conservative: Prioritize well-tested compilation paths\n- Adaptive: Adjust selections based on historical performance\n\n**Implementation Example**\n```prolog\nselect_target(Pred, Options, Target) :-\n    is_recursive(Pred) ->\n        Target = csharp_query ;\n        Target = csharp_stream.\n```\n\nThese automation rules are embedded directly in the compiler, allowing UnifyWeaver to make intelligent target selection without manual intervention. See education/book-04-workflows/ for workflow patterns and education/book-02-bash-target/ through book-08-sql-target/ for target-specific compilation details.", "answer_variant": "default", "answer_source": "education/book-04-workflows/04_economic_decisions.md", "topics": ["heuristics", "automation", "policy"], "original_answer": "## Decision Heuristics\n\n### Size-Based Rules\n\n```prolog\ntarget_heuristic(Lines, Target) :-\n    Lines < 1000 -> Target = awk ;\n    Lines < 100000 -> Target = python ;\n    Target = go.\n```\n\n### Characteristic Checks\n\n- **Data size**: Small \u2192 AWK, Large \u2192 Go\n- **Schema complexity**: Simple \u2192 streaming, Complex \u2192 batch\n- **Resource limits**: Constrained \u2192 lightweight target\n\n### Policies\n\n| Policy | Behavior |\n|--------|----------|\n| Greedy | Pick fastest available |\n| Conservative | Prefer proven paths |\n| Adaptive | Learn from past runs |\n\n### Automation\n\nHeuristics encoded as Prolog rules:\n```prolog\nselect_target(Pred, Options, Target) :-\n    is_recursive(Pred) ->\n        Target = csharp_query ;\n        Target = csharp_stream.\n```", "answer_tailored": true}
{"pair_id": "b4-c4-decision-heuristics_p2", "cluster_id": "b4-c4-decision-heuristics", "question": "What decision policies can workflows define?", "question_type": "medium", "answer": "Workflows can define several types of decision policies to guide target selection and execution strategies:\n\n**Greedy Policy**: Selects the fastest available target for immediate execution. This policy prioritizes performance without considering resource constraints or historical data.\n\n**Conservative Policy**: Prefers proven execution paths based on reliability and tested behavior. This reduces risk by sticking to well-validated approaches.\n\n**Adaptive Policy**: Learns from past workflow runs to improve future decisions. This policy evolves based on execution history and performance metrics.\n\nThese policies are implemented through Prolog heuristics that consider factors like data size, schema complexity, and resource limits. For example, a size-based heuristic might route small datasets (<1000 lines) to AWK, medium datasets to Python, and large datasets to Go. The policy framework allows workflows to automatically select appropriate targets based on predicate characteristics:\n\n```prolog\nselect_target(Pred, Options, Target) :-\n    is_recursive(Pred) ->\n        Target = csharp_query ;\n        Target = csharp_stream.\n```\n\nSee education/book-04-workflows/04_economic_decisions.md for complete policy definitions and implementation examples.", "answer_variant": "default", "answer_source": "education/book-04-workflows/04_economic_decisions.md", "topics": ["heuristics", "automation", "policy"], "original_answer": "## Decision Heuristics\n\n### Size-Based Rules\n\n```prolog\ntarget_heuristic(Lines, Target) :-\n    Lines < 1000 -> Target = awk ;\n    Lines < 100000 -> Target = python ;\n    Target = go.\n```\n\n### Characteristic Checks\n\n- **Data size**: Small \u2192 AWK, Large \u2192 Go\n- **Schema complexity**: Simple \u2192 streaming, Complex \u2192 batch\n- **Resource limits**: Constrained \u2192 lightweight target\n\n### Policies\n\n| Policy | Behavior |\n|--------|----------|\n| Greedy | Pick fastest available |\n| Conservative | Prefer proven paths |\n| Adaptive | Learn from past runs |\n\n### Automation\n\nHeuristics encoded as Prolog rules:\n```prolog\nselect_target(Pred, Options, Target) :-\n    is_recursive(Pred) ->\n        Target = csharp_query ;\n        Target = csharp_stream.\n```", "answer_tailored": true}
{"pair_id": "b4-c4-resource-constraints_p0", "cluster_id": "b4-c4-resource-constraints", "question": "How do workflows handle resource constraints?", "question_type": "medium", "answer": "Workflows in UnifyWeaver handle resource constraints through several mechanisms. The orchestrator recognizes five main constraint types: memory limits (e.g., `max_memory(4gb)`), CPU allocation (`max_cores(4)`), time boundaries (`timeout(5min)`), API rate limits (`rate_limit(100/min)`), and storage caps (`max_disk(10gb)`).\n\nWhen constraints are encountered, the orchestrator adapts by selecting lighter compilation targets (choosing Bash over C# for simpler operations), switching to streaming processing instead of loading data into memory, batching API calls to stay within rate limits, and spilling intermediate results to disk when memory pressure occurs.\n\nFallback strategies can be specified declaratively. For example, when memory is exceeded, the system can switch to streaming mode, reduce parallelism, or enable disk spilling:\n\n```prolog\nconstraint_fallback(memory_exceeded, [\n    switch_to(streaming_mode),\n    reduce_parallelism(2),\n    enable_disk_spill\n]).\n```\n\nConstraints are declared upfront using specifications like:\n\n```prolog\nworkflow_constraints([\n    max_memory(4gb),\n    timeout(10min),\n    rate_limit(api_calls, 100, minute)\n]).\n```\n\nFor more details on workflow orchestration and resource management, see education/book-04-workflows/.", "answer_variant": "default", "answer_source": "education/book-04-workflows/04_economic_decisions.md", "topics": ["resources", "constraints", "scheduling"], "original_answer": "## Resource Constraints\n\n### Constraint Types\n\n| Constraint | Example |\n|------------|----------|\n| Memory | max_memory(4gb) |\n| CPU | max_cores(4) |\n| Time | timeout(5min) |\n| API rate | rate_limit(100/min) |\n| Storage | max_disk(10gb) |\n\n### Orchestrator Response\n\n1. **Light targets**: Bash instead of C#\n2. **Streaming**: Instead of in-memory\n3. **Batching**: API calls under rate limit\n4. **Spilling**: Intermediate results to disk\n\n### Fallback Strategies\n\n```prolog\nconstraint_fallback(memory_exceeded, [\n    switch_to(streaming_mode),\n    reduce_parallelism(2),\n    enable_disk_spill\n]).\n```\n\n### Specification\n\n```prolog\nworkflow_constraints([\n    max_memory(4gb),\n    timeout(10min),\n    rate_limit(api_calls, 100, minute)\n]).\n```", "answer_tailored": true}
{"pair_id": "b4-c4-resource-constraints_p1", "cluster_id": "b4-c4-resource-constraints", "question": "What resource limits can be specified?", "question_type": "medium", "answer": "UnifyWeaver allows you to specify several types of resource limits for workflows:\n\n**Available Resource Limits:**\n\n| Limit Type | Syntax |\n|------------|--------|\n| Memory | max_memory(4gb) |\n| CPU cores | max_cores(4) |\n| Execution time | timeout(5min) |\n| API rate | rate_limit(100/min) |\n| Disk storage | max_disk(10gb) |\n\n**How Limits are Specified:**\n\n```prolog\nworkflow_constraints([\n    max_memory(4gb),\n    timeout(10min),\n    rate_limit(api_calls, 100, minute)\n]).\n```\n\n**Orchestrator Adaptations:**\n\nWhen resource limits are approached, the orchestrator automatically adjusts:\n\n1. **Target selection**: Chooses lighter-weight targets (e.g., Bash over C#)\n2. **Processing mode**: Switches to streaming instead of loading everything in memory\n3. **API handling**: Batches calls to stay within rate limits\n4. **Storage strategy**: Spills intermediate data to disk when memory is constrained\n\n**Fallback Behavior:**\n\nYou can define how the system responds when limits are exceeded:\n\n```prolog\nconstraint_fallback(memory_exceeded, [\n    switch_to(streaming_mode),\n    reduce_parallelism(2),\n    enable_disk_spill\n]).\n```\n\nFor more details on workflow orchestration, see education/book-04-workflows/.", "answer_variant": "default", "answer_source": "education/book-04-workflows/04_economic_decisions.md", "topics": ["resources", "constraints", "scheduling"], "original_answer": "## Resource Constraints\n\n### Constraint Types\n\n| Constraint | Example |\n|------------|----------|\n| Memory | max_memory(4gb) |\n| CPU | max_cores(4) |\n| Time | timeout(5min) |\n| API rate | rate_limit(100/min) |\n| Storage | max_disk(10gb) |\n\n### Orchestrator Response\n\n1. **Light targets**: Bash instead of C#\n2. **Streaming**: Instead of in-memory\n3. **Batching**: API calls under rate limit\n4. **Spilling**: Intermediate results to disk\n\n### Fallback Strategies\n\n```prolog\nconstraint_fallback(memory_exceeded, [\n    switch_to(streaming_mode),\n    reduce_parallelism(2),\n    enable_disk_spill\n]).\n```\n\n### Specification\n\n```prolog\nworkflow_constraints([\n    max_memory(4gb),\n    timeout(10min),\n    rate_limit(api_calls, 100, minute)\n]).\n```", "answer_tailored": true}
{"pair_id": "b4-c4-resource-constraints_p2", "cluster_id": "b4-c4-resource-constraints", "question": "How does UnifyWeaver optimize for limited resources?", "question_type": "medium", "answer": "UnifyWeaver optimizes for limited resources through intelligent orchestrator decisions and fallback strategies. When facing constraints like memory limits (e.g., max_memory(4gb)), CPU restrictions (max_cores(4)), timeouts, API rate limits, or storage caps, the system adapts its execution plan.\n\nThe orchestrator employs several optimization techniques:\n- **Target selection**: Chooses lightweight targets like Bash over heavier runtimes like C# when resources are scarce\n- **Streaming processing**: Processes data incrementally instead of loading everything into memory\n- **API batching**: Groups requests to stay within rate limits (e.g., rate_limit(100/min))\n- **Disk spilling**: Writes intermediate results to storage when memory is insufficient\n\nFallback strategies activate automatically when constraints are exceeded. For example, if memory runs out, the system can switch to streaming mode, reduce parallelism, or enable disk spilling:\n\n```prolog\nconstraint_fallback(memory_exceeded, [\n    switch_to(streaming_mode),\n    reduce_parallelism(2),\n    enable_disk_spill\n]).\n```\n\nYou can specify resource constraints declaratively in your workflow:\n\n```prolog\nworkflow_constraints([\n    max_memory(4gb),\n    timeout(10min),\n    rate_limit(api_calls, 100, minute)\n]).\n```\n\nFor more on workflow orchestration and resource management, see education/book-04-workflows/.", "answer_variant": "default", "answer_source": "education/book-04-workflows/04_economic_decisions.md", "topics": ["resources", "constraints", "scheduling"], "original_answer": "## Resource Constraints\n\n### Constraint Types\n\n| Constraint | Example |\n|------------|----------|\n| Memory | max_memory(4gb) |\n| CPU | max_cores(4) |\n| Time | timeout(5min) |\n| API rate | rate_limit(100/min) |\n| Storage | max_disk(10gb) |\n\n### Orchestrator Response\n\n1. **Light targets**: Bash instead of C#\n2. **Streaming**: Instead of in-memory\n3. **Batching**: API calls under rate limit\n4. **Spilling**: Intermediate results to disk\n\n### Fallback Strategies\n\n```prolog\nconstraint_fallback(memory_exceeded, [\n    switch_to(streaming_mode),\n    reduce_parallelism(2),\n    enable_disk_spill\n]).\n```\n\n### Specification\n\n```prolog\nworkflow_constraints([\n    max_memory(4gb),\n    timeout(10min),\n    rate_limit(api_calls, 100, minute)\n]).\n```", "answer_tailored": true}
