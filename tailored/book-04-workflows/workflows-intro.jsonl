{"pair_id": "b4-c1-workflows-vs-playbooks_p0", "cluster_id": "b4-c1-workflows-vs-playbooks", "question": "What is the difference between workflows and playbooks in UnifyWeaver?", "question_type": "medium", "answer": "In UnifyWeaver, **workflows** and **playbooks** serve distinct but complementary roles:\n\n**Workflows** define the strategic decision-making process - they answer \"what should I do\" and \"why should I do it.\" They're high-level frameworks that guide you through choices based on project requirements, target language constraints, and architectural goals.\n\n**Playbooks** provide the tactical implementation details - they answer \"how do I do it.\" These are concrete, executable scripts with specific commands, parameters, and step-by-step sequences.\n\nThe distinction comes down to abstraction level:\n- Workflows operate at the **strategic layer**: defining goals, evaluation criteria, and decision points\n- Playbooks operate at the **tactical layer**: providing exact commands, compilation sequences, and configuration parameters\n\nFor example, a workflow might help you decide *whether* to use C# or Bash for a given predicate based on platform requirements and data sources. Once that decision is made, a playbook shows you *how* to actually compile that predicate to your chosen target.\n\nThese concepts work together hierarchically: workflows reference specific playbooks as implementation options. When you reach a decision point in a workflow (like \"Is this predicate recursive?\"), the workflow directs you to the appropriate playbook for execution (such as \"Compile with Query Runtime\" for recursive predicates or \"Compile with Stream Target\" for non-recursive ones).\n\nYou can find workflow guides in `education/book-04-workflows/` and playbook examples in the `playbooks/` directory at the project root.", "answer_variant": "default", "answer_source": "education/book-04-workflows/01_introduction.md", "topics": ["workflows", "playbooks", "strategic-hierarchy"], "original_answer": "## Workflows vs Playbooks\n\n**Workflows** are high-level strategic guides that define decision-making frameworks and processes.\n\n**Playbooks** are concrete execution scripts that implement specific steps.\n\n### Key Differences\n\n| Aspect | Workflows | Playbooks |\n|--------|-----------|------------|\n| Focus | What & Why | How |\n| Level | Strategic | Tactical |\n| Content | Goals, criteria, decisions | Commands, sequences, params |\n| Example | When to use C# vs Bash | How to compile factorial |\n\n### Relationship\n\nWorkflows reference playbooks as implementation details. A workflow defines the decision points; playbooks provide the execution steps for each choice.\n\n```\nWorkflow: \"Compilation Strategy\"\n\u251c\u2500 Decision: Is predicate recursive?\n\u2502  \u251c\u2500 YES \u2192 Playbook: \"Compile with Query Runtime\"\n\u2502  \u2514\u2500 NO  \u2192 Playbook: \"Compile with Stream Target\"\n```", "answer_tailored": true}
{"pair_id": "b4-c1-workflows-vs-playbooks_p1", "cluster_id": "b4-c1-workflows-vs-playbooks", "question": "How do workflows guide AI agents?", "question_type": "medium", "answer": "Workflows provide AI agents with strategic decision-making frameworks rather than step-by-step instructions. They define **what decisions to make** and **why**, helping agents determine the appropriate course of action based on context and criteria.\n\nFor example, a workflow might guide an agent to evaluate whether a predicate is recursive, then select the appropriate compilation approach accordingly. The workflow establishes the decision logic (checking for recursion, assessing performance needs), while playbooks handle the actual execution steps.\n\nThis hierarchical structure allows agents to:\n- Make informed choices between alternatives (e.g., C# vs Bash target)\n- Apply consistent criteria across different scenarios\n- Select and invoke the right playbook for each situation\n\nThink of workflows as decision trees that map from goals and conditions to specific playbooks. See education/book-04-workflows/ for the complete framework and examples of how UnifyWeaver uses workflows to guide compilation strategies.", "answer_variant": "default", "answer_source": "education/book-04-workflows/01_introduction.md", "topics": ["workflows", "playbooks", "strategic-hierarchy"], "original_answer": "## Workflows vs Playbooks\n\n**Workflows** are high-level strategic guides that define decision-making frameworks and processes.\n\n**Playbooks** are concrete execution scripts that implement specific steps.\n\n### Key Differences\n\n| Aspect | Workflows | Playbooks |\n|--------|-----------|------------|\n| Focus | What & Why | How |\n| Level | Strategic | Tactical |\n| Content | Goals, criteria, decisions | Commands, sequences, params |\n| Example | When to use C# vs Bash | How to compile factorial |\n\n### Relationship\n\nWorkflows reference playbooks as implementation details. A workflow defines the decision points; playbooks provide the execution steps for each choice.\n\n```\nWorkflow: \"Compilation Strategy\"\n\u251c\u2500 Decision: Is predicate recursive?\n\u2502  \u251c\u2500 YES \u2192 Playbook: \"Compile with Query Runtime\"\n\u2502  \u2514\u2500 NO  \u2192 Playbook: \"Compile with Stream Target\"\n```", "answer_tailored": true}
{"pair_id": "b4-c1-workflows-vs-playbooks_p2", "cluster_id": "b4-c1-workflows-vs-playbooks", "question": "What is the relationship between workflows and playbooks?", "question_type": "medium", "answer": "Workflows and playbooks serve complementary roles in UnifyWeaver. **Workflows** define the strategic decision-making process\u2014they answer \"what should we do\" and \"why.\" **Playbooks** provide the tactical implementation\u2014they specify exactly \"how to do it.\"\n\nThink of workflows as the decision tree and playbooks as the executable leaves. A workflow evaluates conditions and chooses the appropriate path, while playbooks contain the concrete commands and steps to execute that path.\n\nFor example, a workflow might determine \"Should we use the query runtime or stream target for this predicate?\" based on recursion analysis. Once that decision is made, it delegates to a specific playbook that contains the actual compilation commands and parameters.\n\nSee `education/book-04-workflows/` for detailed coverage of this relationship and how workflows orchestrate playbook execution.", "answer_variant": "default", "answer_source": "education/book-04-workflows/01_introduction.md", "topics": ["workflows", "playbooks", "strategic-hierarchy"], "original_answer": "## Workflows vs Playbooks\n\n**Workflows** are high-level strategic guides that define decision-making frameworks and processes.\n\n**Playbooks** are concrete execution scripts that implement specific steps.\n\n### Key Differences\n\n| Aspect | Workflows | Playbooks |\n|--------|-----------|------------|\n| Focus | What & Why | How |\n| Level | Strategic | Tactical |\n| Content | Goals, criteria, decisions | Commands, sequences, params |\n| Example | When to use C# vs Bash | How to compile factorial |\n\n### Relationship\n\nWorkflows reference playbooks as implementation details. A workflow defines the decision points; playbooks provide the execution steps for each choice.\n\n```\nWorkflow: \"Compilation Strategy\"\n\u251c\u2500 Decision: Is predicate recursive?\n\u2502  \u251c\u2500 YES \u2192 Playbook: \"Compile with Query Runtime\"\n\u2502  \u2514\u2500 NO  \u2192 Playbook: \"Compile with Stream Target\"\n```", "answer_tailored": true}
{"pair_id": "b4-c2-playbook-format_p0", "cluster_id": "b4-c2-playbook-format", "question": "What is the structure of a UnifyWeaver playbook?", "question_type": "medium", "answer": "A UnifyWeaver playbook follows a structured markdown format organized into these main components:\n\n**Core Sections**\n\n- **Header metadata**: Includes playbook name, version number, and prerequisites\n- **Overview**: Describes the playbook's purpose and what it will accomplish\n- **Steps**: Contains numbered, sequential procedures to follow\n- **Outputs**: Specifies what results to expect\n- **Troubleshooting**: Lists common problems and solutions\n\n**Special Callouts**\n\nThe playbook format uses distinctive callout markers for different content types:\n\n- `[!output]` - Shows expected command outputs\n- `[!example-record]` - Provides reusable code patterns\n- `[!decision]` - Indicates decision points where you choose between options\n- `[!warning]` - Highlights critical information\n- `[!action]` - Marks commands or actions to execute\n\n**Step Format Example**\n\nEach step typically includes an action callout with the command to run, followed by an output callout showing expected results:\n\n```markdown\n## Step 2: Compile the Predicate\n\n> [!action]\n> Run the compilation command\n\n```bash\nswipl -q -g \"compile(factorial/2, [], _), halt\"\n```\n\n> [!output]\n> Generated: factorial.sh\n```\n\nFor complete details on playbook authoring, see education/book-04-workflows/02_playbook_format.md.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["playbook-format", "callouts", "markdown-structure"], "original_answer": "## Playbook Structure\n\nPlaybooks use structured markdown with special callouts:\n\n### Sections\n\n1. **Header metadata**: Name, version, prerequisites\n2. **Overview**: What this playbook accomplishes\n3. **Steps**: Step-by-step procedures\n4. **Outputs**: Expected results\n5. **Troubleshooting**: Common issues\n\n### Callout Types\n\n| Callout | Purpose |\n|---------|----------|\n| `[!output]` | Expected command outputs |\n| `[!example-record]` | Reusable code patterns |\n| `[!decision]` | Branch points |\n| `[!warning]` | Important notes |\n\n### Example Step\n\n```markdown\n## Step 2: Compile the Predicate\n\n> [!action]\n> Run the compilation command\n\n```bash\nswipl -q -g \"compile(factorial/2, [], _), halt\"\n```\n\n> [!output]\n> Generated: factorial.sh\n```", "answer_tailored": true}
{"pair_id": "b4-c2-playbook-format_p1", "cluster_id": "b4-c2-playbook-format", "question": "What callout types are used in playbooks?", "question_type": "medium", "answer": "UnifyWeaver playbooks use several special callout types in their markdown format:\n\n- `[!output]` - Shows expected command outputs\n- `[!example-record]` - Provides reusable code patterns\n- `[!decision]` - Marks decision points or branches in workflows\n- `[!warning]` - Highlights important notes and cautions\n- `[!action]` - Indicates actions to perform (as seen in step examples)\n\nThese callouts help structure playbook content and make it clear what readers should expect at each stage. For complete details on playbook formatting and structure, see education/book-04-workflows/02_playbook_format.md.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["playbook-format", "callouts", "markdown-structure"], "original_answer": "## Playbook Structure\n\nPlaybooks use structured markdown with special callouts:\n\n### Sections\n\n1. **Header metadata**: Name, version, prerequisites\n2. **Overview**: What this playbook accomplishes\n3. **Steps**: Step-by-step procedures\n4. **Outputs**: Expected results\n5. **Troubleshooting**: Common issues\n\n### Callout Types\n\n| Callout | Purpose |\n|---------|----------|\n| `[!output]` | Expected command outputs |\n| `[!example-record]` | Reusable code patterns |\n| `[!decision]` | Branch points |\n| `[!warning]` | Important notes |\n\n### Example Step\n\n```markdown\n## Step 2: Compile the Predicate\n\n> [!action]\n> Run the compilation command\n\n```bash\nswipl -q -g \"compile(factorial/2, [], _), halt\"\n```\n\n> [!output]\n> Generated: factorial.sh\n```", "answer_tailored": true}
{"pair_id": "b4-c2-playbook-format_p2", "cluster_id": "b4-c2-playbook-format", "question": "How do you write a playbook in markdown?", "question_type": "medium", "answer": "Playbooks in UnifyWeaver use markdown with specialized callout blocks for structure and clarity:\n\n**Document Structure:**\n- Header metadata (name, version, prerequisites)\n- Overview section explaining the playbook's purpose\n- Numbered steps with actions and expected results\n- Outputs section listing what gets generated\n- Troubleshooting guidance for common problems\n\n**Key Callout Blocks:**\n\n| Callout | Use |\n|---------|-----|\n| `[!action]` | Commands to execute |\n| `[!output]` | Expected command results |\n| `[!example-record]` | Reusable code snippets |\n| `[!decision]` | Conditional branching points |\n| `[!warning]` | Critical notes and caveats |\n\n**Step Format:**\n\n```markdown\n## Step 2: Compile the Predicate\n\n> [!action]\n> Run the compilation command\n\n```bash\nswipl -q -g \"compile(factorial/2, [], _), halt\"\n```\n\n> [!output]\n> Generated: factorial.sh\n```\n\nThis structured format enables the semantic search system to parse and retrieve relevant playbook content. For complete playbook examples, see playbooks/ directory and education/book-04-workflows/02_playbook_format.md.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["playbook-format", "callouts", "markdown-structure"], "original_answer": "## Playbook Structure\n\nPlaybooks use structured markdown with special callouts:\n\n### Sections\n\n1. **Header metadata**: Name, version, prerequisites\n2. **Overview**: What this playbook accomplishes\n3. **Steps**: Step-by-step procedures\n4. **Outputs**: Expected results\n5. **Troubleshooting**: Common issues\n\n### Callout Types\n\n| Callout | Purpose |\n|---------|----------|\n| `[!output]` | Expected command outputs |\n| `[!example-record]` | Reusable code patterns |\n| `[!decision]` | Branch points |\n| `[!warning]` | Important notes |\n\n### Example Step\n\n```markdown\n## Step 2: Compile the Predicate\n\n> [!action]\n> Run the compilation command\n\n```bash\nswipl -q -g \"compile(factorial/2, [], _), halt\"\n```\n\n> [!output]\n> Generated: factorial.sh\n```", "answer_tailored": true}
{"pair_id": "b4-c2-callout-types_p0", "cluster_id": "b4-c2-callout-types", "question": "What is the [!example-record] callout format?", "question_type": "medium", "answer": "The `[!example-record]` callout is a structured format for documenting reusable patterns in UnifyWeaver playbooks. It uses YAML-style metadata within a Markdown callout:\n\n```markdown\n> [!example-record]\n> id: YYYYMMDD-name\n> name: unifyweaver.category.specific\n> pattern: pattern_type\n> difficulty: beginner|intermediate|advanced\n```\n\n**Required Fields:**\n- `id`: Unique identifier following YYYYMMDD-name format\n- `name`: Namespaced pattern name (dot-separated)\n\n**Optional Fields:**\n- `pattern`: Pattern classification/type\n- `difficulty`: Skill level (beginner, intermediate, or advanced)\n- `parent_example`: Links to a parent example by ID\n- `child_examples`: Lists dependent examples\n- `related`: Cross-references to related patterns\n- `tags`: Additional categorization tags\n\nThis format works alongside the `[!output]` callout, which shows expected command results:\n\n```markdown\n> [!output]\n> factorial 5\n> 120\n```\n\nFor complete playbook formatting guidelines, see education/book-04-workflows/02_playbook_format.md.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["example-record", "output-callout", "metadata"], "original_answer": "## Example Record Callout\n\nThe `[!example-record]` callout documents reusable patterns:\n\n```markdown\n> [!example-record]\n> id: YYYYMMDD-name\n> name: unifyweaver.category.specific\n> pattern: pattern_type\n> difficulty: beginner|intermediate|advanced\n```\n\n### Metadata Fields\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `id` | Yes | Unique ID (YYYYMMDD-name) |\n| `name` | Yes | Namespaced name |\n| `pattern` | No | Classification |\n| `difficulty` | No | beginner/intermediate/advanced |\n| `parent_example` | No | Parent example ID |\n| `child_examples` | No | List of dependents |\n| `related` | No | Cross-references |\n| `tags` | No | Additional tags |\n\n### Output Callout\n\n```markdown\n> [!output]\n> factorial 5\n> 120\n```\n\nShows expected command output for verification.", "answer_tailored": true}
{"pair_id": "b4-c2-callout-types_p1", "cluster_id": "b4-c2-callout-types", "question": "How do you document expected outputs in playbooks?", "question_type": "medium", "answer": "Expected outputs in playbooks are documented using the `[!output]` callout block, which shows the command and its expected result for verification purposes:\n\n```markdown\n> [!output]\n> factorial 5\n> 120\n```\n\nThis format helps users verify their implementation produces the correct output. The first line after `> [!output]` contains the command or query being run, and subsequent lines show the expected result.\n\nFor comprehensive playbook structure including example metadata and other documentation elements, see `education/book-04-workflows/02_playbook_format.md`. Example records can be defined with additional metadata using `[!example-record]` callouts that include fields like `id` (YYYYMMDD-name format), `name` (namespaced identifier), `pattern` classification, and `difficulty` level.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["example-record", "output-callout", "metadata"], "original_answer": "## Example Record Callout\n\nThe `[!example-record]` callout documents reusable patterns:\n\n```markdown\n> [!example-record]\n> id: YYYYMMDD-name\n> name: unifyweaver.category.specific\n> pattern: pattern_type\n> difficulty: beginner|intermediate|advanced\n```\n\n### Metadata Fields\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `id` | Yes | Unique ID (YYYYMMDD-name) |\n| `name` | Yes | Namespaced name |\n| `pattern` | No | Classification |\n| `difficulty` | No | beginner/intermediate/advanced |\n| `parent_example` | No | Parent example ID |\n| `child_examples` | No | List of dependents |\n| `related` | No | Cross-references |\n| `tags` | No | Additional tags |\n\n### Output Callout\n\n```markdown\n> [!output]\n> factorial 5\n> 120\n```\n\nShows expected command output for verification.", "answer_tailored": true}
{"pair_id": "b4-c2-callout-types_p2", "cluster_id": "b4-c2-callout-types", "question": "What metadata fields are used in example records?", "question_type": "medium", "answer": "Example records use these metadata fields:\n\n**Required fields:**\n- `id` - Unique identifier in YYYYMMDD-name format\n- `name` - Namespaced identifier (e.g., unifyweaver.category.specific)\n\n**Optional fields:**\n- `pattern` - Pattern classification type\n- `difficulty` - Complexity level (beginner, intermediate, or advanced)\n- `parent_example` - References the parent example's ID\n- `child_examples` - Lists dependent example IDs\n- `related` - Cross-reference links\n- `tags` - Additional categorization labels\n\nThese fields are documented within `[!example-record]` callouts in playbook files. The `id` and `name` fields must be present, while other fields provide optional metadata for organization and discovery.\n\nFor complete documentation on playbook formatting, see education/book-04-workflows/02_playbook_format.md.", "answer_variant": "default", "answer_source": "education/book-04-workflows/02_playbook_format.md", "topics": ["example-record", "output-callout", "metadata"], "original_answer": "## Example Record Callout\n\nThe `[!example-record]` callout documents reusable patterns:\n\n```markdown\n> [!example-record]\n> id: YYYYMMDD-name\n> name: unifyweaver.category.specific\n> pattern: pattern_type\n> difficulty: beginner|intermediate|advanced\n```\n\n### Metadata Fields\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `id` | Yes | Unique ID (YYYYMMDD-name) |\n| `name` | Yes | Namespaced name |\n| `pattern` | No | Classification |\n| `difficulty` | No | beginner/intermediate/advanced |\n| `parent_example` | No | Parent example ID |\n| `child_examples` | No | List of dependents |\n| `related` | No | Cross-references |\n| `tags` | No | Additional tags |\n\n### Output Callout\n\n```markdown\n> [!output]\n> factorial 5\n> 120\n```\n\nShows expected command output for verification.", "answer_tailored": true}
