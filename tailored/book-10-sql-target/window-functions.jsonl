{"pair_id": "sql-window-001_p0", "cluster_id": "sql-window-001", "question": "How do window functions work in the SQL target?", "question_type": "medium", "answer": "The SQL target implements window functions through `sql_window/4` and `sql_window/5` predicates that generate OVER clauses. These let you compute values across row sets without grouping.\n\nThe basic form is `sql_window(Function, Args, PartitionBy, OrderBy)`. For instance, ranking employees by salary within each department:\n\n```prolog\nemployees_ranked(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n```\n\nThis produces: `RANK() OVER (PARTITION BY dept ORDER BY salary DESC)`\n\nThe extended form `sql_window/5` adds a FrameSpec parameter for controlling the window frame (ROWS BETWEEN, etc.). Unlike aggregations that collapse rows, window functions preserve all rows while calculating across related subsets.\n\nFor implementation details, see education/book-10-sql-target/06_window_functions.md", "answer_variant": "default", "answer_source": "book-10-sql-target/06_window_functions.md", "topics": [], "original_answer": "Window functions calculate across related rows without collapsing them like aggregations. Syntax:\n\n```prolog\nsql_window(Function, Args, PartitionBy, OrderBy)\nsql_window(Function, Args, PartitionBy, OrderBy, FrameSpec)\n```\n\nExample - rank employees by salary within department:\n```prolog\nemployees_ranked(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n```\n\nGenerates: `RANK() OVER (PARTITION BY dept ORDER BY salary DESC)`", "answer_tailored": true}
{"pair_id": "sql-window-001_p0", "cluster_id": "sql-window-001", "question": "What ranking functions does the SQL target support?", "question_type": "medium", "answer": "UnifyWeaver's SQL target provides three ranking functions, each handling ties differently:\n\n**ROW_NUMBER**: Assigns unique sequential numbers regardless of ties (1, 2, 3, 4...). When two employees have the same salary, they still get different row numbers.\n\n**RANK**: Gives the same rank to tied values but leaves gaps after ties (1, 1, 3, 4...). If two employees tie for first place, the next employee gets rank 3.\n\n**DENSE_RANK**: Assigns the same rank to ties without gaps in the sequence (1, 1, 2, 3...). Tied employees share a rank, and the next rank continues sequentially.\n\nAll three use the `sql_window/4` functor with partition, order-by clauses:\n\n```prolog\nRowNum = sql_window(row_number, [], [Dept], [(Salary, desc)])\nRank = sql_window(rank, [], [Dept], [(Salary, desc)])\nDenseRank = sql_window(dense_rank, [], [Dept], [(Salary, desc)])\n```\n\nFor salaries [100K, 100K, 90K, 80K], the rankings would be:\n- ROW_NUMBER: 1, 2, 3, 4\n- RANK: 1, 1, 3, 4\n- DENSE_RANK: 1, 1, 2, 3\n\nSee education/book-10-sql-target/06_window_functions.md for complete details on window function compilation.", "answer_variant": "default", "answer_source": "book-10-sql-target/06_window_functions.md", "topics": [], "original_answer": "Three ranking functions with different tie-handling:\n\n```prolog\n% ROW_NUMBER - unique sequential numbers (1, 2, 3, 4...)\nRowNum = sql_window(row_number, [], [Dept], [(Salary, desc)])\n\n% RANK - same rank for ties, with gaps (1, 1, 3, 4...)\nRank = sql_window(rank, [], [Dept], [(Salary, desc)])\n\n% DENSE_RANK - same rank for ties, no gaps (1, 1, 2, 3...)\nDenseRank = sql_window(dense_rank, [], [Dept], [(Salary, desc)])\n```\n\nComparison for [100K, 100K, 90K, 80K]:\n| ROW_NUMBER | RANK | DENSE_RANK |\n|------------|------|------------|\n| 1 | 1 | 1 |\n| 2 | 1 | 1 |\n| 3 | 3 | 2 |\n| 4 | 4 | 3 |", "answer_tailored": true}
{"pair_id": "sql-window-002_p0", "cluster_id": "sql-window-002", "question": "How do I use LAG and LEAD in the SQL target?", "question_type": "medium", "answer": "The SQL target supports LAG and LEAD for accessing adjacent rows within a window. Use `sql_window/4` with the function name, arguments including the column and offset, partition columns, and ordering:\n\n```prolog\n% LAG retrieves the previous row's value\nsales_with_previous(Salesperson, Amount, SaleDate, PrevAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    PrevAmount = sql_window(lag, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n\n% LEAD retrieves the next row's value\nsales_with_next(Salesperson, Amount, SaleDate, NextAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    NextAmount = sql_window(lead, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n```\n\nThe offset parameter (second element in the arguments list) determines how many rows forward or backward to look. You can also use `first_value` and `last_value` to access partition boundaries. For comprehensive coverage, see education/book-10-sql-target/06_window_functions.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/06_window_functions.md", "topics": [], "original_answer": "LAG accesses previous rows, LEAD accesses following rows:\n\n```prolog\n% LAG - previous row's value\nsales_with_previous(Salesperson, Amount, SaleDate, PrevAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    PrevAmount = sql_window(lag, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n\n% LEAD - next row's value\nsales_with_next(Salesperson, Amount, SaleDate, NextAmount) :-\n    sales(_, Salesperson, _, Amount, SaleDate),\n    NextAmount = sql_window(lead, [Amount, 1], [Salesperson], [(SaleDate, asc)]).\n```\n\nThe second argument is the offset (how many rows). Also available: `first_value`, `last_value` for partition extremes.", "answer_tailored": true}
{"pair_id": "sql-window-002_p0", "cluster_id": "sql-window-002", "question": "How do I specify window frames in the SQL target?", "question_type": "medium", "answer": "Window frames in the SQL target use the 5-argument `sql_window/5` form where the fifth argument specifies the frame:\n\n```prolog\nsql_window(Function, Args, PartitionBy, OrderBy, FrameSpec)\n```\n\nThe `FrameSpec` defines which rows to include relative to the current row using `rows_between(Start, End)`.\n\n**Example - Running total (unbounded start to current row):**\n```prolog\nrunning_total(Person, Date, Amount, Total) :-\n    sales(_, Person, _, Amount, Date),\n    Total = sql_window(sum, [Amount], [Person], [(Date, asc)],\n                       rows_between(unbounded_preceding, current_row)).\n```\n\n**Example - 3-day moving average (2 rows back to current):**\n```prolog\nmoving_avg_3day(Person, Date, Amount, MovingAvg) :-\n    sales(_, Person, _, Amount, Date),\n    MovingAvg = sql_window(avg, [Amount], [Person], [(Date, asc)],\n                           rows_between(2 preceding, current_row)).\n```\n\n**Available frame boundaries:**\n- `unbounded_preceding` - start of partition\n- `N preceding` - N rows before current\n- `current_row` - the current row\n- `N following` - N rows after current\n- `unbounded_following` - end of partition\n\nFor more details, see education/book-10-sql-target/06_window_functions.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/06_window_functions.md", "topics": [], "original_answer": "Control exactly which rows are included using the 5-argument form:\n\n```prolog\nsql_window(Function, Args, PartitionBy, OrderBy, FrameSpec)\n```\n\n**Running total (default frame):**\n```prolog\nrunning_total(Person, Date, Amount, Total) :-\n    sales(_, Person, _, Amount, Date),\n    Total = sql_window(sum, [Amount], [Person], [(Date, asc)],\n                       rows_between(unbounded_preceding, current_row)).\n```\n\n**3-day moving average:**\n```prolog\nmoving_avg_3day(Person, Date, Amount, MovingAvg) :-\n    sales(_, Person, _, Amount, Date),\n    MovingAvg = sql_window(avg, [Amount], [Person], [(Date, asc)],\n                           rows_between(2 preceding, current_row)).\n```\n\nBoundaries: `unbounded_preceding`, `current_row`, `unbounded_following`, `N preceding`, `N following`", "answer_tailored": true}
