{"pair_id": "sql-cte-001_p0", "cluster_id": "sql-cte-001", "question": "How do I use Common Table Expressions (CTEs) in the SQL target?", "question_type": "medium", "answer": "To use Common Table Expressions in the SQL target, employ the `compile_with_cte/4` predicate to generate WITH clauses. First, define the CTE body as a Prolog rule containing your subquery logic. Then create a main query rule that references the CTE by its assigned name. Finally, call `compile_with_cte/4` with the CTE name, CTE body predicate, main query predicate, and output variable.\n\nExample:\n\n```prolog\n% Define the CTE body\nhigh_earner_data(Id, Name, Salary) :-\n    employees(Id, Name, _, Salary, _),\n    Salary > 100000.\n\n% Main query referencing the CTE\nhigh_earner_result(Name, Salary) :-\n    high_earners(_, Name, Salary).\n\n% Compile to SQL\n?- compile_with_cte(high_earners, high_earner_data/3, high_earner_result/2, SQL).\n```\n\nThis produces: `WITH high_earners AS (SELECT id, name, salary FROM employees WHERE salary > 100000) SELECT name, salary FROM high_earners`\n\nFor more details on SQL target features, see education/book-10-sql-target/.", "answer_variant": "default", "answer_source": "book-10-sql-target/07_common_table_expressions.md", "topics": [], "original_answer": "Use `compile_with_cte/4` to create WITH clauses:\n\n```prolog\n% Step 1: Define CTE content\nhigh_earner_data(Id, Name, Salary) :-\n    employees(Id, Name, _, Salary, _),\n    Salary > 100000.\n\n% Step 2: Define main query (references CTE by name)\nhigh_earner_result(Name, Salary) :-\n    high_earners(_, Name, Salary).  % References CTE name\n\n% Step 3: Compile\n?- compile_with_cte(high_earners, high_earner_data/3, high_earner_result/2, SQL).\n```\n\nGenerates: `WITH high_earners AS (SELECT ...) SELECT name, salary FROM high_earners`", "answer_tailored": true}
{"pair_id": "sql-cte-001_p0", "cluster_id": "sql-cte-001", "question": "Why use CTEs instead of subqueries?", "question_type": "medium", "answer": "CTEs offer key advantages over subqueries:\n\n**Readability** - CTEs break down complex logic into named, sequential steps rather than deeply nested subqueries:\n```prolog\nrich_depts_cte(DeptName) :-\n    departments(_, DeptName, Budget, _),\n    Budget > 1000000.\n\nemployees_result(Name) :-\n    employees(_, Name, Dept, _, _),\n    rich_depts(Dept).  % Named reference is clearer than inline subquery\n```\n\n**Window function filtering** - You can't use WHERE directly on window functions, but CTEs let you filter their results:\n```prolog\nranked_cte(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n\ntop_3_per_dept(Name, Dept, Salary, Rank) :-\n    ranked_employees(Name, Dept, Salary, Rank),\n    Rank =< 3.\n```\n\n**Reusability** - Define once, reference multiple times in the same query without duplicating logic.\n\nSee education/book-10-sql-target/07_common_table_expressions.md for complete details.", "answer_variant": "default", "answer_source": "book-10-sql-target/07_common_table_expressions.md", "topics": [], "original_answer": "CTEs provide several advantages:\n\n**1. Improved readability** - Break complex queries into logical steps:\n```prolog\nrich_depts_cte(DeptName) :-\n    departments(_, DeptName, Budget, _),\n    Budget > 1000000.\n\nemployees_result(Name) :-\n    employees(_, Name, Dept, _, _),\n    rich_depts(Dept).  % Clear reference to CTE\n```\n\n**2. Filter window function results** - CTEs enable WHERE on window results:\n```prolog\nranked_cte(Name, Dept, Salary, Rank) :-\n    employees(_, Name, Dept, Salary, _),\n    Rank = sql_window(rank, [], [Dept], [(Salary, desc)]).\n\ntop_3_per_dept(Name, Dept, Salary, Rank) :-\n    ranked_employees(Name, Dept, Salary, Rank),\n    Rank =< 3.\n```\n\n**3. Reuse within query** - Reference the same CTE multiple times.", "answer_tailored": true}
{"pair_id": "sql-cte-002_p0", "cluster_id": "sql-cte-002", "question": "How do I use recursive CTEs in the SQL target?", "question_type": "medium", "answer": "The SQL target provides `compile_recursive_cte/5` to generate `WITH RECURSIVE` queries for hierarchical data traversal:\n\n```prolog\n% Define the recursive CTE schema\n:- sql_recursive_table(org_tree, [id-integer, name-text, manager_id-integer]).\n\n% Base case: employees without a manager\norg_base(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId).\n\n% Recursive case: employees whose manager appears in org_tree\norg_recursive(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    org_tree(ManagerId, _, _).\n\n% Final query from the CTE\norg_result(Id, Name, ManagerId) :-\n    org_tree(Id, Name, ManagerId).\n\n% Compile to SQL\n?- compile_recursive_cte(org_tree, [id, name, manager_id],\n    recursive_cte(org_base/3, org_recursive/3), org_result/3, SQL).\n```\n\nThis produces a `WITH RECURSIVE ... UNION ALL ...` statement. The first predicate defines your anchor case, the second handles the recursive step, and the third specifies the final SELECT. For more SQL target patterns, see education/book-10-sql-target/.", "answer_variant": "default", "answer_source": "book-10-sql-target/08_recursive_ctes.md", "topics": [], "original_answer": "Use `compile_recursive_cte/5` for hierarchical data:\n\n```prolog\n% Declare recursive table schema\n:- sql_recursive_table(org_tree, [id-integer, name-text, manager_id-integer]).\n\n% Base case: Top-level employees (no manager)\norg_base(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId).\n\n% Recursive case: Employees whose manager is in org_tree\norg_recursive(Id, Name, ManagerId) :-\n    employees(Id, Name, ManagerId, _),\n    org_tree(ManagerId, _, _).  % Join to CTE\n\n% Main query\norg_result(Id, Name, ManagerId) :-\n    org_tree(Id, Name, ManagerId).\n\n% Compile\n?- compile_recursive_cte(org_tree, [id, name, manager_id],\n    recursive_cte(org_base/3, org_recursive/3), org_result/3, SQL).\n```\n\nGenerates `WITH RECURSIVE ... UNION ALL ...`", "answer_tailored": true}
{"pair_id": "sql-cte-002_p0", "cluster_id": "sql-cte-002", "question": "What are common recursive CTE patterns?", "question_type": "medium", "answer": "Common recursive CTE patterns in UnifyWeaver include:\n\n**Depth tracking in hierarchies** - Track levels by setting base cases to 0 and incrementing in recursive steps:\n```prolog\nlevel_base(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId),\n    Level = 0.\n\nlevel_recursive(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    org_levels(ManagerId, _, ParentLevel),\n    Level = ParentLevel + 1.\n```\n\n**Path construction** - Build complete paths from root to leaf by concatenating names:\n```prolog\npath_base(Id, Path) :-\n    categories(Id, Name, ParentId),\n    sql_is_null(ParentId),\n    Path = Name.\n\npath_recursive(Id, Path) :-\n    categories(Id, Name, ParentId),\n    paths(ParentId, ParentPath),\n    Path = sql_concat([ParentPath, ' > ', Name]).\n```\n\n**Graph traversal** - Find all reachable nodes from a starting point:\n```prolog\nreach_base(Node) :- edges(1, Node, _).\nreach_recursive(Node) :- reachable(From), edges(From, Node, _).\n```\n\nFor additional recursive patterns and examples, see education/book-10-sql-target/08_recursive_ctes.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/08_recursive_ctes.md", "topics": [], "original_answer": "**1. Hierarchical depth tracking:**\n```prolog\nlevel_base(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    sql_is_null(ManagerId),\n    Level = 0.\n\nlevel_recursive(Id, Name, Level) :-\n    employees(Id, Name, ManagerId, _),\n    org_levels(ManagerId, _, ParentLevel),\n    Level = ParentLevel + 1.\n```\n\n**2. Path accumulation:**\n```prolog\npath_base(Id, Path) :-\n    categories(Id, Name, ParentId),\n    sql_is_null(ParentId),\n    Path = Name.\n\npath_recursive(Id, Path) :-\n    categories(Id, Name, ParentId),\n    paths(ParentId, ParentPath),\n    Path = sql_concat([ParentPath, ' > ', Name]).\n```\n\n**3. Graph reachability:**\n```prolog\nreach_base(Node) :- edges(1, Node, _).\nreach_recursive(Node) :- reachable(From), edges(From, Node, _).\n```", "answer_tailored": true}
