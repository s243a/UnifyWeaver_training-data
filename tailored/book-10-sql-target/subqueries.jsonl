{"pair_id": "sql-subquery-001_p0", "cluster_id": "sql-subquery-001", "question": "How do I use IN subqueries in the SQL target?", "question_type": "medium", "answer": "To use IN subqueries in SQL target compilation, apply the `sql_in_subquery/2` predicate to test whether a value matches any result from a subquery:\n\n```prolog\n% Subquery to find high-budget departments\nhigh_budget_dept(DeptName) :-\n    departments(_, DeptName, Budget, _),\n    Budget > 1000000.\n\n% Main query with IN condition\nemployees_in_rich_depts(EmpName, Dept) :-\n    employees(_, EmpName, Dept, _, _),\n    sql_in_subquery(Dept, high_budget_dept/1).\n```\n\nThis compiles to: `SELECT name, dept FROM employees WHERE dept IN (SELECT name FROM departments WHERE budget > 1000000)`\n\nThe first argument to `sql_in_subquery/2` is the column to check, and the second is the predicate defining the subquery. See education/book-10-sql-target/05_subqueries.md for complete coverage of SQL subquery patterns.", "answer_variant": "default", "answer_source": "book-10-sql-target/05_subqueries.md", "topics": [], "original_answer": "Use `sql_in_subquery/2` to check if a column value exists in another query's results:\n\n```prolog\n% Define subquery predicate\nhigh_budget_dept(DeptName) :-\n    departments(_, DeptName, Budget, _),\n    Budget > 1000000.\n\n% Main query using IN subquery\nemployees_in_rich_depts(EmpName, Dept) :-\n    employees(_, EmpName, Dept, _, _),\n    sql_in_subquery(Dept, high_budget_dept/1).\n```\n\nGenerates: `SELECT name, dept FROM employees WHERE dept IN (SELECT name FROM departments WHERE budget > 1000000)`", "answer_tailored": true}
{"pair_id": "sql-subquery-001_p0", "cluster_id": "sql-subquery-001", "question": "How do I use EXISTS subqueries?", "question_type": "medium", "answer": "To check if any rows exist matching a condition, use `sql_exists/1`. This is typically more performant than IN when working with large tables:\n\n```prolog\ndept_has_employees(DeptName) :-\n    employees(_, _, DeptName, _, _).\n\nactive_departments(DeptName, Budget) :-\n    departments(_, DeptName, Budget, _),\n    sql_exists(dept_has_employees(DeptName)).\n```\n\nThis generates: `WHERE EXISTS (SELECT 1 FROM employees WHERE dept = d.name)`\n\nYou can also use `sql_not_exists/1` for the inverse check:\n```prolog\nproducts_never_ordered(Name, Price) :-\n    products(_, Name, _, Price),\n    sql_not_exists(product_ordered(Name)).\n```\n\nFor more on SQL target subquery patterns, see education/book-10-sql-target/05_subqueries.md", "answer_variant": "default", "answer_source": "book-10-sql-target/05_subqueries.md", "topics": [], "original_answer": "Use `sql_exists/1` to check if ANY rows exist in the subquery. It's more efficient than IN for large datasets:\n\n```prolog\ndept_has_employees(DeptName) :-\n    employees(_, _, DeptName, _, _).\n\nactive_departments(DeptName, Budget) :-\n    departments(_, DeptName, Budget, _),\n    sql_exists(dept_has_employees(DeptName)).\n```\n\nGenerates: `WHERE EXISTS (SELECT 1 FROM employees WHERE dept = d.name)`\n\nFor negation, use `sql_not_exists/1`:\n```prolog\nproducts_never_ordered(Name, Price) :-\n    products(_, Name, _, Price),\n    sql_not_exists(product_ordered(Name)).\n```", "answer_tailored": true}
{"pair_id": "sql-subquery-002_p0", "cluster_id": "sql-subquery-002", "question": "What's the difference between correlated and non-correlated subqueries?", "question_type": "medium", "answer": "The key distinction is in how the subquery executes relative to the outer query:\n\n**Non-correlated subqueries** execute once independently, without referencing the outer query. The subquery completes first, then its results are used by the outer query:\n```prolog\navg_salary_dept(Dept) :-\n    employees(_, _, Dept, Salary, _),\n    sql_group_by([Dept]),\n    AvgSal = sql_avg(Salary),\n    sql_having(AvgSal > 60000).\n\nemployees_in_high_avg_depts(Name) :-\n    employees(_, Name, Dept, _, _),\n    sql_in_subquery(Dept, avg_salary_dept/1).\n```\n\n**Correlated subqueries** reference columns from the outer query and execute once for each row in the outer query:\n```prolog\ndept_employee_exists(DeptName) :-\n    employees(_, _, DeptName, _, _).  % DeptName comes from outer query\n\ndepts_with_staff(Name) :-\n    departments(_, Name, _, _),\n    sql_exists(dept_employee_exists(Name)).  % Executes per department\n```\n\nCorrelated subqueries are common with EXISTS clauses, while IN typically uses non-correlated subqueries. For more on SQL compilation patterns, see education/book-10-sql-target/.", "answer_variant": "default", "answer_source": "book-10-sql-target/05_subqueries.md", "topics": [], "original_answer": "**Non-correlated**: Subquery runs once, independently of outer query:\n```prolog\navg_salary_dept(Dept) :-\n    employees(_, _, Dept, Salary, _),\n    sql_group_by([Dept]),\n    AvgSal = sql_avg(Salary),\n    sql_having(AvgSal > 60000).\n\nemployees_in_high_avg_depts(Name) :-\n    employees(_, Name, Dept, _, _),\n    sql_in_subquery(Dept, avg_salary_dept/1).\n```\n\n**Correlated**: Subquery references outer query (runs once per outer row):\n```prolog\ndept_employee_exists(DeptName) :-\n    employees(_, _, DeptName, _, _).  % DeptName from outer\n\ndepts_with_staff(Name) :-\n    departments(_, Name, _, _),\n    sql_exists(dept_employee_exists(Name)).  % Correlated\n```\n\nEXISTS subqueries are typically correlated.", "answer_tailored": true}
