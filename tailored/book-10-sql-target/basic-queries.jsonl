{"pair_id": "sql-basic-001_p0", "cluster_id": "sql-basic-001", "question": "What comparison operators does the SQL target support?", "question_type": "medium", "answer": "The SQL target supports all standard comparison operators through Prolog operator translation:\n\n- `=` (equal) maps to SQL `=`\n- `\\=` (not equal) maps to SQL `<>`\n- `<` (less than) maps to SQL `<`\n- `>` (greater than) maps to SQL `>`\n- `=<` (less than or equal) maps to SQL `<=`\n- `>=` (greater than or equal) maps to SQL `>=`\n\nWhen you write multiple comparison predicates in a Prolog clause body, they combine with AND in the generated SQL WHERE clause. For complete examples, see education/book-10-sql-target/02_basic_queries.md.", "answer_variant": "default", "answer_source": "book-10-sql-target/02_basic_queries.md", "topics": [], "original_answer": "Prolog operators translate directly to SQL:\n| Prolog | SQL | Description |\n|--------|-----|-------------|\n| `=` | `=` | Equal |\n| `\\=` | `<>` | Not equal |\n| `<` | `<` | Less than |\n| `>` | `>` | Greater than |\n| `=<` | `<=` | Less than or equal |\n| `>=` | `>=` | Greater than or equal |\n\nMultiple conditions in clause body become AND in WHERE clause.", "answer_tailored": true}
{"pair_id": "sql-basic-001_p0", "cluster_id": "sql-basic-001", "question": "How do I use ORDER BY, LIMIT, and OFFSET in SQL target?", "question_type": "medium", "answer": "To control result ordering and pagination in UnifyWeaver's SQL target, use the following special predicates in your clause body:\n\nFor sorting, use `sql_order_by(Column, Direction)` where direction is `asc` or `desc`:\n\n```prolog\ntop_5_earners(Name, Salary) :-\n    employees(_, Name, _, Salary, _, _),\n    sql_order_by(Salary, desc),\n    sql_limit(5).\n```\n\nFor pagination, combine `sql_limit/1` (number of rows) with `sql_offset/1` (rows to skip):\n\n```prolog\npage_2(Name) :-\n    employees(_, Name, _, _, _, _),\n    sql_order_by(Name, asc),\n    sql_limit(10),\n    sql_offset(10).  % Skip first 10 rows\n```\n\nFor multi-column sorting, call `sql_order_by/2` multiple times in the order you want columns prioritized. See education/book-10-sql-target/02_basic_queries.md for more examples.", "answer_variant": "default", "answer_source": "book-10-sql-target/02_basic_queries.md", "topics": [], "original_answer": "Use special predicates in the clause body:\n\n```prolog\ntop_5_earners(Name, Salary) :-\n    employees(_, Name, _, Salary, _, _),\n    sql_order_by(Salary, desc),\n    sql_limit(5).\n\n% With pagination (page 2)\npage_2(Name) :-\n    employees(_, Name, _, _, _, _),\n    sql_order_by(Name, asc),\n    sql_limit(10),\n    sql_offset(10).\n```\n\nFor multi-column sort, call `sql_order_by/2` multiple times.", "answer_tailored": true}
{"pair_id": "sql-basic-002_p0", "cluster_id": "sql-basic-002", "question": "How do I use DISTINCT and column aliasing in SQL target?", "question_type": "medium", "answer": "To get unique rows in SQL target, use the `sql_distinct/0` predicate. For renaming columns in your results, use `sql_as/2` with the pattern `sql_as(Expression, alias_name)`:\n\n```prolog\n% Get distinct department values\nunique_depts(Dept) :-\n    employees(_, _, Dept, _, _, _),\n    sql_distinct.\n\n% Alias a column\nemployee_info(EmpName) :-\n    employees(_, Name, _, _, _, _),\n    EmpName = sql_as(Name, employee_name).\n\n% Alias computed expressions\nsalary_k(Name, SalaryK) :-\n    employees(_, Name, _, Salary, _, _),\n    SalaryK = sql_as(Salary / 1000, salary_thousands).\n```\n\nThe `sql_distinct` ensures only unique result rows are returned, while `sql_as/2` lets you give custom names to columns or calculated values in your query output.", "answer_variant": "default", "answer_source": "book-10-sql-target/02_basic_queries.md", "topics": [], "original_answer": "Use `sql_distinct/0` for unique rows and `sql_as/2` for aliases:\n\n```prolog\n% DISTINCT\nunique_depts(Dept) :-\n    employees(_, _, Dept, _, _, _),\n    sql_distinct.\n\n% Column aliasing\nemployee_info(EmpName) :-\n    employees(_, Name, _, _, _, _),\n    EmpName = sql_as(Name, employee_name).\n\n% With expressions\nsalary_k(Name, SalaryK) :-\n    employees(_, Name, _, Salary, _, _),\n    SalaryK = sql_as(Salary / 1000, salary_thousands).\n```", "answer_tailored": true}
