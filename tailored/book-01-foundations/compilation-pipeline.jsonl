{"pair_id": "compilation-pipeline_p0", "cluster_id": "compilation-pipeline", "question": "How does the UnifyWeaver compilation pipeline work?", "question_type": "medium", "answer": "The UnifyWeaver compilation pipeline transforms Prolog predicates into target language code through several stages:\n\n**Pipeline Flow:**\n\n1. **Pattern Classification** - The `recursive_compiler.pl` module analyzes the input Prolog predicate to determine its structure (facts only, non-recursive rules, tail recursion, linear recursion, or mutual recursion)\n\n2. **Routing** - Based on classification:\n   - Non-recursive predicates \u2192 `stream_compiler.pl`\n   - Recursive predicates \u2192 specialized handlers in `advanced/` (tail_recursion.pl, linear_recursion.pl, or mutual_recursion.pl with SCC detection)\n\n3. **Constraint Analysis** - The `constraint_analyzer.pl` examines the predicate for modifiers like `unique` or `ordered` that affect code generation\n\n4. **Template Selection & Rendering** - The `template_system.pl` selects the appropriate code template for the target language and renders it with the analyzed structure\n\n5. **Code Generation** - Final target language code is produced (Bash, Python, Go, Rust, C#, PowerShell, or SQL)\n\n**Example compilation:**\n```prolog\n?- compile(ancestor/2, [target(bash)], Scripts).\n% Analyzes ancestor/2 as linear_recursion with unique constraint\n% Generates output/ancestor.sh\n```\n\nThe core implementation resides in `src/unifyweaver/core/` with the recursive analysis modules located in `src/unifyweaver/core/advanced/`. For detailed examples of each compilation path, see education/book-01-foundations/03_unifyweaver_architecture.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["architecture", "compilation", "pipeline", "recursive-compiler", "stream-compiler", "template-system"], "original_answer": "## Compilation Pipeline\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prolog Predicate \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Classify Pattern \u2502  (recursive_compiler.pl)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Non-Rec \u2502  \u2502 Recursive           \u2502\n\u2502stream  \u2502  \u2502 advanced_recursive  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Analyze Constraints & Options    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Select & Render Template         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Generated Code \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Core Modules\n\n```prolog\n% Module structure\nsrc/unifyweaver/core/\n\u251c\u2500\u2500 template_system.pl      % Template rendering engine\n\u251c\u2500\u2500 stream_compiler.pl      % Non-recursive predicates\n\u251c\u2500\u2500 recursive_compiler.pl   % Main dispatcher\n\u251c\u2500\u2500 constraint_analyzer.pl  % unique, ordered constraints\n\u2514\u2500\u2500 advanced/\n    \u251c\u2500\u2500 advanced_recursive_compiler.pl\n    \u251c\u2500\u2500 tail_recursion.pl\n    \u251c\u2500\u2500 linear_recursion.pl\n    \u2514\u2500\u2500 mutual_recursion.pl\n```\n\n## Classification\n\n```prolog\n% recursive_compiler dispatches based on pattern:\n% - Facts only \u2192 stream_compiler\n% - Non-recursive rules \u2192 stream_compiler  \n% - Tail recursion \u2192 tail_recursion.pl\n% - Linear recursion \u2192 linear_recursion.pl\n% - Mutual recursion \u2192 mutual_recursion.pl (SCC detection)\n```\n\n## Example: Compiling a Predicate\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n\n% Output:\n=== Compiling ancestor/2 ===\n  Constraints: [unique(true)]\nType: linear_recursion\nScripts: ['output/ancestor.sh']\n```", "answer_tailored": true}
{"pair_id": "compilation-pipeline_p1", "cluster_id": "compilation-pipeline", "question": "What are the core modules in UnifyWeaver?", "question_type": "medium", "answer": "UnifyWeaver's core modules are organized under `src/unifyweaver/core/` and include:\n\n- **template_system.pl** - The template rendering engine that generates target language code\n- **stream_compiler.pl** - Handles non-recursive predicates and fact-only definitions\n- **recursive_compiler.pl** - Main dispatcher that classifies patterns and routes to appropriate handlers\n- **constraint_analyzer.pl** - Analyzes constraints like unique and ordered requirements\n- **advanced/** subdirectory containing specialized recursive handlers:\n  - advanced_recursive_compiler.pl - Advanced recursion patterns\n  - tail_recursion.pl - Optimized tail-recursive compilation\n  - linear_recursion.pl - Linear recursive patterns\n  - mutual_recursion.pl - Mutual recursion with SCC detection\n\nThe recursive_compiler module serves as the entry point, classifying each predicate by analyzing its structure. Facts and non-recursive rules go to stream_compiler, while recursive predicates are dispatched to specialized modules based on their recursion pattern (tail, linear, or mutual). The constraint_analyzer examines uniqueness and ordering requirements, and template_system renders the final code for the target language.\n\nFor implementation details, see `education/book-01-foundations/03_unifyweaver_architecture.md`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["architecture", "compilation", "pipeline", "recursive-compiler", "stream-compiler", "template-system"], "original_answer": "## Compilation Pipeline\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prolog Predicate \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Classify Pattern \u2502  (recursive_compiler.pl)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Non-Rec \u2502  \u2502 Recursive           \u2502\n\u2502stream  \u2502  \u2502 advanced_recursive  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Analyze Constraints & Options    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Select & Render Template         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Generated Code \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Core Modules\n\n```prolog\n% Module structure\nsrc/unifyweaver/core/\n\u251c\u2500\u2500 template_system.pl      % Template rendering engine\n\u251c\u2500\u2500 stream_compiler.pl      % Non-recursive predicates\n\u251c\u2500\u2500 recursive_compiler.pl   % Main dispatcher\n\u251c\u2500\u2500 constraint_analyzer.pl  % unique, ordered constraints\n\u2514\u2500\u2500 advanced/\n    \u251c\u2500\u2500 advanced_recursive_compiler.pl\n    \u251c\u2500\u2500 tail_recursion.pl\n    \u251c\u2500\u2500 linear_recursion.pl\n    \u2514\u2500\u2500 mutual_recursion.pl\n```\n\n## Classification\n\n```prolog\n% recursive_compiler dispatches based on pattern:\n% - Facts only \u2192 stream_compiler\n% - Non-recursive rules \u2192 stream_compiler  \n% - Tail recursion \u2192 tail_recursion.pl\n% - Linear recursion \u2192 linear_recursion.pl\n% - Mutual recursion \u2192 mutual_recursion.pl (SCC detection)\n```\n\n## Example: Compiling a Predicate\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n\n% Output:\n=== Compiling ancestor/2 ===\n  Constraints: [unique(true)]\nType: linear_recursion\nScripts: ['output/ancestor.sh']\n```", "answer_tailored": true}
{"pair_id": "compilation-pipeline_p2", "cluster_id": "compilation-pipeline", "question": "How does UnifyWeaver classify predicates?", "question_type": "medium", "answer": "UnifyWeaver classifies predicates by analyzing their structure and recursion patterns in the `recursive_compiler.pl` module. The classifier examines each predicate and categorizes it into one of several types:\n\n**Non-recursive predicates** (handled by `stream_compiler.pl`):\n- Facts only (no rules)\n- Rules without recursive calls\n\n**Recursive predicates** (handled by `advanced_recursive_compiler.pl` subsystems):\n- **Tail recursion** - recursive call is the last operation (`tail_recursion.pl`)\n- **Linear recursion** - single recursive call per clause (`linear_recursion.pl`)\n- **Mutual recursion** - predicates call each other in cycles, detected via strongly-connected component (SCC) analysis (`mutual_recursion.pl`)\n\nAfter classification, the appropriate specialized compiler analyzes constraints (like `unique` or `ordered`) and renders the target code using the template system. For example, compiling `ancestor/2` with `compile(ancestor/2, [target(bash)], Scripts)` would classify it as linear recursion and generate the corresponding Bash script.\n\nThe full classification logic and compilation pipeline are detailed in `src/unifyweaver/core/recursive_compiler.pl` and related modules under `src/unifyweaver/core/advanced/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["architecture", "compilation", "pipeline", "recursive-compiler", "stream-compiler", "template-system"], "original_answer": "## Compilation Pipeline\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prolog Predicate \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Classify Pattern \u2502  (recursive_compiler.pl)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Non-Rec \u2502  \u2502 Recursive           \u2502\n\u2502stream  \u2502  \u2502 advanced_recursive  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Analyze Constraints & Options    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Select & Render Template         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Generated Code \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Core Modules\n\n```prolog\n% Module structure\nsrc/unifyweaver/core/\n\u251c\u2500\u2500 template_system.pl      % Template rendering engine\n\u251c\u2500\u2500 stream_compiler.pl      % Non-recursive predicates\n\u251c\u2500\u2500 recursive_compiler.pl   % Main dispatcher\n\u251c\u2500\u2500 constraint_analyzer.pl  % unique, ordered constraints\n\u2514\u2500\u2500 advanced/\n    \u251c\u2500\u2500 advanced_recursive_compiler.pl\n    \u251c\u2500\u2500 tail_recursion.pl\n    \u251c\u2500\u2500 linear_recursion.pl\n    \u2514\u2500\u2500 mutual_recursion.pl\n```\n\n## Classification\n\n```prolog\n% recursive_compiler dispatches based on pattern:\n% - Facts only \u2192 stream_compiler\n% - Non-recursive rules \u2192 stream_compiler  \n% - Tail recursion \u2192 tail_recursion.pl\n% - Linear recursion \u2192 linear_recursion.pl\n% - Mutual recursion \u2192 mutual_recursion.pl (SCC detection)\n```\n\n## Example: Compiling a Predicate\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n\n% Output:\n=== Compiling ancestor/2 ===\n  Constraints: [unique(true)]\nType: linear_recursion\nScripts: ['output/ancestor.sh']\n```", "answer_tailored": true}
{"pair_id": "compilation-pipeline_p3", "cluster_id": "compilation-pipeline", "question": "What is the difference between stream_compiler and recursive_compiler?", "question_type": "medium", "answer": "The `stream_compiler` handles non-recursive predicates (facts and simple rules without self-reference), while `recursive_compiler` serves as the main dispatcher that classifies predicates and routes them to appropriate handlers.\n\nWhen you compile a predicate, `recursive_compiler.pl` first analyzes the pattern:\n- **Facts only or non-recursive rules** \u2192 Routes to `stream_compiler.pl`\n- **Tail recursion** \u2192 Routes to `advanced/tail_recursion.pl`\n- **Linear recursion** \u2192 Routes to `advanced/linear_recursion.pl`\n- **Mutual recursion** \u2192 Routes to `advanced/mutual_recursion.pl` (using SCC detection)\n\nIn essence, `stream_compiler` is the execution module for straightforward predicates, while `recursive_compiler` is the classification and routing layer that determines which compilation strategy to use. The distinction occurs in `src/unifyweaver/core/recursive_compiler.pl`, which dispatches based on recursion patterns detected in your Prolog code.\n\nFor example, a simple fact-based predicate like `parent(john, mary)` goes directly to `stream_compiler`, while `ancestor/2` (which calls itself recursively) gets classified by `recursive_compiler` and routed to the appropriate recursive handler based on its recursion type.", "answer_variant": "default", "answer_source": "education/book-01-foundations/03_unifyweaver_architecture.md", "topics": ["architecture", "compilation", "pipeline", "recursive-compiler", "stream-compiler", "template-system"], "original_answer": "## Compilation Pipeline\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prolog Predicate \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Classify Pattern \u2502  (recursive_compiler.pl)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Non-Rec \u2502  \u2502 Recursive           \u2502\n\u2502stream  \u2502  \u2502 advanced_recursive  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Analyze Constraints & Options    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Select & Render Template         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Generated Code \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Core Modules\n\n```prolog\n% Module structure\nsrc/unifyweaver/core/\n\u251c\u2500\u2500 template_system.pl      % Template rendering engine\n\u251c\u2500\u2500 stream_compiler.pl      % Non-recursive predicates\n\u251c\u2500\u2500 recursive_compiler.pl   % Main dispatcher\n\u251c\u2500\u2500 constraint_analyzer.pl  % unique, ordered constraints\n\u2514\u2500\u2500 advanced/\n    \u251c\u2500\u2500 advanced_recursive_compiler.pl\n    \u251c\u2500\u2500 tail_recursion.pl\n    \u251c\u2500\u2500 linear_recursion.pl\n    \u2514\u2500\u2500 mutual_recursion.pl\n```\n\n## Classification\n\n```prolog\n% recursive_compiler dispatches based on pattern:\n% - Facts only \u2192 stream_compiler\n% - Non-recursive rules \u2192 stream_compiler  \n% - Tail recursion \u2192 tail_recursion.pl\n% - Linear recursion \u2192 linear_recursion.pl\n% - Mutual recursion \u2192 mutual_recursion.pl (SCC detection)\n```\n\n## Example: Compiling a Predicate\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n\n% Output:\n=== Compiling ancestor/2 ===\n  Constraints: [unique(true)]\nType: linear_recursion\nScripts: ['output/ancestor.sh']\n```", "answer_tailored": true}
