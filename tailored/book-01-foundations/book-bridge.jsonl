{"pair_id": "prolog-to-bash-bridge_p0", "cluster_id": "prolog-to-bash-bridge", "question": "How do Prolog predicates become Bash scripts?", "question_type": "medium", "answer": "UnifyWeaver transforms Prolog predicates into executable Bash scripts through a compilation process that maps logical constructs to shell equivalents.\n\n**The Transformation Process:**\n\nWhen you define Prolog predicates like facts and rules:\n```prolog\nparent(abraham, isaac).\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nAnd compile them using UnifyWeaver's compiler driver:\n```prolog\n?- compile(ancestor/2, [output_dir('output')], Scripts).\n```\n\nYou get Bash scripts where:\n- **Facts** \u2192 Associative arrays storing the relationships\n- **Rules** \u2192 Shell functions implementing the logic\n- **Recursion** \u2192 BFS (breadth-first search) loops with memoization\n- **Unification** \u2192 Key matching in arrays\n- **Backtracking** \u2192 Streaming multiple results through stdout\n\n**Generated Output:**\n\n```bash\n# parent.sh - data storage\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh - rule logic\nancestor_all() {\n    declare -A visited\n    # BFS traversal implementation\n}\n```\n\nThe resulting scripts can be sourced and executed directly: `source output/ancestor.sh && ancestor abraham jacob`\n\nFor implementation details, see education/book-02-bash-target/ which covers the compilation strategy, and src/unifyweaver/targets/bash/ for the actual compiler code.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["compilation", "prolog", "bash", "workflow", "bridge"], "original_answer": "## From Prolog to Bash: The Complete Workflow\n\nThis bridges Book 1 (Prolog fundamentals) with Book 2 (Bash compilation).\n\n### Step 1: Define in Prolog (Book 1)\n\n```prolog\n% Facts - basic assertions\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules - derived relationships\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### Step 2: Compile with UnifyWeaver (Book 2)\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n### Step 3: What Gets Generated\n\n```bash\n# parent.sh - Facts become associative arrays\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh - Rules become BFS with memoization\nancestor_all() {\n    declare -A visited\n    # ... BFS traversal using parent_data\n}\n```\n\n### Step 4: Execute\n\n```bash\nsource output/parent.sh\nsource output/ancestor.sh\nancestor abraham jacob  # Finds path!\n```\n\n### Key Transformations\n\n| Prolog (Book 1) | Bash (Book 2) |\n|-----------------|---------------|\n| Facts | Associative arrays |\n| Rules | Functions |\n| Recursion | BFS loops |\n| Unification | Key matching |\n| Backtracking | Streaming output |", "answer_tailored": true}
{"pair_id": "prolog-to-bash-bridge_p1", "cluster_id": "prolog-to-bash-bridge", "question": "What is the complete workflow from Prolog to Bash?", "question_type": "medium", "answer": "The complete workflow from Prolog to Bash involves four main stages:\n\n**1. Write Prolog Logic**\n\nStart by defining your facts and rules in Prolog:\n\n```prolog\n% Facts represent raw data\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules define relationships\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n**2. Invoke the Compiler**\n\nUse UnifyWeaver's compiler driver to translate Prolog to Bash:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**3. Generated Bash Scripts**\n\nThe compiler produces Bash code where:\n- Facts become associative array declarations\n- Rules become functions with BFS traversal\n- Recursion is handled through loops with memoization\n\n```bash\n# parent.sh\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh\nancestor_all() {\n    declare -A visited\n    # BFS traversal logic using parent_data\n}\n```\n\n**4. Run the Scripts**\n\nExecute the generated Bash code:\n\n```bash\nsource output/parent.sh\nsource output/ancestor.sh\nancestor abraham jacob  # Returns the ancestral relationship\n```\n\n**Core Translation Mappings:**\n- Prolog facts \u2192 Bash associative arrays\n- Prolog rules \u2192 Bash functions\n- Recursive queries \u2192 BFS with memoization\n- Unification \u2192 Key pattern matching\n- Backtracking \u2192 Stream-based result output\n\nFor detailed compilation mechanics, see education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["compilation", "prolog", "bash", "workflow", "bridge"], "original_answer": "## From Prolog to Bash: The Complete Workflow\n\nThis bridges Book 1 (Prolog fundamentals) with Book 2 (Bash compilation).\n\n### Step 1: Define in Prolog (Book 1)\n\n```prolog\n% Facts - basic assertions\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules - derived relationships\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### Step 2: Compile with UnifyWeaver (Book 2)\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n### Step 3: What Gets Generated\n\n```bash\n# parent.sh - Facts become associative arrays\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh - Rules become BFS with memoization\nancestor_all() {\n    declare -A visited\n    # ... BFS traversal using parent_data\n}\n```\n\n### Step 4: Execute\n\n```bash\nsource output/parent.sh\nsource output/ancestor.sh\nancestor abraham jacob  # Finds path!\n```\n\n### Key Transformations\n\n| Prolog (Book 1) | Bash (Book 2) |\n|-----------------|---------------|\n| Facts | Associative arrays |\n| Rules | Functions |\n| Recursion | BFS loops |\n| Unification | Key matching |\n| Backtracking | Streaming output |", "answer_tailored": true}
{"pair_id": "prolog-to-bash-bridge_p2", "cluster_id": "prolog-to-bash-bridge", "question": "How do Book 1 concepts connect to Book 2?", "question_type": "medium", "answer": "Book 1 establishes Prolog fundamentals (facts, rules, queries, unification) that Book 2 transforms into executable Bash scripts through UnifyWeaver's compilation pipeline.\n\n### The Connection: Prolog Concepts \u2192 Bash Implementations\n\n**Book 1 teaches:**\n- Facts as basic assertions (`parent(abraham, isaac)`)\n- Rules with logical inference (`ancestor(X,Y) :- parent(X,Z), ancestor(Z,Y)`)\n- Queries and unification mechanisms\n- Recursive reasoning patterns\n\n**Book 2 shows how these compile:**\n- Facts \u2192 Bash associative arrays for fast lookup\n- Rules \u2192 Shell functions with BFS traversal\n- Recursion \u2192 Iterative loops with queues\n- Unification \u2192 Pattern matching on array keys\n- Backtracking \u2192 Streaming results via loops\n\n### Concrete Example\n\nStarting with Book 1's genealogy program:\n\n```prolog\nparent(abraham, isaac).\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nBook 2 compiles this to:\n\n```bash\ndeclare -A parent_data=([abraham:isaac]=1 [isaac:jacob]=1)\n\nancestor_all() {\n    # BFS implementation with memoization\n    # Replaces Prolog's recursive search\n}\n```\n\n### Why This Matters\n\nBook 1 gives you the logical foundation\u2014understanding how Prolog programs work. Book 2 reveals UnifyWeaver's transformation strategy\u2014how those logical constructs map to imperative shell code. Together, they show the complete journey from declarative specification to executable script.\n\nFor detailed compilation mechanics, see `education/book-02-bash-target/`.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["compilation", "prolog", "bash", "workflow", "bridge"], "original_answer": "## From Prolog to Bash: The Complete Workflow\n\nThis bridges Book 1 (Prolog fundamentals) with Book 2 (Bash compilation).\n\n### Step 1: Define in Prolog (Book 1)\n\n```prolog\n% Facts - basic assertions\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules - derived relationships\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### Step 2: Compile with UnifyWeaver (Book 2)\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n### Step 3: What Gets Generated\n\n```bash\n# parent.sh - Facts become associative arrays\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh - Rules become BFS with memoization\nancestor_all() {\n    declare -A visited\n    # ... BFS traversal using parent_data\n}\n```\n\n### Step 4: Execute\n\n```bash\nsource output/parent.sh\nsource output/ancestor.sh\nancestor abraham jacob  # Finds path!\n```\n\n### Key Transformations\n\n| Prolog (Book 1) | Bash (Book 2) |\n|-----------------|---------------|\n| Facts | Associative arrays |\n| Rules | Functions |\n| Recursion | BFS loops |\n| Unification | Key matching |\n| Backtracking | Streaming output |", "answer_tailored": true}
{"pair_id": "prolog-to-bash-bridge_p3", "cluster_id": "prolog-to-bash-bridge", "question": "What happens during UnifyWeaver compilation?", "question_type": "medium", "answer": "During UnifyWeaver compilation, Prolog code is transformed into executable scripts in your target language. Here's what happens at each stage:\n\n**Compilation Process:**\n\n1. **Input Analysis** - The compiler analyzes your Prolog predicates (facts and rules). For example, `parent(abraham, isaac)` facts and `ancestor(X, Y)` rules.\n\n2. **Target Code Generation** - Each Prolog construct maps to target-specific code:\n   - Facts \u2192 Data structures (associative arrays in Bash, dictionaries in Python)\n   - Rules \u2192 Functions with logic\n   - Recursion \u2192 Iterative algorithms (typically BFS with memoization)\n   - Unification \u2192 Pattern matching and key lookups\n   - Backtracking \u2192 Stream-based result generation\n\n3. **Output Files** - Generates separate scripts for each predicate, like `parent.sh` and `ancestor.sh`\n\n**Example Transformation:**\n\nWhen you compile `ancestor/2`:\n```prolog\n?- compile(ancestor/2, [output_dir('output')], Scripts).\n```\n\nProlog facts become data stores:\n```bash\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n```\n\nProlog rules become executable functions with breadth-first search traversal using the fact data.\n\n**Execution** - Generated scripts can be sourced and called directly: `ancestor abraham jacob`\n\nFor complete details on Bash target compilation, see education/book-02-bash-target/. Other target languages follow similar patterns with language-specific optimizations (covered in books 3-8).", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["compilation", "prolog", "bash", "workflow", "bridge"], "original_answer": "## From Prolog to Bash: The Complete Workflow\n\nThis bridges Book 1 (Prolog fundamentals) with Book 2 (Bash compilation).\n\n### Step 1: Define in Prolog (Book 1)\n\n```prolog\n% Facts - basic assertions\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Rules - derived relationships\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\n### Step 2: Compile with UnifyWeaver (Book 2)\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n### Step 3: What Gets Generated\n\n```bash\n# parent.sh - Facts become associative arrays\ndeclare -A parent_data=(\n    [abraham:isaac]=1\n    [isaac:jacob]=1\n)\n\n# ancestor.sh - Rules become BFS with memoization\nancestor_all() {\n    declare -A visited\n    # ... BFS traversal using parent_data\n}\n```\n\n### Step 4: Execute\n\n```bash\nsource output/parent.sh\nsource output/ancestor.sh\nancestor abraham jacob  # Finds path!\n```\n\n### Key Transformations\n\n| Prolog (Book 1) | Bash (Book 2) |\n|-----------------|---------------|\n| Facts | Associative arrays |\n| Rules | Functions |\n| Recursion | BFS loops |\n| Unification | Key matching |\n| Backtracking | Streaming output |", "answer_tailored": true}
