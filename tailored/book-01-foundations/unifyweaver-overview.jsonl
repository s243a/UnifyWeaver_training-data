{"pair_id": "unifyweaver-overview_p0", "cluster_id": "unifyweaver-overview", "question": "What is UnifyWeaver?", "question_type": "medium", "answer": "UnifyWeaver is a compiler that transforms Prolog specifications into native code for multiple target languages (Bash, Python, Go, Rust, C#, PowerShell, SQL). Rather than interpreting Prolog at runtime, it generates optimized target code from declarative logic definitions.\n\n## Core Concept\n\nWrite your logic once in Prolog, then compile it to any supported target:\n\n```prolog\n% Define facts\nparent(alice, bob).\nparent(bob, charlie).\n\n% Define rules\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompile to your target:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n```\n\nThe compiler produces optimized code with BFS traversal, memoization, and cycle detection for the chosen platform.\n\n## Why Use It\n\nUnifyWeaver solves several development challenges:\n- **Eliminate boilerplate** - Write logic once, deploy everywhere\n- **Ensure consistency** - Single Prolog source for all targets\n- **Clarify dependencies** - Prolog makes relationships explicit\n- **Simplify maintenance** - Update Prolog, regenerate targets automatically\n\nFor detailed examples and tutorials, see playbooks/ and education/book-01-foundations/.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["unifyweaver", "code-generation", "prolog", "declarative-programming"], "original_answer": "UnifyWeaver is a Prolog-based code generator that compiles declarative specifications into multiple target languages. It uses Prolog as a high-level language to define data relationships, rules, and queries, then compiles these into optimized code for your chosen target.\n\n## How It Works\n\nYou define predicates in Prolog:\n\n```prolog\n% Define facts\nparent(alice, bob).\nparent(bob, charlie).\n\n% Define rules\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nThen compile to your target language:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n```\n\nThis generates optimized Bash code with BFS traversal, memoization, and cycle detection.\n\n## The Problem It Solves\n\nUnifyWeaver addresses common complexity issues:\n- **Repetitive boilerplate** - Define logic once, generate for multiple targets\n- **Inconsistent data handling** - Single source of truth in Prolog\n- **Hidden dependencies** - Prolog makes relationships explicit\n- **Maintenance nightmares** - Change Prolog, regenerate all targets\n\nUnifyWeaver is NOT a Prolog interpreter - it's a compiler that translates Prolog specifications into native code for the target platform.", "answer_tailored": true}
{"pair_id": "unifyweaver-overview_p1", "cluster_id": "unifyweaver-overview", "question": "How does UnifyWeaver work?", "question_type": "medium", "answer": "UnifyWeaver works as a compiler that transforms Prolog specifications into native code for multiple target languages (Bash, Python, Go, Rust, C#, PowerShell, SQL). Rather than interpreting Prolog at runtime, it analyzes your declarative logic and generates optimized implementations.\n\n## The Compilation Process\n\nYou start by writing Prolog predicates that describe your data and logic:\n\n```prolog\n% Facts about relationships\nparent(alice, bob).\nparent(bob, charlie).\n\n% Recursive rule\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nThen invoke the compiler to generate target code:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n```\n\nThe compiler produces optimized native code that includes BFS traversal, memoization, and cycle detection automatically.\n\n## Core Benefits\n\nBy compiling declarative specifications, UnifyWeaver eliminates:\n- **Boilerplate duplication** - Write logic once, deploy everywhere\n- **Data inconsistencies** - Prolog serves as the single source of truth\n- **Implicit dependencies** - All relationships are explicitly declared\n- **Cross-platform maintenance** - Update Prolog and regenerate targets\n\nFor implementation details and examples, see education/book-01-foundations/ and the playbooks/ directory.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["unifyweaver", "code-generation", "prolog", "declarative-programming"], "original_answer": "UnifyWeaver is a Prolog-based code generator that compiles declarative specifications into multiple target languages. It uses Prolog as a high-level language to define data relationships, rules, and queries, then compiles these into optimized code for your chosen target.\n\n## How It Works\n\nYou define predicates in Prolog:\n\n```prolog\n% Define facts\nparent(alice, bob).\nparent(bob, charlie).\n\n% Define rules\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nThen compile to your target language:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n```\n\nThis generates optimized Bash code with BFS traversal, memoization, and cycle detection.\n\n## The Problem It Solves\n\nUnifyWeaver addresses common complexity issues:\n- **Repetitive boilerplate** - Define logic once, generate for multiple targets\n- **Inconsistent data handling** - Single source of truth in Prolog\n- **Hidden dependencies** - Prolog makes relationships explicit\n- **Maintenance nightmares** - Change Prolog, regenerate all targets\n\nUnifyWeaver is NOT a Prolog interpreter - it's a compiler that translates Prolog specifications into native code for the target platform.", "answer_tailored": true}
{"pair_id": "unifyweaver-overview_p2", "cluster_id": "unifyweaver-overview", "question": "What problem does UnifyWeaver solve?", "question_type": "medium", "answer": "UnifyWeaver solves the complexity and maintenance challenges of managing logic across multiple programming environments. Specifically, it addresses:\n\n- **Repetitive boilerplate across platforms** - Write your logic once in Prolog and generate implementations for Bash, Python, Go, Rust, C#, PowerShell, or SQL\n- **Inconsistent data handling** - Maintain a single source of truth in declarative Prolog rather than duplicating logic in multiple languages\n- **Hidden dependencies and implicit relationships** - Prolog's declarative nature makes data relationships and dependencies explicit\n- **Maintenance burden** - Update the Prolog specification and automatically regenerate all target implementations\n\nInstead of manually coding the same query logic in different languages, UnifyWeaver acts as a compiler that transforms Prolog declarations into optimized native code. For example, you can define ancestor relationships in Prolog:\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nThen compile to any target:\n\n```prolog\n?- compile(ancestor/2, [target(bash)], Scripts).\n```\n\nThe generated code includes optimizations like BFS traversal, memoization, and cycle detection\u2014without writing any target-language code yourself. See education/book-01-foundations/ for foundational concepts.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["unifyweaver", "code-generation", "prolog", "declarative-programming"], "original_answer": "UnifyWeaver is a Prolog-based code generator that compiles declarative specifications into multiple target languages. It uses Prolog as a high-level language to define data relationships, rules, and queries, then compiles these into optimized code for your chosen target.\n\n## How It Works\n\nYou define predicates in Prolog:\n\n```prolog\n% Define facts\nparent(alice, bob).\nparent(bob, charlie).\n\n% Define rules\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nThen compile to your target language:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n```\n\nThis generates optimized Bash code with BFS traversal, memoization, and cycle detection.\n\n## The Problem It Solves\n\nUnifyWeaver addresses common complexity issues:\n- **Repetitive boilerplate** - Define logic once, generate for multiple targets\n- **Inconsistent data handling** - Single source of truth in Prolog\n- **Hidden dependencies** - Prolog makes relationships explicit\n- **Maintenance nightmares** - Change Prolog, regenerate all targets\n\nUnifyWeaver is NOT a Prolog interpreter - it's a compiler that translates Prolog specifications into native code for the target platform.", "answer_tailored": true}
{"pair_id": "unifyweaver-overview_p3", "cluster_id": "unifyweaver-overview", "question": "Is UnifyWeaver a Prolog interpreter?", "question_type": "medium", "answer": "No, UnifyWeaver is not a Prolog interpreter\u2014it's a compiler. While it uses Prolog as its specification language, UnifyWeaver translates (compiles) Prolog predicates into native code for target platforms like Bash, Python, Go, Rust, C#, PowerShell, and SQL.\n\nThe key difference: an interpreter executes Prolog directly at runtime, while UnifyWeaver performs a compile-time transformation that generates optimized target-language code.\n\n## What UnifyWeaver Actually Does\n\nYou write Prolog specifications:\n\n```prolog\n% Define facts\nparent(alice, bob).\nparent(bob, charlie).\n\n% Define rules\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nThen compile them to native code:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n```\n\nThe result is standalone Bash (or Python, Go, etc.) code with built-in optimizations like BFS traversal, memoization, and cycle detection\u2014no Prolog runtime required.\n\n## Why This Matters\n\nAs a compiler rather than an interpreter, UnifyWeaver produces:\n- **Standalone executables** - No Prolog dependency at deployment\n- **Native performance** - Target-language speed, not interpreted overhead\n- **Multi-target portability** - Same logic, different platforms\n- **Production-ready code** - Optimized for real-world use\n\nFor more on the compilation process and architecture, see education/book-01-foundations/ and education/book-02-bash-target/.", "answer_variant": "default", "answer_source": "education/book-01-foundations/01_introduction.md", "topics": ["unifyweaver", "code-generation", "prolog", "declarative-programming"], "original_answer": "UnifyWeaver is a Prolog-based code generator that compiles declarative specifications into multiple target languages. It uses Prolog as a high-level language to define data relationships, rules, and queries, then compiles these into optimized code for your chosen target.\n\n## How It Works\n\nYou define predicates in Prolog:\n\n```prolog\n% Define facts\nparent(alice, bob).\nparent(bob, charlie).\n\n% Define rules\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nThen compile to your target language:\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n?- compile(ancestor/2, [target(bash)], Scripts).\n```\n\nThis generates optimized Bash code with BFS traversal, memoization, and cycle detection.\n\n## The Problem It Solves\n\nUnifyWeaver addresses common complexity issues:\n- **Repetitive boilerplate** - Define logic once, generate for multiple targets\n- **Inconsistent data handling** - Single source of truth in Prolog\n- **Hidden dependencies** - Prolog makes relationships explicit\n- **Maintenance nightmares** - Change Prolog, regenerate all targets\n\nUnifyWeaver is NOT a Prolog interpreter - it's a compiler that translates Prolog specifications into native code for the target platform.", "answer_tailored": true}
