{"pair_id": "recursion-patterns_p0", "cluster_id": "recursion-patterns", "question": "What recursion patterns does UnifyWeaver support?", "question_type": "medium", "answer": "UnifyWeaver supports five primary recursion patterns, all implemented across Bash, Python, and C# targets:\n\n**Tail Recursion**: The recursive call appears in tail position (final operation). Optimized to iterative loops to prevent stack growth.\n\n**Linear Recursion**: Contains a single recursive call per clause. Example: computing Fibonacci numbers where each call makes one recursive invocation.\n\n**Tree Recursion**: Multiple recursive calls that decompose structured data. The key characteristic is passing subtree structures (not computed scalars) to recursive calls, such as `tree_sum([Value, Left, Right], Sum)` where `Left` and `Right` are tree structures.\n\n**Transitive Closure**: Reachability and ancestor queries like `ancestor(X, Y) :- parent(X, Y). ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).` Compiled using BFS with memoization to avoid redundant computation.\n\n**Mutual Recursion**: Cyclic dependencies where predicate A calls B and B calls A.\n\nThe distinction between tree and linear recursion depends on **what arguments flow** through recursive calls: tree recursion passes structural components (subtrees, sublists), while linear recursion passes computed scalar values (`N1 is N - 1`).\n\nFor implementation details and compilation strategies, see `docs/RECURSION_PATTERN_THEORY.md`.", "answer_variant": "default", "answer_source": "docs/RECURSION_PATTERN_THEORY.md", "topics": ["recursion", "tail-recursion", "linear-recursion", "tree-recursion", "transitive-closure", "mutual-recursion"], "original_answer": "## Supported Recursion Patterns\n\n| Pattern | Description | Bash | Python | C# |\n|---------|-------------|:----:|:------:|:--:|\n| Tail Recursion | Last call is recursive | \u2705 | \u2705 | \u2705 |\n| Linear Recursion | Single recursive call | \u2705 | \u2705 | \u2705 |\n| Tree Recursion | Multiple recursive calls on structure | \u2705 | \u2705 | \u2705 |\n| Transitive Closure | Reachability queries | \u2705 | \u2705 | \u2705 |\n| Mutual Recursion | A calls B, B calls A | \u2705 | \u2705 | \u2705 |\n\n## Tree vs Linear Recursion\n\nThe key difference is **what gets passed** to recursive calls:\n\n```prolog\n% TREE RECURSION - structural decomposition\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n\n% LINEAR RECURSION - computed scalar values\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is computed\n    N2 is N - 2,           % N2 is computed\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n## Transitive Closure Compilation\n\n```prolog\n% Prolog (what you write)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompiles to BFS with memoization:\n\n```bash\n# Generated Bash (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand frontier...\n    done\n}\n```\n\n## Tail Recursion Optimization\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nCompiles to iterative loop (no stack growth).", "answer_tailored": true}
{"pair_id": "recursion-patterns_p1", "cluster_id": "recursion-patterns", "question": "What is the difference between tree and linear recursion?", "question_type": "medium", "answer": "The main distinction is **what gets passed to recursive calls**:\n\n**Linear Recursion** makes a single recursive call with **computed scalar values**:\n```prolog\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % Computed integers\n    N2 is N - 2,\n    fib(N1, F1),           % Single path with computed values\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n**Tree Recursion** makes multiple recursive calls on **structural decomposition** of data:\n```prolog\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n```\n\nIn linear recursion, you're working with computed values (like `N-1`, `N-2`). In tree recursion, you're decomposing a data structure (like a tree) into its components (left/right subtrees) and recursing on those structural pieces.\n\nBoth patterns are fully supported across all UnifyWeaver targets (Bash, Python, C#, Go, Rust). See `docs/RECURSION_PATTERN_THEORY.md` for complete details on recursion compilation strategies.", "answer_variant": "default", "answer_source": "docs/RECURSION_PATTERN_THEORY.md", "topics": ["recursion", "tail-recursion", "linear-recursion", "tree-recursion", "transitive-closure", "mutual-recursion"], "original_answer": "## Supported Recursion Patterns\n\n| Pattern | Description | Bash | Python | C# |\n|---------|-------------|:----:|:------:|:--:|\n| Tail Recursion | Last call is recursive | \u2705 | \u2705 | \u2705 |\n| Linear Recursion | Single recursive call | \u2705 | \u2705 | \u2705 |\n| Tree Recursion | Multiple recursive calls on structure | \u2705 | \u2705 | \u2705 |\n| Transitive Closure | Reachability queries | \u2705 | \u2705 | \u2705 |\n| Mutual Recursion | A calls B, B calls A | \u2705 | \u2705 | \u2705 |\n\n## Tree vs Linear Recursion\n\nThe key difference is **what gets passed** to recursive calls:\n\n```prolog\n% TREE RECURSION - structural decomposition\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n\n% LINEAR RECURSION - computed scalar values\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is computed\n    N2 is N - 2,           % N2 is computed\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n## Transitive Closure Compilation\n\n```prolog\n% Prolog (what you write)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompiles to BFS with memoization:\n\n```bash\n# Generated Bash (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand frontier...\n    done\n}\n```\n\n## Tail Recursion Optimization\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nCompiles to iterative loop (no stack growth).", "answer_tailored": true}
{"pair_id": "recursion-patterns_p2", "cluster_id": "recursion-patterns", "question": "How does UnifyWeaver compile transitive closures?", "question_type": "medium", "answer": "UnifyWeaver compiles transitive closure patterns (like reachability queries) into iterative breadth-first search with memoization. This avoids exponential re-computation while maintaining Prolog's logical semantics.\n\nFor example, this Prolog ancestor relation:\n\n```prolog\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nGets compiled to target code that uses a work queue and visited set:\n\n```bash\n# Bash target (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand to next generation...\n    done\n}\n```\n\nThe pattern is recognized during compilation and transformed from recursive clauses into an iterative algorithm that:\n- Starts with direct relationships (base case)\n- Expands the frontier one step at a time (BFS)\n- Tracks visited nodes to prevent redundant work\n- Terminates when no new nodes are discovered\n\nThis compilation strategy is supported across all UnifyWeaver targets (Bash, Python, C#, Go, Rust). See docs/RECURSION_PATTERN_THEORY.md for the complete taxonomy of supported recursion patterns.", "answer_variant": "default", "answer_source": "docs/RECURSION_PATTERN_THEORY.md", "topics": ["recursion", "tail-recursion", "linear-recursion", "tree-recursion", "transitive-closure", "mutual-recursion"], "original_answer": "## Supported Recursion Patterns\n\n| Pattern | Description | Bash | Python | C# |\n|---------|-------------|:----:|:------:|:--:|\n| Tail Recursion | Last call is recursive | \u2705 | \u2705 | \u2705 |\n| Linear Recursion | Single recursive call | \u2705 | \u2705 | \u2705 |\n| Tree Recursion | Multiple recursive calls on structure | \u2705 | \u2705 | \u2705 |\n| Transitive Closure | Reachability queries | \u2705 | \u2705 | \u2705 |\n| Mutual Recursion | A calls B, B calls A | \u2705 | \u2705 | \u2705 |\n\n## Tree vs Linear Recursion\n\nThe key difference is **what gets passed** to recursive calls:\n\n```prolog\n% TREE RECURSION - structural decomposition\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n\n% LINEAR RECURSION - computed scalar values\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is computed\n    N2 is N - 2,           % N2 is computed\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n## Transitive Closure Compilation\n\n```prolog\n% Prolog (what you write)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompiles to BFS with memoization:\n\n```bash\n# Generated Bash (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand frontier...\n    done\n}\n```\n\n## Tail Recursion Optimization\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nCompiles to iterative loop (no stack growth).", "answer_tailored": true}
{"pair_id": "recursion-patterns_p3", "cluster_id": "recursion-patterns", "question": "What is tail recursion optimization?", "question_type": "medium", "answer": "Tail recursion optimization occurs when the recursive call is in tail position (the last operation in a clause). UnifyWeaver compiles tail-recursive predicates to iterative loops, avoiding stack growth:\n\n```prolog\n% Tail recursive - recursive call is the final operation\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION - nothing happens after this call\n```\n\nThis compiles to an iterative loop instead of recursive function calls, preventing stack overflow on deep recursion. The optimization is supported across Bash, Python, and C# targets.\n\nFor contrast, non-tail recursion requires keeping stack frames:\n\n```prolog\n% NOT tail recursive - computation happens after recursive call\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0, N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.  % Multiplication happens AFTER the recursive call returns\n```\n\nSee docs/RECURSION_PATTERN_THEORY.md for detailed recursion pattern comparisons and compilation strategies.", "answer_variant": "default", "answer_source": "docs/RECURSION_PATTERN_THEORY.md", "topics": ["recursion", "tail-recursion", "linear-recursion", "tree-recursion", "transitive-closure", "mutual-recursion"], "original_answer": "## Supported Recursion Patterns\n\n| Pattern | Description | Bash | Python | C# |\n|---------|-------------|:----:|:------:|:--:|\n| Tail Recursion | Last call is recursive | \u2705 | \u2705 | \u2705 |\n| Linear Recursion | Single recursive call | \u2705 | \u2705 | \u2705 |\n| Tree Recursion | Multiple recursive calls on structure | \u2705 | \u2705 | \u2705 |\n| Transitive Closure | Reachability queries | \u2705 | \u2705 | \u2705 |\n| Mutual Recursion | A calls B, B calls A | \u2705 | \u2705 | \u2705 |\n\n## Tree vs Linear Recursion\n\nThe key difference is **what gets passed** to recursive calls:\n\n```prolog\n% TREE RECURSION - structural decomposition\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n\n% LINEAR RECURSION - computed scalar values\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is computed\n    N2 is N - 2,           % N2 is computed\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n## Transitive Closure Compilation\n\n```prolog\n% Prolog (what you write)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompiles to BFS with memoization:\n\n```bash\n# Generated Bash (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand frontier...\n    done\n}\n```\n\n## Tail Recursion Optimization\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nCompiles to iterative loop (no stack growth).", "answer_tailored": true}
