{"pair_id": "prolog-facts-rules_p0", "cluster_id": "prolog-facts-rules", "question": "How do I define facts and rules in Prolog?", "question_type": "medium", "answer": "To define facts and rules in Prolog, you use two fundamental constructs:\n\n**Defining Facts**\n\nFacts are simple assertions that end with a period. They declare something as true without conditions:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\nEach fact states a relationship or property that holds unconditionally.\n\n**Defining Rules**\n\nRules use the `:-` operator (read as \"if\") to define conditional knowledge:\n\n```prolog\n% Syntax: head :- body.\n% Meaning: \"head is true IF body is true\"\n\n% Direct dependency (base case)\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Indirect dependency (recursive case)\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThe head (left side) becomes true when the body (right side) is satisfied. Multiple conditions in the body are separated by commas, representing logical AND.\n\nThis example shows a transitive closure pattern - UnifyWeaver can optimize these recursive structures when compiling to target languages.\n\n**Testing Your Definitions**\n\nQuery your facts and rules at the `?-` prompt:\n\n```prolog\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n```\n\nFor more on Prolog fundamentals, see education/book-01-foundations/02_prolog_fundamentals.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
{"pair_id": "prolog-facts-rules_p1", "cluster_id": "prolog-facts-rules", "question": "What is a Prolog fact?", "question_type": "medium", "answer": "A **Prolog fact** is a basic assertion that declares something to be true. Facts are the simplest form of Prolog statement and always end with a period.\n\nFor example, in a build dependency system:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\nEach line is a fact stating a relationship between files. The first fact asserts that `main.o` depends on `main.c`. These facts form the knowledge base that Prolog uses to answer queries.\n\nFacts differ from **rules** (which use `:-` to define conditional logic) and **queries** (which ask questions using `?-`). For more on how facts work with rules and queries in UnifyWeaver, see education/book-01-foundations/02_prolog_fundamentals.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
{"pair_id": "prolog-facts-rules_p2", "cluster_id": "prolog-facts-rules", "question": "How do rules work in Prolog?", "question_type": "medium", "answer": "In Prolog, a **rule** defines logical relationships using the `:-` operator (read as \"if\"). The syntax is:\n\n```prolog\nhead :- body.\n% \"head is true IF body is true\"\n```\n\nRules let you derive new knowledge from existing facts and other rules. Here's a practical example:\n\n```prolog\n% Base case: a rule that directly uses facts\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: a rule that calls itself\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis creates a **transitive closure** - finding both direct and indirect dependencies. The first rule handles direct dependencies, while the second rule recursively finds dependencies through intermediate files.\n\nWhen Prolog evaluates a rule, it tries to prove the body is true. If successful, the head becomes true. For example, with these facts:\n\n```prolog\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.c', 'utils.c').\n```\n\nQuerying `?- transitive_dependency('main.o', 'utils.c').` will succeed because:\n1. The recursive rule finds `file_dependency('main.o', 'main.c')` \n2. Then recursively proves `transitive_dependency('main.c', 'utils.c')`\n3. Which matches the base case via `file_dependency('main.c', 'utils.c')`\n\nUnifyWeaver specifically optimizes transitive closure patterns like this. For more details on Prolog fundamentals, see education/book-01-foundations/02_prolog_fundamentals.md.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
{"pair_id": "prolog-facts-rules_p3", "cluster_id": "prolog-facts-rules", "question": "How do I write a transitive closure in Prolog?", "question_type": "medium", "answer": "To write a transitive closure in Prolog, define both the base case and recursive case using rules:\n\n```prolog\n% Base case: direct relationship\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect relationship through intermediate node\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis pattern expresses \"F transitively depends on D if F directly depends on some intermediate I, and I transitively depends on D.\"\n\n**Example with facts:**\n\n```prolog\n% Direct dependencies\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\n```\n\n**Querying the transitive closure:**\n\n```prolog\n% Find all transitive dependencies of main.o\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n\n% Check if specific transitive dependency exists\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n```\n\nUnifyWeaver recognizes and optimizes this transitive closure pattern during compilation. See education/book-01-foundations/02_prolog_fundamentals.md for more details on facts, rules, and queries.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
{"pair_id": "prolog-facts-rules_p4", "cluster_id": "prolog-facts-rules", "question": "How do I query Prolog?", "question_type": "medium", "answer": "To query Prolog, use the `?-` prompt to ask questions:\n\n```prolog\n% Query with a variable to find matches\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Query with specific values to test if something is true\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all matching results\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` to get the next solution, or Enter to stop.\n\nVariables (like `X`) act as wildcards that Prolog fills in with matching values. You can query facts directly or use rules that derive new information. For example, `transitive_dependency/2` is a rule that finds both direct and indirect dependencies through recursive reasoning.\n\nSee education/book-01-foundations/02_prolog_fundamentals.md for more on facts, rules, and how queries work together.", "answer_variant": "default", "answer_source": "education/book-01-foundations/02_prolog_fundamentals.md", "topics": ["prolog", "facts", "rules", "queries", "recursion", "transitive-closure"], "original_answer": "## Facts\n\nA **fact** is a basic assertion that is true. Facts end with a period:\n\n```prolog\n% file_dependency(dependent, dependency)\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\nfile_dependency('main.c', 'utils.c').\nfile_dependency('utils.o', 'utils.c').\nfile_dependency('utils.o', 'utils.h').\n```\n\n## Rules\n\nA **rule** defines new knowledge using `:-` (read as \"if\"):\n\n```prolog\n% head :- body.\n% \"head is true IF body is true\"\n\n% Base case: direct dependency\ntransitive_dependency(F, D) :- file_dependency(F, D).\n\n% Recursive case: indirect dependency\ntransitive_dependency(F, D) :-\n    file_dependency(F, I),\n    transitive_dependency(I, D).\n```\n\nThis is a **transitive closure** - UnifyWeaver optimizes this pattern.\n\n## Queries\n\nAsk questions at the `?-` prompt:\n\n```prolog\n% What does main.o depend on directly?\n?- file_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h'.\n\n% Does main.o transitively depend on utils.c?\n?- transitive_dependency('main.o', 'utils.c').\ntrue.\n\n% Find all transitive dependencies\n?- transitive_dependency('main.o', X).\nX = 'main.c' ;\nX = 'utils.h' ;\nX = 'utils.c'.\n```\n\nPress `;` for more solutions, Enter to stop.", "answer_tailored": true}
