{"pair_id": "prolog-firewall-001_p0", "cluster_id": "prolog-firewall-001", "question": "How does the firewall integrate with the Prolog target?", "question_type": "medium", "answer": "The Prolog target firewall integration provides multi-layered control over code generation through policy directives:\n\n**Dialect Control:**\n```prolog\n:- allow(prolog_target(swi)).\n:- disallow(prolog_target(gnu)).\n```\nThese rules restrict which Prolog implementations can be targeted.\n\n**Compilation Restrictions:**\n```prolog\n:- disallow(compile(native)).\n```\nPrevents specific compilation modes from being used.\n\n**Module Import Filtering:**\n```prolog\n:- allow(import_module(library(lists))).\n:- disallow(import_module(library(http/_))).\n```\nControls which libraries can be imported during code generation.\n\n**Operational Modes:**\n- `guidance` - Issues warnings without blocking\n- `enforce` - Actively prevents policy violations\n- `audit` - Records all actions for review\n\n**Configuration (.firewall file):**\n```prolog\n:- firewall_mode(enforce).\n:- allow(prolog_target(swi)).\n:- disallow(network_access).\n:- require(validation(strict)).\n```\n\nThis firewall architecture ensures the Prolog target respects security boundaries during compilation. For more details on firewall design, see education/book-13-security-firewall/.", "answer_variant": "default", "answer_source": "book-11-prolog-target/07_firewall_integration.md", "topics": [], "original_answer": "The firewall controls code generation at multiple points:\n\n**1. Dialect Selection:**\n```prolog\n:- allow(prolog_target(swi)).\n:- disallow(prolog_target(gnu)).\n```\n\n**2. Compilation Control:**\n```prolog\n:- disallow(compile(native)).\n```\n\n**3. Module Imports:**\n```prolog\n:- allow(import_module(library(lists))).\n:- disallow(import_module(library(http/_))).\n```\n\n**Firewall modes:**\n- `guidance` - Warn but allow\n- `enforce` - Block violations\n- `audit` - Log everything\n\n**Policy file example (.firewall):**\n```prolog\n:- firewall_mode(enforce).\n:- allow(prolog_target(swi)).\n:- disallow(network_access).\n:- require(validation(strict)).\n```", "answer_tailored": true}
{"pair_id": "prolog-fallback-001_p0", "cluster_id": "prolog-fallback-001", "question": "How does the Prolog target handle compilation failures?", "question_type": "medium", "answer": "When compilation fails, the Prolog target uses `compile_script_safe/3` to handle errors gracefully. By default, it catches compilation failures, logs a warning, and falls back to using the interpreted script:\n\n```prolog\ncompile_script_safe(Dialect, ScriptPath, Options) :-\n    catch(\n        compile_script(Dialect, ScriptPath),\n        error(compilation_failed(FailedDialect, ExitCode), _),\n        (   option(fail_on_compile_error(true), Options)\n        ->  throw(...)  % Strict mode: re-throw\n        ;   % Default: continue with interpreted\n            format('[PrologTarget] WARNING: ~w compilation failed~n', [FailedDialect]),\n            format('[PrologTarget] Continuing with interpreted script~n')\n        )\n    ).\n```\n\nThree failure handling modes are available:\n1. **Silent fallback** (default): Logs a warning and proceeds with the interpreted version\n2. **Strict mode**: Set `fail_on_compile_error(true)` to propagate the error instead\n3. **Multi-dialect fallback** (v0.2): Attempts alternative dialects based on preference order\n\nThis ensures your script remains functional even when native compilation isn't available. For implementation details, see education/book-11-prolog-target/08_fallback_mechanisms.md.", "answer_variant": "default", "answer_source": "book-11-prolog-target/08_fallback_mechanisms.md", "topics": [], "original_answer": "The `compile_script_safe/3` predicate provides graceful fallback:\n\n```prolog\ncompile_script_safe(Dialect, ScriptPath, Options) :-\n    catch(\n        compile_script(Dialect, ScriptPath),\n        error(compilation_failed(FailedDialect, ExitCode), _),\n        (   option(fail_on_compile_error(true), Options)\n        ->  throw(...)  % Strict mode: re-throw\n        ;   % Default: continue with interpreted\n            format('[PrologTarget] WARNING: ~w compilation failed~n', [FailedDialect]),\n            format('[PrologTarget] Continuing with interpreted script~n')\n        )\n    ).\n```\n\n**Fallback strategies:**\n1. **Silent fallback** (default): Log warning, use interpreted script\n2. **Strict mode**: `fail_on_compile_error(true)` - throw on failure\n3. **Multi-dialect** (v0.2): Try alternatives in preference order\n\nThe script remains usable interpreted even if compilation fails.", "answer_tailored": true}
{"pair_id": "prolog-fallback-001_p0", "cluster_id": "prolog-fallback-001", "question": "What fallback strategies does the Prolog target support?", "question_type": "medium", "answer": "The Prolog target implements several fallback strategies to ensure robust execution:\n\n**Version 0.1 (Current):**\n- **Compilation Fallback**: When `gplc` compilation fails, the system automatically falls back to running an interpreted script instead\n- **Firewall Fallback**: If a Prolog dialect is blocked by security rules, the system attempts execution using allowed alternative dialects\n\n**Version 0.2 (Planned):**\n- **Multi-Dialect Chains**: Supports cascading fallback sequences like `[dialects([gnu, swi]), compile(true), fallback(auto)]`, which tries GNU compiled \u2192 GNU interpreted \u2192 SWI interpreted in order\n- **Capability-Based Fallback**: Uses `validate_for_dialect/3` to detect predicate compatibility issues and automatically switches to a compatible dialect when problems are found\n- **Feature Degradation**: With `[fallback(degrade)]`, the system removes unsupported features rather than failing completely\n- **Automatic Dialect Selection**: Setting `[dialect(auto)]` triggers analysis of the Prolog code to automatically choose the most appropriate dialect\n\nFor implementation details and examples, see education/book-11-prolog-target/08_fallback_mechanisms.md.", "answer_variant": "default", "answer_source": "book-11-prolog-target/08_fallback_mechanisms.md", "topics": [], "original_answer": "**Current (v0.1):**\n\n1. **Compilation Fallback**: If `gplc` fails, continue with interpreted script\n2. **Firewall Fallback**: If dialect blocked, try allowed alternatives\n\n**Planned (v0.2):**\n\n1. **Multi-Dialect Chains:**\n```prolog\n[dialects([gnu, swi]), compile(true), fallback(auto)]\n% Try: GNU compiled \u2192 GNU interpreted \u2192 SWI interpreted\n```\n\n2. **Capability-Based Fallback:**\n```prolog\n?- validate_for_dialect(gnu, [my_pred/2], Issues).\n% If Issues, automatically switch to compatible dialect\n```\n\n3. **Feature Degradation:**\n```prolog\n[fallback(degrade)]  % Remove unsupported features, continue\n```\n\n4. **Automatic Dialect Selection:**\n```prolog\n[dialect(auto)]  % Analyze code, pick best dialect\n```", "answer_tailored": true}
