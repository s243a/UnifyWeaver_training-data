{"pair_id": "b6-c7-recursive-compilation_p0", "cluster_id": "b6-c7-recursive-compilation", "question": "How do I compile recursive predicates to Go?", "question_type": "medium", "answer": "To compile recursive predicates to Go, use UnifyWeaver's recursive compiler module:\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\nThis generates Go code using breadth-first search for transitive closure:\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\nThe compiler maps Prolog recursion patterns to idiomatic Go constructs: adjacency lists as `map[string][]string`, BFS queues as `[]string` slices, and visited tracking with `map[string]bool`. For more examples and optimization strategies, see education/book-06-go-target/07_recursive_queries.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["recursive-queries", "transitive-closure", "bfs"], "original_answer": "## Recursive Queries\n\n### Compiling Transitive Closure\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### Generated Go (BFS)\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\n### Go Constructs Used\n\n| Feature | Go Construct |\n|---------|-------------|\n| Adjacency List | `map[string][]string` |\n| BFS Queue | `[]string` slice |\n| Visited Set | `map[string]bool` |", "answer_tailored": true}
{"pair_id": "b6-c7-recursive-compilation_p1", "cluster_id": "b6-c7-recursive-compilation", "question": "What is compile_recursive/3?", "question_type": "medium", "answer": "`compile_recursive/3` is a Prolog predicate that generates code for recursive queries, such as transitive closures. It takes three arguments: the relation to compile (e.g., `ancestor/2`), compilation options (e.g., `[target(go)]`), and returns the generated code.\n\nFor example, compiling an ancestor relation:\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\nThis generates Go code implementing breadth-first search (BFS) traversal:\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\nThe compiler maps Prolog recursion patterns to efficient target-language constructs: adjacency lists (`map[string][]string`), BFS queues (`[]string` slices), and visited sets (`map[string]bool`). See education/book-06-go-target/07_recursive_queries.md for complete details on recursive query compilation.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["recursive-queries", "transitive-closure", "bfs"], "original_answer": "## Recursive Queries\n\n### Compiling Transitive Closure\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### Generated Go (BFS)\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\n### Go Constructs Used\n\n| Feature | Go Construct |\n|---------|-------------|\n| Adjacency List | `map[string][]string` |\n| BFS Queue | `[]string` slice |\n| Visited Set | `map[string]bool` |", "answer_tailored": true}
{"pair_id": "b6-c7-recursive-compilation_p2", "cluster_id": "b6-c7-recursive-compilation", "question": "How does BFS-based transitive closure work?", "question_type": "medium", "answer": "BFS-based transitive closure in UnifyWeaver uses a breadth-first search algorithm to find all reachable nodes from a starting point. The Go implementation maintains a queue of nodes to visit and a visited set to avoid cycles.\n\nHere's how it works:\n\n1. **Initialize**: Start with a queue containing the initial node and an empty visited set\n2. **Process Queue**: While the queue has elements:\n   - Dequeue the current node\n   - For each neighbor in the base relation:\n     - If not already visited, mark as visited, add to queue, and include in results\n3. **Return**: All reachable nodes collected during traversal\n\n**Example Go Implementation**:\n\n```go\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\n**Key Data Structures**:\n- `map[string][]string` - Adjacency list storing base relations\n- `[]string` slice - FIFO queue for BFS traversal\n- `map[string]bool` - Visited tracking to prevent infinite loops\n\nYou can generate this code from Prolog using `compile_recursive(ancestor/2, [target(go)], Code)`. See education/book-06-go-target/07_recursive_queries.md for complete details.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["recursive-queries", "transitive-closure", "bfs"], "original_answer": "## Recursive Queries\n\n### Compiling Transitive Closure\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### Generated Go (BFS)\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\n### Go Constructs Used\n\n| Feature | Go Construct |\n|---------|-------------|\n| Adjacency List | `map[string][]string` |\n| BFS Queue | `[]string` slice |\n| Visited Set | `map[string]bool` |", "answer_tailored": true}
{"pair_id": "b6-c7-recursion-patterns_p0", "cluster_id": "b6-c7-recursion-patterns", "question": "How is tail recursion compiled to Go?", "question_type": "medium", "answer": "Tail recursion in UnifyWeaver is compiled to iterative Go code using `for` loops, achieving O(1) space complexity. For example, when compiling a tail-recursive predicate like `sum_list/3`:\n\n```prolog\n?- go_target:compile_tail_recursion_go(sum_list/3, [], Code).\n```\n\nThe compiler generates an iterative loop instead of recursive function calls:\n\n```go\nfunc sum_list(items []int, acc int) int {\n    for _, item := range items {\n        acc += item\n    }\n    return acc\n}\n```\n\nThis transformation eliminates stack overhead by converting the tail-recursive pattern into iteration. The accumulator pattern in Prolog maps directly to a loop variable in Go, allowing the function to process arbitrarily large inputs without stack growth.\n\nFor non-tail recursive patterns, UnifyWeaver uses different strategies: linear recursion employs memoization with `map[int]int`, and mutual recursion uses shared memo tables. See education/book-06-go-target/07_recursive_queries.md for complete recursion pattern details.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["tail-recursion", "linear-recursion", "mutual-recursion", "memoization"], "original_answer": "## Recursion Patterns in Go\n\n### Tail Recursion (O(1) space)\n\n```prolog\n?- go_target:compile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n```go\nfunc sum_list(items []int, acc int) int {\n    for _, item := range items {\n        acc += item\n    }\n    return acc\n}\n```\n\n### Linear Recursion (Memoization)\n\n```prolog\n?- go_target:compile_linear_recursion_go(triangular/2, [], Code).\n```\n\n```go\nvar triangularMemo = make(map[int]int)\n\nfunc triangular(n int) int {\n    if result, ok := triangularMemo[n]; ok {\n        return result\n    }\n    result := triangular(n-1) + n\n    triangularMemo[n] = result\n    return result\n}\n```\n\n### Mutual Recursion (Shared Memo)\n\n```prolog\n?- go_target:compile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nGenerates shared `map[string]bool` for both predicates.", "answer_tailored": true}
{"pair_id": "b6-c7-recursion-patterns_p1", "cluster_id": "b6-c7-recursion-patterns", "question": "How does memoization work in Go target?", "question_type": "medium", "answer": "In Go target compilation, memoization caches recursive function results using Go maps. When compiling linear recursive predicates, UnifyWeaver generates a dedicated memo map for result storage.\n\nFor example, compiling a recursive predicate like `triangular/2`:\n\n```prolog\n?- go_target:compile_linear_recursion_go(triangular/2, [], Code).\n```\n\nProduces Go code with a package-level cache:\n\n```go\nvar triangularMemo = make(map[int]int)\n\nfunc triangular(n int) int {\n    if result, ok := triangularMemo[n]; ok {\n        return result\n    }\n    result := triangular(n-1) + n\n    triangularMemo[n] = result\n    return result\n}\n```\n\nThe function first checks if the result exists in the memo map. On cache miss, it computes the value recursively, stores it in the memo, and returns it. This transforms O(n) repeated computations into O(1) lookups.\n\nFor mutual recursion scenarios (like `is_even/1` and `is_odd/1`), the compiler generates a shared `map[string]bool` that both predicates access, ensuring consistent memoization across the mutually recursive call chain.\n\nSee education/book-06-go-target/07_recursive_queries.md for complete recursion pattern examples, including tail recursion optimization that avoids stack overhead entirely.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["tail-recursion", "linear-recursion", "mutual-recursion", "memoization"], "original_answer": "## Recursion Patterns in Go\n\n### Tail Recursion (O(1) space)\n\n```prolog\n?- go_target:compile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n```go\nfunc sum_list(items []int, acc int) int {\n    for _, item := range items {\n        acc += item\n    }\n    return acc\n}\n```\n\n### Linear Recursion (Memoization)\n\n```prolog\n?- go_target:compile_linear_recursion_go(triangular/2, [], Code).\n```\n\n```go\nvar triangularMemo = make(map[int]int)\n\nfunc triangular(n int) int {\n    if result, ok := triangularMemo[n]; ok {\n        return result\n    }\n    result := triangular(n-1) + n\n    triangularMemo[n] = result\n    return result\n}\n```\n\n### Mutual Recursion (Shared Memo)\n\n```prolog\n?- go_target:compile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nGenerates shared `map[string]bool` for both predicates.", "answer_tailored": true}
{"pair_id": "b6-c7-recursion-patterns_p2", "cluster_id": "b6-c7-recursion-patterns", "question": "How are mutually recursive predicates compiled?", "question_type": "medium", "answer": "Mutually recursive predicates in Go are compiled with a shared memoization structure. When predicates call each other recursively (like `is_even/1` and `is_odd/1`), the compiler generates a single `map[string]bool` that both functions use for caching results. This prevents redundant computation across the recursive calls between predicates.\n\nTo compile mutually recursive predicates:\n\n```prolog\n?- go_target:compile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nThe generated Go code creates one memo map shared between both functions, rather than separate memoization for each predicate. This approach is more efficient than independent memoization since the predicates depend on each other's results.\n\nFor comparison, linear recursion (single predicate) uses `map[int]int` for individual memoization, while tail recursion optimizes to iterative loops without memoization. See education/book-06-go-target/07_recursive_queries.md for details on all recursion compilation patterns.", "answer_variant": "default", "answer_source": "education/book-06-go-target/07_recursive_queries.md", "topics": ["tail-recursion", "linear-recursion", "mutual-recursion", "memoization"], "original_answer": "## Recursion Patterns in Go\n\n### Tail Recursion (O(1) space)\n\n```prolog\n?- go_target:compile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n```go\nfunc sum_list(items []int, acc int) int {\n    for _, item := range items {\n        acc += item\n    }\n    return acc\n}\n```\n\n### Linear Recursion (Memoization)\n\n```prolog\n?- go_target:compile_linear_recursion_go(triangular/2, [], Code).\n```\n\n```go\nvar triangularMemo = make(map[int]int)\n\nfunc triangular(n int) int {\n    if result, ok := triangularMemo[n]; ok {\n        return result\n    }\n    result := triangular(n-1) + n\n    triangularMemo[n] = result\n    return result\n}\n```\n\n### Mutual Recursion (Shared Memo)\n\n```prolog\n?- go_target:compile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nGenerates shared `map[string]bool` for both predicates.", "answer_tailored": true}
