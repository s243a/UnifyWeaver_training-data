{"pair_id": "b6-c1-go-overview_p0", "cluster_id": "b6-c1-go-overview", "question": "Why compile Prolog to Go?", "question_type": "medium", "answer": "Compiling Prolog to Go provides several compelling advantages for production deployments:\n\n**No Runtime Dependencies**: Go compilation produces a single, self-contained binary with no external requirements - just copy and run the executable.\n\n**True Cross-Platform Support**: Unlike Bash which requires Unix-like environments, Go runs natively on Linux, Windows, and macOS. You can even cross-compile from one platform to another:\n\n```bash\n# Build Windows executable from Linux\nGOOS=windows GOARCH=amd64 go build -o tool.exe tool.go\n```\n\n**Strong Performance**: Go excels at string processing and I/O operations, making it ideal for high-performance ETL pipelines and data transformation tasks.\n\n**Simplified Deployment**: Distribution is straightforward - just deliver the compiled executable with zero installation steps or dependency management.\n\nThis contrasts with the Bash target, which requires Bash 4.0+ and system tools, limiting it to Unix-like environments. Go sacrifices some of Bash's shell scripting convenience for superior portability and performance.\n\nFor implementation details, see education/book-06-go-target/.", "answer_variant": "default", "answer_source": "education/book-06-go-target/01_introduction.md", "topics": ["go-target", "native-binaries", "cross-platform"], "original_answer": "## Go Target Overview\n\nThe Go target compiles Prolog logic into standalone Go programs.\n\n### Key Benefits\n\n| Benefit | Description |\n|---------|-------------|\n| Single Binary | No runtime dependencies |\n| Cross-Platform | Linux, Windows, macOS from one source |\n| Performance | Excellent for string/I/O processing |\n| Deployment | Just copy the executable |\n\n### Cross-Compilation\n\n```bash\n# Build for Windows on Linux\nGOOS=windows GOARCH=amd64 go build -o tool.exe tool.go\n```\n\n### Comparison with Bash\n\n| Feature | Bash | Go |\n|---------|------|----|\n| Runtime | Bash 4.0+ | None |\n| Portability | Unix-like | All platforms |\n| Dependencies | System tools | None |\n| Use case | Shell scripts | High-performance ETL |", "answer_tailored": true}
{"pair_id": "b6-c1-go-overview_p1", "cluster_id": "b6-c1-go-overview", "question": "What are the advantages of the Go target?", "question_type": "medium", "answer": "The Go target offers several key advantages for UnifyWeaver compilations:\n\n**No Runtime Dependencies**: Unlike interpreted targets, Go produces a single standalone binary with everything built in. This eliminates version conflicts and simplifies deployment.\n\n**True Cross-Platform Support**: Compile once for Linux, Windows, or macOS. Go's cross-compilation is straightforward:\n\n```bash\n# Target Windows from any platform\nGOOS=windows GOARCH=amd64 go build -o tool.exe tool.go\n```\n\n**Strong Performance**: Go excels at string processing and I/O operations, making it ideal for high-performance ETL pipelines and data transformation tasks.\n\n**Trivial Deployment**: Just copy the executable\u2014no installers, no dependency management, no version checking.\n\n**Broader Reach than Bash**: While the Bash target requires Unix-like systems with Bash 4.0+, Go binaries run anywhere. This makes Go the better choice when you need portability beyond Linux/macOS or when system dependencies are a concern.\n\nFor implementation details and examples, see education/book-06-go-target/.", "answer_variant": "default", "answer_source": "education/book-06-go-target/01_introduction.md", "topics": ["go-target", "native-binaries", "cross-platform"], "original_answer": "## Go Target Overview\n\nThe Go target compiles Prolog logic into standalone Go programs.\n\n### Key Benefits\n\n| Benefit | Description |\n|---------|-------------|\n| Single Binary | No runtime dependencies |\n| Cross-Platform | Linux, Windows, macOS from one source |\n| Performance | Excellent for string/I/O processing |\n| Deployment | Just copy the executable |\n\n### Cross-Compilation\n\n```bash\n# Build for Windows on Linux\nGOOS=windows GOARCH=amd64 go build -o tool.exe tool.go\n```\n\n### Comparison with Bash\n\n| Feature | Bash | Go |\n|---------|------|----|\n| Runtime | Bash 4.0+ | None |\n| Portability | Unix-like | All platforms |\n| Dependencies | System tools | None |\n| Use case | Shell scripts | High-performance ETL |", "answer_tailored": true}
{"pair_id": "b6-c1-go-overview_p2", "cluster_id": "b6-c1-go-overview", "question": "How does Go compare to Bash target?", "question_type": "medium", "answer": "## Go vs Bash Target Comparison\n\nWhen comparing Go to the Bash target, the main differences are in portability, dependencies, and use cases:\n\n**Bash Target:**\n- Requires Bash 4.0+ runtime\n- Limited to Unix-like systems\n- Relies on system tools and utilities\n- Best for shell scripting and system automation tasks\n\n**Go Target:**\n- Compiles to standalone binaries with no runtime dependencies\n- Cross-platform support (Linux, Windows, macOS)\n- Self-contained executables with no external tool requirements\n- Ideal for high-performance ETL and data processing workloads\n\n**Key Advantages of Go:**\n- **Single Binary Deployment** - Just distribute the compiled executable\n- **Cross-Compilation** - Build for any platform from one source (e.g., `GOOS=windows GOARCH=amd64 go build`)\n- **Performance** - Superior string and I/O processing capabilities\n- **Portability** - Works anywhere without system dependencies\n\nFor shell automation, Bash target is simpler. For portable, high-performance tools, Go target excels.\n\nSee education/book-06-go-target/01_introduction.md for the complete comparison details.", "answer_variant": "default", "answer_source": "education/book-06-go-target/01_introduction.md", "topics": ["go-target", "native-binaries", "cross-platform"], "original_answer": "## Go Target Overview\n\nThe Go target compiles Prolog logic into standalone Go programs.\n\n### Key Benefits\n\n| Benefit | Description |\n|---------|-------------|\n| Single Binary | No runtime dependencies |\n| Cross-Platform | Linux, Windows, macOS from one source |\n| Performance | Excellent for string/I/O processing |\n| Deployment | Just copy the executable |\n\n### Cross-Compilation\n\n```bash\n# Build for Windows on Linux\nGOOS=windows GOARCH=amd64 go build -o tool.exe tool.go\n```\n\n### Comparison with Bash\n\n| Feature | Bash | Go |\n|---------|------|----|\n| Runtime | Bash 4.0+ | None |\n| Portability | Unix-like | All platforms |\n| Dependencies | System tools | None |\n| Use case | Shell scripts | High-performance ETL |", "answer_tailored": true}
{"pair_id": "b6-c2-basic-compilation_p0", "cluster_id": "b6-c2-basic-compilation", "question": "How do I compile Prolog facts to Go?", "question_type": "medium", "answer": "To compile Prolog facts to Go, use the `compile_facts_to_go/3` predicate:\n\n```prolog\n?- go_target:compile_facts_to_go(user, 2, Code).\n```\n\nThis generates a Go struct representing your fact, along with helper functions:\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n\nfunc ContainsUSER(target USER) bool { ... }\n```\n\nThe predicate takes three arguments: the fact name (e.g., `user`), the arity (number of arguments), and the output variable for generated code. The resulting Go code includes a typed struct, a function to retrieve all facts, a streaming iterator, and a membership check function.\n\nFor more details on Go target compilation, see education/book-06-go-target/.", "answer_variant": "default", "answer_source": "education/book-06-go-target/02_basic_compilation.md", "topics": ["fact-export", "struct-generation", "streaming"], "original_answer": "## Basic Compilation\n\n### Compiling Facts\n\n```prolog\n?- go_target:compile_facts_to_go(user, 2, Code).\n```\n\n**Generated Go:**\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n\nfunc ContainsUSER(target USER) bool { ... }\n```\n\n### Compiling Rules\n\nRules generate stream processors (stdin \u2192 stdout):\n\n```bash\necho -e \"alice:bob\\ncharlie:david\" | ./swap\n# Output: bob:alice, david:charlie\n```", "answer_tailored": true}
{"pair_id": "b6-c2-basic-compilation_p1", "cluster_id": "b6-c2-basic-compilation", "question": "What does compile_facts_to_go generate?", "question_type": "medium", "answer": "The `compile_facts_to_go/3` predicate generates Go code that includes:\n\n1. **A struct type** - Defines fields for each argument (e.g., `USER` with `Arg1`, `Arg2` as strings)\n\n2. **`GetAll` function** - Returns a slice containing all facts as struct instances (e.g., `GetAllUSER()` returns `[]USER`)\n\n3. **`Stream` function** - Accepts a callback and iterates over all facts, applying the function to each (e.g., `StreamUSER(fn func(USER))`)\n\n4. **`Contains` function** - Checks if a specific fact exists in the dataset (e.g., `ContainsUSER(target USER) bool`)\n\nFor example, calling `go_target:compile_facts_to_go(user, 2, Code)` produces these four components for a `user/2` predicate. The generated code provides multiple access patterns - bulk retrieval via `GetAll`, iteration via `Stream`, and membership testing via `Contains`.\n\nSee education/book-06-go-target/02_basic_compilation.md for complete examples and usage patterns.", "answer_variant": "default", "answer_source": "education/book-06-go-target/02_basic_compilation.md", "topics": ["fact-export", "struct-generation", "streaming"], "original_answer": "## Basic Compilation\n\n### Compiling Facts\n\n```prolog\n?- go_target:compile_facts_to_go(user, 2, Code).\n```\n\n**Generated Go:**\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n\nfunc ContainsUSER(target USER) bool { ... }\n```\n\n### Compiling Rules\n\nRules generate stream processors (stdin \u2192 stdout):\n\n```bash\necho -e \"alice:bob\\ncharlie:david\" | ./swap\n# Output: bob:alice, david:charlie\n```", "answer_tailored": true}
{"pair_id": "b6-c2-basic-compilation_p2", "cluster_id": "b6-c2-basic-compilation", "question": "How do I compile rules for stream processing?", "question_type": "medium", "answer": "## Stream Processing Compilation\n\nFor stream processing, UnifyWeaver compiles Prolog rules into Go programs that process data from stdin to stdout. Each rule becomes a stream processor:\n\n```bash\necho -e \"alice:bob\\ncharlie:david\" | ./swap\n# Output: bob:alice, david:charlie\n```\n\nThe compilation generates functions that handle streaming data through a pipeline. Behind the scenes, the generated Go code includes:\n\n```go\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n```\n\nThis streaming function iterates through data and applies transformations defined in your Prolog rules.\n\nTo compile facts that support streaming:\n\n```prolog\n?- go_target:compile_facts_to_go(user, 2, Code).\n```\n\nThis produces structs and streaming utilities:\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\nfunc ContainsUSER(target USER) bool { ... }\n```\n\nSee education/book-06-go-target/02_basic_compilation.md for additional compilation patterns.", "answer_variant": "default", "answer_source": "education/book-06-go-target/02_basic_compilation.md", "topics": ["fact-export", "struct-generation", "streaming"], "original_answer": "## Basic Compilation\n\n### Compiling Facts\n\n```prolog\n?- go_target:compile_facts_to_go(user, 2, Code).\n```\n\n**Generated Go:**\n\n```go\ntype USER struct {\n    Arg1 string\n    Arg2 string\n}\n\nfunc GetAllUSER() []USER {\n    return []USER{\n        {Arg1: \"john\", Arg2: \"25\"},\n        {Arg1: \"jane\", Arg2: \"30\"},\n    }\n}\n\nfunc StreamUSER(fn func(USER)) {\n    for _, fact := range GetAllUSER() {\n        fn(fact)\n    }\n}\n\nfunc ContainsUSER(target USER) bool { ... }\n```\n\n### Compiling Rules\n\nRules generate stream processors (stdin \u2192 stdout):\n\n```bash\necho -e \"alice:bob\\ncharlie:david\" | ./swap\n# Output: bob:alice, david:charlie\n```", "answer_tailored": true}
