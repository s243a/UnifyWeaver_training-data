{"pair_id": "b6-a3-boltdb-schema_p0", "cluster_id": "b6-a3-boltdb-schema", "question": "How does BoltDB store facts in Go target?", "question_type": "medium", "answer": "BoltDB stores facts in the Go target using a bucket-per-predicate organization. Each predicate (like \"ancestor\") gets its own bucket created via `CreateBucketIfNotExists`. Within each bucket, facts are stored as key-value pairs where keys are `[]byte` representations of strings, and values are JSON-encoded `map[string]interface{}` objects containing the predicate name and arguments.\n\nFor example, a fact like `ancestor(john, mary)` is stored as:\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\nAll encoding uses UTF-8 strings and JSON serialization. The implementation uses `go.etcd.io/bbolt v1.3.8`. For more details on Go target persistence patterns, see education/book-06-go-target/A3_database_persistence.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["boltdb", "database-schema", "bucket-organization"], "original_answer": "## BoltDB Schema in Go Target\n\n### Storage Format\n\n| Component | Format |\n|-----------|--------|\n| Keys | `[]byte` (string converted) |\n| Values | JSON-marshaled `map[string]interface{}` |\n| Encoding | UTF-8 strings, JSON objects |\n\n### Bucket Organization\n\nEach predicate gets its own bucket:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n    _, err := tx.CreateBucketIfNotExists([]byte(\"ancestor\"))\n    return err\n})\n```\n\n### Example Stored Record\n\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\n**Library:** `go.etcd.io/bbolt v1.3.8`", "answer_tailored": true}
{"pair_id": "b6-a3-boltdb-schema_p1", "cluster_id": "b6-a3-boltdb-schema", "question": "What is the BoltDB schema?", "question_type": "medium", "answer": "BoltDB uses a key-value storage model where keys are byte arrays (converted from strings) and values are JSON-encoded `map[string]interface{}` objects. Each predicate in UnifyWeaver's Go target is stored in its own bucket, created as needed:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n    _, err := tx.CreateBucketIfNotExists([]byte(\"ancestor\"))\n    return err\n})\n```\n\nRecords are persisted as JSON with the predicate name and arguments. For example, the fact `ancestor(john, mary)` would be stored as:\n\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\nAll data uses UTF-8 encoding for strings and standard JSON serialization for structured values. The implementation relies on `go.etcd.io/bbolt v1.3.8`.\n\nFor more details on database integration in the Go target, see education/book-06-go-target/A3_database_persistence.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["boltdb", "database-schema", "bucket-organization"], "original_answer": "## BoltDB Schema in Go Target\n\n### Storage Format\n\n| Component | Format |\n|-----------|--------|\n| Keys | `[]byte` (string converted) |\n| Values | JSON-marshaled `map[string]interface{}` |\n| Encoding | UTF-8 strings, JSON objects |\n\n### Bucket Organization\n\nEach predicate gets its own bucket:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n    _, err := tx.CreateBucketIfNotExists([]byte(\"ancestor\"))\n    return err\n})\n```\n\n### Example Stored Record\n\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\n**Library:** `go.etcd.io/bbolt v1.3.8`", "answer_tailored": true}
{"pair_id": "b6-a3-boltdb-schema_p2", "cluster_id": "b6-a3-boltdb-schema", "question": "How are facts organized in buckets?", "question_type": "medium", "answer": "In BoltDB, each predicate gets its own bucket for organizing facts. When storing data, the system creates a dedicated bucket per predicate name:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n    _, err := tx.CreateBucketIfNotExists([]byte(\"ancestor\"))\n    return err\n})\n```\n\nWithin each bucket, facts are stored as key-value pairs where:\n- Keys are `[]byte` representations (converted from strings)\n- Values are JSON-marshaled `map[string]interface{}` objects containing the predicate relation and arguments\n\nFor example, a fact in the \"ancestor\" bucket might look like:\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\nThis bucket-per-predicate organization allows efficient querying and isolation of different fact types. See education/book-06-go-target/A3_database_persistence.md for complete details on the BoltDB schema (using `go.etcd.io/bbolt v1.3.8`).", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["boltdb", "database-schema", "bucket-organization"], "original_answer": "## BoltDB Schema in Go Target\n\n### Storage Format\n\n| Component | Format |\n|-----------|--------|\n| Keys | `[]byte` (string converted) |\n| Values | JSON-marshaled `map[string]interface{}` |\n| Encoding | UTF-8 strings, JSON objects |\n\n### Bucket Organization\n\nEach predicate gets its own bucket:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n    _, err := tx.CreateBucketIfNotExists([]byte(\"ancestor\"))\n    return err\n})\n```\n\n### Example Stored Record\n\n```json\n{\"relation\":\"ancestor\",\"args\":{\"arg0\":\"john\",\"arg1\":\"mary\"}}\n```\n\n**Library:** `go.etcd.io/bbolt v1.3.8`", "answer_tailored": true}
{"pair_id": "b6-a3-key-strategies_p0", "cluster_id": "b6-a3-key-strategies", "question": "What key strategies does Go target support?", "question_type": "medium", "answer": "The Go target supports several key strategies for BoltDB persistence:\n\n**Single Field Keys** - The simplest approach uses one field as the key. For example, with `db_key_field(name)`, you get keys like `\"Alice\"` or `\"Bob\"`.\n\n**Composite Keys** - Combine multiple fields into a single key using `db_key_strategy(composite([field(dept), field(name)]))`. With a delimiter like `':'`, this generates keys such as `\"eng:Alice\"` or `\"sales:Bob\"`.\n\n**Hash Keys** - Generate deterministic hash-based keys using `db_key_strategy(hash(field(content)))`, which produces SHA-256 hex digests.\n\n**Composite with Hash** - Mix explicit fields with hashed fields, like `db_key_strategy(composite([field(name), hash(field(content))]))`, producing keys such as `\"readme:a3f2b1c9...\"`.\n\nThese strategies are configured through options when compiling predicates with `db_backend(bbolt)`. For complete implementation details, see education/book-06-go-target/A3_database_persistence.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["key-strategies", "composite-keys", "hash-keys"], "original_answer": "## BoltDB Key Strategies\n\n### Single Field Key (Default)\n\n```prolog\ncompile_predicate_to_go(user/2, [\n    db_backend(bbolt),\n    db_key_field(name)\n], Code).\n```\n\nGenerated key: `\"Alice\"`, `\"Bob\"`\n\n### Composite Keys\n\n```prolog\ndb_key_strategy(composite([field(dept), field(name)])),\ndb_key_delimiter(':')\n```\n\nGenerated keys: `\"eng:Alice\"`, `\"sales:Bob\"`\n\n### Hash Keys\n\n```prolog\ndb_key_strategy(hash(field(content)))\n```\n\nGenerated key: SHA-256 hex digest\n\n### Composite with Hash\n\n```prolog\ndb_key_strategy(composite([field(name), hash(field(content))]))\n```\n\nGenerated key: `\"readme:a3f2b1c9...\"`", "answer_tailored": true}
{"pair_id": "b6-a3-key-strategies_p1", "cluster_id": "b6-a3-key-strategies", "question": "How do I use composite keys in BoltDB?", "question_type": "medium", "answer": "BoltDB in UnifyWeaver supports composite keys by combining multiple fields. To use composite keys, specify the `db_key_strategy(composite([...]))` option with the fields you want to combine:\n\n```prolog\ncompile_predicate_to_go(user/2, [\n    db_backend(bbolt),\n    db_key_strategy(composite([field(dept), field(name)])),\n    db_key_delimiter(':')\n], Code).\n```\n\nThis generates keys like `\"eng:Alice\"` or `\"sales:Bob\"` by joining the department and name fields with a colon delimiter.\n\nYou can also combine composite keys with hashing for scenarios where one field is large or variable-length:\n\n```prolog\ndb_key_strategy(composite([field(name), hash(field(content))]))\n```\n\nThis produces keys like `\"readme:a3f2b1c9...\"` where the content field is hashed to a SHA-256 digest.\n\nFor comparison, single-field keys use `db_key_field(name)` and generate simple keys like `\"Alice\"`, while pure hash keys use `db_key_strategy(hash(field(content)))` to create SHA-256 hex digests.\n\nSee education/book-06-go-target/A3_database_persistence.md for complete details on BoltDB key strategies.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["key-strategies", "composite-keys", "hash-keys"], "original_answer": "## BoltDB Key Strategies\n\n### Single Field Key (Default)\n\n```prolog\ncompile_predicate_to_go(user/2, [\n    db_backend(bbolt),\n    db_key_field(name)\n], Code).\n```\n\nGenerated key: `\"Alice\"`, `\"Bob\"`\n\n### Composite Keys\n\n```prolog\ndb_key_strategy(composite([field(dept), field(name)])),\ndb_key_delimiter(':')\n```\n\nGenerated keys: `\"eng:Alice\"`, `\"sales:Bob\"`\n\n### Hash Keys\n\n```prolog\ndb_key_strategy(hash(field(content)))\n```\n\nGenerated key: SHA-256 hex digest\n\n### Composite with Hash\n\n```prolog\ndb_key_strategy(composite([field(name), hash(field(content))]))\n```\n\nGenerated key: `\"readme:a3f2b1c9...\"`", "answer_tailored": true}
{"pair_id": "b6-a3-key-strategies_p2", "cluster_id": "b6-a3-key-strategies", "question": "What is db_key_strategy?", "question_type": "medium", "answer": "`db_key_strategy` is a configuration option in UnifyWeaver's Go target that determines how database keys are generated when using BoltDB persistence. It supports several approaches:\n\n**Single field** (default): Uses one field's value directly as the key. For example, with `db_key_field(name)`, keys would be `\"Alice\"`, `\"Bob\"`.\n\n**Composite keys**: Combines multiple fields using `composite([field(dept), field(name)])`. With `db_key_delimiter(':')`, this generates keys like `\"eng:Alice\"` or `\"sales:Bob\"`.\n\n**Hash-based keys**: Uses `hash(field(content))` to generate a SHA-256 hex digest as the key, useful for large or variable-length data.\n\n**Composite with hash**: Combines field values with hashed fields using `composite([field(name), hash(field(content))])`, producing keys like `\"readme:a3f2b1c9...\"`.\n\nThe strategy is specified when compiling predicates with the `db_backend(bbolt)` option. See education/book-06-go-target/A3_database_persistence.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["key-strategies", "composite-keys", "hash-keys"], "original_answer": "## BoltDB Key Strategies\n\n### Single Field Key (Default)\n\n```prolog\ncompile_predicate_to_go(user/2, [\n    db_backend(bbolt),\n    db_key_field(name)\n], Code).\n```\n\nGenerated key: `\"Alice\"`, `\"Bob\"`\n\n### Composite Keys\n\n```prolog\ndb_key_strategy(composite([field(dept), field(name)])),\ndb_key_delimiter(':')\n```\n\nGenerated keys: `\"eng:Alice\"`, `\"sales:Bob\"`\n\n### Hash Keys\n\n```prolog\ndb_key_strategy(hash(field(content)))\n```\n\nGenerated key: SHA-256 hex digest\n\n### Composite with Hash\n\n```prolog\ndb_key_strategy(composite([field(name), hash(field(content))]))\n```\n\nGenerated key: `\"readme:a3f2b1c9...\"`", "answer_tailored": true}
{"pair_id": "b6-a3-query-outside_p0", "cluster_id": "b6-a3-query-outside", "question": "How do I query BoltDB outside generated programs?", "question_type": "medium", "answer": "You can query BoltDB databases created by UnifyWeaver Go programs in several ways:\n\n**Direct BoltDB Access**: Use the standard BoltDB API in your own Go code. Open the database file in read-only mode and navigate to the appropriate bucket. The stored values are JSON-encoded, so you'll need to unmarshal them:\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v contains JSON bytes - unmarshal as needed\n    return nil\n})\n```\n\n**Runtime Store API**: For easier access, use UnifyWeaver's storage wrapper which handles JSON marshaling automatically:\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // Returns map[string]interface{}\n```\n\n**Export Approach**: If you need all data in a portable format, generate a program that queries and outputs everything, then redirect to a file:\n\n```bash\n./query_users > all_users.jsonl\n```\n\nFor implementation details, see education/book-06-go-target/A3_database_persistence.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["query-database", "external-access", "go-api"], "original_answer": "## Querying BoltDB Outside Generated Programs\n\n### Option 1: Custom Go Code\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v is JSON bytes\n    return nil\n})\n```\n\n### Option 2: Runtime Store Wrapper\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // map[string]interface{}\n```\n\n### Option 3: Export to JSON\n\n```bash\n./query_users > all_users.jsonl\n```", "answer_tailored": true}
{"pair_id": "b6-a3-query-outside_p1", "cluster_id": "b6-a3-query-outside", "question": "Can I access the database directly?", "question_type": "medium", "answer": "Yes, you can access the database directly in several ways:\n\n**Direct BoltDB Access** - Open the database file with the BoltDB library in your own Go code:\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v contains JSON bytes\n    return nil\n})\n```\n\n**Runtime Store API** - Use UnifyWeaver's storage wrapper for a higher-level interface:\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // returns map[string]interface{}\n```\n\n**Export to JSON** - Run the generated program to export data:\n\n```bash\n./query_users > all_users.jsonl\n```\n\nFor more details on Go target database persistence, see education/book-06-go-target/A3_database_persistence.md.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["query-database", "external-access", "go-api"], "original_answer": "## Querying BoltDB Outside Generated Programs\n\n### Option 1: Custom Go Code\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v is JSON bytes\n    return nil\n})\n```\n\n### Option 2: Runtime Store Wrapper\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // map[string]interface{}\n```\n\n### Option 3: Export to JSON\n\n```bash\n./query_users > all_users.jsonl\n```", "answer_tailored": true}
{"pair_id": "b6-a3-query-outside_p2", "cluster_id": "b6-a3-query-outside", "question": "How do I read BoltDB data in custom Go code?", "question_type": "medium", "answer": "You can read BoltDB data from custom Go code by opening the database file and querying the bucket directly:\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v contains JSON-encoded bytes\n    return nil\n})\n```\n\nAlternatively, use UnifyWeaver's runtime store wrapper for easier access:\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // returns map[string]interface{}\n```\n\nFor bulk extraction, you can also export query results to JSON format from the command line. See education/book-06-go-target/A3_database_persistence.md for complete examples and additional persistence patterns.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["query-database", "external-access", "go-api"], "original_answer": "## Querying BoltDB Outside Generated Programs\n\n### Option 1: Custom Go Code\n\n```go\ndb, _ := bolt.Open(\"users.db\", 0600, &bolt.Options{ReadOnly: true})\ndefer db.Close()\n\ndb.View(func(tx *bolt.Tx) error {\n    bucket := tx.Bucket([]byte(\"users\"))\n    v := bucket.Get([]byte(\"Alice\"))\n    // v is JSON bytes\n    return nil\n})\n```\n\n### Option 2: Runtime Store Wrapper\n\n```go\nimport \"unifyweaver/targets/go_runtime/storage\"\n\nstore, _ := storage.NewStore(\"users.db\")\nobj, _ := store.GetObject(\"Alice\")  // map[string]interface{}\n```\n\n### Option 3: Export to JSON\n\n```bash\n./query_users > all_users.jsonl\n```", "answer_tailored": true}
{"pair_id": "b6-a3-incremental_p0", "cluster_id": "b6-a3-incremental", "question": "How does incremental Datalog work with BoltDB?", "question_type": "medium", "answer": "UnifyWeaver's incremental Datalog implementation uses BoltDB (bbolt) to maintain state across runs. When you configure a predicate with `db_backend(bbolt)` and specify a `db_file`, the system automatically loads existing facts from the database at startup, adds any new facts from stdin, runs the fixpoint computation to derive new results, and persists only the newly derived facts back to the database.\n\nThis enables incremental workflows where you can:\n- Run your program once to compute initial results: `./ancestor`\n- Add new facts later and continue from the saved state: `echo '{\"relation\":\"parent\",...}' | ./ancestor`\n- Query persisted results separately: `./query_ancestors`\n\nConfigure it in your compilation directive:\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```\n\nThe database acts as both input (loading prior facts) and output (storing new derivations), making it efficient to incrementally build up large fact sets over multiple executions.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["incremental-computation", "persistence", "datalog"], "original_answer": "## Incremental Datalog with BoltDB\n\n### Workflow\n\n```bash\n# First run - compute and persist\n./ancestor\n\n# Add new facts - continue from saved state\necho '{\"relation\":\"parent\",...}' | ./ancestor\n\n# Query persisted results\n./query_ancestors\n```\n\n### How It Works\n\n1. Load existing facts from database\n2. Add new input facts from stdin\n3. Run fixpoint until no new derivations\n4. Persist new facts to database\n\n### Configuration\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a3-incremental_p1", "cluster_id": "b6-a3-incremental", "question": "Can I add facts to an existing database?", "question_type": "medium", "answer": "Yes, you can add facts to an existing database incrementally. UnifyWeaver's Go target with BoltDB support allows you to persist derived facts and continue from a saved state.\n\n### Adding New Facts\n\n```bash\n# Initial run - computes and stores results\n./ancestor\n\n# Add more facts later - builds on existing data\necho '{\"relation\":\"parent\",...}' | ./ancestor\n\n# Query the accumulated results\n./query_ancestors\n```\n\n### How Incremental Updates Work\n\nWhen you add new facts, the system:\n1. Loads previously stored facts from the database\n2. Incorporates your new input facts from stdin\n3. Runs the fixpoint computation to derive any new conclusions\n4. Saves only the newly derived facts back to the database\n\n### Enabling Database Persistence\n\nConfigure your predicate compilation with BoltDB backend:\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```\n\nSee education/book-06-go-target/A3_database_persistence.md for complete examples of incremental fact addition and persistence patterns.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["incremental-computation", "persistence", "datalog"], "original_answer": "## Incremental Datalog with BoltDB\n\n### Workflow\n\n```bash\n# First run - compute and persist\n./ancestor\n\n# Add new facts - continue from saved state\necho '{\"relation\":\"parent\",...}' | ./ancestor\n\n# Query persisted results\n./query_ancestors\n```\n\n### How It Works\n\n1. Load existing facts from database\n2. Add new input facts from stdin\n3. Run fixpoint until no new derivations\n4. Persist new facts to database\n\n### Configuration\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```", "answer_tailored": true}
{"pair_id": "b6-a3-incremental_p2", "cluster_id": "b6-a3-incremental", "question": "How does persistence enable incremental computation?", "question_type": "medium", "answer": "Persistence enables incremental computation by saving derived facts to disk, allowing subsequent runs to build on previous results instead of recomputing from scratch. When you first run `./ancestor`, it computes all ancestor relationships and stores them in BoltDB. On the next run, the system:\n\n1. Loads existing facts from the database\n2. Accepts only new input facts via stdin (e.g., `echo '{\"relation\":\"parent\",...}' | ./ancestor`)\n3. Runs fixpoint computation starting from the saved state, deriving only what's new\n4. Persists the newly derived facts back to the database\n\nThis workflow means adding a single new parent-child relationship doesn't require recomputing all ancestor relationships\u2014only the incremental changes are processed. Configure persistence with:\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```\n\nThe database acts as a checkpoint, making large-scale Datalog computations practical by avoiding redundant work across multiple invocations.", "answer_variant": "default", "answer_source": "education/book-06-go-target/A3_database_persistence.md", "topics": ["incremental-computation", "persistence", "datalog"], "original_answer": "## Incremental Datalog with BoltDB\n\n### Workflow\n\n```bash\n# First run - compute and persist\n./ancestor\n\n# Add new facts - continue from saved state\necho '{\"relation\":\"parent\",...}' | ./ancestor\n\n# Query persisted results\n./query_ancestors\n```\n\n### How It Works\n\n1. Load existing facts from database\n2. Add new input facts from stdin\n3. Run fixpoint until no new derivations\n4. Persist new facts to database\n\n### Configuration\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db'),\n    json_input(true)\n], Code).\n```", "answer_tailored": true}
