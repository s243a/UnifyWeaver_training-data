{"pair_id": "ps-windows-001_p0", "cluster_id": "ps-windows-001", "question": "How do I automate Windows services with the PowerShell target?", "question_type": "medium", "answer": "To automate Windows service management, define your services as Prolog facts with their configuration:\n\n```prolog\nservice(spooler, 'Print Spooler', automatic).\nservice(wuauserv, 'Windows Update', manual).\n\nrunning(Name) :- service(Name, _, _), service_status(Name, 'Running').\n\nservice_alert(Name, Msg) :-\n    service(Name, _, automatic),\n    \\+ running(Name),\n    format(string(Msg), \"Critical ~w not running\", [Name]).\n```\n\n**PowerShell target output:**\n```powershell\nfunction Test-ServiceRunning {\n    [CmdletBinding()]\n    param([string]$ServiceName)\n    \n    $svc = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue\n    $svc -and $svc.Status -eq 'Running'\n}\n\nfunction Watch-CriticalServices {\n    $critical = @('spooler', 'wuauserv')\n    foreach ($name in $critical) {\n        $svc = Get-Service -Name $name\n        if ($svc.StartType -eq 'Automatic' -and $svc.Status -ne 'Running') {\n            Write-Warning \"ALERT: $name not running\"\n        }\n    }\n}\n```\n\nThis approach lets you declare service requirements in Prolog while the PowerShell target handles the native Windows service APIs. For comprehensive examples, see education/book-12-powershell-target/05_windows_automation.md.", "answer_variant": "default", "answer_source": "book-12-powershell-target/05_windows_automation.md", "topics": [], "original_answer": "Model services as Prolog facts and rules:\n\n```prolog\nservice(spooler, 'Print Spooler', automatic).\nservice(wuauserv, 'Windows Update', manual).\n\nrunning(Name) :- service(Name, _, _), service_status(Name, 'Running').\n\nservice_alert(Name, Msg) :-\n    service(Name, _, automatic),\n    \\+ running(Name),\n    format(string(Msg), \"Critical ~w not running\", [Name]).\n```\n\n**Generated PowerShell:**\n```powershell\nfunction Test-ServiceRunning {\n    [CmdletBinding()]\n    param([string]$ServiceName)\n    \n    $svc = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue\n    $svc -and $svc.Status -eq 'Running'\n}\n\nfunction Watch-CriticalServices {\n    $critical = @('spooler', 'wuauserv')\n    foreach ($name in $critical) {\n        $svc = Get-Service -Name $name\n        if ($svc.StartType -eq 'Automatic' -and $svc.Status -ne 'Running') {\n            Write-Warning \"ALERT: $name not running\"\n        }\n    }\n}\n```", "answer_tailored": true}
{"pair_id": "ps-windows-001_p0", "cluster_id": "ps-windows-001", "question": "How do I access the Windows Registry with the PowerShell target?", "question_type": "medium", "answer": "The PowerShell target enables Windows Registry access by modeling registry operations as Prolog facts and rules. Define registry values as facts:\n\n```prolog\nreg_value('HKLM:\\SOFTWARE\\MyApp', 'Version', '1.0.0').\n\napp_installed(AppName) :-\n    reg_value(Path, 'DisplayName', AppName),\n    sub_string(Path, _, _, _, 'Uninstall').\n```\n\n**Compiled to PowerShell:**\n```powershell\nfunction Get-AppInstalled {\n    param([string]$AppName)\n    \n    $paths = @(\n        'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',\n        'HKLM:\\SOFTWARE\\WOW6432Node\\...\\Uninstall\\*'\n    )\n    \n    $paths | ForEach-Object {\n        Get-ItemProperty -Path $_ -ErrorAction SilentlyContinue\n    } | Where-Object { $_.DisplayName -like \"*$AppName*\" }\n}\n\nfunction Set-UserPreference {\n    [CmdletBinding(SupportsShouldProcess=$true)]\n    param([string]$AppName, [string]$Key, $Value)\n    \n    $path = \"HKCU:\\Software\\$AppName\"\n    if ($PSCmdlet.ShouldProcess($path, \"Set $Key\")) {\n        Set-ItemProperty -Path $path -Name $Key -Value $Value\n    }\n}\n```\n\nThis approach maps registry queries to `Get-ItemProperty` and `Set-ItemProperty` cmdlets, handling both HKLM and HKCU hives. For comprehensive Windows automation patterns, see education/book-12-powershell-target/05_windows_automation.md.", "answer_variant": "default", "answer_source": "book-12-powershell-target/05_windows_automation.md", "topics": [], "original_answer": "Model registry as facts:\n\n```prolog\nreg_value('HKLM:\\SOFTWARE\\MyApp', 'Version', '1.0.0').\n\napp_installed(AppName) :-\n    reg_value(Path, 'DisplayName', AppName),\n    sub_string(Path, _, _, _, 'Uninstall').\n```\n\n**Generated PowerShell:**\n```powershell\nfunction Get-AppInstalled {\n    param([string]$AppName)\n    \n    $paths = @(\n        'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',\n        'HKLM:\\SOFTWARE\\WOW6432Node\\...\\Uninstall\\*'\n    )\n    \n    $paths | ForEach-Object {\n        Get-ItemProperty -Path $_ -ErrorAction SilentlyContinue\n    } | Where-Object { $_.DisplayName -like \"*$AppName*\" }\n}\n\nfunction Set-UserPreference {\n    [CmdletBinding(SupportsShouldProcess=$true)]\n    param([string]$AppName, [string]$Key, $Value)\n    \n    $path = \"HKCU:\\Software\\$AppName\"\n    if ($PSCmdlet.ShouldProcess($path, \"Set $Key\")) {\n        Set-ItemProperty -Path $path -Name $Key -Value $Value\n    }\n}\n```", "answer_tailored": true}
{"pair_id": "ps-windows-002_p0", "cluster_id": "ps-windows-002", "question": "How do I query WMI/CIM with the PowerShell target?", "question_type": "medium", "answer": "The PowerShell target compiles WMI/CIM queries by translating Prolog facts into `Get-CimInstance` cmdlets. Define your data model in Prolog, then generate PowerShell functions that wrap CIM queries:\n\n```prolog\nlow_disk(DeviceId) :-\n    disk_info(DeviceId, Size, FreeSpace),\n    Percent is (FreeSpace / Size) * 100,\n    Percent < 10.\n```\n\n**Compiled PowerShell:**\n```powershell\nfunction Get-DiskFact {\n    Get-CimInstance Win32_LogicalDisk -Filter \"DriveType=3\" |\n        ForEach-Object {\n            [PSCustomObject]@{\n                DeviceId = $_.DeviceID\n                Size = $_.Size\n                FreeSpace = $_.FreeSpace\n                PercentFree = [math]::Round(($_.FreeSpace / $_.Size) * 100, 2)\n            }\n        }\n}\n\nfunction Test-LowDisk {\n    param([int]$ThresholdPercent = 10)\n    Get-DiskFact | Where-Object { $_.PercentFree -lt $ThresholdPercent }\n}\n```\n\n**Frequently used CIM classes:** Win32_ComputerSystem, Win32_OperatingSystem, Win32_LogicalDisk, Win32_Service, Win32_Process. For more automation examples, see education/book-12-powershell-target/05_windows_automation.md.", "answer_variant": "default", "answer_source": "book-12-powershell-target/05_windows_automation.md", "topics": [], "original_answer": "Model system info as facts:\n\n```prolog\nlow_disk(DeviceId) :-\n    disk_info(DeviceId, Size, FreeSpace),\n    Percent is (FreeSpace / Size) * 100,\n    Percent < 10.\n```\n\n**Generated PowerShell:**\n```powershell\nfunction Get-DiskFact {\n    Get-CimInstance Win32_LogicalDisk -Filter \"DriveType=3\" |\n        ForEach-Object {\n            [PSCustomObject]@{\n                DeviceId = $_.DeviceID\n                Size = $_.Size\n                FreeSpace = $_.FreeSpace\n                PercentFree = [math]::Round(($_.FreeSpace / $_.Size) * 100, 2)\n            }\n        }\n}\n\nfunction Test-LowDisk {\n    param([int]$ThresholdPercent = 10)\n    Get-DiskFact | Where-Object { $_.PercentFree -lt $ThresholdPercent }\n}\n```\n\n**Common CIM classes:** Win32_ComputerSystem, Win32_OperatingSystem, Win32_LogicalDisk, Win32_Service, Win32_Process", "answer_tailored": true}
