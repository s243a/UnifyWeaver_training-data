{"pair_id": "b7-c12a-service-mesh_p0", "cluster_id": "b7-c12a-service-mesh", "question": "What is a service mesh?", "question_type": "medium", "answer": "A service mesh is a distributed infrastructure layer that manages service-to-service communication in UnifyWeaver deployments. It handles cross-cutting concerns like load balancing, reliability, and monitoring.\n\n**Load Distribution**\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)  % alternatives: random, least_connections\n]).\n```\n\n**Fault Tolerance**\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % failures before opening circuit\n    timeout(30),            % seconds before retry\n    fallback(local_cache/2) % backup when unavailable\n]).\n```\n\n**Service Monitoring**\n```prolog\n:- health_check(service_name, [\n    endpoint('/health'),\n    interval(10),\n    timeout(5)\n]).\n```\n\nFor comprehensive coverage of service mesh integration, see education/book-07-cross-target-glue/12a_service_mesh.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12a_service_mesh.md", "topics": ["service-mesh", "load-balancing", "circuit-breaker"], "original_answer": "## Service Mesh Patterns\n\n### Load Balancing Strategies\n\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)  % or: random, least_connections\n]).\n```\n\n### Circuit Breakers\n\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % failures before open\n    timeout(30),            % seconds before half-open\n    fallback(local_cache/2) % use when open\n]).\n```\n\n### Health Checks\n\n```prolog\n:- health_check(service_name, [\n    endpoint('/health'),\n    interval(10),\n    timeout(5)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c12a-service-mesh_p1", "cluster_id": "b7-c12a-service-mesh", "question": "How does load balancing work?", "question_type": "medium", "answer": "UnifyWeaver supports multiple load balancing strategies for distributed service calls. You can configure load balancing when declaring services with multiple instances:\n\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)  % or: random, least_connections\n]).\n```\n\nThe `strategy` option determines how requests are distributed across instances:\n- `round_robin` - Cycles through instances sequentially\n- `random` - Randomly selects an instance for each request\n- `least_connections` - Routes to the instance with fewest active connections\n\nThis integrates with circuit breakers and health checks to ensure requests only go to healthy instances. For more on service mesh patterns, see education/book-07-cross-target-glue/12a_service_mesh.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12a_service_mesh.md", "topics": ["service-mesh", "load-balancing", "circuit-breaker"], "original_answer": "## Service Mesh Patterns\n\n### Load Balancing Strategies\n\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)  % or: random, least_connections\n]).\n```\n\n### Circuit Breakers\n\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % failures before open\n    timeout(30),            % seconds before half-open\n    fallback(local_cache/2) % use when open\n]).\n```\n\n### Health Checks\n\n```prolog\n:- health_check(service_name, [\n    endpoint('/health'),\n    interval(10),\n    timeout(5)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c12a-service-mesh_p2", "cluster_id": "b7-c12a-service-mesh", "question": "What are circuit breakers?", "question_type": "medium", "answer": "Circuit breakers are a resilience pattern in UnifyWeaver's service mesh that prevent cascading failures when calling remote services. When a service fails repeatedly, the circuit breaker \"opens\" to stop making additional calls and instead uses a fallback mechanism.\n\nIn UnifyWeaver, you configure circuit breakers using the `declare_circuit_breaker/2` directive:\n\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % failures before open\n    timeout(30),            % seconds before half-open\n    fallback(local_cache/2) % use when open\n]).\n```\n\nThe key parameters are:\n- **threshold**: Number of consecutive failures that trigger the circuit to open\n- **timeout**: How long (in seconds) to wait before attempting recovery (half-open state)\n- **fallback**: Alternative predicate to invoke when the circuit is open\n\nThis pattern protects your application from repeatedly attempting calls that are likely to fail, reducing latency and resource consumption. For more details on service mesh patterns, see education/book-07-cross-target-glue/12a_service_mesh.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12a_service_mesh.md", "topics": ["service-mesh", "load-balancing", "circuit-breaker"], "original_answer": "## Service Mesh Patterns\n\n### Load Balancing Strategies\n\n```prolog\n:- declare_service(transform/2, [\n    instances([\n        'http://worker1:8080',\n        'http://worker2:8080',\n        'http://worker3:8080'\n    ]),\n    strategy(round_robin)  % or: random, least_connections\n]).\n```\n\n### Circuit Breakers\n\n```prolog\n:- declare_circuit_breaker(remote_api/2, [\n    threshold(5),           % failures before open\n    timeout(30),            % seconds before half-open\n    fallback(local_cache/2) % use when open\n]).\n```\n\n### Health Checks\n\n```prolog\n:- health_check(service_name, [\n    endpoint('/health'),\n    interval(10),\n    timeout(5)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c12b-polyglot_p0", "cluster_id": "b7-c12b-polyglot", "question": "How do polyglot distributed systems work?", "question_type": "medium", "answer": "In UnifyWeaver, polyglot distributed systems enable services written in different target languages to communicate and collaborate. The system orchestrates cross-language pipelines where, for example, a Go parser can feed data to a Python ML service, which passes results to a Rust aggregator, finally reaching a Go API endpoint.\n\nFor handling large datasets across distributed polyglot services, UnifyWeaver provides sharding directives (Phases 4-6). You can declare sharding strategies in Prolog:\n\n```prolog\n:- declare_sharding(large_dataset/2, [\n    shard_key(id),\n    shard_count(4),\n    strategy(hash_mod)\n]).\n```\n\nThe system also handles protocol negotiation between services automatically. By declaring connection preferences, services can negotiate the most efficient serialization format they both support:\n\n```prolog\n:- declare_connection(go_service, python_service, [\n    negotiate_format([json, msgpack, protobuf])\n]).\n```\n\nThis allows different language runtimes to interoperate seamlessly while using optimal data formats. For more details on cross-target communication patterns, see education/book-07-cross-target-glue/12b_polyglot_distributed.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12b_polyglot_distributed.md", "topics": ["polyglot", "sharding", "cross-language"], "original_answer": "## Polyglot Distributed Systems\n\n### Cross-Language Communication\n\nDifferent services can use different languages:\n\n```\nGo (parser) \u2192 Python (ML) \u2192 Rust (aggregator) \u2192 Go (API)\n```\n\n### Sharding (Phases 4-6)\n\n```prolog\n:- declare_sharding(large_dataset/2, [\n    shard_key(id),\n    shard_count(4),\n    strategy(hash_mod)\n]).\n```\n\n### Protocol Negotiation\n\n```prolog\n% Automatic format selection\n:- declare_connection(go_service, python_service, [\n    negotiate_format([json, msgpack, protobuf])\n]).\n```\n\nServices negotiate the most efficient format both support.", "answer_tailored": true}
{"pair_id": "b7-c12b-polyglot_p1", "cluster_id": "b7-c12b-polyglot", "question": "What is sharding in cross-target glue?", "question_type": "medium", "answer": "Sharding in cross-target glue is a distributed data partitioning mechanism covered in Phases 4-6. You declare sharding rules using `declare_sharding/2`:\n\n```prolog\n:- declare_sharding(large_dataset/2, [\n    shard_key(id),\n    shard_count(4),\n    strategy(hash_mod)\n]).\n```\n\nThis splits data across multiple nodes based on a shard key (like `id`), distributing it into a specified number of shards (4 in this example) using a partitioning strategy (such as `hash_mod`). This enables horizontal scaling when working with large datasets across polyglot distributed systems where different services may use Go, Python, Rust, or other target languages.\n\nFor more details on polyglot distributed patterns, see education/book-07-cross-target-glue/12b_polyglot_distributed.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12b_polyglot_distributed.md", "topics": ["polyglot", "sharding", "cross-language"], "original_answer": "## Polyglot Distributed Systems\n\n### Cross-Language Communication\n\nDifferent services can use different languages:\n\n```\nGo (parser) \u2192 Python (ML) \u2192 Rust (aggregator) \u2192 Go (API)\n```\n\n### Sharding (Phases 4-6)\n\n```prolog\n:- declare_sharding(large_dataset/2, [\n    shard_key(id),\n    shard_count(4),\n    strategy(hash_mod)\n]).\n```\n\n### Protocol Negotiation\n\n```prolog\n% Automatic format selection\n:- declare_connection(go_service, python_service, [\n    negotiate_format([json, msgpack, protobuf])\n]).\n```\n\nServices negotiate the most efficient format both support.", "answer_tailored": true}
{"pair_id": "b7-c12b-polyglot_p2", "cluster_id": "b7-c12b-polyglot", "question": "How does protocol negotiation work?", "question_type": "medium", "answer": "Protocol negotiation in UnifyWeaver allows services to automatically select the most efficient communication format that both endpoints support. You declare this using `declare_connection/3`:\n\n```prolog\n% Automatic format selection\n:- declare_connection(go_service, python_service, [\n    negotiate_format([json, msgpack, protobuf])\n]).\n```\n\nWhen services connect, they exchange their supported formats and agree on the optimal one (typically prioritizing efficiency). This enables polyglot distributed systems where different components use different languages (e.g., Go parser \u2192 Python ML \u2192 Rust aggregator) while maintaining efficient communication.\n\nFor more details on cross-language integration patterns, see education/book-07-cross-target-glue/12b_polyglot_distributed.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12b_polyglot_distributed.md", "topics": ["polyglot", "sharding", "cross-language"], "original_answer": "## Polyglot Distributed Systems\n\n### Cross-Language Communication\n\nDifferent services can use different languages:\n\n```\nGo (parser) \u2192 Python (ML) \u2192 Rust (aggregator) \u2192 Go (API)\n```\n\n### Sharding (Phases 4-6)\n\n```prolog\n:- declare_sharding(large_dataset/2, [\n    shard_key(id),\n    shard_count(4),\n    strategy(hash_mod)\n]).\n```\n\n### Protocol Negotiation\n\n```prolog\n% Automatic format selection\n:- declare_connection(go_service, python_service, [\n    negotiate_format([json, msgpack, protobuf])\n]).\n```\n\nServices negotiate the most efficient format both support.", "answer_tailored": true}
{"pair_id": "b7-c12c-discovery-tracing_p0", "cluster_id": "b7-c12c-discovery-tracing", "question": "How does service discovery work?", "question_type": "medium", "answer": "UnifyWeaver's service discovery operates through Phase 7 declarations that configure backend integrations. You declare a discovery configuration using `declare_discovery/2`, specifying the service identifier, backend system (Consul, etcd, or DNS), service name, and optional tags:\n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\nThe compiler integrates this into generated code across all targets, enabling runtime service location. When your Prolog queries reference `ml_service`, the generated code automatically performs lookups against the configured backend (Consul, etcd, or DNS) to resolve service endpoints.\n\nThis works in conjunction with distributed tracing (Phase 8), where trace IDs propagate through service calls to maintain observability across the discovery chain. For implementation details on cross-target service integration, see education/book-07-cross-target-glue/12c_discovery_tracing.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12c_discovery_tracing.md", "topics": ["service-discovery", "distributed-tracing", "consul"], "original_answer": "## Service Discovery & Tracing\n\n### Service Discovery (Phase 7)\n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\n**Backends:** Consul, etcd, DNS\n\n### Distributed Tracing (Phase 8)\n\n```prolog\n:- declare_tracing([\n    backend(jaeger),\n    propagation(w3c),  % or: b3\n    sample_rate(0.1)\n]).\n```\n\n**Propagation:** W3C Trace Context, B3 (Zipkin)\n\n### Trace Correlation\n\nAll generated code includes trace ID propagation:\n\n```go\nctx = context.WithValue(ctx, \"trace_id\", traceID)\n```", "answer_tailored": true}
{"pair_id": "b7-c12c-discovery-tracing_p1", "cluster_id": "b7-c12c-discovery-tracing", "question": "What is distributed tracing?", "question_type": "medium", "answer": "Distributed tracing is a mechanism for tracking requests across multiple services in UnifyWeaver's generated code. In Phase 8, you can declare tracing configuration that gets woven into all target implementations:\n\n```prolog\n:- declare_tracing([\n    backend(jaeger),\n    propagation(w3c),  % or: b3\n    sample_rate(0.1)\n]).\n```\n\nThe system supports two propagation formats: W3C Trace Context (standard) and B3 from Zipkin. When enabled, UnifyWeaver automatically instruments generated code to propagate trace IDs across service boundaries. For example, in Go targets, trace IDs are added to context:\n\n```go\nctx = context.WithValue(ctx, \"trace_id\", traceID)\n```\n\nThis correlation happens automatically across all generated code, allowing you to track a single logical request as it flows through Bash scripts, Python services, Go microservices, and other targets. See education/book-07-cross-target-glue/12c_discovery_tracing.md for full details on configuring tracing backends and propagation strategies.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12c_discovery_tracing.md", "topics": ["service-discovery", "distributed-tracing", "consul"], "original_answer": "## Service Discovery & Tracing\n\n### Service Discovery (Phase 7)\n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\n**Backends:** Consul, etcd, DNS\n\n### Distributed Tracing (Phase 8)\n\n```prolog\n:- declare_tracing([\n    backend(jaeger),\n    propagation(w3c),  % or: b3\n    sample_rate(0.1)\n]).\n```\n\n**Propagation:** W3C Trace Context, B3 (Zipkin)\n\n### Trace Correlation\n\nAll generated code includes trace ID propagation:\n\n```go\nctx = context.WithValue(ctx, \"trace_id\", traceID)\n```", "answer_tailored": true}
{"pair_id": "b7-c12c-discovery-tracing_p2", "cluster_id": "b7-c12c-discovery-tracing", "question": "How do I use Consul with UnifyWeaver?", "question_type": "medium", "answer": "To integrate Consul with UnifyWeaver, use the service discovery declaration in your Prolog code:\n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\nThis Phase 7 feature configures UnifyWeaver to use Consul as the service discovery backend for the specified service. The `backend(consul)` option tells UnifyWeaver to generate target language code that queries Consul for service locations at runtime.\n\nUnifyWeaver also supports etcd and DNS as alternative discovery backends. When you compile queries that reference `ml_service`, the generated code will automatically include Consul client calls to resolve the service endpoint.\n\nFor distributed tracing integration alongside Consul, you can combine this with Phase 8 tracing declarations that propagate trace IDs across service boundaries (using Jaeger, W3C Trace Context, or B3 formats).\n\nSee education/book-07-cross-target-glue/12c_discovery_tracing.md for complete details on service discovery and tracing configuration.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12c_discovery_tracing.md", "topics": ["service-discovery", "distributed-tracing", "consul"], "original_answer": "## Service Discovery & Tracing\n\n### Service Discovery (Phase 7)\n\n```prolog\n:- declare_discovery(ml_service, [\n    backend(consul),\n    service_name('ml-predictor'),\n    tags([ml, gpu])\n]).\n```\n\n**Backends:** Consul, etcd, DNS\n\n### Distributed Tracing (Phase 8)\n\n```prolog\n:- declare_tracing([\n    backend(jaeger),\n    propagation(w3c),  % or: b3\n    sample_rate(0.1)\n]).\n```\n\n**Propagation:** W3C Trace Context, B3 (Zipkin)\n\n### Trace Correlation\n\nAll generated code includes trace ID propagation:\n\n```go\nctx = context.WithValue(ctx, \"trace_id\", traceID)\n```", "answer_tailored": true}
{"pair_id": "b7-c12d-kg-topology_p0", "cluster_id": "b7-c12d-kg-topology", "question": "What is KG Topology?", "question_type": "medium", "answer": "KG Topology refers to the network structure of UnifyWeaver's knowledge graph, which organizes expert system nodes across semantic domains. The topology uses Kleinberg small-world routing to efficiently navigate between nodes based on their semantic similarity in embedding space.\n\nKey aspects:\n\n**Multi-Interface Nodes**: A single expert system can handle multiple related semantic domains. For example, a CSV expert node might serve queries about CSV files, delimited data, and tabular formats:\n\n```prolog\nservice(csv_expert_node, [\n    discovery_metadata([\n        semantic_centroid(\"base64_vector...\"),\n        interface_topics([csv, delimited, tabular])\n    ]),\n    routing(kleinberg([\n        alpha(2.0),\n        max_hops(10),\n        path_folding(true)\n    ]))\n]).\n```\n\n**Kleinberg Routing**: The system uses small-world routing principles where:\n- Each node has a position determined by its interface centroid in embedding space\n- Queries route greedily toward nodes with the most similar centroids\n- Path folding creates dynamic shortcuts after successful matches\n- HTL (hop-to-live) limits prevent infinite traversal\n\nSee education/book-07-cross-target-glue/12d_kg_topology.md for the complete specification.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12d_kg_topology.md", "topics": ["knowledge-graph", "kleinberg-routing", "semantic-search"], "original_answer": "## Knowledge Graph Topology\n\n### Multi-Interface Nodes\n\nOne expert system can serve multiple semantic domains:\n\n```prolog\nservice(csv_expert_node, [\n    discovery_metadata([\n        semantic_centroid(\"base64_vector...\"),\n        interface_topics([csv, delimited, tabular])\n    ]),\n    routing(kleinberg([\n        alpha(2.0),\n        max_hops(10),\n        path_folding(true)\n    ]))\n]).\n```\n\n### Kleinberg Small-World Routing\n\n| Concept | Application |\n|---------|-------------|\n| Node location | Interface centroid in embedding space |\n| Greedy routing | Forward to most similar centroid |\n| Path folding | Dynamic shortcuts after matches |\n| HTL | Maximum hops before giving up |", "answer_tailored": true}
{"pair_id": "b7-c12d-kg-topology_p1", "cluster_id": "b7-c12d-kg-topology", "question": "How does Kleinberg routing work?", "question_type": "medium", "answer": "Kleinberg routing uses a greedy algorithm in embedding space to navigate between nodes in the knowledge graph. Each node has a location defined by its interface centroid (semantic embedding). When routing a query, the system forwards it to the neighbor with the most similar centroid vector, progressively moving closer to the target. The algorithm includes a hop-to-live (HTL) limit that defines the maximum number of hops before giving up, and supports path folding which creates dynamic shortcuts after successful matches to optimize future queries. You can configure these parameters in the service definition using `routing(kleinberg([alpha(2.0), max_hops(10), path_folding(true)]))`.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12d_kg_topology.md", "topics": ["knowledge-graph", "kleinberg-routing", "semantic-search"], "original_answer": "## Knowledge Graph Topology\n\n### Multi-Interface Nodes\n\nOne expert system can serve multiple semantic domains:\n\n```prolog\nservice(csv_expert_node, [\n    discovery_metadata([\n        semantic_centroid(\"base64_vector...\"),\n        interface_topics([csv, delimited, tabular])\n    ]),\n    routing(kleinberg([\n        alpha(2.0),\n        max_hops(10),\n        path_folding(true)\n    ]))\n]).\n```\n\n### Kleinberg Small-World Routing\n\n| Concept | Application |\n|---------|-------------|\n| Node location | Interface centroid in embedding space |\n| Greedy routing | Forward to most similar centroid |\n| Path folding | Dynamic shortcuts after matches |\n| HTL | Maximum hops before giving up |", "answer_tailored": true}
{"pair_id": "b7-c12d-kg-topology_p2", "cluster_id": "b7-c12d-kg-topology", "question": "What are multi-interface semantic nodes?", "question_type": "medium", "answer": "Multi-interface semantic nodes are expert system services in UnifyWeaver that can handle multiple related topic domains simultaneously. Instead of having separate services for each concept, a single node can advertise expertise across several semantic areas.\n\nFor example, a CSV expert node can declare proficiency in \"csv\", \"delimited\", and \"tabular\" data processing through its `interface_topics` list. The node defines a semantic centroid (its position in embedding space) and can use Kleinberg small-world routing to efficiently forward queries it can't handle to more appropriate nodes.\n\nThis approach leverages greedy routing based on centroid similarity, with features like path folding for dynamic shortcuts and hop-to-live (HTL) limits. The routing strategy positions each node by its interface centroid in the embedding space, forwarding requests to the most semantically similar service available.\n\nFor more details on knowledge graph topology and routing strategies, see education/book-07-cross-target-glue/12d_kg_topology.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/12d_kg_topology.md", "topics": ["knowledge-graph", "kleinberg-routing", "semantic-search"], "original_answer": "## Knowledge Graph Topology\n\n### Multi-Interface Nodes\n\nOne expert system can serve multiple semantic domains:\n\n```prolog\nservice(csv_expert_node, [\n    discovery_metadata([\n        semantic_centroid(\"base64_vector...\"),\n        interface_topics([csv, delimited, tabular])\n    ]),\n    routing(kleinberg([\n        alpha(2.0),\n        max_hops(10),\n        path_folding(true)\n    ]))\n]).\n```\n\n### Kleinberg Small-World Routing\n\n| Concept | Application |\n|---------|-------------|\n| Node location | Interface centroid in embedding space |\n| Greedy routing | Forward to most similar centroid |\n| Path folding | Dynamic shortcuts after matches |\n| HTL | Maximum hops before giving up |", "answer_tailored": true}
