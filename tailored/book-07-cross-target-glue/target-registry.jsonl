{"pair_id": "b7-c3-target-registry_p0", "cluster_id": "b7-c3-target-registry", "question": "What is the target registry?", "question_type": "medium", "answer": "The target registry is a system component that manages metadata about compilation targets, organizing them into runtime families and tracking predicate mappings. It provides APIs to register new targets, query which family a target belongs to (e.g., shell, dotnet, or native), check if two targets share the same family, and determine default locations and transport mechanisms for cross-target communication.\n\nKey operations include:\n- `register_target/3` - Add a new target to the registry\n- `target_family/2` - Look up which family a target belongs to\n- `targets_same_family/2` - Verify if targets share a runtime family\n- `default_location/2` and `default_transport/3` - Configure deployment and communication defaults\n\nTargets are declared using directives like `:- declare_target(analyze/2, python).` with optional settings for format, location, and timeout. Built-in families group related targets: shell family (bash, awk, sed, perl), dotnet family (csharp, powershell, ironpython), and native family (go, rust, c).\n\nSee education/book-07-cross-target-glue/03_target_registry.md for the complete specification.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["target-registry", "declare-target", "target-mapping"], "original_answer": "## Target Registry\n\nThe target registry manages target metadata, runtime families, and predicate mappings.\n\n### API\n\n```prolog\n:- module(target_registry, [\n    register_target/3,      % Register a new target\n    target_family/2,        % Query target's family\n    targets_same_family/2,  % Check family membership\n    default_location/2,     % Default location for target\n    default_transport/3     % Default transport between locations\n]).\n```\n\n### Declaring Targets\n\n```prolog\n% Basic declaration\n:- declare_target(analyze/2, python).\n\n% With options\n:- declare_target(analyze/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\n### Built-in Families\n\n| Family | Targets |\n|--------|--------|\n| shell | bash, awk, sed, perl |\n| dotnet | csharp, powershell, ironpython |\n| native | go, rust, c |", "answer_tailored": true}
{"pair_id": "b7-c3-target-registry_p1", "cluster_id": "b7-c3-target-registry", "question": "How do I declare a target for a predicate?", "question_type": "medium", "answer": "To declare a target for a predicate, use the `declare_target/2` or `declare_target/3` directive:\n\n```prolog\n% Simple declaration\n:- declare_target(analyze/2, python).\n\n% With additional options\n:- declare_target(analyze/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\nThe first argument is the predicate indicator (Name/Arity), the second is the target language (python, bash, go, rust, csharp, powershell, etc.), and the optional third argument contains configuration options like data format, execution location, and timeout settings.\n\nThese declarations are managed by the target registry module, which tracks target metadata, runtime families, and predicate mappings. The registry groups related targets into families - for example, shell family includes bash, awk, sed, and perl; dotnet family includes csharp, powershell, and ironpython; and native family includes go, rust, and c.\n\nFor more details on cross-target glue and the target registry API, see education/book-07-cross-target-glue/03_target_registry.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["target-registry", "declare-target", "target-mapping"], "original_answer": "## Target Registry\n\nThe target registry manages target metadata, runtime families, and predicate mappings.\n\n### API\n\n```prolog\n:- module(target_registry, [\n    register_target/3,      % Register a new target\n    target_family/2,        % Query target's family\n    targets_same_family/2,  % Check family membership\n    default_location/2,     % Default location for target\n    default_transport/3     % Default transport between locations\n]).\n```\n\n### Declaring Targets\n\n```prolog\n% Basic declaration\n:- declare_target(analyze/2, python).\n\n% With options\n:- declare_target(analyze/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\n### Built-in Families\n\n| Family | Targets |\n|--------|--------|\n| shell | bash, awk, sed, perl |\n| dotnet | csharp, powershell, ironpython |\n| native | go, rust, c |", "answer_tailored": true}
{"pair_id": "b7-c3-target-registry_p2", "cluster_id": "b7-c3-target-registry", "question": "What is declare_target/3?", "question_type": "medium", "answer": "`declare_target/3` is a directive used to specify which target language a particular predicate should compile to, along with optional configuration settings.\n\n### Basic Usage\n\n```prolog\n% Simple declaration - predicate analyze/2 compiles to Python\n:- declare_target(analyze/2, python).\n```\n\n### With Options\n\nYou can provide additional configuration through the third argument:\n\n```prolog\n:- declare_target(analyze/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\nThis directive is part of the target registry system, which manages target metadata and runtime families. The target registry module (`target_registry`) provides related predicates like `register_target/3` for programmatic registration, `target_family/2` for querying a target's family, and `targets_same_family/2` for checking family membership.\n\nFor more details on the target registry system and cross-target capabilities, see education/book-07-cross-target-glue/03_target_registry.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["target-registry", "declare-target", "target-mapping"], "original_answer": "## Target Registry\n\nThe target registry manages target metadata, runtime families, and predicate mappings.\n\n### API\n\n```prolog\n:- module(target_registry, [\n    register_target/3,      % Register a new target\n    target_family/2,        % Query target's family\n    targets_same_family/2,  % Check family membership\n    default_location/2,     % Default location for target\n    default_transport/3     % Default transport between locations\n]).\n```\n\n### Declaring Targets\n\n```prolog\n% Basic declaration\n:- declare_target(analyze/2, python).\n\n% With options\n:- declare_target(analyze/2, python, [\n    format(json),\n    location(local_process),\n    timeout(30)\n]).\n```\n\n### Built-in Families\n\n| Family | Targets |\n|--------|--------|\n| shell | bash, awk, sed, perl |\n| dotnet | csharp, powershell, ironpython |\n| native | go, rust, c |", "answer_tailored": true}
{"pair_id": "b7-c3-location-resolution_p0", "cluster_id": "b7-c3-location-resolution", "question": "How does location resolution work?", "question_type": "medium", "answer": "Location resolution in UnifyWeaver determines where and how cross-target predicates execute based on declared constraints and defaults. When you specify `declare_location/2`, you can force predicates to run on remote hosts or in separate processes:\n\n```prolog\n% Execute on remote machine\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n\n% Run in isolated process\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\nThe resolution follows a hierarchy of rules:\n\n1. **Same target family, local execution** \u2192 Runs in-process (when the target supports it)\n2. **Different target families, local execution** \u2192 Uses pipes for inter-process communication\n3. **Remote execution** \u2192 Uses HTTP or socket transport\n\nYou can control resolution granularity through the override hierarchy:\n\n```prolog\n% Basic: Accept defaults\n:- declare_target(analyze/2, python).\n\n% Moderate: Specify data format\n:- declare_target(analyze/2, python, [format(json)]).\n\n% Advanced: Fine-grained control\n:- declare_target(analyze/2, python, [\n    format(json), location(local_process), timeout(30), retry(3)\n]).\n```\n\nFor more details on cross-target execution patterns, see education/book-07-cross-target-glue/.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["location", "transport", "resolution"], "original_answer": "## Location and Transport Resolution\n\n### Location Declarations\n\n```prolog\n% Force remote execution\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n\n% Force separate process\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\n### Resolution Rules\n\n1. **Same family, local** \u2192 In-process (if supported)\n2. **Different family, local** \u2192 Pipes\n3. **Remote** \u2192 HTTP/socket\n\n### Override Hierarchy\n\n```prolog\n% Level 1: Just works (defaults)\n:- declare_target(analyze/2, python).\n\n% Level 2: Specify format\n:- declare_target(analyze/2, python, [format(json)]).\n\n% Level 3: Full control\n:- declare_target(analyze/2, python, [\n    format(json), location(local_process), timeout(30), retry(3)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c3-location-resolution_p1", "cluster_id": "b7-c3-location-resolution", "question": "What is declare_location/2?", "question_type": "medium", "answer": "`declare_location/2` is a Prolog directive in UnifyWeaver that overrides default execution location and transport for a predicate. It forces specific deployment decisions regardless of target compatibility.\n\n**Basic syntax:**\n```prolog\n:- declare_location(Predicate/Arity, Options).\n```\n\n**Common use cases:**\n\nForce remote execution on a specific host:\n```prolog\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n```\n\nForce separate process execution:\n```prolog\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\n**How it relates to target declarations:**\n\n`declare_location/2` provides more control than basic `declare_target/2`. The hierarchy is:\n\n1. `declare_target(analyze/2, python)` - uses defaults\n2. `declare_target(analyze/2, python, [format(json)])` - specifies format\n3. `declare_location(analyze/2, [...])` - full control over location, transport, timeout, retry\n\nWithout explicit location declarations, UnifyWeaver applies default resolution rules: same-family targets run in-process when possible, different-family local targets communicate via pipes, and remote predicates use HTTP or sockets.\n\nSee education/book-07-cross-target-glue/03_target_registry.md for complete details on location and transport resolution.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["location", "transport", "resolution"], "original_answer": "## Location and Transport Resolution\n\n### Location Declarations\n\n```prolog\n% Force remote execution\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n\n% Force separate process\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\n### Resolution Rules\n\n1. **Same family, local** \u2192 In-process (if supported)\n2. **Different family, local** \u2192 Pipes\n3. **Remote** \u2192 HTTP/socket\n\n### Override Hierarchy\n\n```prolog\n% Level 1: Just works (defaults)\n:- declare_target(analyze/2, python).\n\n% Level 2: Specify format\n:- declare_target(analyze/2, python, [format(json)]).\n\n% Level 3: Full control\n:- declare_target(analyze/2, python, [\n    format(json), location(local_process), timeout(30), retry(3)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c3-location-resolution_p2", "cluster_id": "b7-c3-location-resolution", "question": "How do I specify remote execution?", "question_type": "medium", "answer": "To specify remote execution in UnifyWeaver, use `declare_location/2` with host and transport details:\n\n```prolog\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n```\n\nThis forces the predicate to execute on the specified remote host. You can also control process separation locally:\n\n```prolog\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\nUnifyWeaver automatically resolves the transport mechanism based on location:\n- Same target family, local \u2192 In-process (when supported)\n- Different target family, local \u2192 Pipes\n- Remote \u2192 HTTP/socket\n\nFor fine-grained control, combine location with target declarations:\n\n```prolog\n:- declare_target(analyze/2, python, [\n    format(json), \n    location(local_process), \n    timeout(30), \n    retry(3)\n]).\n```\n\nSee education/book-07-cross-target-glue/03_target_registry.md for complete details on location and transport configuration.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/03_target_registry.md", "topics": ["location", "transport", "resolution"], "original_answer": "## Location and Transport Resolution\n\n### Location Declarations\n\n```prolog\n% Force remote execution\n:- declare_location(heavy_compute/2, [\n    host('gpu-worker.local'),\n    port(8080),\n    transport(http)\n]).\n\n% Force separate process\n:- declare_location(memory_hungry/2, [\n    process(separate)\n]).\n```\n\n### Resolution Rules\n\n1. **Same family, local** \u2192 In-process (if supported)\n2. **Different family, local** \u2192 Pipes\n3. **Remote** \u2192 HTTP/socket\n\n### Override Hierarchy\n\n```prolog\n% Level 1: Just works (defaults)\n:- declare_target(analyze/2, python).\n\n% Level 2: Specify format\n:- declare_target(analyze/2, python, [format(json)]).\n\n% Level 3: Full control\n:- declare_target(analyze/2, python, [\n    format(json), location(local_process), timeout(30), retry(3)\n]).\n```", "answer_tailored": true}
