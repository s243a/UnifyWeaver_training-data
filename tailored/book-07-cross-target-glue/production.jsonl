{"pair_id": "b7-c15-deployment_p0", "cluster_id": "b7-c15-deployment", "question": "How do I deploy cross-target services?", "question_type": "medium", "answer": "To deploy cross-target services in UnifyWeaver, you'll configure service declarations, security, and monitoring settings in your Prolog source.\n\n**Service Configuration**\n\nDeclare your service with deployment parameters:\n\n```prolog\n:- declare_service(transform/2, [\n    port(8080),\n    workers(4),\n    healthcheck('/health')\n]).\n```\n\n**Security Setup**\n\nEnforce encryption and authentication for remote connections:\n\n```prolog\n:- declare_connection(client, server, [\n    encryption(tls),     % Required for remote\n    auth(bearer_token)\n]).\n```\n\n**Operational Features**\n\nThe deployment system handles graceful shutdown with connection draining, supports rolling restarts, and provides built-in health check endpoints.\n\n**Monitoring Integration**\n\nConfigure observability tools:\n\n```prolog\n:- monitoring([\n    metrics(prometheus),\n    logging(json),\n    alerting(pagerduty)\n]).\n```\n\nFor comprehensive deployment patterns and examples, see education/book-07-cross-target-glue/15_deployment_production.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/15_deployment_production.md", "topics": ["deployment", "security", "monitoring"], "original_answer": "## Production Deployment\n\n### Service Declarations\n\n```prolog\n:- declare_service(transform/2, [\n    port(8080),\n    workers(4),\n    healthcheck('/health')\n]).\n```\n\n### Security Enforcement\n\n```prolog\n:- declare_connection(client, server, [\n    encryption(tls),     % Required for remote\n    auth(bearer_token)\n]).\n```\n\n### Lifecycle Management\n\n- Graceful shutdown (drain connections)\n- Rolling restarts\n- Health checks\n\n### Monitoring\n\n```prolog\n:- monitoring([\n    metrics(prometheus),\n    logging(json),\n    alerting(pagerduty)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c15-deployment_p1", "cluster_id": "b7-c15-deployment", "question": "How does security enforcement work?", "question_type": "medium", "answer": "Security enforcement in UnifyWeaver uses connection declarations to specify requirements between components. The `declare_connection/3` predicate defines security policies such as encryption and authentication methods. For example, connections can mandate TLS encryption for remote communications and specify authentication mechanisms like bearer tokens. These declarations ensure that data flow between client and server components meets defined security standards. Connection security is enforced at the infrastructure level during deployment, preventing insecure communications from being established. For production deployment patterns and service configuration, see education/book-07-cross-target-glue/15_deployment_production.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/15_deployment_production.md", "topics": ["deployment", "security", "monitoring"], "original_answer": "## Production Deployment\n\n### Service Declarations\n\n```prolog\n:- declare_service(transform/2, [\n    port(8080),\n    workers(4),\n    healthcheck('/health')\n]).\n```\n\n### Security Enforcement\n\n```prolog\n:- declare_connection(client, server, [\n    encryption(tls),     % Required for remote\n    auth(bearer_token)\n]).\n```\n\n### Lifecycle Management\n\n- Graceful shutdown (drain connections)\n- Rolling restarts\n- Health checks\n\n### Monitoring\n\n```prolog\n:- monitoring([\n    metrics(prometheus),\n    logging(json),\n    alerting(pagerduty)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c15-deployment_p2", "cluster_id": "b7-c15-deployment", "question": "What monitoring is available?", "question_type": "medium", "answer": "UnifyWeaver provides monitoring through declarative configuration. You can specify metrics collection (e.g., Prometheus format), structured logging (JSON output), and alerting integrations (such as PagerDuty) using the `monitoring/1` directive:\n\n```prolog\n:- monitoring([\n    metrics(prometheus),\n    logging(json),\n    alerting(pagerduty)\n]).\n```\n\nThese monitoring capabilities work alongside service health checks and lifecycle management features. The deployment system also supports graceful shutdown, rolling restarts, and healthcheck endpoints defined in service declarations. For complete deployment configuration details, see education/book-07-cross-target-glue/15_deployment_production.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/15_deployment_production.md", "topics": ["deployment", "security", "monitoring"], "original_answer": "## Production Deployment\n\n### Service Declarations\n\n```prolog\n:- declare_service(transform/2, [\n    port(8080),\n    workers(4),\n    healthcheck('/health')\n]).\n```\n\n### Security Enforcement\n\n```prolog\n:- declare_connection(client, server, [\n    encryption(tls),     % Required for remote\n    auth(bearer_token)\n]).\n```\n\n### Lifecycle Management\n\n- Graceful shutdown (drain connections)\n- Rolling restarts\n- Health checks\n\n### Monitoring\n\n```prolog\n:- monitoring([\n    metrics(prometheus),\n    logging(json),\n    alerting(pagerduty)\n]).\n```", "answer_tailored": true}
{"pair_id": "b7-c16-cloud-enterprise_p0", "cluster_id": "b7-c16-cloud-enterprise", "question": "How do I deploy to Kubernetes?", "question_type": "medium", "answer": "UnifyWeaver can generate Kubernetes manifests for your Prolog predicates. Use `generate_k8s_manifest/3` to create deployment YAML:\n\n```prolog\ngenerate_k8s_manifest(service/2, Options, YAML).\n```\n\nYou'll also want to containerize your service first:\n\n```prolog\ngenerate_dockerfile(service/2, Options, Dockerfile).\n```\n\nThe Options parameter lets you configure replicas, resource limits, service types, and other K8s settings. For secret management in Kubernetes deployments, UnifyWeaver integrates with Vault, AWS Secrets Manager, Azure Key Vault, and GCP Secret Manager:\n\n```prolog\n:- secrets_backend(vault, [\n    addr('https://vault.example.com'),\n    path('secret/data/myapp')\n]).\n```\n\nFor more on cloud deployment patterns, see education/book-07-cross-target-glue/16_cloud_enterprise.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/16_cloud_enterprise.md", "topics": ["docker", "kubernetes", "serverless"], "original_answer": "## Cloud & Enterprise Deployment\n\n### Container Deployment\n\n```prolog\ngenerate_dockerfile(service/2, Options, Dockerfile).\ngenerate_k8s_manifest(service/2, Options, YAML).\n```\n\n### Secrets Management\n\n```prolog\n:- secrets_backend(vault, [\n    addr('https://vault.example.com'),\n    path('secret/data/myapp')\n]).\n\n% Also supports: AWS Secrets Manager, Azure Key Vault, GCP Secret Manager\n```\n\n### Serverless Functions\n\n```prolog\n% Generate AWS Lambda handler\ngenerate_lambda_handler(transform/2, Options, Handler).\n\n% Generate Google Cloud Function\ngenerate_gcf_handler(transform/2, Options, Handler).\n\n% Generate Azure Function\ngenerate_azure_function(transform/2, Options, Handler).\n```", "answer_tailored": true}
{"pair_id": "b7-c16-cloud-enterprise_p1", "cluster_id": "b7-c16-cloud-enterprise", "question": "How does secrets management work?", "question_type": "medium", "answer": "UnifyWeaver provides flexible secrets management through multiple backend integrations. You configure a secrets backend using directives like:\n\n```prolog\n:- secrets_backend(vault, [\n    addr('https://vault.example.com'),\n    path('secret/data/myapp')\n]).\n```\n\nThis example uses HashiCorp Vault, but the system also supports AWS Secrets Manager, Azure Key Vault, and GCP Secret Manager. The compiler integrates these backends into generated code, ensuring credentials and sensitive data are retrieved securely at runtime rather than being hardcoded.\n\nFor more details on cloud deployment patterns including secrets handling, see education/book-07-cross-target-glue/16_cloud_enterprise.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/16_cloud_enterprise.md", "topics": ["docker", "kubernetes", "serverless"], "original_answer": "## Cloud & Enterprise Deployment\n\n### Container Deployment\n\n```prolog\ngenerate_dockerfile(service/2, Options, Dockerfile).\ngenerate_k8s_manifest(service/2, Options, YAML).\n```\n\n### Secrets Management\n\n```prolog\n:- secrets_backend(vault, [\n    addr('https://vault.example.com'),\n    path('secret/data/myapp')\n]).\n\n% Also supports: AWS Secrets Manager, Azure Key Vault, GCP Secret Manager\n```\n\n### Serverless Functions\n\n```prolog\n% Generate AWS Lambda handler\ngenerate_lambda_handler(transform/2, Options, Handler).\n\n% Generate Google Cloud Function\ngenerate_gcf_handler(transform/2, Options, Handler).\n\n% Generate Azure Function\ngenerate_azure_function(transform/2, Options, Handler).\n```", "answer_tailored": true}
{"pair_id": "b7-c16-cloud-enterprise_p2", "cluster_id": "b7-c16-cloud-enterprise", "question": "Can I use serverless functions?", "question_type": "medium", "answer": "Yes, UnifyWeaver supports serverless deployment. You can generate handlers for major cloud providers:\n\n```prolog\n% AWS Lambda\ngenerate_lambda_handler(transform/2, Options, Handler).\n\n% Google Cloud Functions\ngenerate_gcf_handler(transform/2, Options, Handler).\n\n% Azure Functions\ngenerate_azure_function(transform/2, Options, Handler).\n```\n\nThese predicates compile your Prolog logic into platform-specific serverless handlers. UnifyWeaver also provides container deployment options (`generate_dockerfile/3`, `generate_k8s_manifest/3`) and integrates with secrets management systems like Vault, AWS Secrets Manager, Azure Key Vault, and GCP Secret Manager for secure credential handling in cloud environments.\n\nFor more details on cloud deployment patterns, see education/book-07-cross-target-glue/16_cloud_enterprise.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/16_cloud_enterprise.md", "topics": ["docker", "kubernetes", "serverless"], "original_answer": "## Cloud & Enterprise Deployment\n\n### Container Deployment\n\n```prolog\ngenerate_dockerfile(service/2, Options, Dockerfile).\ngenerate_k8s_manifest(service/2, Options, YAML).\n```\n\n### Secrets Management\n\n```prolog\n:- secrets_backend(vault, [\n    addr('https://vault.example.com'),\n    path('secret/data/myapp')\n]).\n\n% Also supports: AWS Secrets Manager, Azure Key Vault, GCP Secret Manager\n```\n\n### Serverless Functions\n\n```prolog\n% Generate AWS Lambda handler\ngenerate_lambda_handler(transform/2, Options, Handler).\n\n% Generate Google Cloud Function\ngenerate_gcf_handler(transform/2, Options, Handler).\n\n% Generate Azure Function\ngenerate_azure_function(transform/2, Options, Handler).\n```", "answer_tailored": true}
{"pair_id": "b7-c14-case-studies_p0", "cluster_id": "b7-c14-case-studies", "question": "What are real-world use cases for cross-target glue?", "question_type": "medium", "answer": "Cross-target glue enables several powerful real-world scenarios in UnifyWeaver:\n\n**ETL Pipeline (Bash + AWK + Python + SQL)**\nData flows from Bash's curl for fetching, through AWK for filtering, into Python's pandas for transformation, and finally to SQL for loading. Each target handles what it does best.\n\n**Enterprise .NET Integration (C# + PowerShell + IronPython)**\nPowerShell orchestrates the workflow, calling into C# for business logic (in-process), which then invokes IronPython for ML model execution. This demonstrates mixed-language integration within the .NET ecosystem.\n\n**High-Performance Computing (Go + Rust)**\nGo spawns 8 goroutines for parallel parsing, passes data to Rust for SIMD-vectorized transformations, then aggregates results back in Go. This combines Go's concurrency with Rust's low-level performance.\n\n**Microservices Architecture (Distributed HTTP)**\nA Go service and Rust service communicate via HTTP/JSON, each managing its own local database or cache. This shows how UnifyWeaver supports distributed system patterns.\n\nFor implementation details on cross-target communication mechanisms, see education/book-07-cross-target-glue/.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/14_case_studies.md", "topics": ["case-studies", "etl", "microservices"], "original_answer": "## Case Studies\n\n### ETL Pipeline: Bash + AWK + Python + SQL\n\n```\nBash (curl) \u2192 AWK (filter) \u2192 Python (pandas) \u2192 SQL (load)\n```\n\n### .NET Integration: C# + PowerShell + IronPython\n\n```\nPowerShell (orchestration)\n     \u2193 (in-process)\nC# (business logic)\n     \u2193 (in-process)\nIronPython (ML model)\n```\n\n### High-Performance: Go + Rust\n\n```\nGo (parallel parse) \u2192 Rust (SIMD transform) \u2192 Go (aggregate)\n     8 goroutines          vectorized           merge results\n```\n\n### Microservices: Distributed HTTP\n\n```\nGo Service A \u2190\u2500\u2500HTTP/JSON\u2500\u2500\u2192 Rust Service B\n      \u2193                            \u2193\n   Local DB                   Local Cache\n```", "answer_tailored": true}
{"pair_id": "b7-c14-case-studies_p1", "cluster_id": "b7-c14-case-studies", "question": "How do I build an ETL pipeline?", "question_type": "medium", "answer": "To build an ETL pipeline with UnifyWeaver, you can orchestrate multiple target languages in sequence. A typical pattern uses Bash for extraction (curl to fetch data), AWK for filtering, Python with pandas for transformation, and SQL for loading into a database:\n\n```\nBash (curl) \u2192 AWK (filter) \u2192 Python (pandas) \u2192 SQL (load)\n```\n\nThis approach leverages each language's strengths: Bash handles HTTP requests and process orchestration, AWK performs lightweight text processing, Python provides rich data transformation capabilities through pandas, and SQL executes efficient bulk inserts.\n\nFor high-throughput scenarios, consider a Go + Rust pipeline where Go handles parallel parsing across multiple goroutines, Rust applies SIMD-accelerated transformations, and Go performs final aggregation. For .NET environments, PowerShell can orchestrate in-process calls between C# business logic and IronPython ML models.\n\nSee education/book-07-cross-target-glue/14_case_studies.md for complete examples of cross-language pipeline patterns.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/14_case_studies.md", "topics": ["case-studies", "etl", "microservices"], "original_answer": "## Case Studies\n\n### ETL Pipeline: Bash + AWK + Python + SQL\n\n```\nBash (curl) \u2192 AWK (filter) \u2192 Python (pandas) \u2192 SQL (load)\n```\n\n### .NET Integration: C# + PowerShell + IronPython\n\n```\nPowerShell (orchestration)\n     \u2193 (in-process)\nC# (business logic)\n     \u2193 (in-process)\nIronPython (ML model)\n```\n\n### High-Performance: Go + Rust\n\n```\nGo (parallel parse) \u2192 Rust (SIMD transform) \u2192 Go (aggregate)\n     8 goroutines          vectorized           merge results\n```\n\n### Microservices: Distributed HTTP\n\n```\nGo Service A \u2190\u2500\u2500HTTP/JSON\u2500\u2500\u2192 Rust Service B\n      \u2193                            \u2193\n   Local DB                   Local Cache\n```", "answer_tailored": true}
{"pair_id": "b7-c14-case-studies_p2", "cluster_id": "b7-c14-case-studies", "question": "How do I build microservices with UnifyWeaver?", "question_type": "medium", "answer": "UnifyWeaver supports building microservices through distributed HTTP communication between services written in different target languages. The typical architecture involves independent services (e.g., a Go service and a Rust service) communicating via HTTP/JSON APIs, with each service managing its own local resources like databases or caches.\n\nFor example, you might have Service A written in Go handling web requests and maintaining a local database, while Service B in Rust performs high-performance computations with its own cache layer. These services communicate through standard HTTP/JSON interfaces, allowing you to leverage each language's strengths while maintaining service isolation.\n\nThis approach gives you:\n- Language-specific optimization (Go for concurrency, Rust for performance-critical paths)\n- Independent deployment and scaling of each service\n- Clear service boundaries with HTTP APIs\n- Local resource management per service\n\nYou can also combine this with other integration patterns. For instance, a Go service might use parallel goroutines for request handling, while a Rust service uses SIMD vectorization for data processing. See education/book-07-cross-target-glue/ for more details on cross-target communication patterns and integration strategies.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/14_case_studies.md", "topics": ["case-studies", "etl", "microservices"], "original_answer": "## Case Studies\n\n### ETL Pipeline: Bash + AWK + Python + SQL\n\n```\nBash (curl) \u2192 AWK (filter) \u2192 Python (pandas) \u2192 SQL (load)\n```\n\n### .NET Integration: C# + PowerShell + IronPython\n\n```\nPowerShell (orchestration)\n     \u2193 (in-process)\nC# (business logic)\n     \u2193 (in-process)\nIronPython (ML model)\n```\n\n### High-Performance: Go + Rust\n\n```\nGo (parallel parse) \u2192 Rust (SIMD transform) \u2192 Go (aggregate)\n     8 goroutines          vectorized           merge results\n```\n\n### Microservices: Distributed HTTP\n\n```\nGo Service A \u2190\u2500\u2500HTTP/JSON\u2500\u2500\u2192 Rust Service B\n      \u2193                            \u2193\n   Local DB                   Local Cache\n```", "answer_tailored": true}
