{"pair_id": "b7-c1-cross-target-overview_p0", "cluster_id": "b7-c1-cross-target-overview", "question": "What is cross-target glue?", "question_type": "medium", "answer": "## Cross-Target Glue Overview\n\nCross-target glue enables predicates compiled to different languages to communicate seamlessly.\n\n### The Unix Philosophy Extended\n\n```\nTraditional Unix:    grep | sort | uniq | wc\nCross-target glue:   awk_filter | python_transform | go_aggregate | sql_store\n```\n\n### Location and Transport Model\n\n| Location | Description |\n|----------|-------------|\n| `in_process` | Same runtime (C# calling PowerShell) |\n| `local_process` | Separate process, same machine (pipes) |\n| `remote(Host)` | Different machine (network) |\n\n| Transport | Use Case |\n|-----------|----------|\n| `direct` | Function call (in-process) |\n| `pipe` | Unix pipes with TSV/JSON |\n| `http` | REST API calls |", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["cross-target-glue", "multi-language", "pipelines"], "answer_tailored": false}
{"pair_id": "b7-c1-cross-target-overview_p1", "cluster_id": "b7-c1-cross-target-overview", "question": "Why do I need multi-language pipelines?", "question_type": "medium", "answer": "## Cross-Target Glue Overview\n\nCross-target glue enables predicates compiled to different languages to communicate seamlessly.\n\n### The Unix Philosophy Extended\n\n```\nTraditional Unix:    grep | sort | uniq | wc\nCross-target glue:   awk_filter | python_transform | go_aggregate | sql_store\n```\n\n### Location and Transport Model\n\n| Location | Description |\n|----------|-------------|\n| `in_process` | Same runtime (C# calling PowerShell) |\n| `local_process` | Separate process, same machine (pipes) |\n| `remote(Host)` | Different machine (network) |\n\n| Transport | Use Case |\n|-----------|----------|\n| `direct` | Function call (in-process) |\n| `pipe` | Unix pipes with TSV/JSON |\n| `http` | REST API calls |", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["cross-target-glue", "multi-language", "pipelines"], "answer_tailored": false}
{"pair_id": "b7-c1-cross-target-overview_p2", "cluster_id": "b7-c1-cross-target-overview", "question": "How does UnifyWeaver connect different targets?", "question_type": "medium", "answer": "UnifyWeaver connects different targets through its cross-target glue system, which allows predicates compiled to various languages to communicate seamlessly. This extends the Unix philosophy of piping commands together\u2014instead of just `grep | sort | uniq`, you can chain together predicates like `awk_filter | python_transform | go_aggregate | sql_store`.\n\nThe connection mechanism uses a **location and transport model**:\n\n**Locations** specify where code runs:\n- `in_process`: Same runtime environment (e.g., C# calling PowerShell within the same process)\n- `local_process`: Separate processes on the same machine, connected via pipes\n- `remote(Host)`: Different machines entirely, connected over the network\n\n**Transports** define how data flows between targets:\n- `direct`: Direct function calls for in-process communication\n- `pipe`: Unix-style pipes carrying TSV or JSON data between processes\n- `http`: REST API calls for remote communication\n\nThis architecture lets you mix and match languages based on their strengths while maintaining clean data flow between components. For comprehensive details and examples, see education/book-07-cross-target-glue/.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["cross-target-glue", "multi-language", "pipelines"], "original_answer": "## Cross-Target Glue Overview\n\nCross-target glue enables predicates compiled to different languages to communicate seamlessly.\n\n### The Unix Philosophy Extended\n\n```\nTraditional Unix:    grep | sort | uniq | wc\nCross-target glue:   awk_filter | python_transform | go_aggregate | sql_store\n```\n\n### Location and Transport Model\n\n| Location | Description |\n|----------|-------------|\n| `in_process` | Same runtime (C# calling PowerShell) |\n| `local_process` | Separate process, same machine (pipes) |\n| `remote(Host)` | Different machine (network) |\n\n| Transport | Use Case |\n|-----------|----------|\n| `direct` | Function call (in-process) |\n| `pipe` | Unix pipes with TSV/JSON |\n| `http` | REST API calls |", "answer_tailored": true}
{"pair_id": "b7-c1-runtime-families_p0", "cluster_id": "b7-c1-runtime-families", "question": "What are runtime families?", "question_type": "medium", "answer": "Runtime families are groups of targets that share a common execution environment, enabling efficient inter-target communication. UnifyWeaver defines several families:\n\n| Family | Targets | Communication Method |\n|--------|---------|---------------------|\n| .NET | C#, PowerShell, IronPython | In-process (zero serialization) |\n| JVM | Java, Scala, Jython | In-process |\n| Shell | Bash, AWK, sed | Pipes |\n| Native | Go, Rust, C | Pipes or shared memory |\n| Python | CPython | Pipes |\n\nWithin a runtime family, targets can exchange data directly without serialization overhead. For instance, C# can invoke PowerShell and receive objects in-process:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\nCross-family calls (like AWK to Python) require serialization since they operate in different runtime environments. This family-aware optimization is a core UnifyWeaver feature for efficient cross-target glue. See education/book-07-cross-target-glue/ for complete details.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["runtime-families", "in-process", "communication"], "original_answer": "## Runtime Families\n\nTargets in the same family can communicate more efficiently:\n\n| Family | Targets | Communication |\n|--------|---------|---------------|\n| .NET | C#, PowerShell, IronPython | In-process (zero serialization) |\n| JVM | Java, Scala, Jython | In-process |\n| Shell | Bash, AWK, sed | Pipes |\n| Native | Go, Rust, C | Pipes or shared memory |\n| Python | CPython | Pipes |\n\n### Example: .NET In-Process\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\n**Key insight**: C# calling PowerShell passes objects directly. AWK calling Python must serialize.", "answer_tailored": true}
{"pair_id": "b7-c1-runtime-families_p1", "cluster_id": "b7-c1-runtime-families", "question": "Which targets can communicate in-process?", "question_type": "medium", "answer": "Targets within the same runtime family can communicate in-process:\n\n- **.NET family** (C#, PowerShell, IronPython): Zero-serialization communication\n- **JVM family** (Java, Scala, Jython): Direct in-process calls\n\nFor example, when C# invokes PowerShell code, objects pass directly without serialization:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // No marshalling needed\n```\n\nIn contrast, targets from different families (like Bash and Python, or Go and Rust) require serialization and typically communicate via pipes or shared memory.\n\nSee education/book-07-cross-target-glue/ for implementation details on cross-target communication patterns.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["runtime-families", "in-process", "communication"], "original_answer": "## Runtime Families\n\nTargets in the same family can communicate more efficiently:\n\n| Family | Targets | Communication |\n|--------|---------|---------------|\n| .NET | C#, PowerShell, IronPython | In-process (zero serialization) |\n| JVM | Java, Scala, Jython | In-process |\n| Shell | Bash, AWK, sed | Pipes |\n| Native | Go, Rust, C | Pipes or shared memory |\n| Python | CPython | Pipes |\n\n### Example: .NET In-Process\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\n**Key insight**: C# calling PowerShell passes objects directly. AWK calling Python must serialize.", "answer_tailored": true}
{"pair_id": "b7-c1-runtime-families_p2", "cluster_id": "b7-c1-runtime-families", "question": "How do .NET targets communicate?", "question_type": "medium", "answer": ".NET targets (C#, PowerShell, and IronPython) communicate in-process with zero serialization overhead. Since they all run on the Common Language Runtime, they can pass objects directly between each other without any marshaling or conversion.\n\nFor example, when C# invokes PowerShell code, it can receive results as typed objects:\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\nThis in-process communication is significantly more efficient than cross-runtime communication (like AWK calling Python), which requires serialization through pipes or other IPC mechanisms. For more details on cross-target communication strategies, see education/book-07-cross-target-glue/.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/01_introduction.md", "topics": ["runtime-families", "in-process", "communication"], "original_answer": "## Runtime Families\n\nTargets in the same family can communicate more efficiently:\n\n| Family | Targets | Communication |\n|--------|---------|---------------|\n| .NET | C#, PowerShell, IronPython | In-process (zero serialization) |\n| JVM | Java, Scala, Jython | In-process |\n| Shell | Bash, AWK, sed | Pipes |\n| Native | Go, Rust, C | Pipes or shared memory |\n| Python | CPython | Pipes |\n\n### Example: .NET In-Process\n\n```csharp\nvar ps = PowerShell.Create();\nps.AddScript(scriptCode);\nvar results = ps.Invoke<OutputType>();  // Direct object passing!\n```\n\n**Key insight**: C# calling PowerShell passes objects directly. AWK calling Python must serialize.", "answer_tailored": true}
{"pair_id": "b7-c2-design-principles_p0", "cluster_id": "b7-c2-design-principles", "question": "What is location transparency?", "question_type": "medium", "answer": "Location transparency means predicates can be called without needing to know where they execute. In UnifyWeaver, you write unified Prolog code where each predicate might run in a different target environment\u2014one in Bash, another in Python, a third as SQL on a remote database\u2014but you call them the same way:\n\n```prolog\nresult(X) :-\n    fetch_data(RawData),      % Maybe Bash/curl\n    analyze(RawData, Result),  % Maybe Python/pandas\n    store(Result, X).          % Maybe SQL on remote DB\n```\n\nThe compiler handles the cross-target communication automatically. This is one of the core design principles detailed in education/book-07-cross-target-glue/02_philosophy.md, which also covers sensible defaults (in-process for same runtime, pipes/TSV for different runtimes, HTTP/JSON for remote) and streaming-by-default for pipeline parallelism.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["location-transparency", "design-principles", "streaming"], "original_answer": "## Cross-Target Design Principles\n\n### 1. Location Transparency\n\nPredicates should be callable regardless of where they execute:\n\n```prolog\nresult(X) :-\n    fetch_data(RawData),      % Maybe Bash/curl\n    analyze(RawData, Result),  % Maybe Python/pandas\n    store(Result, X).          % Maybe SQL on remote DB\n```\n\n### 2. Sensible Defaults with Override\n\n| Scenario | Default |\n|----------|--------|\n| Same runtime family | In-process |\n| Different runtimes | Pipes with TSV |\n| Remote targets | HTTP with JSON |\n\n### 3. Streaming by Default\n\n```bash\n# Works on 100GB with 1MB memory\ncat huge.tsv | awk '{...}' | python3 transform.py | sort\n```\n\nAll stages run concurrently (pipeline parallelism).", "answer_tailored": true}
{"pair_id": "b7-c2-design-principles_p1", "cluster_id": "b7-c2-design-principles", "question": "What are the design principles of cross-target glue?", "question_type": "medium", "answer": "Cross-target glue in UnifyWeaver follows three core design principles:\n\n**Location Transparency**: Predicates can be invoked without needing to know their execution location. For example, in a pipeline where `fetch_data/1` runs as Bash/curl, `analyze/2` uses Python/pandas, and `store/2` executes SQL on a remote database, the calling code remains identical regardless of where each component executes.\n\n**Sensible Defaults with Override Capability**: The system automatically selects appropriate inter-process communication mechanisms based on context. When predicates share the same runtime family, they communicate in-process for efficiency. Different runtimes default to pipes with TSV format, while remote targets use HTTP with JSON. These defaults can be overridden when needed.\n\n**Streaming by Default**: All cross-target operations support streaming to handle large datasets efficiently. Pipeline stages execute concurrently, enabling processing of massive files (e.g., 100GB) with minimal memory footprint through Unix-style pipeline parallelism. This allows commands like `cat huge.tsv | awk '{...}' | python3 transform.py | sort` to process data incrementally rather than loading entire datasets into memory.\n\nFor implementation details and examples, see education/book-07-cross-target-glue/.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["location-transparency", "design-principles", "streaming"], "original_answer": "## Cross-Target Design Principles\n\n### 1. Location Transparency\n\nPredicates should be callable regardless of where they execute:\n\n```prolog\nresult(X) :-\n    fetch_data(RawData),      % Maybe Bash/curl\n    analyze(RawData, Result),  % Maybe Python/pandas\n    store(Result, X).          % Maybe SQL on remote DB\n```\n\n### 2. Sensible Defaults with Override\n\n| Scenario | Default |\n|----------|--------|\n| Same runtime family | In-process |\n| Different runtimes | Pipes with TSV |\n| Remote targets | HTTP with JSON |\n\n### 3. Streaming by Default\n\n```bash\n# Works on 100GB with 1MB memory\ncat huge.tsv | awk '{...}' | python3 transform.py | sort\n```\n\nAll stages run concurrently (pipeline parallelism).", "answer_tailored": true}
{"pair_id": "b7-c2-design-principles_p2", "cluster_id": "b7-c2-design-principles", "question": "Why is streaming the default?", "question_type": "medium", "answer": "Streaming is the default because it enables processing arbitrarily large datasets with minimal memory overhead. When data flows through Unix pipes between different runtime stages (like Bash, Python, or other targets), all processing happens concurrently with pipeline parallelism. This means you can handle files of any size\u2014even 100GB\u2014using only a small constant amount of memory at each stage, rather than loading everything into RAM at once. The streaming model naturally fits UnifyWeaver's cross-target pipeline architecture where predicates executing in different runtimes pass data incrementally rather than buffering complete results.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["location-transparency", "design-principles", "streaming"], "original_answer": "## Cross-Target Design Principles\n\n### 1. Location Transparency\n\nPredicates should be callable regardless of where they execute:\n\n```prolog\nresult(X) :-\n    fetch_data(RawData),      % Maybe Bash/curl\n    analyze(RawData, Result),  % Maybe Python/pandas\n    store(Result, X).          % Maybe SQL on remote DB\n```\n\n### 2. Sensible Defaults with Override\n\n| Scenario | Default |\n|----------|--------|\n| Same runtime family | In-process |\n| Different runtimes | Pipes with TSV |\n| Remote targets | HTTP with JSON |\n\n### 3. Streaming by Default\n\n```bash\n# Works on 100GB with 1MB memory\ncat huge.tsv | awk '{...}' | python3 transform.py | sort\n```\n\nAll stages run concurrently (pipeline parallelism).", "answer_tailored": true}
{"pair_id": "b7-c2-data-formats_p0", "cluster_id": "b7-c2-data-formats", "question": "What data formats does cross-target glue support?", "question_type": "medium", "answer": "Cross-target glue in UnifyWeaver supports two primary data formats for inter-process communication:\n\n**TSV (Tab-Separated Values)** - The default format, chosen for its universal parseability across all target languages, streaming efficiency with line-by-line processing and bounded memory usage, and excellent debuggability with standard Unix tools like `cat`, `head`, and `tail`.\n\n**JSON Lines** - Used when you need nested data structures, self-describing formats, or API compatibility.\n\nYou specify the format in the pipeline generation options:\n\n```prolog\n% TSV (default)\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% JSON Lines  \ngenerate_pipeline(Steps, [format(json)], Script).\n```\n\nFor more details on cross-target glue design principles, see education/book-07-cross-target-glue/02_philosophy.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["tsv", "json", "pipe-protocols"], "original_answer": "## Data Format Selection\n\n### TSV: The Default Choice\n\nTSV is default for pipes because:\n- **Universal**: Every language can parse it\n- **Streaming**: Process line-by-line, bounded memory\n- **Debuggable**: `cat`, `head`, `tail` work perfectly\n\n```\nname    age    city\nAlice   30     NYC\nBob     25     LA\n```\n\n### JSON: For Structure\n\nUse JSON when you need:\n- Nested data structures\n- Self-describing format\n- API compatibility\n\n### Protocol Specification\n\n```prolog\n% TSV (default)\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% JSON Lines\ngenerate_pipeline(Steps, [format(json)], Script).\n```", "answer_tailored": true}
{"pair_id": "b7-c2-data-formats_p1", "cluster_id": "b7-c2-data-formats", "question": "When should I use TSV vs JSON?", "question_type": "medium", "answer": "Use **TSV by default** for data passing between UnifyWeaver pipeline stages. TSV is the recommended format because it's universally parseable across all target languages (Bash, Python, Go, Rust, C#, PowerShell, SQL), supports streaming with bounded memory usage, and is easily debuggable with standard command-line tools like `cat`, `head`, and `tail`.\n\nSwitch to **JSON** when your data contains nested structures, you need a self-describing format, or you're integrating with external APIs that require JSON.\n\nIn your Prolog code, TSV is the default:\n```prolog\ngenerate_pipeline(Steps, [format(tsv)], Script).\n```\n\nFor JSON Lines format:\n```prolog\ngenerate_pipeline(Steps, [format(json)], Script).\n```\n\nSee education/book-07-cross-target-glue/02_philosophy.md for the complete philosophy on data format selection in cross-target pipelines.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["tsv", "json", "pipe-protocols"], "original_answer": "## Data Format Selection\n\n### TSV: The Default Choice\n\nTSV is default for pipes because:\n- **Universal**: Every language can parse it\n- **Streaming**: Process line-by-line, bounded memory\n- **Debuggable**: `cat`, `head`, `tail` work perfectly\n\n```\nname    age    city\nAlice   30     NYC\nBob     25     LA\n```\n\n### JSON: For Structure\n\nUse JSON when you need:\n- Nested data structures\n- Self-describing format\n- API compatibility\n\n### Protocol Specification\n\n```prolog\n% TSV (default)\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% JSON Lines\ngenerate_pipeline(Steps, [format(json)], Script).\n```", "answer_tailored": true}
{"pair_id": "b7-c2-data-formats_p2", "cluster_id": "b7-c2-data-formats", "question": "What is the TSV protocol?", "question_type": "medium", "answer": "The TSV (Tab-Separated Values) protocol is UnifyWeaver's default data interchange format for cross-target pipelines. It uses tab characters to separate fields and newlines to separate records, making it universally parsable across all target languages (Bash, Python, Go, Rust, C#, PowerShell, SQL).\n\nTSV is preferred because it enables streaming processing with bounded memory\u2014each line can be processed independently\u2014and it's easily debuggable with standard Unix tools like `cat`, `head`, and `tail`. A simple TSV example:\n\n```\nname    age    city\nAlice   30     NYC\nBob     25     LA\n```\n\nWhile TSV is the default, UnifyWeaver also supports JSON Lines format when you need nested structures or API compatibility. You can specify the protocol in Prolog:\n\n```prolog\n% TSV (default)\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% JSON Lines\ngenerate_pipeline(Steps, [format(json)], Script).\n```\n\nFor more details on cross-target data interchange, see education/book-07-cross-target-glue/02_philosophy.md.", "answer_variant": "default", "answer_source": "education/book-07-cross-target-glue/02_philosophy.md", "topics": ["tsv", "json", "pipe-protocols"], "original_answer": "## Data Format Selection\n\n### TSV: The Default Choice\n\nTSV is default for pipes because:\n- **Universal**: Every language can parse it\n- **Streaming**: Process line-by-line, bounded memory\n- **Debuggable**: `cat`, `head`, `tail` work perfectly\n\n```\nname    age    city\nAlice   30     NYC\nBob     25     LA\n```\n\n### JSON: For Structure\n\nUse JSON when you need:\n- Nested data structures\n- Self-describing format\n- API compatibility\n\n### Protocol Specification\n\n```prolog\n% TSV (default)\ngenerate_pipeline(Steps, [format(tsv)], Script).\n\n% JSON Lines\ngenerate_pipeline(Steps, [format(json)], Script).\n```", "answer_tailored": true}
