{"pair_id": "semantic-dist-001_p0", "cluster_id": "semantic-dist-001", "question": "How does distributed semantic search work in UnifyWeaver?", "question_type": "medium", "answer": "UnifyWeaver implements distributed semantic search through a multi-node architecture where each node hosts multiple specialized interfaces (like CSV, JSON, etc.), each with its own semantic centroid. Queries are routed across this network using Kleinberg's small-world routing algorithm.\n\n**How it works:**\n- Each expert system node maintains several interface centroids representing different data format specializations\n- The Kleinberg router performs greedy forwarding, passing queries to whichever neighboring node has the highest semantic similarity to the query embedding\n- HTL (Hops-To-Live) counters prevent infinite routing loops\n- Path folding creates shortcuts after successful queries, optimizing future searches\n\n**Implementation:**\n```python\nrouter = KleinbergRouter(\n    discovery_client=create_discovery_client('consul'),\n    alpha=2.0, max_hops=10, path_folding_enabled=True\n)\nresults = router.route_query(query_embedding, envelope, top_k=5)\n```\n\nWith proper small-world graph topology (achieved via the alpha parameter), routing typically completes in O(log\u00b2n) hops. All nodes share access to a common knowledge graph database for consistent results.\n\nSee education/book-13-semantic-search/06_distributed_search.md for the complete protocol specification.", "answer_variant": "default", "answer_source": "book-13-semantic-search/06_distributed_search.md", "topics": [], "original_answer": "Multi-interface nodes with Kleinberg routing:\n\n**Architecture:**\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Expert System (Node)        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502  \u2502Interface\u2502 \u2502Interface\u2502 ...    \u2502\n\u2502  \u2502  \"CSV\"  \u2502 \u2502 \"JSON\" \u2502        \u2502\n\u2502  \u2502centroid \u2502 \u2502centroid\u2502        \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2502        Shared KG Database       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Kleinberg routing protocol:**\n- Greedy forwarding to node with highest similarity\n- HTL (Hops-To-Live) prevents infinite loops\n- Path folding creates shortcuts for future queries\n\n```python\nrouter = KleinbergRouter(\n    discovery_client=create_discovery_client('consul'),\n    alpha=2.0, max_hops=10, path_folding_enabled=True\n)\nresults = router.route_query(query_embedding, envelope, top_k=5)\n```\n\nProper small-world structure achieves O(log\u00b2n) path length.", "answer_tailored": true}
{"pair_id": "semantic-dist-001_p0", "cluster_id": "semantic-dist-001", "question": "How does federated query aggregation handle source diversity?", "question_type": "medium", "answer": "Federated aggregation tracks whether results come from independent sources or echo chambers using a 3-tier diversity model:\n\n**Tier 1 - Different corpora:** Results from completely different training sets (e.g., one node trained on docs/, another on education/) are fully independent. Scores are summed to reflect genuine consensus.\n\n**Tier 2 - Same corpus, disjoint sources:** When nodes share a corpus but use different source files, there's partial independence. The aggregator applies a boosted average: `(score_A + score_B + max(score_A, score_B)) / 2`.\n\n**Tier 3 - Overlapping sources:** If nodes trained on the same underlying files, results are likely echoes. Only the maximum score is kept to avoid artificial inflation.\n\n**Implementation:**\n```python\ndef _diversity_merge(self, existing_score, new_score, existing_prov, new_prov):\n    if existing_prov.corpus_id != new_prov.corpus_id:\n        return existing_score + new_score  # Full independence\n    \n    if not existing_prov.data_sources.intersection(new_prov.data_sources):\n        return (existing_score + new_score + max(existing_score, new_score)) / 2  # Partial\n    \n    return max(existing_score, new_score)  # Echo chamber\n```\n\nConfigure in Prolog with `federation_k(5), aggregation(diversity), consensus_threshold(3)`. See education/book-13-semantic-search/ for distributed search architecture details.", "answer_variant": "default", "answer_source": "book-13-semantic-search/06_distributed_search.md", "topics": [], "original_answer": "Results from multiple nodes need diversity-aware aggregation:\n\n**The problem:** Two nodes trained on the same dataset returning similar answers - is that consensus or echo?\n\n**3-Tier diversity model:**\n```python\ndef _diversity_merge(self, existing_score, new_score, existing_prov, new_prov):\n    # Tier 1: Different corpus = full independence = SUM\n    if existing_prov.corpus_id != new_prov.corpus_id:\n        return existing_score + new_score\n    \n    # Tier 2: Same corpus, disjoint sources = partial boost\n    if not existing_prov.data_sources.intersection(new_prov.data_sources):\n        return (existing_score + new_score + max(existing_score, new_score)) / 2\n    \n    # Tier 3: Overlapping sources = echo = MAX only\n    return max(existing_score, new_score)\n```\n\n**Prolog config:**\n```prolog\nfederation_k(5), aggregation(diversity), consensus_threshold(3)\n```", "answer_tailored": true}
