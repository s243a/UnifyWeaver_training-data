{"pair_id": "semantic-polyglot-001_p0", "cluster_id": "semantic-polyglot-001", "question": "Why generate Go and Rust code from Prolog specs?", "question_type": "medium", "answer": "Generating Go and Rust from the same Prolog specs enables optimal deployment across different environments without rewriting logic:\n\n**Performance and resource characteristics:**\n\n| Aspect | Python | Go | Rust |\n|--------|--------|-------|------|\n| Startup | ~100ms | ~5ms | ~5ms |\n| Memory | High | Low | Lowest |\n| Deployment | Virtualenv | Single binary | Single binary |\n| Concurrency | GIL-limited | Goroutines | async/await |\n| Best for | Prototyping, ML | Microservices | Embedded, perf-critical |\n\n**Deployment strategy:**\n- Python targets: Development environments and ML-heavy processing nodes\n- Go targets: High-throughput microservices and aggregator nodes\n- Rust targets: Resource-constrained edge devices and performance-critical systems\n\n**Single source, multiple outputs:**\n```prolog\n?- compile_adaptive_federation_go([adaptive_k([base_k(5)])], GoCode).\n?- compile_adaptive_federation_rust([adaptive_k([base_k(5)])], RustCode).\n```\n\nThis approach lets you write federation logic once in Prolog, then deploy the same semantics to Python for flexibility, Go for scalability, or Rust for maximum efficiency. See education/book-13-semantic-search/ for implementation details.", "answer_variant": "default", "answer_source": "book-13-semantic-search/10_go_rust_codegen.md", "topics": [], "original_answer": "Different languages for different deployment needs:\n\n| Aspect | Python | Go | Rust |\n|--------|--------|-------|------|\n| Startup | ~100ms | ~5ms | ~5ms |\n| Memory | High | Low | Lowest |\n| Deployment | Virtualenv | Single binary | Single binary |\n| Concurrency | GIL-limited | Goroutines | async/await |\n| Best for | Prototyping, ML | Microservices | Embedded, perf-critical |\n\n**Typical deployment:**\n- Python: Development, ML-heavy nodes\n- Go: High-throughput aggregator nodes\n- Rust: Edge nodes with constrained resources\n\n**Same Prolog spec \u2192 multiple targets:**\n```prolog\n?- compile_adaptive_federation_go([adaptive_k([base_k(5)])], GoCode).\n?- compile_adaptive_federation_rust([adaptive_k([base_k(5)])], RustCode).\n```", "answer_tailored": true}
{"pair_id": "semantic-polyglot-001_p0", "cluster_id": "semantic-polyglot-001", "question": "What Phase 5-8 code generation predicates are available?", "question_type": "medium", "answer": "UnifyWeaver provides code generation predicates across Phases 5-8 for Go and Rust targets:\n\n**Phase 5 - Advanced Federation:**\n- `compile_adaptive_federation_go/2`: Generates AdaptiveKCalculator using goroutines\n- `compile_adaptive_federation_rust/2`: Generates AdaptiveKCalculator with tokio async runtime\n- `compile_query_planner_go/2`: Creates QueryPlanner and PlanExecutor components\n- `compile_streaming_federation_go/2`: Implements PartialResult types with channel-based streaming\n- `compile_streaming_federation_rust/2`: Implements streaming via mpsc::Receiver\n\n**Phase 7 - Proper Small-World:**\nThe `compile_small_world_proper_go/2` predicate generates proper Kleinberg routing with O(log\u00b2n) path length. Example:\n```prolog\n?- compile_small_world_proper_go([k_local(10), k_long(5), alpha(2.0)], Code).\n```\n\n**Phase 8 - Scale-Free Nodes:**\nThe `compile_multi_interface_node_rust/2` predicate generates nodes with power-law interface distribution (~60% have 1-2 interfaces, ~3% have 20+). Example:\n```prolog\n?- compile_multi_interface_node_rust([gamma(2.5), min_interfaces(1)], Code).\n```\n\nFor complete implementation details, see education/book-13-semantic-search/10_go_rust_codegen.md.", "answer_variant": "default", "answer_source": "book-13-semantic-search/10_go_rust_codegen.md", "topics": [], "original_answer": "**Phase 5: Advanced Federation**\n\n| Predicate | Generated Code |\n|-----------|----------------|\n| `compile_adaptive_federation_go/2` | AdaptiveKCalculator (goroutines) |\n| `compile_adaptive_federation_rust/2` | AdaptiveKCalculator (tokio async) |\n| `compile_query_planner_go/2` | QueryPlanner, PlanExecutor |\n| `compile_streaming_federation_go/2` | PartialResult, channels |\n| `compile_streaming_federation_rust/2` | mpsc::Receiver streaming |\n\n**Phase 7: Proper Small-World**\n```prolog\n?- compile_small_world_proper_go([k_local(10), k_long(5), alpha(2.0)], Code).\n```\nGenerates proper Kleinberg routing with O(log\u00b2n) path length.\n\n**Phase 8: Scale-Free Nodes**\n```prolog\n?- compile_multi_interface_node_rust([gamma(2.5), min_interfaces(1)], Code).\n```\nPower-law interface distribution: ~60% nodes have 1-2 interfaces, ~3% have 20+.", "answer_tailored": true}
