{"pair_id": "semantic-001_p0", "cluster_id": "semantic-001", "question": "What is the Python semantic target?", "question_type": "medium", "answer": "The Python semantic target is UnifyWeaver's specialized Python compilation mode for building **Intelligent Semantic Agents** that integrate declarative Prolog logic with AI/ML capabilities.\n\n**Core infrastructure:**\n- `PtImporter`: Manages SQLite-backed storage for objects, relationships, and vector embeddings\n- `PtCrawler`: Streams and parses XML/HTML documents while extracting links\n- `PtSearcher`: Performs vector similarity search and graph-based traversal\n- `LLMProvider`: Interfaces with LLM command-line tools for retrieval-augmented generation\n- `OnnxEmbeddingProvider`: Generates embeddings locally using ONNX models\n\n**Example usage:**\n```prolog\n:- use_module(unifyweaver(targets/python_target)).\n\nsearch(Query, Result) :-\n    embed(Query, Vector),\n    vector_search(Vector, 5, Matches),\n    member(Result, Matches).\n\n?- compile_python_semantic(search/2, [], Code).\n```\n\nThis target bridges Prolog's declarative reasoning with Python's rich AI/ML ecosystem, enabling access to language models, vector stores, and advanced data processing libraries. For implementation details, see `src/unifyweaver/targets/python_runtime/`.", "answer_variant": "default", "answer_source": "book-13-semantic-search/01_introduction.md", "topics": [], "original_answer": "The Python target in UnifyWeaver builds **Intelligent Semantic Agents** that combine declarative logic with AI capabilities:\n\n**Key components:**\n- `PtImporter`: SQLite storage for objects, links, vectors\n- `PtCrawler`: XML/HTML streaming with link extraction\n- `PtSearcher`: Vector search and graph traversal\n- `LLMProvider`: Wraps LLM CLIs for RAG tasks\n- `OnnxEmbeddingProvider`: Local embeddings via ONNX\n\n```prolog\n:- use_module(unifyweaver(targets/python_target)).\n\nsearch(Query, Result) :-\n    embed(Query, Vector),\n    vector_search(Vector, 5, Matches),\n    member(Result, Matches).\n\n?- compile_python_semantic(search/2, [], Code).\n```\n\nPython enables access to the AI/ML ecosystem: LLMs, vector databases, data processing.", "answer_tailored": true}
{"pair_id": "semantic-001_p0", "cluster_id": "semantic-001", "question": "What is Graph RAG and how does it differ from standard RAG?", "question_type": "medium", "answer": "Graph RAG extends traditional RAG by incorporating **relationship-based retrieval** instead of relying solely on vector similarity.\n\n**Key Difference:**\n- **Standard RAG** finds documents by cosine similarity to the query vector\n- **Graph RAG** follows semantic relationships (parent/child, citations, cross-references) to discover contextually relevant content that may not match the query directly\n\n**How it works in UnifyWeaver:**\n1. **Anchor phase**: Vector search identifies initial relevant nodes (e.g., \"Apollo 11\")\n2. **Traversal phase**: Graph expansion follows relationships in the `links` table to find connected documents\n3. **Synthesis phase**: Combined anchor + neighbor content feeds the LLM for answer generation\n\n```prolog\n% Traditional vector-only search\nsemantic_search(Query, 5, Results).\n\n% Graph-aware search with relationship expansion\ngraph_search(Query, 3, 1, Results).  % 3 anchors, 1-hop expansion\n\n% Applied to RAG pipeline\nsummarize(Topic, Summary) :-\n    graph_search(Topic, 3, 1, Context),\n    llm_ask('Summarize using context.', Context, Summary).\n```\n\nThis approach captures related information that vector search alone would miss\u2014for example, retrieving \"1968 Budget Documentation\" when querying \"Apollo program\" because they're linked in the knowledge graph. See education/book-13-semantic-search/02_graph_rag.md for implementation details.", "answer_variant": "default", "answer_source": "book-13-semantic-search/02_graph_rag.md", "topics": [], "original_answer": "**Standard RAG**: Retrieves documents by vector similarity only.\n\n**Graph RAG**: Retrieves documents based on **relationships** (parent/child, citations, see-also), not just vector distance.\n\n**The UnifyWeaver approach:**\n1. **Anchor**: Vector search finds entry nodes (\"Apollo 11\" page)\n2. **Traverse**: Graph expansion finds neighbors via `links` table\n3. **Synthesize**: Feed Anchor + Neighbors to LLM\n\n```prolog\n% Standard vector search\nsemantic_search(Query, 5, Results).\n\n% Graph RAG - includes neighbors\ngraph_search(Query, 3, 1, Results).  % Top 3, expand 1 hop\n\n% Use in RAG\nsummarize(Topic, Summary) :-\n    graph_search(Topic, 3, 1, Context),\n    llm_ask('Summarize using context.', Context, Summary).\n```\n\nGraph RAG captures context that flat search misses (e.g., finding \"Budget 1968\" linked to Apollo).", "answer_tailored": true}
