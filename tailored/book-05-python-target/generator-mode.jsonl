{"pair_id": "b5-c3-generator-mode_p0", "cluster_id": "b5-c3-generator-mode", "question": "What is generator mode in the Python target?", "question_type": "medium", "answer": "Generator mode in the Python target is a compilation mode that implements semi-naive fixpoint evaluation for recursive queries. It's particularly useful for transitive closure operations (finding all paths in a graph), reachability queries, recursive joins, and handling deep recursion that would otherwise exceed Python's recursion limit.\n\nThe mode uses a semi-naive algorithm that maintains two key sets: **total** (all facts discovered so far) and **delta** (facts discovered in the current iteration). The algorithm works by initializing both sets with input facts, applying rules to the delta set, adding newly derived facts to new_delta, and checking if a fixpoint is reached (when new_delta is empty). If not, delta is updated to new_delta and the process repeats.\n\nTo compile a predicate using generator mode, use: `compile_predicate_to_python(path/2, [mode(generator)], Code)`.\n\nFor more details on the Python target, see education/book-05-python-target/.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["generator-mode", "semi-naive", "fixpoint-evaluation"], "original_answer": "## Generator Mode\n\nGenerator mode implements semi-naive fixpoint evaluation for recursive queries.\n\n### When to Use Generator Mode\n\n- Transitive closure (all paths in a graph)\n- Reachability queries\n- Recursive joins\n- Deep recursion (avoiding Python's limit)\n\n### Semi-Naive Algorithm\n\nMaintains two sets:\n- **total** - All facts discovered so far\n- **delta** - Facts discovered in current iteration\n\n### Algorithm Steps\n\n1. Initialize total and delta with input facts\n2. Apply rules to facts in delta\n3. Add newly derived facts to new_delta\n4. If new_delta empty \u2192 fixpoint reached\n5. Otherwise delta = new_delta, repeat\n\n### Compilation\n\n```prolog\ncompile_predicate_to_python(path/2, [mode(generator)], Code).\n```", "answer_tailored": true}
{"pair_id": "b5-c3-generator-mode_p1", "cluster_id": "b5-c3-generator-mode", "question": "How does semi-naive fixpoint evaluation work?", "question_type": "medium", "answer": "Semi-naive fixpoint evaluation maintains two distinct sets during recursive computation: **total** (all facts discovered so far) and **delta** (facts from the current iteration). \n\nThe algorithm works as follows:\n1. Initialize both total and delta with the input facts\n2. Apply rules only to facts in delta (not the entire total set)\n3. Add newly derived facts to new_delta\n4. If new_delta is empty, the fixpoint is reached\n5. Otherwise, set delta = new_delta and repeat\n\nThis semi-naive approach is more efficient than naive evaluation because it avoids re-deriving facts that were already computed in previous iterations. In UnifyWeaver's Python target, generator mode implements this strategy for recursive queries like transitive closure, reachability analysis, and deep recursion scenarios where Python's recursion limit would otherwise be a constraint. For implementation details, see education/book-05-python-target/03_generator_mode.md.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["generator-mode", "semi-naive", "fixpoint-evaluation"], "original_answer": "## Generator Mode\n\nGenerator mode implements semi-naive fixpoint evaluation for recursive queries.\n\n### When to Use Generator Mode\n\n- Transitive closure (all paths in a graph)\n- Reachability queries\n- Recursive joins\n- Deep recursion (avoiding Python's limit)\n\n### Semi-Naive Algorithm\n\nMaintains two sets:\n- **total** - All facts discovered so far\n- **delta** - Facts discovered in current iteration\n\n### Algorithm Steps\n\n1. Initialize total and delta with input facts\n2. Apply rules to facts in delta\n3. Add newly derived facts to new_delta\n4. If new_delta empty \u2192 fixpoint reached\n5. Otherwise delta = new_delta, repeat\n\n### Compilation\n\n```prolog\ncompile_predicate_to_python(path/2, [mode(generator)], Code).\n```", "answer_tailored": true}
{"pair_id": "b5-c3-generator-mode_p2", "cluster_id": "b5-c3-generator-mode", "question": "When should I use generator mode vs procedural mode?", "question_type": "medium", "answer": "Use generator mode when your query involves recursive operations that need to explore multiple derivation steps until no new results are found. This includes:\n\n- **Transitive closure** - Finding all paths or connections in a graph\n- **Reachability queries** - Determining what nodes are reachable from a starting point\n- **Recursive joins** - Queries where rules recursively reference themselves\n- **Deep recursion scenarios** - When recursion depth might exceed Python's stack limit\n\nGenerator mode uses semi-naive fixpoint evaluation, maintaining a **total** set (all discovered facts) and a **delta** set (newly found facts in the current iteration). It iteratively applies rules only to new facts until reaching a fixpoint where no additional results emerge.\n\nIn contrast, use **procedural mode** for straightforward queries without recursive derivation\u2014simple filtering, single-step transformations, or direct data lookups.\n\nTo enable generator mode, specify it during compilation:\n```prolog\ncompile_predicate_to_python(path/2, [mode(generator)], Code).\n```\n\nSee education/book-05-python-target/03_generator_mode.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["generator-mode", "semi-naive", "fixpoint-evaluation"], "original_answer": "## Generator Mode\n\nGenerator mode implements semi-naive fixpoint evaluation for recursive queries.\n\n### When to Use Generator Mode\n\n- Transitive closure (all paths in a graph)\n- Reachability queries\n- Recursive joins\n- Deep recursion (avoiding Python's limit)\n\n### Semi-Naive Algorithm\n\nMaintains two sets:\n- **total** - All facts discovered so far\n- **delta** - Facts discovered in current iteration\n\n### Algorithm Steps\n\n1. Initialize total and delta with input facts\n2. Apply rules to facts in delta\n3. Add newly derived facts to new_delta\n4. If new_delta empty \u2192 fixpoint reached\n5. Otherwise delta = new_delta, repeat\n\n### Compilation\n\n```prolog\ncompile_predicate_to_python(path/2, [mode(generator)], Code).\n```", "answer_tailored": true}
{"pair_id": "b5-c3-frozendict_p0", "cluster_id": "b5-c3-frozendict", "question": "What is FrozenDict in the Python target?", "question_type": "medium", "answer": "FrozenDict is an immutable, hashable dictionary implementation in UnifyWeaver's Python target. Since Python's standard `dict` is mutable and cannot be hashed, it can't be stored in a `set`. FrozenDict solves this by providing:\n\n- **Immutability** - Once created, contents cannot be changed\n- **Hashability** - Can be used as elements in sets for O(1) average lookup\n- **Dictionary-like interface** - Supports methods like `get()` for value access\n\n```python\n# Create a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Store in a set\nfacts = set()\nfacts.add(fd)\n\n# Check membership efficiently\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd2 in facts)  # True\n\n# Convert back to regular dict if needed\nd = fd.to_dict()\n```\n\nThis is particularly important for efficient duplicate detection during fixpoint iteration in generator mode. See education/book-05-python-target/03_generator_mode.md for more details on how FrozenDict enables efficient fact storage.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["frozendict", "hashable", "immutable", "data-structure"], "original_answer": "## FrozenDict Data Structure\n\nPython's `dict` is mutable and unhashable, so it can't be stored in a `set`. FrozenDict provides:\n\n- **Immutability** - Cannot be modified after creation\n- **Hashability** - Can be used as set elements\n- **Dictionary interface** - `get()` method for accessing values\n\n### Usage\n\n```python\n# Creating a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Using in a set (O(1) average lookup)\nfacts = set()\nfacts.add(fd)\n\n# Checking membership\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd2 in facts)  # True\n\n# Converting back to dict\nd = fd.to_dict()\n```\n\nThis enables efficient duplicate detection in fixpoint iteration.", "answer_tailored": true}
{"pair_id": "b5-c3-frozendict_p1", "cluster_id": "b5-c3-frozendict", "question": "Why can't Python dicts be used in sets?", "question_type": "medium", "answer": "Python's standard `dict` type cannot be used in sets because it is mutable and unhashable. Since sets require their elements to be hashable for efficient O(1) lookup, regular dictionaries don't satisfy this constraint.\n\nTo work around this limitation, UnifyWeaver's Python target uses a **FrozenDict** data structure that provides:\n\n- **Hashability** - Implements `__hash__()` so it can be stored in sets\n- **Immutability** - Contents cannot be changed after creation\n- **Dictionary-like interface** - Supports `get()` and other dict operations\n\n### Example Usage\n\n```python\n# Create a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Add to a set (now possible!)\nfacts = set()\nfacts.add(fd)\n\n# Membership testing works with O(1) lookup\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd2 in facts)  # True\n\n# Convert back when needed\nd = fd.to_dict()\n```\n\nThis immutable, hashable alternative is essential for efficient duplicate detection during fixpoint iteration in the Python runtime. See education/book-05-python-target/03_generator_mode.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["frozendict", "hashable", "immutable", "data-structure"], "original_answer": "## FrozenDict Data Structure\n\nPython's `dict` is mutable and unhashable, so it can't be stored in a `set`. FrozenDict provides:\n\n- **Immutability** - Cannot be modified after creation\n- **Hashability** - Can be used as set elements\n- **Dictionary interface** - `get()` method for accessing values\n\n### Usage\n\n```python\n# Creating a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Using in a set (O(1) average lookup)\nfacts = set()\nfacts.add(fd)\n\n# Checking membership\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd2 in facts)  # True\n\n# Converting back to dict\nd = fd.to_dict()\n```\n\nThis enables efficient duplicate detection in fixpoint iteration.", "answer_tailored": true}
{"pair_id": "b5-c3-frozendict_p2", "cluster_id": "b5-c3-frozendict", "question": "How does FrozenDict enable fixpoint evaluation?", "question_type": "medium", "answer": "FrozenDict enables fixpoint evaluation by making dictionaries hashable and storing them in sets for efficient duplicate detection. During fixpoint iteration, UnifyWeaver needs to track which facts have already been derived to avoid infinite loops and detect convergence.\n\nSince Python's standard `dict` is mutable and unhashable, it cannot be added to a `set`. FrozenDict solves this by providing:\n\n- **Immutability** - Facts cannot be modified once created, ensuring hash stability\n- **Hashability** - Can be stored in sets for O(1) average-case membership testing\n- **Dictionary interface** - Maintains `get()` and other dict-like methods for easy use\n\n```python\n# Store derived facts in a set\nfacts = set()\n\n# Add a fact as FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nfacts.add(fd)\n\n# Check if fact already exists (duplicate detection)\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nif fd2 in facts:  # O(1) lookup\n    # Skip - already derived\n```\n\nThis allows the fixpoint algorithm to efficiently detect when no new facts are being generated, signaling convergence. See education/book-05-python-target/03_generator_mode.md for implementation details.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["frozendict", "hashable", "immutable", "data-structure"], "original_answer": "## FrozenDict Data Structure\n\nPython's `dict` is mutable and unhashable, so it can't be stored in a `set`. FrozenDict provides:\n\n- **Immutability** - Cannot be modified after creation\n- **Hashability** - Can be used as set elements\n- **Dictionary interface** - `get()` method for accessing values\n\n### Usage\n\n```python\n# Creating a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Using in a set (O(1) average lookup)\nfacts = set()\nfacts.add(fd)\n\n# Checking membership\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd2 in facts)  # True\n\n# Converting back to dict\nd = fd.to_dict()\n```\n\nThis enables efficient duplicate detection in fixpoint iteration.", "answer_tailored": true}
{"pair_id": "b5-c3-negation_p0", "cluster_id": "b5-c3-negation", "question": "How does generator mode handle negation?", "question_type": "medium", "answer": "Generator mode implements negation-as-failure through stratification checks. When a rule contains negation (like `\\+ blocked(X, Y)`), the generated Python code tests whether the negated fact exists in the accumulated fact set before proceeding.\n\nFor example, with a rule like `safe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y)`, the Python generator constructs a fact dictionary for the negated predicate and checks its presence in the total fact set. If the fact exists, the negation condition fails and no result is yielded. Otherwise, execution continues.\n\nThe compiler enforces stratification at compile time: negated predicates cannot depend (directly or transitively) on the predicate currently being defined. This prevents logical inconsistencies in the fixpoint computation.\n\nSee education/book-05-python-target/03_generator_mode.md for implementation details and complete examples.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["negation", "stratification", "negation-as-failure"], "original_answer": "## Negation in Generator Mode\n\nGenerator mode supports negation-as-failure with stratification.\n\n### Example\n\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\n### Generated Python\n\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check negation\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\n### Stratification Requirement\n\nNegated predicates must not depend (directly or indirectly) on the predicate being defined. The compiler validates this at compile time.", "answer_tailored": true}
{"pair_id": "b5-c3-negation_p1", "cluster_id": "b5-c3-negation", "question": "What is stratified negation?", "question_type": "medium", "answer": "Stratified negation is a requirement in UnifyWeaver's generator mode that ensures negation-as-failure operates correctly. It mandates that any predicate used in a negated context (like `\\+ blocked(X, Y)`) must not depend\u2014either directly or through a chain of rules\u2014on the predicate currently being defined.\n\nFor example, in:\n```prolog\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\n```\n\nThe `blocked/2` predicate cannot recursively reference `safe_path/2`, preventing circular dependencies that would make negation ambiguous.\n\nUnifyWeaver's compiler enforces stratification at compile time, rejecting programs where negated predicates have cyclic dependencies with the rules defining them. This validation ensures the generated Python code (which checks for absence of facts in the total set) produces deterministic, well-defined results.\n\nThe generated Python implements negation by checking if a negated fact exists in the accumulated results\u2014if present, the rule doesn't yield that solution:\n\n```python\nblocked_fact = FrozenDict.from_dict({'relation': 'blocked', 'arg0': x, 'arg1': y})\nif blocked_fact in total:\n    return  # Negation fails\n```\n\nSee education/book-05-python-target/03_generator_mode.md for complete details on negation handling in generator mode.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["negation", "stratification", "negation-as-failure"], "original_answer": "## Negation in Generator Mode\n\nGenerator mode supports negation-as-failure with stratification.\n\n### Example\n\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\n### Generated Python\n\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check negation\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\n### Stratification Requirement\n\nNegated predicates must not depend (directly or indirectly) on the predicate being defined. The compiler validates this at compile time.", "answer_tailored": true}
{"pair_id": "b5-c3-negation_p2", "cluster_id": "b5-c3-negation", "question": "Can I use negation in recursive predicates?", "question_type": "medium", "answer": "Yes, you can use negation in recursive predicates through negation-as-failure, provided they satisfy stratification requirements.\n\n### Stratification Constraint\n\nThe negated predicates cannot depend (directly or indirectly) on the predicate being defined. UnifyWeaver validates this constraint during compilation to ensure correctness.\n\n### Example: Safe Path with Negation\n\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\nHere, `safe_path` recursively calls itself while using `\\+ blocked(X, Y)` as a guard condition.\n\n### Python Implementation\n\nThe generated code checks for the absence of negated facts in the knowledge base:\n\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check negation\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\nFor more details on generator mode semantics, see education/book-05-python-target/03_generator_mode.md.", "answer_variant": "default", "answer_source": "education/book-05-python-target/03_generator_mode.md", "topics": ["negation", "stratification", "negation-as-failure"], "original_answer": "## Negation in Generator Mode\n\nGenerator mode supports negation-as-failure with stratification.\n\n### Example\n\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\n### Generated Python\n\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check negation\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\n### Stratification Requirement\n\nNegated predicates must not depend (directly or indirectly) on the predicate being defined. The compiler validates this at compile time.", "answer_tailored": true}
