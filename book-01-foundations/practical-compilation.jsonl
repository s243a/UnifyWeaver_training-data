{"cluster_id": "practical-compilation", "seed_level": 2, "source_files": ["docs/targets/bash.md", "src/unifyweaver/core/compiler_driver.pl"], "topics": ["compilation", "bash", "how-to", "compile", "generated-code"], "questions": ["How do I compile a Prolog predicate to Bash with UnifyWeaver?", "What is the step-by-step process to compile Prolog to Bash?", "How do I use the UnifyWeaver compiler?", "What command compiles a predicate?"], "answer": {"text": "## Compiling Prolog to Bash\n\nHere's the complete step-by-step process:\n\n### Step 1: Start SWI-Prolog with UnifyWeaver\n\n```bash\ncd UnifyWeaver\nswipl -f init.pl\n```\n\n### Step 2: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\ntrue.\n```\n\n### Step 3: Define Your Predicates\n\n```prolog\n?- assertz(edge(a, b)).\n?- assertz(edge(b, c)).\n?- assertz(edge(c, d)).\ntrue.\n```\n\n### Step 4: Compile to Bash\n\n```prolog\n?- compile(edge/2, [target(bash)], Scripts).\n=== Compiling edge/2 ===\n  Constraints: [unique(true),unordered(true)]\nType: facts (3 clauses)\nScripts = ['education/output/advanced/edge.sh'].\n```\n\n### Step 5: View Generated Code\n\n```bash\ncat education/output/advanced/edge.sh\n```\n\nOutput:\n```bash\n#!/bin/bash\n# edge - fact lookup\ndeclare -A edge_data=(\n    [a:b]=1\n    [b:c]=1\n    [c:d]=1\n)\nedge() {\n  local key=\"$1:$2\"\n  [[ -n \"${edge_data[$key]}\" ]] && echo \"$key\"\n}\nedge_stream() {\n  for key in \"${!edge_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n```\n\n### Step 6: Test the Generated Code\n\n```bash\nsource education/output/advanced/edge.sh\nedge_stream\n# Output: a:b  b:c  c:d\n\nedge a b\n# Output: a:b\n```", "anchor_question_hash": "73685fa99b37483a"}}
{"cluster_id": "generated-code-facts", "seed_level": 2, "source_files": ["src/unifyweaver/core/stream_compiler.pl", "src/unifyweaver/core/template_system.pl"], "topics": ["facts", "associative-arrays", "bash", "generated-code", "declare"], "questions": ["What does generated Bash code look like for Prolog facts?", "How are Prolog facts compiled to Bash?", "Why does UnifyWeaver use associative arrays?", "What is the structure of generated fact lookup code?"], "answer": {"text": "## Generated Code for Facts\n\nProlog facts compile to Bash associative arrays for O(1) lookup:\n\n### Input: Prolog Facts\n\n```prolog\nparent(alice, bob).\nparent(bob, charlie).\nparent(charlie, david).\n```\n\n### Output: Generated Bash\n\n```bash\n#!/bin/bash\n# parent - fact lookup\ndeclare -A parent_data=(\n    [alice:bob]=1\n    [bob:charlie]=1\n    [charlie:david]=1\n)\n\n# Lookup function - O(1) check\nparent() {\n  local key=\"$1:$2\"\n  [[ -n \"${parent_data[$key]}\" ]] && echo \"$key\"\n}\n\n# Stream all facts\nparent_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    echo \"$key\"\n  done\n}\n\n# Reverse lookup (child -> parent)\nparent_reverse_stream() {\n  for key in \"${!parent_data[@]}\"; do\n    IFS=\":\" read -r a b <<< \"$key\"\n    echo \"$b:$a\"\n  done\n}\n```\n\n### Why Associative Arrays?\n\n1. **O(1) lookup** - `[[ -n \"${parent_data[$key]}\" ]]` is constant time\n2. **Deduplication** - Keys are unique by definition\n3. **Memory efficient** - Bash 4+ handles large arrays well\n4. **Streaming** - `${!array[@]}` iterates all keys\n\n### Usage\n\n```bash\nsource parent.sh\n\n# Check if alice is parent of bob\nparent alice bob\n# Output: alice:bob\n\n# List all parent relationships  \nparent_stream\n# Output:\n# alice:bob\n# bob:charlie\n# charlie:david\n```", "anchor_question_hash": "8a3f2d1c9b4e7f60"}}
{"cluster_id": "generated-code-transitive", "seed_level": 3, "source_files": ["src/unifyweaver/core/advanced/linear_recursion.pl", "docs/RECURSION_PATTERN_THEORY.md"], "topics": ["transitive-closure", "recursion", "bfs", "generated-code", "reaches"], "questions": ["How does UnifyWeaver compile a transitive closure to Bash?", "What does generated code for recursive predicates look like?", "How is ancestor/2 compiled to Bash?", "What optimization does UnifyWeaver use for transitive closures?"], "answer": {"text": "## Transitive Closure Compilation\n\nUnifyWeaver detects transitive closure patterns and generates optimized BFS code:\n\n### Input: Prolog Rules\n\n```prolog\n% Base case\nreaches(X, Y) :- edge(X, Y).\n\n% Recursive case  \nreaches(X, Y) :- edge(X, Z), reaches(Z, Y).\n```\n\n### Detection\n\n```prolog\n?- compile(reaches/2, [target(bash)], Scripts).\n=== Analyzing reaches/2 ===\nClassification: transitive_closure(edge)\nDetected transitive closure over edge\n```\n\n### Output: BFS with Visited Tracking\n\n```bash\n#!/bin/bash\n# reaches - transitive closure of edge\n\nreaches_all() {\n    local start=\"$1\"\n    declare -A visited\n    local queue_file=\"/tmp/reaches_queue_$$\"\n    \n    echo \"$start\" > \"$queue_file\"\n    visited[\"$start\"]=1\n    \n    # BFS traversal\n    while [[ -s \"$queue_file\" ]]; do\n        while IFS= read -r current; do\n            # Expand frontier\n            while IFS=\":\" read -r from to; do\n                if [[ \"$from\" == \"$current\" && -z \"${visited[$to]}\" ]]; then\n                    visited[\"$to\"]=1\n                    echo \"$start:$to\"\n                fi\n            done < <(edge_stream | grep \"^$current:\")\n        done < \"$queue_file\"\n    done\n}\n\nreaches() {\n    local start=\"$1\"\n    local target=\"$2\"\n    \n    if [[ -z \"$target\" ]]; then\n        reaches_all \"$start\" | sort -u\n    else\n        reaches_all \"$start\" | grep -q \"^$start:$target$\"\n    fi\n}\n```\n\n### Key Optimizations\n\n1. **BFS not recursion** - Avoids Bash stack limits\n2. **Visited tracking** - `declare -A visited` prevents cycles\n3. **Deduplication** - `sort -u` removes duplicates\n4. **Temp files** - Queue stored in `/tmp` for large graphs\n\n### Usage\n\n```bash\nsource edge.sh reaches.sh\n\n# Find all nodes reachable from 'a'\nreaches a\n# Output: a:b  a:c  a:d\n\n# Check if 'd' is reachable from 'a'\nreaches a d && echo \"yes\" || echo \"no\"\n# Output: yes\n```", "anchor_question_hash": "4c8e2a1f7d3b9e52"}}
