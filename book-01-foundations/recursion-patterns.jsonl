{"cluster_id": "recursion-patterns", "seed_level": 3, "source_files": ["docs/RECURSION_PATTERN_THEORY.md", "docs/ADVANCED_RECURSION.md"], "topics": ["recursion", "tail-recursion", "linear-recursion", "tree-recursion", "transitive-closure", "mutual-recursion"], "questions": ["What recursion patterns does UnifyWeaver support?", "What is the difference between tree and linear recursion?", "How does UnifyWeaver compile transitive closures?", "What is tail recursion optimization?"], "answer": {"text": "## Supported Recursion Patterns\n\n| Pattern | Description | Bash | Python | C# |\n|---------|-------------|:----:|:------:|:--:|\n| Tail Recursion | Last call is recursive | ✅ | ✅ | ✅ |\n| Linear Recursion | Single recursive call | ✅ | ✅ | ✅ |\n| Tree Recursion | Multiple recursive calls on structure | ✅ | ✅ | ✅ |\n| Transitive Closure | Reachability queries | ✅ | ✅ | ✅ |\n| Mutual Recursion | A calls B, B calls A | ✅ | ✅ | ✅ |\n\n## Tree vs Linear Recursion\n\nThe key difference is **what gets passed** to recursive calls:\n\n```prolog\n% TREE RECURSION - structural decomposition\ntree_sum([Value, Left, Right], Sum) :-\n    tree_sum(Left, LS),    % Left is a subtree structure\n    tree_sum(Right, RS),   % Right is a subtree structure\n    Sum is Value + LS + RS.\n\n% LINEAR RECURSION - computed scalar values\nfib(N, F) :-\n    N > 1,\n    N1 is N - 1,           % N1 is computed\n    N2 is N - 2,           % N2 is computed\n    fib(N1, F1),\n    fib(N2, F2),\n    F is F1 + F2.\n```\n\n## Transitive Closure Compilation\n\n```prolog\n% Prolog (what you write)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n```\n\nCompiles to BFS with memoization:\n\n```bash\n# Generated Bash (simplified)\nancestor_all() {\n    declare -A visited\n    local -a queue=($(parent_stream))\n    \n    while [[ ${#queue[@]} -gt 0 ]]; do\n        current=\"${queue[0]}\"; queue=(\"${queue[@]:1}\")\n        [[ ${visited[$current]} ]] && continue\n        visited[$current]=1\n        echo \"$current\"\n        # Expand frontier...\n    done\n}\n```\n\n## Tail Recursion Optimization\n\n```prolog\n% Tail recursive - last call is recursive\ncount(0, Acc, Acc).\ncount(N, Acc, Result) :-\n    N > 0, N1 is N - 1, Acc1 is Acc + 1,\n    count(N1, Acc1, Result).  % TAIL POSITION\n```\n\nCompiles to iterative loop (no stack growth).", "anchor_question_hash": "c6645f0af74afce7"}}
