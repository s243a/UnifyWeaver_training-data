{"cluster_id": "prolog-unification", "seed_level": 1, "source_files": ["education/book-01-foundations/02_prolog_fundamentals.md"], "topics": ["prolog", "unification", "pattern-matching", "variable-binding"], "questions": ["How does unification work in Prolog?", "What is pattern matching in Prolog?", "How do Prolog variables get their values?", "Why is it called UnifyWeaver?"], "answer": {"text": "## Unification: The Engine of Prolog\n\n**Unification** is the process of matching two terms. If they can match, any variables are **instantiated** (given values) to make the terms identical.\n\n## Unification Rules\n\n```prolog\n% Atoms unify only with themselves\nalice = alice.        % succeeds\nalice = bob.          % fails\n\n% Variables unify with any term\nX = alice.            % X is now 'alice'\nX = foo(1, 2).        % X is now 'foo(1, 2)'\n\n% Structures unify if functor, arity, and all args unify\npoint(1, Y) = point(X, 2).  % X=1, Y=2\npoint(1, 2) = point(1, 2, 3).  % fails (different arity)\n```\n\n## Unification in Queries\n\nWhen you query, Prolog unifies your query with facts/rules:\n\n```prolog\n% Database\nfile_dependency('main.o', 'main.c').\nfile_dependency('main.o', 'utils.h').\n\n% Query\n?- file_dependency('main.o', Dep).\n\n% Prolog tries to unify:\n%   file_dependency('main.o', Dep)\n% with\n%   file_dependency('main.o', 'main.c')\n%\n% Result: Dep = 'main.c'\n```\n\n## Why \"UnifyWeaver\"?\n\nThe name comes from **unification** (Prolog's core operation) + **weaving** (interconnecting data threads). UnifyWeaver unifies your declarative specifications and weaves them into executable code:\n\n```prolog\n% Your specification (unified pattern)\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\n\n% Woven into optimized Bash/Python/Go/etc.\n```", "anchor_question_hash": "f7e0d1021f3cb150"}}
