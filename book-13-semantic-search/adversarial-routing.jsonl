{"cluster_id": "semantic-adversarial-001", "question": "How does UnifyWeaver protect against adversarial nodes?", "answer": "Three defense mechanisms:\n\n**1. Soft Collisions (Outlier Detection):**\nReject results that are statistically anomalous:\n```python\ndef detect_outliers(embeddings, threshold=2.5):\n    distances = pairwise_distances(embeddings)\n    z_scores = (distances - distances.mean()) / distances.std()\n    return z_scores > threshold\n```\n\n**2. Hard Collisions (KSK-style Region Locking):**\nNodes claim responsibility for specific embedding regions:\n```python\ndef verify_region_ownership(node_id, embedding, region_registry):\n    claimed_region = region_registry.get(node_id)\n    return claimed_region.contains(embedding)\n```\n\n**3. Consensus Voting with Quorum:**\n```python\ndef requires_quorum(result, min_agreeing_nodes=3):\n    agreeing = [n for n in nodes if n.agrees(result)]\n    return len(agreeing) >= min_agreeing_nodes\n```\n\n**Trust management:** Direct trust + FMS two-dimensional (competence, benevolence).", "source_file": "book-13-semantic-search/11_adversarial_robustness.md", "prerequisites": ["semantic-dist-001"]}
{"cluster_id": "semantic-routing-001", "question": "What's the difference between greedy routing and Kleinberg routing?", "answer": "**Greedy routing:** Forward to the closest neighbor. Simple but no path length guarantees.\n\n**Kleinberg routing:** Requires proper **small-world network structure**:\n- `k_local`: Nearest-neighbor connections for local connectivity\n- `k_long`: Probability-weighted long-range shortcuts (P ~ 1/distance^α)\n\n**Without proper structure:** Only greedy routing\n**With proper structure:** O(log²n) expected path length\n\n```prolog\n% Generate proper small-world network\n?- compile_small_world_proper_python([\n       k_local(10),\n       k_long(5),\n       alpha(2.0),\n       angle_ordering(cosine_based)\n   ], Code).\n```\n\n**HNSW (Hierarchical Navigable Small World):**\nLayered structure with tunable M parameter:\n- Higher M = better recall, more memory\n- Lower M = faster search, less recall\n\nO(log n) scaling for both search and construction.", "source_file": "book-13-semantic-search/13_advanced_routing.md", "prerequisites": ["semantic-dist-001"]}
{"cluster_id": "semantic-scalefree-001", "question": "What are scale-free multi-interface nodes?", "answer": "Power-law distribution of interfaces per node:\n\n```\nP(k) ∝ k^(-γ)  where k = interface count\n```\n\n**Distribution with gamma=2.5:**\n- ~60% nodes: 1-2 interfaces (leaf specialists)\n- ~25% nodes: 3-5 interfaces (mid-tier)\n- ~12% nodes: 6-20 interfaces (regional hubs)\n- ~3% nodes: 20+ interfaces (major hubs)\n\n**Benefits:**\n1. **Capacity-proportional sizing:** Hubs handle more traffic, leaves specialize\n2. **Unified binary search:** O(log n) lookup across all interfaces\n3. **Internal shortcuts:** Related interfaces on same node\n\n```prolog\n?- compile_multi_interface_node_go([\n       gamma(2.5),\n       min_interfaces(1),\n       max_interfaces(100),\n       unified_search(true)\n   ], Code).\n```\n\nMirrors web traffic patterns: few high-traffic hubs, many specialized sites.", "source_file": "book-13-semantic-search/14_scale_free_networks.md", "prerequisites": ["semantic-routing-001"]}
