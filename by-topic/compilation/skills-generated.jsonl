{"id": "skill_extract_records_001", "question": "How do I extract structured data from Markdown example files?", "question_variants": ["extract records from markdown", "parse example records", "get data from markdown files"], "level": 2, "tree_path": ["Data Processing", "Extract Records"], "answer": "Use the Extract Records skill with `scripts/utils/extract_records.pl`. This parses Markdown files that conform to UnifyWeaver Example Record Format and outputs structured data.\n\n```bash\nperl scripts/utils/extract_records.pl [OPTIONS] [PATH...]\n```\n\nCommon options:\n- `-f json` - Output as JSON objects (recommended for processing)\n- `-q <pattern>` - Filter by record name\n- `-f content` - Extract just the code block content\n\nThis is more robust than `grep` for multi-line records and metadata.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["data-processing", "parsing", "markdown"]}
{"id": "skill_extract_records_002", "question": "What's the difference between bash and Prolog records when extracting?", "question_variants": ["run extracted bash script", "execute prolog record", "which interpreter to use", "bash script vs prolog code"], "level": 3, "tree_path": ["Data Processing", "Extract Records"], "answer": "Records contain different code types - you must run them with the correct interpreter:\n\n**Bash records** (marked with ```bash):\n```bash\nperl scripts/utils/extract_records.pl -f content -q 'record.name' file.md > script.sh\nbash script.sh\n```\n\n**Prolog records** (marked with ```prolog):\n```bash\nperl scripts/utils/extract_records.pl -f content -q 'record.name' file.md > code.pl\nswipl -f init.pl -g \"consult('code.pl'), goal, halt\"\n```\n\nAlways check the code fence language (```bash vs ```prolog) to know which interpreter to use.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["parsing", "prolog", "bash", "execution"]}
{"id": "skill_extract_records_003", "question": "When should I use Extract Records instead of grep?", "question_variants": ["extract records vs grep", "when to use extract records tool", "why use extract records"], "level": 2, "tree_path": ["Data Processing", "Extract Records"], "answer": "Use Extract Records when you need to:\n- Parse metadata like `id` or `name` from records\n- Handle multi-line content blocks reliably\n- Get output in structured formats like JSON\n- Filter files by YAML frontmatter (like `file_type=UnifyWeaver Example Library`)\n\nUse `grep` for simple text search. Use Extract Records for semantic parsing of UnifyWeaver record files.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["parsing", "tools", "comparison"]}
{"id": "skill_extract_records_004", "question": "How do I filter extracted records by name?", "question_variants": ["filter records by pattern", "query records by name", "search specific records"], "level": 3, "tree_path": ["Data Processing", "Extract Records"], "answer": "Use the `-q` (query) flag with a regex pattern to filter by record name:\n\n```bash\nperl scripts/utils/extract_records.pl \\\n  -f json \\\n  -q 'unifyweaver.execution.xml_data_source' \\\n  path/to/file.md\n```\n\nThis extracts only records whose `name` metadata matches the pattern. Combine with `-f json` to get structured output for processing.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["parsing", "filtering", "queries"]}
{"id": "skill_find_executable_001", "question": "How do I run a command that's not found in my system PATH?", "question_variants": ["What should I do when I get a 'command not found' error?", "How can I locate an executable that isn't in my PATH?"], "level": 2, "tree_path": ["Execution", "Find Executable"], "answer": "When a command fails with a 'command not found' error, you can use the Find Executable skill to search for the executable in common installation directories. The skill searches OS-specific paths and returns the full path to the executable if found, which you can then use to run the command directly.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["command-not-found", "executable", "path"]}
{"id": "skill_find_executable_002", "question": "Where does the agent look for executables on different operating systems?", "question_variants": ["Which directories are searched for executables?", "What are the common installation paths the agent checks?"], "level": 2, "tree_path": ["Execution", "Find Executable"], "answer": "The Find Executable skill searches OS-specific directories: On Windows, it checks Strawberry Perl and SWI-Prolog installation paths. On Linux, it searches /usr/bin, /usr/local/bin, and /snap/bin. On macOS, it checks /usr/bin, /usr/local/bin, /opt/homebrew/bin, and the SWI-Prolog application path.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["directories", "operating-system", "search-paths"]}
{"id": "skill_find_executable_003", "question": "What does the Find Executable skill return if it can't locate an executable?", "question_variants": ["How do I know if an executable was found?", "What happens when the skill doesn't find the executable?"], "level": 3, "tree_path": ["Execution", "Find Executable"], "answer": "If the executable is found, the Find Executable skill returns the absolute path to it. If the executable is not found, it returns an empty string. You can then use the returned path to execute the command directly, for example: & \"C:\\Strawberry\\perl\\bin\\perl.exe\" my_script.pl on Windows.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["output", "executable-path", "return-value"]}
{"id": "skill_find_executable_004", "question": "How do I use a found executable to run my script?", "question_variants": ["How can I execute a command using the full path returned?", "What's the syntax for running an executable from its full path?"], "level": 3, "tree_path": ["Execution", "Find Executable"], "answer": "Once you have the full path from the Find Executable skill, you can execute the command directly using that path. For example, on Windows you would use: & \"C:\\Strawberry\\perl\\bin\\perl.exe\" my_script.pl, and on Unix-like systems: /usr/local/bin/perl my_script.pl. The & operator on Windows allows you to invoke commands from variable paths.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["execution", "full-path", "script-execution"]}
{"id": "skill_json_sources_001", "question": "How do I read data from a JSON file in a playbook?", "question_variants": ["How can I load JSON data into a playbook?", "What's the syntax for reading JSON files?"], "level": 2, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use the `source/3` directive with `json_file('path/to/file.json')` and `columns/1` to specify which fields to extract. For example:\n```prolog\n:- source(json, my_source, [\n    json_file('data/orders.json'),\n    columns(['order.customer.name', 'items[0].product'])\n]).\n```\nEnsure the number of columns matches your predicate's arity.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["JSON", "data sources", "playbooks"]}
{"id": "skill_json_sources_002", "question": "How do I select nested fields or complex paths in JSON data?", "question_variants": ["Can I use JSONPath expressions to query JSON?", "How do I extract deeply nested JSON values?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use JSONPath selectors with `jsonpath('$.path.to.field')` in your `columns/1` or `schema/1` declaration. JSONPath supports dot notation, bracket properties, array indices, wildcards `[*]`, and recursive descent `..fieldname`. Example:\n```prolog\ncolumns([\n    jsonpath('$.orders[*].total'),\n    jsonpath('$.customer.address.city')\n])\n```\nStrings already starting with `$` are automatically treated as JSONPath.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["JSONPath", "nested fields", "selectors"]}
{"id": "skill_json_sources_003", "question": "How do I return entire JSON objects as rows instead of selecting specific columns?", "question_variants": ["Can I get raw JSON objects from a source?", "How do I work with unflattened JSON data?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use return-object mode by setting `arity(1)`, `return_object(true)`, and providing a `type_hint/1` with a .NET type. Example:\n```prolog\n:- source(json, raw_data, [\n    json_file('data.json'),\n    arity(1),\n    return_object(true),\n    type_hint('System.Text.Json.Nodes.JsonObject, System.Text.Json')\n]).\n```\nThis returns the full JSON object for each row instead of projecting specific fields.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["JSON objects", "return modes"]}
{"id": "skill_json_sources_004", "question": "How do I create typed records from JSON data?", "question_variants": ["Can I automatically generate C# classes from JSON sources?", "How do I define a schema for JSON data?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use `schema/1` to declare typed fields and let the C# backend generate POCOs automatically. Example:\n```prolog\n:- source(json, products, [\n    json_file('products.json'),\n    schema([\n        field(id, 'id', string),\n        field(name, 'name', string),\n        field(price, 'price', double)\n    ]),\n    record_type('ProductRecord')\n]).\n```\nFor nested objects, use `record(TypeName, Fields)` within the schema. The arity must be 1; nested records are instantiated automatically at runtime.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["schema", "records", "typed data"]}
{"id": "skill_unifyweaver_compile_001", "question": "How do I convert Prolog rules into an executable bash script?", "question_variants": ["How do I transpile Prolog predicates to bash?", "What's the process for compiling Prolog to bash?", "How do I execute Prolog logic as a bash script?"], "level": 2, "tree_path": ["Compilation", "Prolog-to-Bash Transpilation"], "answer": "Use the UnifyWeaver compiler to transpile Prolog predicates into executable bash scripts. Run: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<prolog_file>'), compile(<predicate_indicator>, [output_dir('.')])\" -t halt`. Specify your `.pl` file, the main predicate (e.g., `choose_strategy/3`), and output directory. The compiler will handle dependencies automatically.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["compilation", "transpilation", "bash", "prolog"]}
{"id": "skill_unifyweaver_compile_002", "question": "What are the parameters I need to provide to compile Prolog code?", "question_variants": ["What options does the compiler accept?", "How do I specify the output location for compiled scripts?", "What do I need to configure for compilation?"], "level": 3, "tree_path": ["Compilation", "Prolog-to-Bash Transpilation"], "answer": "The compiler requires three key parameters: (1) `<prolog_file>` - path to your `.pl` file, (2) `<predicate_indicator>` - the main predicate in `functor/arity` format (e.g., `choose_strategy/3`), and (3) `<options>` - compiler options like `output_dir('.')` to specify where to save the compiled `.sh` file. Always set `output_dir` to a known location to avoid unexpected output paths.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["compilation", "parameters", "options"]}
{"id": "skill_unifyweaver_compile_003", "question": "What are the limitations when compiling Prolog to bash?", "question_variants": ["Why does my Prolog compilation fail?", "Which Prolog features don't work with the bash compiler?", "Can I use arithmetic operators in my Prolog rules?"], "level": 2, "tree_path": ["Compilation", "Prolog-to-Bash Transpilation"], "answer": "The current compiler cannot transpile predicates that directly use arithmetic comparison operators (>, <, =<). This is a known limitation that will cause compilation to fail. Avoid using these operators directly in your Prolog rules. Check the related documentation for workarounds and supported patterns.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md"], "tags": ["limitations", "arithmetic", "troubleshooting"]}
{"id": "skill_unifyweaver_compile_004", "question": "How does the compiler handle dependencies in my Prolog predicates?", "question_variants": ["Do I need to specify all dependent predicates?", "Will the compiler automatically include predicates my main predicate calls?", "How are recursive predicates handled during compilation?"], "level": 3, "tree_path": ["Compilation", "Prolog-to-Bash Transpilation"], "answer": "The compiler automatically analyzes and includes any user-defined predicates that your main predicate depends on. You only need to specify the main predicate you want to compile, and the compiler will traverse the dependency tree and compile everything needed. This simplifies the compilation process for complex logic.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/ADVANCED_RECURSION.md"], "tags": ["dependencies", "compilation", "recursion"]}
{"id": "skill_unifyweaver_environment_001", "question": "I'm getting an error that says 'source_sink library(...) does not exist' when running a Prolog script. How do I fix this?", "question_variants": ["How do I resolve library path errors in UnifyWeaver?", "What should I do when module loading fails?"], "level": 3, "tree_path": ["Running UnifyWeaver", "Environment Setup"], "answer": "This error means the module search path isn't configured. The best solution is to use init.pl from the project root: `swipl -f init.pl -g \"use_module(library(unifyweaver/sources)), halt\"`. Alternatively, use relative paths like `:- use_module('src/unifyweaver/sources').` and make sure you're running from the project root directory.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "src/unifyweaver/"], "tags": ["error-handling", "module-loading", "prolog-setup"]}
{"id": "skill_unifyweaver_environment_002", "question": "What's the recommended way to run UnifyWeaver Prolog scripts?", "question_variants": ["How should I execute Prolog scripts with UnifyWeaver modules?", "What's the best method to run UnifyWeaver code?"], "level": 2, "tree_path": ["Running UnifyWeaver", "Script Execution"], "answer": "Use init.pl from the project root for automatic environment setup: `cd /path/to/UnifyWeaver && swipl -f init.pl -g \"goal, halt\"`. This automatically configures file search paths and module loading. For inline initialization in playbooks, you can also manually set paths with `asserta(file_search_path(unifyweaver, 'src/unifyweaver'))` before loading modules.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "playbooks/"], "tags": ["script-execution", "best-practices", "module-loading"]}
{"id": "skill_unifyweaver_environment_003", "question": "Do I need to run UnifyWeaver commands from a specific directory?", "question_variants": ["Where should I execute UnifyWeaver scripts from?", "Does the working directory matter for running UnifyWeaver?"], "level": 2, "tree_path": ["Running UnifyWeaver", "Environment Setup"], "answer": "Yes, always run UnifyWeaver commands from the project root directory. This is critical because UnifyWeaver modules use relative paths from the project root (like `src/unifyweaver/`, `playbooks/`, and `templates/`). The init.pl file itself must also be in the project root to work correctly.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "src/unifyweaver/"], "tags": ["working-directory", "setup", "best-practices"]}
{"id": "skill_unifyweaver_environment_004", "question": "I'm getting an 'Unknown procedure' error when running my UnifyWeaver script. What should I check?", "question_variants": ["Why does my script say the procedure doesn't exist?", "How do I debug missing procedure errors?"], "level": 3, "tree_path": ["Running UnifyWeaver", "Error Handling"], "answer": "This means a module wasn't loaded. First, verify the module file exists at `src/unifyweaver/...` and exports the procedure. Then ensure you're loading the module with `:- use_module('src/unifyweaver/...')` or `:- use_module(library(unifyweaver/...))` if using init.pl. Finally, confirm you're running from the project root directory where the relative paths resolve correctly.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["src/unifyweaver/", "init.pl"], "tags": ["error-handling", "module-loading", "debugging"]}
{"id": "skill_extract_records_001", "question": "How do I extract structured examples from UnifyWeaver markdown files?", "question_variants": ["How can I parse data records from markdown files?", "What's the best way to extract examples from UnifyWeaver documentation?", "How do I get structured data out of markdown example files?"], "level": 2, "tree_path": ["Compilation", "Extract Records"], "answer": "Use the `extract_records.pl` script for parsing UnifyWeaver Example Record Format files:\n\n```bash\nperl scripts/utils/extract_records.pl [OPTIONS] [PATH...]\n```\n\nCommon options:\n- `-f content`: Extract just the code/content\n- `-f json`: Get structured JSON output\n- `-q <pattern>`: Filter records by name\n- `--file-filter all`: Process all files (default filters by file_type)\n\nThis is more robust than `grep` because it handles metadata, multi-line blocks, and produces structured output. See `skill_extract_records.md` for details.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md", "scripts/utils/extract_records.pl"], "tags": ["parsing", "markdown", "extraction", "records", "examples"]}
{"id": "skill_extract_records_002", "question": "I need to run an example from the UnifyWeaver examples library - how do I extract and execute it?", "question_variants": ["How do I run bash scripts from UnifyWeaver markdown examples?", "What's the correct way to execute extracted example code?", "How do I know whether to use bash or swipl for an extracted example?"], "level": 3, "tree_path": ["Compilation", "Extract Records", "Execution"], "answer": "**CRITICAL**: Check the code fence type (```bash or ```prolog) to use the right interpreter.\n\nFor **bash scripts**:\n```bash\nperl scripts/utils/extract_records.pl \\\n  -f content \\\n  -q \"record.name.pattern\" \\\n  path/to/file.md > tmp/script.sh\n\nbash tmp/script.sh  # Use bash, NOT swipl!\n```\n\nFor **Prolog code**:\n```bash\nperl scripts/utils/extract_records.pl \\\n  -f content \\\n  -q \"prolog.record\" \\\n  path/to/file.md > tmp/code.pl\n\nswipl -f init.pl -g \"consult('tmp/code.pl'), goal, halt\"\n```\n\nSee `skill_extract_records.md` section 4 for details.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["execution", "bash", "prolog", "examples", "interpreter"]}
{"id": "skill_extract_records_003", "question": "How can I filter and get only specific records from a markdown file?", "question_variants": ["How do I search for particular examples by name?", "Can I extract only certain records matching a pattern?", "How do I query records by their metadata?"], "level": 3, "tree_path": ["Compilation", "Extract Records", "Filtering"], "answer": "Use the `-q` (query) flag to filter records by their `name` metadata using regex:\n\n```bash\nperl scripts/utils/extract_records.pl \\\n  -q \"unifyweaver.execution.xml_data_source\" \\\n  playbooks/examples_library/xml_examples.md\n```\n\nYou can also filter by file frontmatter:\n```bash\n# Process only specific file types\nperl scripts/utils/extract_records.pl \\\n  --file-filter \"file_type=My Custom Type\" \\\n  path/to/files/\n\n# Process all files regardless of type\nperl scripts/utils/extract_records.pl \\\n  --file-filter all \\\n  path/to/files/\n```\n\nSee `skill_extract_records.md` section 3.1 for all filtering options.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["filtering", "query", "regex", "metadata", "search"]}
{"id": "skill_extract_records_004", "question": "What output formats are available when extracting records?", "question_variants": ["Can I get JSON output from extracted records?", "How do I get just the code content without the markdown formatting?", "What's the difference between full, content, and json formats?"], "level": 3, "tree_path": ["Compilation", "Extract Records", "Output Formats"], "answer": "The `-f` flag controls output format:\n\n**`-f full`** (default): Complete markdown block including metadata\n**`-f content`**: Raw code/content only (use this to save to .sh or .pl files)\n**`-f json`**: Structured JSON objects for programmatic processing\n\nExamples:\n```bash\n# Get full markdown blocks\nperl scripts/utils/extract_records.pl -f full file.md\n\n# Extract just code to run\nperl scripts/utils/extract_records.pl -f content file.md > script.sh\n\n# Get structured data for processing\nperl scripts/utils/extract_records.pl -f json file.md | jq '.'\n```\n\nChange the separator with `-s` (default is null byte \\0). See `skill_extract_records.md` section 3.1.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["output", "format", "json", "content", "parsing"]}
{"id": "skill_find_executable_001", "question": "How do I fix 'command not found' errors when running Perl or SWI-Prolog?", "question_variants": ["My agent can't find perl even though it's installed", "Getting command not found for swipl, how to locate it?", "How to find executables that aren't in PATH?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "Use the Find Executable skill to locate executables that aren't in your system's PATH. This skill searches common installation directories on Windows, Linux, and macOS to find tools like `perl` or `swipl`. Once found, it returns the full path so your agent can execute the command directly (e.g., `& \"C:\\Strawberry\\perl\\bin\\perl.exe\" my_script.pl`).", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["executable", "PATH", "command-not-found", "perl", "swipl"]}
{"id": "skill_find_executable_002", "question": "What should my agent do when a command fails because it's not in PATH?", "question_variants": ["How to handle executables not in system PATH?", "Agent can't execute installed programs", "Command exists but agent can't find it"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "When a command fails with 'command not found' but you know it's installed, use the Find Executable skill. It searches OS-specific directories (like `C:\\Strawberry\\perl\\bin` on Windows or `/opt/homebrew/bin` on macOS) to locate the executable and returns its absolute path for execution.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["executable", "PATH", "system-path", "troubleshooting"]}
{"id": "skill_find_executable_003", "question": "How can I run Perl scripts when perl isn't in my PATH?", "question_variants": ["Perl installed but command not found", "How to locate perl executable on Windows?", "Find perl binary on macOS"], "level": 3, "tree_path": ["Compilation", "Find Executable", "Perl"], "answer": "Use the Find Executable skill to locate the `perl` executable. It searches common installation paths like `C:\\Strawberry\\perl\\bin` (Windows), `/usr/local/bin` (Linux/macOS), and returns the full path. Your agent can then execute scripts using the absolute path.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["perl", "executable", "strawberry-perl", "PATH"]}
{"id": "skill_find_executable_004", "question": "Where does the agent look for executables on different operating systems?", "question_variants": ["What directories are searched for missing executables?", "Common installation paths checked by Find Executable", "OS-specific executable search paths"], "level": 3, "tree_path": ["Compilation", "Find Executable", "Search Paths"], "answer": "The Find Executable skill searches OS-specific directories: Windows checks `C:\\Strawberry\\perl\\bin`, `C:\\Program Files\\swipl\\bin`; Linux searches `/usr/bin`, `/usr/local/bin`, `/snap/bin`; macOS looks in `/usr/local/bin`, `/opt/homebrew/bin`, `/Applications/SWI-Prolog.app/Contents/MacOS`, and more. If found, it returns the absolute path; otherwise an empty string.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["search-paths", "installation-directories", "cross-platform", "windows", "linux", "macos"]}
{"id": "skill_json_sources_001", "question": "How do I read JSON data into my Prolog program?", "question_variants": ["How do I load JSON files in UnifyWeaver?", "What's the syntax for reading JSON data sources?", "How do I declare a JSON source in Prolog?"], "level": 2, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use the `source/3` directive to declare JSON data sources. For basic column projection, specify `columns/1` with field paths using dot notation: `:- source(json, order_totals, [json_file('data/orders.json'), columns(['order.customer.name', 'items[0].product'])])`. For JSONPath selectors, use `jsonpath('$.orders[*].total')`. For full JSON objects, use `return_object(true)` with `type_hint/1`. See skill_json_sources.md for all options including schema-generated records and JSON Lines support.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "data-sources", "source-directive", "columns"]}
{"id": "skill_json_sources_002", "question": "How do I handle complex JSON paths with wildcards and nested arrays?", "question_variants": ["Can I use JSONPath selectors in my JSON sources?", "How do I select data from nested JSON structures?", "What's the syntax for wildcards in JSON column paths?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources", "JSONPath Selectors"], "answer": "Use `jsonpath/1` option with JSONPath selectors for complex queries. Supported features include root `$`, dotted properties, bracket notation `['foo']`, array indices `[0]`, wildcards `[*]`, and recursive descent `..name`. Example: `jsonpath('$.orders[*].total')`. Strings starting with `$` are automatically treated as JSONPath, so `columns(['$.orders[0].id'])` works too. Use in both `columns/1` and `schema/1` declarations. See skill_json_sources.md for complete JSONPath syntax.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "jsonpath", "selectors", "wildcards", "nested-data"]}
{"id": "skill_json_sources_003", "question": "How do I create typed records from JSON data instead of just tuples?", "question_variants": ["Can I map JSON to strongly-typed objects in UnifyWeaver?", "How do I generate POCOs from JSON sources?", "What's the schema option for JSON sources?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources", "Schema-Generated Records"], "answer": "Use `schema/1` to declare typed records that generate C# POCOs. Specify fields with `field(Name, Path, Type)` and optionally name the record with `record_type/1`. Example: `:- source(json, product_rows, [json_file('data.json'), schema([field(id, 'id', string), field(price, 'price', double)]), record_type('ProductRecord')])`. Arity must be 1; `return_object(true)` is implied. For nested structures, use `record(TypeName, Fields)`. See skill_json_sources.md for nested schema examples.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "schema", "typed-records", "poco", "code-generation"]}
{"id": "skill_json_sources_004", "question": "How do I handle missing or null values in JSON data?", "question_variants": ["What happens when JSON fields are null or missing?", "How do I set default values for missing JSON fields?", "Can I skip rows with null values in JSON sources?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources", "Null Policies"], "answer": "Use `null_policy/1` to control missing/null field behavior. Options: `null_policy(fail)` throws immediately on null, `null_policy(skip)` skips rows with nulls, `null_policy(default(Value))` substitutes a placeholder (e.g., `default('N/A')` or `default('0')`). Example: `:- source(json, items, [json_file('data.jsonl'), columns([jsonpath('$.items[1].product')]), null_policy(default('N/A'))])`. Also useful with `record_format(jsonl)` for newline-delimited JSON. See skill_json_sources.md for validation rules.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "null-handling", "default-values", "error-handling", "jsonl"]}
{"id": "skill_unifyweaver_compile_001", "question": "How do I convert Prolog rules into an executable bash script?", "question_variants": ["How can I transpile Prolog predicates to bash?", "What's the process for compiling Prolog to bash in UnifyWeaver?"], "level": 2, "tree_path": ["Compilation", "Prolog-to-Bash Transpiler"], "answer": "Use the UnifyWeaver compiler to transpile Prolog to bash. Run: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<your_file.pl>'), compile(<predicate>/<arity>, [output_dir('.')])\" -t halt`. For example, to compile `choose_strategy/3` from `temp_strategy.pl`: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('temp_strategy.pl'), compile(choose_strategy/3, [output_dir('.')])\", -t halt`. This creates an executable `.sh` file. Note: arithmetic operators like `>`, `<` are not yet supported.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md", "src/unifyweaver/core/compiler_driver.pl", "src/unifyweaver/targets/bash/"], "tags": ["compilation", "transpiler", "prolog", "bash", "compiler_driver"]}
{"id": "skill_unifyweaver_compile_002", "question": "I have Prolog predicates in a file - how do I make them executable?", "question_variants": ["How do I run Prolog rules as a script?", "What's the next step after writing Prolog predicates?"], "level": 2, "tree_path": ["Compilation", "Making Predicates Executable"], "answer": "Compile your Prolog file to an executable bash script using UnifyWeaver's compiler. The command is: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<prolog_file>'), compile(<predicate>/<arity>, [output_dir('.')])\" -t halt`. Replace `<prolog_file>` with your `.pl` file path, and `<predicate>/<arity>` with your main predicate (e.g., `choose_strategy/3`). The compiler handles dependencies automatically and outputs a `.sh` file you can execute directly.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl", "src/unifyweaver/targets/bash/"], "tags": ["compilation", "executable", "prolog", "workflow"]}
{"id": "skill_unifyweaver_compile_003", "question": "Where does the compiled bash script get saved?", "question_variants": ["How do I specify the output location for compiled scripts?", "Can I control where the .sh file is created?"], "level": 3, "tree_path": ["Compilation", "Output Configuration"], "answer": "Use the `output_dir('<directory>')` option when compiling. For example: `compile(my_predicate/2, [output_dir('.')])` saves to the current directory. If you don't specify `output_dir`, the file may be saved to an unexpected default location. The output filename is automatically derived from the predicate name (e.g., `my_predicate.sh`).", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["compilation", "output", "configuration", "compiler_driver"]}
{"id": "skill_unifyweaver_compile_004", "question": "Why does my Prolog compilation fail with arithmetic operators?", "question_variants": ["Can I use > or < in predicates I want to compile?", "What arithmetic operations are supported in compilation?"], "level": 3, "tree_path": ["Compilation", "Limitations"], "answer": "The current UnifyWeaver compiler has a known limitation: it cannot transpile predicates that directly use arithmetic comparison operators like `>`, `<`, or `=<`. This will cause compilation to fail. As a workaround, restructure your logic to avoid direct arithmetic comparisons in predicates you need to compile. Dependencies are handled automatically, but any predicate using these operators will block the compilation process.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["compilation", "limitations", "arithmetic", "troubleshooting", "operators"]}
{"id": "skill_unifyweaver_environment_001", "question": "I'm getting an error 'source_sink library(unifyweaver/...) does not exist' when running my script", "question_variants": ["How do I fix 'source_sink library does not exist' errors?", "Why can't Prolog find the UnifyWeaver modules?", "Getting module not found errors in UnifyWeaver"], "level": 3, "tree_path": ["Compilation", "Environment Setup", "Troubleshooting"], "answer": "This error means the UnifyWeaver module path isn't in your search path. Run your script using `swipl -f init.pl` from the project root directory, which sets up all module paths automatically. Alternatively, use relative paths like `'src/unifyweaver/sources'` instead of `library(unifyweaver/sources)` and ensure you're running from the project root.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "scripts/testing/init_testing.sh"], "tags": ["environment", "modules", "errors", "troubleshooting"]}
{"id": "skill_unifyweaver_environment_002", "question": "How do I run UnifyWeaver playbooks correctly?", "question_variants": ["What's the proper way to execute UnifyWeaver scripts?", "How do I set up the environment for running UnifyWeaver?", "What directory should I run UnifyWeaver commands from?"], "level": 2, "tree_path": ["Compilation", "Environment Setup"], "answer": "Always run UnifyWeaver commands from the project root directory (which contains `src/unifyweaver/`, `playbooks/`, and `init.pl`). Use `swipl -f init.pl -g \"your_goal, halt\"` for scripts, or use inline initialization in playbooks: `swipl -q -g \"asserta(file_search_path(unifyweaver, 'src/unifyweaver')), [your_script], halt\"` for reproducibility.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "playbooks/examples_library/", "templates/init_template.pl"], "tags": ["environment", "playbooks", "execution", "setup"]}
{"id": "skill_unifyweaver_environment_003", "question": "What's the difference between using init.pl and inline initialization?", "question_variants": ["Should I use init.pl or inline setup for my script?", "When should I use swipl -f init.pl?", "What's the best way to initialize the UnifyWeaver environment?"], "level": 3, "tree_path": ["Compilation", "Environment Setup", "Initialization Methods"], "answer": "Use `swipl -f init.pl` for interactive sessions and regular scripts - it automatically sets up all paths. Use inline initialization (`asserta(file_search_path(unifyweaver, 'src/unifyweaver'))`) for playbooks where you want the setup embedded in the command for reproducibility. Both require running from the project root directory.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "templates/init_template.pl"], "tags": ["environment", "initialization", "init.pl", "best-practices"]}
{"id": "skill_unifyweaver_environment_004", "question": "How do I set up a test environment for UnifyWeaver?", "question_variants": ["Can I create an isolated UnifyWeaver environment for testing?", "How do I test UnifyWeaver without affecting my main project?", "What's the test environment initialization process?"], "level": 3, "tree_path": ["Compilation", "Environment Setup", "Testing"], "answer": "Use the test environment initialization script: `cd /path/to/UnifyWeaver && bash scripts/testing/init_testing.sh && cd scripts/testing/test_env && ./unifyweaver.sh`. This creates a self-contained environment with all modules copied, allowing isolated testing without affecting your main project.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["scripts/testing/init_testing.sh"], "tags": ["testing", "environment", "isolation", "test-setup"]}
{"id": "skill_extract_records_001", "question": "How do I extract code examples or data records from markdown files?", "question_variants": ["Is there a tool to parse structured data from the documentation?", "How can I get JSON output from markdown records instead of just using grep?"], "level": 2, "tree_path": ["Compilation", "Extract Records"], "answer": "Use the `scripts/utils/extract_records.pl` tool. It is designed to parse UnifyWeaver Example Record Format files, handling metadata and multi-line blocks more reliably than `grep`, and can output in JSON format.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md", "scripts/utils/extract_records.pl"], "tags": ["extraction", "parsing", "tools"]}
{"id": "skill_extract_records_002", "question": "How do I run a bash script found in a markdown record?", "question_variants": ["I want to execute a shell script record from the playbooks.", "What is the correct way to extract and run a bash code block?"], "level": 3, "tree_path": ["Compilation", "Extract Records"], "answer": "Extract the content using `perl scripts/utils/extract_records.pl -f content ... > script.sh`, then run it using `bash script.sh`. Do not attempt to run bash records using `swipl`.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["bash", "execution", "cli"]}
{"id": "skill_extract_records_003", "question": "How can I filter extracted records by their name?", "question_variants": ["Can I search for a specific metadata ID within the markdown files?", "How do I query records using a regex pattern?"], "level": 3, "tree_path": ["Compilation", "Extract Records"], "answer": "Use the `-q` or `--query` flag with the `extract_records.pl` script. This accepts a regex pattern to filter records based on their `name` metadata field.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["filtering", "querying", "metadata"]}
{"id": "skill_extract_records_004", "question": "How do I extract and load Prolog code from documentation examples?", "question_variants": ["How can I test the prolog snippets found in the guide?", "What is the workflow for consulting a prolog record?"], "level": 3, "tree_path": ["Compilation", "Extract Records"], "answer": "Use `scripts/utils/extract_records.pl` with the `-f content` flag to save the code to a `.pl` file. You can then load it into the runtime using `swipl -f init.pl -g \"consult('file.pl')...\"`.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["prolog", "execution", "workflow"]}
{"id": "skill_find_executable_001", "question": "What should I do if a command like 'perl' is not found in my system path?", "question_variants": ["How do I locate an executable that is missing from my PATH?", "What happens if a tool like SWI-Prolog isn't recognized by the terminal?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "Use the 'Find Executable' skill to search common installation directories across Windows, Linux, and macOS. It returns the absolute path to the binary, allowing you to execute it directly even if it's missing from your PATH.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["path", "troubleshooting", "executable"]}
{"id": "skill_find_executable_002", "question": "How can I find the installation path for a specific tool on my computer?", "question_variants": ["Can the agent help me locate where a program is installed?", "How do I find the full path to an executable file?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "By providing the executable name (e.g., 'swipl' or 'perl'), the 'Find Executable' skill searches standard OS-specific locations like /usr/local/bin or Program Files and returns the full path for execution.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["installation", "search", "tools"]}
{"id": "skill_find_executable_003", "question": "Where does the agent look for software that isn't in the PATH?", "question_variants": ["What directories are searched when trying to find a missing tool?", "Which standard locations are checked for installed executables?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "The 'Find Executable' skill searches predefined directories based on your OS, such as C:\\Program Files on Windows, /usr/bin and /snap/bin on Linux, and /opt/homebrew/bin or Applications on macOS.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["directories", "os-specific", "environment"]}
{"id": "skill_find_executable_004", "question": "My terminal says 'command not found'. Is there a way to fix this automatically?", "question_variants": ["How do I resolve a 'command not found' error for a required tool?", "Can the system automatically find a program if the shell can't?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "When a 'command not found' error occurs, trigger the 'Find Executable' skill. It attempts to locate the binary in common installation paths and returns the absolute path needed to run the command successfully.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["errors", "automation", "fix"]}
{"id": "skill_json_sources_001", "question": "How do I read specific fields from a JSON file into a Prolog predicate?", "question_variants": ["How to project JSON fields to Prolog arguments?", "Reading a JSON file with specific columns"], "level": 2, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use the `:- source(json, ...)` directive with the `columns/1` option. Provide a list of field names (dot notation) or `jsonpath(...)` selectors that match the arity of your predicate.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "source", "columns", "projection"]}
{"id": "skill_json_sources_002", "question": "How can I select nested data or arrays from a JSON source?", "question_variants": ["Using JSONPath in UnifyWeaver sources", "Extracting values from JSON arrays using wildcards"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use `jsonpath('$.selector')` within your `columns` or `schema` definition. You can use standard JSONPath features like `[*]` for wildcards, `[0]` for indices, and `..` for recursive descent.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "jsonpath", "nested-data"]}
{"id": "skill_json_sources_003", "question": "How do I map JSON data to strongly typed C# records?", "question_variants": ["Generating POCOs from JSON sources", "Using schema definitions for JSON files"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use the `schema/1` option in your source declaration instead of `columns/1`. Define a list of `field(Name, Path, Type)` terms and set `record_type('TypeName')`. The predicate must have an arity of 1.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "schema", "csharp", "types"]}
{"id": "skill_json_sources_004", "question": "How do I process newline-delimited JSON (JSONL) files?", "question_variants": ["Reading .jsonl files in UnifyWeaver", "Handling null values in JSON sources"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Add `record_format(jsonl)` to your source options. You can also configure `null_policy/1` (set to `skip`, `fail`, or `default(Value)`) to manage how missing data impacts the stream.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "jsonl", "null-handling", "streaming"]}
{"id": "skill_unifyweaver_compile_001", "question": "How do I turn my Prolog file into an executable bash script?", "question_variants": ["Convert prolog logic to shell script", "How to compile prolog rules to bash", "Make prolog file executable in bash"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "You can transpile Prolog logic to Bash using the UnifyWeaver compiler driver. Invoke it via `swipl` by loading the driver module and your source file, then calling the `compile/2` predicate. For example: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('my_rules.pl'), compile(my_pred/2, [output_dir('.')])\" -t halt`.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md", "src/unifyweaver/core/compiler_driver.pl", "src/unifyweaver/targets/bash/"], "tags": ["compilation", "bash", "prolog", "transpiler"]}
{"id": "skill_unifyweaver_compile_002", "question": "What is the command syntax to compile a specific predicate?", "question_variants": ["Command to transpile a prolog predicate", "How to run the unifyweaver compiler", "Syntax for compiling functor/arity to bash"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "The standard command follows this template: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<prolog_file>'), compile(<predicate_indicator>, [<options>])\" -t halt`. Ensure you specify the `output_dir` option, usually `output_dir('.')`, to control where the resulting script is saved.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["command", "syntax", "compiler_driver", "swipl"]}
{"id": "skill_unifyweaver_compile_003", "question": "Does the compiler handle dependencies if my rule uses other rules?", "question_variants": ["Do I need to compile dependent predicates manually?", "How does the compiler handle sub-goals?", "Automatic dependency resolution in compilation"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "Yes, the compiler automatically handles dependencies. When you target a specific predicate (e.g., `main/0`), the `compiler_driver` analyzes the call graph and compiles all user-defined predicates that your main predicate depends on into the final Bash script.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["dependencies", "compilation", "automation"]}
{"id": "skill_unifyweaver_compile_004", "question": "Why is my compilation failing when using arithmetic operators?", "question_variants": ["Can I use greater than or less than signs in rules to be compiled?", "Compilation error with arithmetic comparisons", "Limitations of the bash transpiler"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "The current version of the UnifyWeaver `compiler_driver` has a limitation regarding arithmetic comparison operators. It cannot transpile predicates that directly use operators like `>`, `<`, or `=<`. You must restructure your logic to avoid direct arithmetic comparisons in the Prolog source intended for Bash compilation.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["limitations", "arithmetic", "troubleshooting", "bash"]}
{"id": "skill_unifyweaver_environment_001", "question": "How do I run a UnifyWeaver Prolog script correctly?", "question_variants": ["What is the standard command to execute a script using UnifyWeaver modules?", "How do I use init.pl to run my script?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "Run `swipl` from the project root using the `-f init.pl` flag to automatically set up paths. For example:\n```bash\ncd /path/to/UnifyWeaver\nswipl -f init.pl -g \"consult('your_script.pl'), run_goal, halt\"\n```", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["templates/init_template.pl"], "tags": ["environment", "init.pl", "execution"]}
{"id": "skill_unifyweaver_environment_002", "question": "How do I fix 'source_sink library(unifyweaver/...) does not exist' errors?", "question_variants": ["Why can't Prolog find the unifyweaver library modules?", "I'm getting an error about missing source_sink library files when running a script."], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "This error occurs when the module search path isn't configured. To fix it:\n1. Ensure you are running from the **project root directory**.\n2. Use the `init.pl` file: `swipl -f init.pl ...`\n3. Or use relative paths in your code (e.g., `'src/unifyweaver/sources'` instead of `library(...)`).", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": [], "tags": ["troubleshooting", "modules", "paths"]}
{"id": "skill_unifyweaver_environment_003", "question": "Where should I run UnifyWeaver commands from?", "question_variants": ["What is the required working directory for UnifyWeaver?", "Do I need to be in a specific folder to run playbooks?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "CRITICAL: All UnifyWeaver commands and scripts must be run from the **project root directory**. This is the directory containing `src/`, `playbooks/`, and `init.pl`.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": [], "tags": ["environment", "directory", "setup"]}
{"id": "skill_unifyweaver_environment_004", "question": "How do I configure the UnifyWeaver environment in a standalone playbook?", "question_variants": ["What is the best way to load paths in a bash playbook?", "How do I use inline initialization for non-interactive scripts?"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "For reproducible playbooks, you can use inline initialization to set the search path before loading modules:\n```bash\nswipl -g \"asserta(file_search_path(unifyweaver, 'src/unifyweaver')), [script], halt\"\n```\nAlternatively, simply invoke with `swipl -f init.pl ...`.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["playbooks/examples_library/"], "tags": ["playbooks", "automation", "inline-init"]}
{"id": "skill_extract_records_001", "question": "How do I extract structured data records from Markdown files?", "question_variants": ["How can I parse records from Markdown files?", "What's the best way to extract example data from Markdown?"], "level": 2, "tree_path": ["Data Processing", "Extract Records"], "answer": "Use the `extract_records.pl` script to parse structured data records from Markdown files. This is more robust than grep for handling metadata and multi-line content blocks.\n\nBasic command:\n```bash\nperl scripts/utils/extract_records.pl path/to/file.md\n```\n\nFor JSON output:\n```bash\nperl scripts/utils/extract_records.pl -f json path/to/file.md\n```\n\nSee skill_extract_records.md for details.", "related_skills": ["skill_extract_records.md", "skill_data_sources.md", "skill_json_sources.md"], "related_docs": ["docs/playbooks/parsing/README.md", "scripts/utils/extract_records.pl"], "tags": ["data-extraction", "markdown", "parsing"]}
{"id": "skill_extract_records_002", "question": "How do I filter records by name when extracting from Markdown?", "question_variants": ["Can I search for specific records by name?", "How do I extract only certain records from a file?"], "level": 3, "tree_path": ["Data Processing", "Extract Records"], "answer": "Use the `-q` (query) flag with a regex pattern to filter records by their `name` metadata.\n\n```bash\nperl scripts/utils/extract_records.pl -q \"pattern_name\" path/to/file.md\n```\n\nExample filtering for specific record names:\n```bash\nperl scripts/utils/extract_records.pl -q \"unifyweaver.execution\" playbooks/examples_library/file.md\n```\n\nSee skill_extract_records.md for details.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["filtering", "regex", "metadata"]}
{"id": "skill_extract_records_003", "question": "What output formats are available when extracting records?", "question_variants": ["Can I get record output as JSON?", "How do I extract just the content without metadata?"], "level": 2, "tree_path": ["Data Processing", "Extract Records"], "answer": "Three output formats are available via the `-f` flag:\n\n- **full**: Complete original Markdown block (default)\n- **content**: Raw content only (no metadata wrapper)\n- **json**: Stream of JSON objects with structured data\n\nExample:\n```bash\nperl scripts/utils/extract_records.pl -f json path/to/file.md\nperl scripts/utils/extract_records.pl -f content path/to/file.md\n```\n\nSee skill_extract_records.md for details.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["output-formats", "json", "parsing"]}
{"id": "skill_extract_records_004", "question": "How do I run extracted bash scripts from records?", "question_variants": ["I extracted a bash script - how do I execute it?", "What's the right way to run bash code from extracted records?"], "level": 3, "tree_path": ["Data Processing", "Extract Records"], "answer": "Extract bash scripts with `-f content`, save to a `.sh` file, then run with `bash`:\n\n```bash\nperl scripts/utils/extract_records.pl -f content -q \"record_name\" file.md > script.sh\nbash script.sh\n```\n\nCritical: Always check the code fence type (```bash vs ```prolog) and use the appropriate interpreter. Running bash scripts with `swipl` will fail.\n\nSee skill_extract_records.md for details.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["bash", "execution", "scripts"]}
{"id": "skill_extract_records_005", "question": "How do I extract and load Prolog code from records?", "question_variants": ["How do I use Prolog code from extracted records?", "How do I load extracted Prolog files with swipl?"], "level": 3, "tree_path": ["Data Processing", "Extract Records"], "answer": "Extract Prolog code with `-f content`, save to a `.pl` file, then load with `swipl`:\n\n```bash\nperl scripts/utils/extract_records.pl -f content -q \"record_name\" file.md > code.pl\nswipl -f init.pl -g \"consult('code.pl'), goal, halt\"\n```\n\nImportant: Code marked with ```prolog should be loaded with `swipl`, not `bash`. Verify the code fence language before choosing your interpreter.\n\nSee skill_extract_records.md for details.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["prolog", "swipl", "code-loading"]}
{"id": "skill_extract_records_006", "question": "When should I use extract_records instead of grep?", "question_variants": ["Should I use grep or extract_records for parsing Markdown?", "What are the advantages of extract_records over grep?"], "level": 2, "tree_path": ["Data Processing", "Extract Records"], "answer": "Use `extract_records.pl` when you need to:\n\n- Parse metadata like `id` or `name` fields\n- Handle multi-line content blocks reliably\n- Get output in structured formats (JSON)\n- Process files that follow the UnifyWeaver Example Record Format\n\nUse `grep` for simple pattern matching in plain text. The `extract_records` tool is specifically designed for semantic parsing of structured records, making it more robust for complex data extraction tasks.\n\nSee skill_extract_records.md for details.", "related_skills": ["skill_extract_records.md", "skill_data_sources.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["comparison", "tools", "best-practices"]}
{"id": "skill_find_executable_001", "question": "How do I find an executable that's not in my system PATH?", "question_variants": ["Where can I locate a program if 'command not found' error occurs?", "How do I get the full path to an executable on my system?"], "level": 2, "tree_path": ["System", "Find Executable"], "answer": "Use the find executable skill to search common installation directories for the executable you need. Provide the executable name (e.g., 'perl', 'swipl'). The skill searches platform-specific directories and returns the absolute path if found, or an empty string if not. You can then use the returned path to run the command directly. See skill_find_executable.md for details.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["executable", "path", "system", "command-not-found"]}
{"id": "skill_find_executable_002", "question": "What do I do when a command fails with 'command not found'?", "question_variants": ["How do I handle a 'command not found' error?", "What's the next step when a program can't be located?"], "level": 2, "tree_path": ["System", "Find Executable"], "answer": "When you get a 'command not found' error, use the find executable skill to locate the program. Pass the executable name to the skill and it will search your system's common installation directories. If found, use the returned full path to execute the command, for example: `& \"C:\\Strawberry\\perl\\bin\\perl.exe\" my_script.pl` on Windows or `/opt/homebrew/bin/perl` on macOS. See skill_find_executable.md for details.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["command-not-found", "executable", "path", "error-handling"]}
{"id": "skill_find_executable_003", "question": "Which directories does the system check to find executables?", "question_variants": ["What are the common installation directories for programs?", "Where does the executable search look for programs?"], "level": 3, "tree_path": ["System", "Find Executable"], "answer": "The search paths vary by operating system. On Windows: `C:\\Strawberry\\perl\\bin`, `C:\\Program Files\\swipl\\bin`, `C:\\Program Files (x86)\\swipl\\bin`. On Linux: `/usr/bin`, `/usr/local/bin`, `/snap/bin`. On macOS: `/usr/bin`, `/usr/local/bin`, `/opt/homebrew/bin`, `/Applications/SWI-Prolog.app/Contents/MacOS`. The skill automatically uses the correct paths for your platform. See skill_find_executable.md for details.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["directories", "paths", "windows", "linux", "macos", "installation"]}
{"id": "skill_find_executable_004", "question": "How do I use a found executable path to run a command?", "question_variants": ["What do I do with the returned executable path?", "How do I execute a program using its full path?"], "level": 3, "tree_path": ["System", "Find Executable"], "answer": "Once the find executable skill returns the full path, use it directly to run the command. On Windows, use the `&` operator with quotes: `& \"C:\\Strawberry\\perl\\bin\\perl.exe\" my_script.pl`. On Unix-like systems, use the path directly: `/usr/local/bin/perl my_script.pl` or `/opt/homebrew/bin/swipl`. This bypasses the need for the executable to be in PATH. See skill_find_executable.md for details.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["execution", "path", "command-execution", "full-path"]}
{"id": "skill_find_executable_005", "question": "What happens if an executable is not found?", "question_variants": ["What does the skill return if the program isn't installed?", "How do I know if an executable couldn't be located?"], "level": 2, "tree_path": ["System", "Find Executable"], "answer": "If the executable cannot be found in any of the searched directories, the skill returns an empty string. This indicates the program is not installed in the common locations on your system. You may need to install the executable or manually specify its installation path. See skill_find_executable.md for details.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["not-found", "installation", "executable", "empty-result"]}
{"id": "skill_find_executable_006", "question": "Can I use this skill to find perl, Python, or SWI-Prolog?", "question_variants": ["What programs can this skill find?", "Does the skill work with specific programming languages?"], "level": 3, "tree_path": ["System", "Find Executable"], "answer": "Yes, the skill is designed to find commonly used executables including perl, swipl (SWI-Prolog), and other programs. It searches dedicated installation directories for these tools on each platform. For example, on Windows it checks `C:\\Strawberry\\perl\\bin` for Perl. Provide the executable name (e.g., 'perl', 'swipl', 'python') and the skill will search the platform-specific directories. See skill_find_executable.md for details.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["perl", "swipl", "prolog", "python", "programming-languages"]}
{"id": "skill_json_sources_001", "question": "How do I read specific columns from a JSON file in my playbook?", "question_variants": ["How do I project columns from JSON data?", "What's the syntax for selecting fields from JSON with dot notation?"], "level": 2, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use the `source(json, ...)` directive with `json_file()` and `columns()`. Provide column names using dot notation (e.g., `'order.customer.name'`) or array indices (e.g., `'items[0].total'`). The `columns/1` arity must match your predicate arity. Example:\n```prolog\n:- source(json, order_totals, [\n    json_file('data/orders.json'),\n    columns(['order.customer.name', 'items[0].product', 'items[0].total'])\n]).\n```\nSee skill_json_sources.md for details.", "related_skills": ["skill_json_sources.md"], "related_docs": ["src/unifyweaver/sources/json_source.pl"], "tags": ["json", "columns", "projection", "dot-notation"]}
{"id": "skill_json_sources_002", "question": "When should I use JSONPath selectors instead of dot notation?", "question_variants": ["How do I use JSONPath expressions to query JSON data?", "What complex JSON queries can I perform with JSONPath?"], "level": 2, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use `jsonpath()` for complex selections that dot notation can't handle. JSONPath supports root `$`, dotted properties, bracket properties, array indices `[0]`, wildcards `[*]`, and recursive descent `..name`. Strings starting with `$` are automatically treated as JSONPath. Example:\n```prolog\njsonpath('$.orders[*].total')\n```\nUse JSONPath in both `columns/1` and `schema/1` when you need advanced filtering or recursive selection. See skill_json_sources.md for details.", "related_skills": ["skill_json_sources.md"], "related_docs": ["src/unifyweaver/sources/json_source.pl"], "tags": ["jsonpath", "selectors", "complex-queries", "recursive-descent"]}
{"id": "skill_json_sources_003", "question": "How do I return full JSON objects as rows instead of projecting columns?", "question_variants": ["How do I work with raw JSON objects in my playbook?", "When would I use return_object mode?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use return-object mode by setting `arity(1)`, `return_object(true)`, and providing a `type_hint` with a .NET type. Example:\n```prolog\n:- source(json, raw_products, [\n    json_file('test_data/test_products.json'),\n    arity(1),\n    return_object(true),\n    type_hint('System.Text.Json.Nodes.JsonObject, System.Text.Json')\n]).\n```\nThis returns each JSON object as a row instead of extracting individual columns. See skill_json_sources.md for details.", "related_skills": ["skill_json_sources.md"], "related_docs": ["src/unifyweaver/sources/json_source.pl"], "tags": ["return-object", "raw-json", "type-hint"]}
{"id": "skill_json_sources_004", "question": "How do I define a typed record structure from JSON data?", "question_variants": ["How do I create a POCO from JSON using schema?", "How do I specify field types when reading JSON?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use `schema([field(Name, Path, Type), ...])` to declare typed records. The C# backend generates a POCO automatically. Example:\n```prolog\n:- source(json, product_rows, [\n    json_file('test_data/test_products.json'),\n    schema([\n        field(id, 'id', string),\n        field(name, 'name', string),\n        field(price, 'price', double)\n    ]),\n    record_type('ProductRecord')\n]).\n```\nPredicate arity must be `1` and `return_object(true)` is implied. Use `record_type()` to name the generated record. See skill_json_sources.md for details.", "related_skills": ["skill_json_sources.md"], "related_docs": ["src/unifyweaver/sources/json_source.pl"], "tags": ["schema", "typed-records", "poco", "field-mapping"]}
{"id": "skill_json_sources_005", "question": "How do I create nested record structures from JSON?", "question_variants": ["How do I handle nested objects in schema definitions?", "How do I map sub-objects from JSON to nested records?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use `record(TypeName, Fields)` or `record(Fields)` within your schema to create nested structures. Nested selectors are evaluated relative to their sub-object. Example:\n```prolog\n:- source(json, order_rows, [\n    json_file('test_data/test_orders.json'),\n    schema([\n        field(order, 'order', record('OrderRecord', [\n            field(id, 'id', string),\n            field(customer, 'customer.name', string)\n        ])),\n        field(first_item, 'items[0]', record('LineItemRecord', [\n            field(product, 'product', string),\n            field(total, 'total', double)\n        ]))\n    ]),\n    record_type('OrderSummaryRecord')\n]).\n```\nThe runtime instantiates all nested POCOs automatically. See skill_json_sources.md for details.", "related_skills": ["skill_json_sources.md"], "related_docs": ["src/unifyweaver/sources/json_source.pl"], "tags": ["nested-records", "nested-schema", "sub-objects", "structured-data"]}
{"id": "skill_json_sources_006", "question": "How do I handle missing or null values when reading JSON Lines files?", "question_variants": ["How do I configure null handling for JSONL streams?", "What options do I have for missing JSON fields?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use `record_format(jsonl)` for newline-delimited JSON and `null_policy()` to control null behavior. Options: `null_policy(fail)` throws on null, `null_policy(skip)` skips rows with nulls, `null_policy(default(Value))` substitutes a placeholder. Example:\n```prolog\n:- source(json, order_items, [\n    json_file('test_data/test_orders.jsonl'),\n    record_format(jsonl),\n    columns([jsonpath('$.order.customer.name'), jsonpath('$.items[1].product')]),\n    null_policy(default('N/A'))\n]).\n```\nEach line is treated as an independent object. See skill_json_sources.md for details.", "related_skills": ["skill_json_sources.md"], "related_docs": ["src/unifyweaver/sources/json_source.pl"], "tags": ["jsonl", "null-policy", "missing-data", "default-values"]}
{"id": "skill_unifyweaver_compile_001", "question": "How do I convert Prolog rules into an executable bash script?", "question_variants": ["How do I transpile Prolog predicates to bash?", "What's the process for turning Prolog code into a runnable script?", "How do I compile my Prolog rules to bash?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "Use the UnifyWeaver compilation engine with swipl. Run: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<prolog_file>'), compile(<predicate_indicator>, [<options>])\" -t halt` where `<prolog_file>` is your .pl file and `<predicate_indicator>` is the main predicate (e.g., `choose_strategy/3`). Always include `output_dir('.')` in options to save the compiled .sh file to the current directory. See skill_unifyweaver_compile.md for details.", "related_skills": ["skill_unifyweaver_compile.md", "skill_unifyweaver_environment.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl", "src/unifyweaver/targets/bash/"], "tags": ["compilation", "transpiler", "prolog", "bash"]}
{"id": "skill_unifyweaver_compile_002", "question": "Where does the compiled bash script get saved after compilation?", "question_variants": ["What's the output location for compiled scripts?", "How do I control where the .sh file is created?", "Can I specify the output directory for my compiled script?"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "The compiled .sh file is saved to the directory specified by the `output_dir()` option. Include `output_dir('.')` to save to the current directory, or specify another path like `output_dir('/path/to/output')`. The filename is automatically derived from the predicate name (e.g., `choose_strategy/3` becomes `choose_strategy.sh`). It's highly recommended to always set `output_dir` to a known location. See skill_unifyweaver_compile.md for details.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["compilation", "output", "configuration"]}
{"id": "skill_unifyweaver_compile_003", "question": "What happens if my Prolog predicates use arithmetic comparison operators like > or <?", "question_variants": ["Can I compile Prolog rules with arithmetic comparisons?", "Why is my compilation failing with arithmetic operators?", "Are there limitations with math operators in Prolog compilation?"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "The current version of the compiler driver has a known limitation: it cannot transpile predicates that directly use arithmetic comparison operators (`>`, `<`, `=<`, etc.). Attempting to compile such predicates will cause the compilation to fail. You'll need to refactor your Prolog rules to avoid direct arithmetic comparisons or use alternative logic patterns. See skill_unifyweaver_compile.md for details.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md"], "tags": ["compilation", "limitations", "arithmetic", "operators"]}
{"id": "skill_unifyweaver_compile_004", "question": "Do I need to manually handle all the dependencies when compiling a predicate?", "question_variants": ["How are dependencies handled during compilation?", "Will the compiler automatically compile predicates that my main predicate depends on?", "What happens with helper predicates during compilation?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "No, you don't need to manually handle dependencies. The compiler automatically analyzes and compiles any user-defined predicates that your main predicate depends on. You only need to specify the main predicate indicator (e.g., `choose_strategy/3`) in the compile command, and the compiler will take care of resolving and including all dependencies in the output bash script. See skill_unifyweaver_compile.md for details.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["src/unifyweaver/core/compiler_driver.pl", "docs/ADVANCED_RECURSION.md"], "tags": ["compilation", "dependencies", "automation"]}
{"id": "skill_unifyweaver_compile_005", "question": "What format should I use to specify which predicate to compile?", "question_variants": ["How do I identify the main predicate to compile?", "What's the correct syntax for the predicate indicator?", "How do predicates work with their arity in compilation?"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "Use the predicate indicator format `functor/arity`, where functor is the predicate name and arity is the number of arguments. For example, `choose_strategy/3` means compile the predicate named `choose_strategy` that takes 3 arguments. This format tells the compiler exactly which predicate to transpile from your .pl file. Include it in the compile command as: `compile(choose_strategy/3, [output_dir('.')])`. See skill_unifyweaver_compile.md for details.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["src/unifyweaver/core/compiler_driver.pl"], "tags": ["compilation", "predicate", "syntax", "indicators"]}
{"id": "skill_unifyweaver_compile_006", "question": "What basic command structure should I use when compiling Prolog to bash?", "question_variants": ["What's the general command format for compilation?", "Can you show me the basic template for a compilation command?", "How do I structure the swipl command for compilation?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "The basic command structure is: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<prolog_file>'), compile(<predicate_indicator>, [<options>])\" -t halt`. Replace `<prolog_file>` with your .pl file path, `<predicate_indicator>` with the predicate you want to compile (e.g., `choose_strategy/3`), and include at least `output_dir('.')` in the options. The result is an executable .sh file in your specified output directory. See skill_unifyweaver_compile.md for details.", "related_skills": ["skill_unifyweaver_compile.md", "skill_unifyweaver_environment.md"], "related_docs": ["docs/EXTENDED_README.md"], "tags": ["compilation", "command", "template", "swipl"]}
{"id": "skill_unifyweaver_environment_001", "question": "I'm getting an error that says 'source_sink library(...) does not exist' when trying to run a Prolog script. How do I fix this?", "question_variants": ["Why can't Prolog find my UnifyWeaver modules?", "How do I fix module loading errors in Prolog scripts?", "What does 'library(...) does not exist' mean and how do I resolve it?"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "This error means the module path isn't in your search path. Run from the project root and use `swipl -f init.pl -g \"use_module(library(unifyweaver/sources)), halt\"`. If that doesn't work, use relative paths instead: `:- use_module('src/unifyweaver/sources').` See skill_unifyweaver_environment.md for details.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "scripts/testing/init_testing.sh", "templates/init_template.pl"], "tags": ["module-loading", "error-handling", "prolog"]}
{"id": "skill_unifyweaver_environment_002", "question": "What's the correct way to run UnifyWeaver Prolog scripts?", "question_variants": ["How do I execute Prolog scripts with UnifyWeaver modules?", "Should I use init.pl or inline initialization for running scripts?", "What's the recommended approach for running UnifyWeaver playbooks?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "Use `init.pl` for scripts: First `cd /path/to/UnifyWeaver`, then run `swipl -f init.pl -g \"goal, halt\"`. For playbooks, use inline initialization with `swipl -q -g \"asserta(file_search_path(unifyweaver, 'src/unifyweaver')), [script.pl], goal, halt\"`. Always run from the project root directory. See skill_unifyweaver_environment.md for details.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "playbooks/README.md", "templates/init_template.pl"], "tags": ["script-execution", "playbooks", "prolog"]}
{"id": "skill_unifyweaver_environment_003", "question": "I'm getting an 'Unknown procedure' error when running a Prolog script. How do I fix it?", "question_variants": ["Why is Prolog saying my predicates don't exist?", "How do I load modules to fix 'Unknown procedure' errors?", "What causes 'Unknown procedure' errors in UnifyWeaver scripts?"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "This means a required module wasn't loaded. Add `:- use_module('src/unifyweaver/...')` directives to your script. Make sure the module file exists and exports the predicate you're using. Also verify you're running from the project root directory. See skill_unifyweaver_environment.md for details.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["src/unifyweaver/", "init.pl"], "tags": ["module-loading", "error-handling", "debugging"]}
{"id": "skill_unifyweaver_environment_004", "question": "Where should I run UnifyWeaver Prolog commands from?", "question_variants": ["Does working directory matter when running UnifyWeaver scripts?", "Why should I run commands from the project root?", "What directory structure does UnifyWeaver expect?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "Always run from the project root directory. UnifyWeaver expects to find `src/unifyweaver/`, `playbooks/`, `templates/`, and `scripts/` subdirectories. Module paths are relative to this root, and `init.pl` uses its own location to determine the project root. Running from elsewhere will cause module loading to fail. See skill_unifyweaver_environment.md for details.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl"], "tags": ["working-directory", "setup", "best-practices"]}
{"id": "skill_unifyweaver_environment_005", "question": "How do I set up an isolated testing environment for UnifyWeaver?", "question_variants": ["Can I test UnifyWeaver scripts in isolation?", "What's the test environment initialization script?", "How do I use scripts/testing/init_testing.sh?"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "Run `bash scripts/testing/init_testing.sh` from the project root. This creates a self-contained test environment at `scripts/testing/test_env` with all modules copied. Then `cd scripts/testing/test_env` and run `./unifyweaver.sh`. This approach isolates your tests from the main environment. See skill_unifyweaver_environment.md for details.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["scripts/testing/init_testing.sh"], "tags": ["testing", "isolated-environment", "setup"]}
{"id": "skill_unifyweaver_environment_006", "question": "Can I run UnifyWeaver scripts interactively and what module syntax should I use?", "question_variants": ["How do I start an interactive Prolog session with UnifyWeaver?", "Should I use library(...) or relative paths for module loading?", "What's the difference between library(unifyweaver/...) and 'src/unifyweaver/...'?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "Yes, use `swipl -f init.pl` from the project root to start an interactive session. Once loaded, `init.pl` sets up the paths so you can use `library(unifyweaver/...)` syntax. Without `init.pl`, use relative paths like `:- use_module('src/unifyweaver/sources').` instead. Always run from project root. See skill_unifyweaver_environment.md for details.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "templates/init_template.pl"], "tags": ["interactive-session", "module-paths", "prolog-syntax"]}
{"id": "skill_unifyweaver_compile_001", "question": "How do I compile Prolog to Bash with UnifyWeaver?", "question_variants": ["How do I transpile Prolog to shell scripts?", "Can UnifyWeaver generate executable bash?"], "level": 2, "tree_path": ["Compilation", "Prolog to Bash"], "answer": "Use the compiler_driver: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('my_rules.pl'), compile(my_predicate/2, [output_dir('.')])\" -t halt`. This generates an executable .sh file. Always set output_dir to a known location. Note: arithmetic operators (>, <, =<) are not currently supported.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["src/unifyweaver/core/compiler_driver.pl", "docs/EXTENDED_README.md"], "tags": ["compile", "prolog", "bash", "transpile"]}
{"id": "skill_unifyweaver_compile_002", "question": "What are the limitations of the UnifyWeaver compiler?", "question_variants": ["What can't UnifyWeaver compile?", "Are there any known compiler issues?"], "level": 3, "tree_path": ["Compilation", "Limitations"], "answer": "The current compiler_driver cannot transpile predicates with direct arithmetic comparison operators (>, <, =<, >=). These cause compilation to fail. Work around by using helper predicates or restructuring logic. The compiler automatically handles user-defined predicate dependencies but may have issues with complex nested structures.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/ADVANCED_RECURSION.md"], "tags": ["compile", "limitations", "arithmetic"]}
{"id": "skill_transpiler_extension_001", "question": "How do I add a new data source to UnifyWeaver?", "question_variants": ["Can I read from custom file formats?", "How do I create a source plugin?"], "level": 2, "tree_path": ["Compilation", "Extension", "Sources"], "answer": "Declare a source with `source(TYPE, NAME, [OPTIONS])`. Built-in types: json, csv, xml, yaml, sqlite, http, python, semantic. For custom sources, create a plugin module with source_info/1, validate_config/1, and compile_source/4, then register with `register_source_type(my_format, my_module)`.", "related_skills": ["skill_transpiler_extension.md", "skill_json_sources.md"], "related_docs": ["src/unifyweaver/sources/", "src/unifyweaver/core/dynamic_source_compiler.pl"], "tags": ["source", "extension", "plugin", "data"]}
{"id": "skill_transpiler_extension_002", "question": "How do I map Prolog predicates to Python functions?", "question_variants": ["Can I call Python stdlib from Prolog?", "How do bindings work?"], "level": 2, "tree_path": ["Compilation", "Extension", "Bindings"], "answer": "Use bindings: `binding(python, string_length/2, 'len', [string], [int], [pure])`. This maps the Prolog predicate to Python's len(). Options include pure, effect(io), effect(state), import(Module), and deterministic. Initialize with `:- init_python_bindings.` Available binding modules exist for Python, Go, Rust, Bash, C#, PowerShell, and 20+ targets.", "related_skills": ["skill_transpiler_extension.md"], "related_docs": ["src/unifyweaver/bindings/python_bindings.pl", "docs/BINDING_MATRIX.md"], "tags": ["bindings", "python", "ffi", "mapping"]}
{"id": "skill_transpiler_extension_003", "question": "How do I add a new target language to UnifyWeaver?", "question_variants": ["Can I compile to a custom language?", "How do I create a new compilation target?"], "level": 3, "tree_path": ["Compilation", "Extension", "New Target"], "answer": "Create a target module with compile_to_mylang/3 and register it: `register_target(mylang, mylang_target, [extension('.ml'), comment_style('...'), supports([recursion])])`. Add bindings in a separate module with `declare_binding/6`. Optionally add templates with mylang_template/3 for code generation patterns.", "related_skills": ["skill_transpiler_extension.md"], "related_docs": ["src/unifyweaver/core/target_registry.pl"], "tags": ["target", "language", "extension", "compile"]}
{"id": "skill_transpiler_extension_004", "question": "What is the component registry?", "question_variants": ["How do I create reusable components?", "What's the component system for?"], "level": 3, "tree_path": ["Compilation", "Extension", "Components"], "answer": "The component registry manages reusable units across categories (runtime, source, binding). Define a category with `define_category(validator, 'Data validation', [...])`, register a type with `register_component_type(validator, json_schema, module, [...])`, declare instances with `declare_component(validator, my_validator, json_schema, [...])`, and invoke with `invoke_component/4`.", "related_skills": ["skill_transpiler_extension.md"], "related_docs": ["src/unifyweaver/core/component_registry.pl", "docs/proposals/COMPONENT_REGISTRY.md"], "tags": ["component", "registry", "reusable", "plugin"]}
{"id": "skill_webassembly_001", "question": "How do I compile Prolog to WebAssembly?", "question_variants": ["Can UnifyWeaver generate WASM?", "How do I run Prolog in the browser?"], "level": 2, "tree_path": ["Compilation", "WebAssembly"], "answer": "Use the LLVM target: `compile_tail_recursion_llvm(factorial/2, [export(true)], LLVMCode)`. Write to file with `write_llvm_program/2`, then build WASM with `build_wasm_module('file.ll', 'output', Commands)`. The generated commands use clang with --target=wasm32. Use musttail for guaranteed O(1) stack space.", "related_skills": ["skill_webassembly.md"], "related_docs": ["src/unifyweaver/targets/llvm_target.pl"], "tags": ["webassembly", "wasm", "llvm", "browser"]}
{"id": "skill_webassembly_002", "question": "How do I generate TypeScript bindings for WASM?", "question_variants": ["Can I call WASM from TypeScript?", "How do I use compiled WASM in my app?"], "level": 3, "tree_path": ["Compilation", "WebAssembly", "TypeScript"], "answer": "After compiling to WASM, generate bindings: `generate_ts_bindings([factorial, fibonacci], TSCode)`. This creates a WasmModule class with async init() and typed methods. For functions with string arguments, use `generate_ts_string_bindings/2` which includes encoder/decoder support.", "related_skills": ["skill_webassembly.md"], "related_docs": ["src/unifyweaver/targets/llvm_target.pl"], "tags": ["typescript", "wasm", "bindings", "browser"]}
{"id": "skill_webassembly_003", "question": "How do I create a native library for Go from Prolog?", "question_variants": ["Can I call UnifyWeaver code from Go?", "How do I generate cgo bindings?"], "level": 3, "tree_path": ["Compilation", "WebAssembly", "FFI"], "answer": "Compile to shared library: `compile_shared_library_llvm([factorial, fibonacci], [], LLVMCode)`. Generate C header with `generate_c_header/2` and Go bindings with `generate_cgo_bindings/2`. Build with `build_shared_library('math.ll', 'math', Commands)` which produces libmodule.so. Similar FFI generators exist for Rust (`generate_rust_ffi/2`).", "related_skills": ["skill_webassembly.md"], "related_docs": ["src/unifyweaver/targets/llvm_target.pl"], "tags": ["go", "cgo", "ffi", "native"]}
{"id": "skill_webassembly_004", "question": "What recursion patterns does the LLVM target support?", "question_variants": ["Can I compile recursive Prolog to WASM?", "How does tail-call optimization work?"], "level": 3, "tree_path": ["Compilation", "WebAssembly", "Recursion"], "answer": "The LLVM target supports: tail recursion with `compile_tail_recursion_llvm/3` (uses musttail for O(1) stack), linear recursion with `compile_linear_recursion_llvm/3` (Fibonacci-style with memoization), transitive closure with `compile_transitive_closure_llvm/3` (graph traversal), and mutual recursion with `compile_mutual_recursion_llvm/3`.", "related_skills": ["skill_webassembly.md"], "related_docs": ["src/unifyweaver/targets/llvm_target.pl"], "tags": ["recursion", "tail-call", "llvm", "optimization"]}
