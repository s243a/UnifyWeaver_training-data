{"id": "skill_extract_records_001", "question": "How do I extract structured data from Markdown example files?", "question_variants": ["extract records from markdown", "parse example records", "get data from markdown files"], "level": 2, "tree_path": ["Data Processing", "Extract Records"], "answer": "Use the Extract Records skill with `scripts/utils/extract_records.pl`. This parses Markdown files that conform to UnifyWeaver Example Record Format and outputs structured data.\n\n```bash\nperl scripts/utils/extract_records.pl [OPTIONS] [PATH...]\n```\n\nCommon options:\n- `-f json` - Output as JSON objects (recommended for processing)\n- `-q <pattern>` - Filter by record name\n- `-f content` - Extract just the code block content\n\nThis is more robust than `grep` for multi-line records and metadata.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["data-processing", "parsing", "markdown"]}
{"id": "skill_extract_records_002", "question": "What's the difference between bash and Prolog records when extracting?", "question_variants": ["run extracted bash script", "execute prolog record", "which interpreter to use", "bash script vs prolog code"], "level": 3, "tree_path": ["Data Processing", "Extract Records"], "answer": "Records contain different code types - you must run them with the correct interpreter:\n\n**Bash records** (marked with ```bash):\n```bash\nperl scripts/utils/extract_records.pl -f content -q 'record.name' file.md > script.sh\nbash script.sh\n```\n\n**Prolog records** (marked with ```prolog):\n```bash\nperl scripts/utils/extract_records.pl -f content -q 'record.name' file.md > code.pl\nswipl -f init.pl -g \"consult('code.pl'), goal, halt\"\n```\n\nAlways check the code fence language (```bash vs ```prolog) to know which interpreter to use.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["parsing", "prolog", "bash", "execution"]}
{"id": "skill_extract_records_003", "question": "When should I use Extract Records instead of grep?", "question_variants": ["extract records vs grep", "when to use extract records tool", "why use extract records"], "level": 2, "tree_path": ["Data Processing", "Extract Records"], "answer": "Use Extract Records when you need to:\n- Parse metadata like `id` or `name` from records\n- Handle multi-line content blocks reliably\n- Get output in structured formats like JSON\n- Filter files by YAML frontmatter (like `file_type=UnifyWeaver Example Library`)\n\nUse `grep` for simple text search. Use Extract Records for semantic parsing of UnifyWeaver record files.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["parsing", "tools", "comparison"]}
{"id": "skill_extract_records_004", "question": "How do I filter extracted records by name?", "question_variants": ["filter records by pattern", "query records by name", "search specific records"], "level": 3, "tree_path": ["Data Processing", "Extract Records"], "answer": "Use the `-q` (query) flag with a regex pattern to filter by record name:\n\n```bash\nperl scripts/utils/extract_records.pl \\\n  -f json \\\n  -q 'unifyweaver.execution.xml_data_source' \\\n  path/to/file.md\n```\n\nThis extracts only records whose `name` metadata matches the pattern. Combine with `-f json` to get structured output for processing.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md"], "tags": ["parsing", "filtering", "queries"]}
{"id": "skill_find_executable_001", "question": "How do I run a command that's not found in my system PATH?", "question_variants": ["What should I do when I get a 'command not found' error?", "How can I locate an executable that isn't in my PATH?"], "level": 2, "tree_path": ["Execution", "Find Executable"], "answer": "When a command fails with a 'command not found' error, you can use the Find Executable skill to search for the executable in common installation directories. The skill searches OS-specific paths and returns the full path to the executable if found, which you can then use to run the command directly.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["command-not-found", "executable", "path"]}
{"id": "skill_find_executable_002", "question": "Where does the agent look for executables on different operating systems?", "question_variants": ["Which directories are searched for executables?", "What are the common installation paths the agent checks?"], "level": 2, "tree_path": ["Execution", "Find Executable"], "answer": "The Find Executable skill searches OS-specific directories: On Windows, it checks Strawberry Perl and SWI-Prolog installation paths. On Linux, it searches /usr/bin, /usr/local/bin, and /snap/bin. On macOS, it checks /usr/bin, /usr/local/bin, /opt/homebrew/bin, and the SWI-Prolog application path.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["directories", "operating-system", "search-paths"]}
{"id": "skill_find_executable_003", "question": "What does the Find Executable skill return if it can't locate an executable?", "question_variants": ["How do I know if an executable was found?", "What happens when the skill doesn't find the executable?"], "level": 3, "tree_path": ["Execution", "Find Executable"], "answer": "If the executable is found, the Find Executable skill returns the absolute path to it. If the executable is not found, it returns an empty string. You can then use the returned path to execute the command directly, for example: & \"C:\\Strawberry\\perl\\bin\\perl.exe\" my_script.pl on Windows.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["output", "executable-path", "return-value"]}
{"id": "skill_find_executable_004", "question": "How do I use a found executable to run my script?", "question_variants": ["How can I execute a command using the full path returned?", "What's the syntax for running an executable from its full path?"], "level": 3, "tree_path": ["Execution", "Find Executable"], "answer": "Once you have the full path from the Find Executable skill, you can execute the command directly using that path. For example, on Windows you would use: & \"C:\\Strawberry\\perl\\bin\\perl.exe\" my_script.pl, and on Unix-like systems: /usr/local/bin/perl my_script.pl. The & operator on Windows allows you to invoke commands from variable paths.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["execution", "full-path", "script-execution"]}
{"id": "skill_json_sources_001", "question": "How do I read data from a JSON file in a playbook?", "question_variants": ["How can I load JSON data into a playbook?", "What's the syntax for reading JSON files?"], "level": 2, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use the `source/3` directive with `json_file('path/to/file.json')` and `columns/1` to specify which fields to extract. For example:\n```prolog\n:- source(json, my_source, [\n    json_file('data/orders.json'),\n    columns(['order.customer.name', 'items[0].product'])\n]).\n```\nEnsure the number of columns matches your predicate's arity.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["JSON", "data sources", "playbooks"]}
{"id": "skill_json_sources_002", "question": "How do I select nested fields or complex paths in JSON data?", "question_variants": ["Can I use JSONPath expressions to query JSON?", "How do I extract deeply nested JSON values?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use JSONPath selectors with `jsonpath('$.path.to.field')` in your `columns/1` or `schema/1` declaration. JSONPath supports dot notation, bracket properties, array indices, wildcards `[*]`, and recursive descent `..fieldname`. Example:\n```prolog\ncolumns([\n    jsonpath('$.orders[*].total'),\n    jsonpath('$.customer.address.city')\n])\n```\nStrings already starting with `$` are automatically treated as JSONPath.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["JSONPath", "nested fields", "selectors"]}
{"id": "skill_json_sources_003", "question": "How do I return entire JSON objects as rows instead of selecting specific columns?", "question_variants": ["Can I get raw JSON objects from a source?", "How do I work with unflattened JSON data?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use return-object mode by setting `arity(1)`, `return_object(true)`, and providing a `type_hint/1` with a .NET type. Example:\n```prolog\n:- source(json, raw_data, [\n    json_file('data.json'),\n    arity(1),\n    return_object(true),\n    type_hint('System.Text.Json.Nodes.JsonObject, System.Text.Json')\n]).\n```\nThis returns the full JSON object for each row instead of projecting specific fields.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["JSON objects", "return modes"]}
{"id": "skill_json_sources_004", "question": "How do I create typed records from JSON data?", "question_variants": ["Can I automatically generate C# classes from JSON sources?", "How do I define a schema for JSON data?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use `schema/1` to declare typed fields and let the C# backend generate POCOs automatically. Example:\n```prolog\n:- source(json, products, [\n    json_file('products.json'),\n    schema([\n        field(id, 'id', string),\n        field(name, 'name', string),\n        field(price, 'price', double)\n    ]),\n    record_type('ProductRecord')\n]).\n```\nFor nested objects, use `record(TypeName, Fields)` within the schema. The arity must be 1; nested records are instantiated automatically at runtime.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["schema", "records", "typed data"]}
{"id": "skill_unifyweaver_compile_001", "question": "How do I convert Prolog rules into an executable bash script?", "question_variants": ["How do I transpile Prolog predicates to bash?", "What's the process for compiling Prolog to bash?", "How do I execute Prolog logic as a bash script?"], "level": 2, "tree_path": ["Compilation", "Prolog-to-Bash Transpilation"], "answer": "Use the UnifyWeaver compiler to transpile Prolog predicates into executable bash scripts. Run: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<prolog_file>'), compile(<predicate_indicator>, [output_dir('.')])\" -t halt`. Specify your `.pl` file, the main predicate (e.g., `choose_strategy/3`), and output directory. The compiler will handle dependencies automatically.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md", "src/unifyweaver/core/compiler_driver.pl", "education/book-02-bash-target/01_introduction.md"], "tags": ["compilation", "transpilation", "bash", "prolog"]}
{"id": "skill_unifyweaver_compile_002", "question": "What are the parameters I need to provide to compile Prolog code?", "question_variants": ["What options does the compiler accept?", "How do I specify the output location for compiled scripts?", "What do I need to configure for compilation?"], "level": 3, "tree_path": ["Compilation", "Prolog-to-Bash Transpilation"], "answer": "The compiler requires three key parameters: (1) `<prolog_file>` - path to your `.pl` file, (2) `<predicate_indicator>` - the main predicate in `functor/arity` format (e.g., `choose_strategy/3`), and (3) `<options>` - compiler options like `output_dir('.')` to specify where to save the compiled `.sh` file. Always set `output_dir` to a known location to avoid unexpected output paths.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["compilation", "parameters", "options"]}
{"id": "skill_unifyweaver_compile_003", "question": "What are the limitations when compiling Prolog to bash?", "question_variants": ["Why does my Prolog compilation fail?", "Which Prolog features don't work with the bash compiler?", "Can I use arithmetic operators in my Prolog rules?"], "level": 2, "tree_path": ["Compilation", "Prolog-to-Bash Transpilation"], "answer": "The current compiler cannot transpile predicates that directly use arithmetic comparison operators (>, <, =<). This is a known limitation that will cause compilation to fail. Avoid using these operators directly in your Prolog rules. Check the related documentation for workarounds and supported patterns.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md", "education/book-02-bash-target/02_simple_predicates.md"], "tags": ["limitations", "arithmetic", "troubleshooting"]}
{"id": "skill_unifyweaver_compile_004", "question": "How does the compiler handle dependencies in my Prolog predicates?", "question_variants": ["Do I need to specify all dependent predicates?", "Will the compiler automatically include predicates my main predicate calls?", "How are recursive predicates handled during compilation?"], "level": 3, "tree_path": ["Compilation", "Prolog-to-Bash Transpilation"], "answer": "The compiler automatically analyzes and includes any user-defined predicates that your main predicate depends on. You only need to specify the main predicate you want to compile, and the compiler will traverse the dependency tree and compile everything needed. This simplifies the compilation process for complex logic.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/ADVANCED_RECURSION.md", "education/book-02-bash-target/03_recursion_patterns.md", "education/book-02-bash-target/04_data_structures.md"], "tags": ["dependencies", "compilation", "recursion"]}
{"id": "skill_unifyweaver_environment_001", "question": "I'm getting an error that says 'source_sink library(...) does not exist' when running a Prolog script. How do I fix this?", "question_variants": ["How do I resolve library path errors in UnifyWeaver?", "What should I do when module loading fails?"], "level": 3, "tree_path": ["Running UnifyWeaver", "Environment Setup"], "answer": "This error means the module search path isn't configured. The best solution is to use init.pl from the project root: `swipl -f init.pl -g \"use_module(library(unifyweaver/sources)), halt\"`. Alternatively, use relative paths like `:- use_module('src/unifyweaver/sources').` and make sure you're running from the project root directory.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "src/unifyweaver/"], "tags": ["error-handling", "module-loading", "prolog-setup"]}
{"id": "skill_unifyweaver_environment_002", "question": "What's the recommended way to run UnifyWeaver Prolog scripts?", "question_variants": ["How should I execute Prolog scripts with UnifyWeaver modules?", "What's the best method to run UnifyWeaver code?"], "level": 2, "tree_path": ["Running UnifyWeaver", "Script Execution"], "answer": "Use init.pl from the project root for automatic environment setup: `cd /path/to/UnifyWeaver && swipl -f init.pl -g \"goal, halt\"`. This automatically configures file search paths and module loading. For inline initialization in playbooks, you can also manually set paths with `asserta(file_search_path(unifyweaver, 'src/unifyweaver'))` before loading modules.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "playbooks/"], "tags": ["script-execution", "best-practices", "module-loading"]}
{"id": "skill_unifyweaver_environment_003", "question": "Do I need to run UnifyWeaver commands from a specific directory?", "question_variants": ["Where should I execute UnifyWeaver scripts from?", "Does the working directory matter for running UnifyWeaver?"], "level": 2, "tree_path": ["Running UnifyWeaver", "Environment Setup"], "answer": "Yes, always run UnifyWeaver commands from the project root directory. This is critical because UnifyWeaver modules use relative paths from the project root (like `src/unifyweaver/`, `playbooks/`, and `templates/`). The init.pl file itself must also be in the project root to work correctly.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "src/unifyweaver/"], "tags": ["working-directory", "setup", "best-practices"]}
{"id": "skill_unifyweaver_environment_004", "question": "I'm getting an 'Unknown procedure' error when running my UnifyWeaver script. What should I check?", "question_variants": ["Why does my script say the procedure doesn't exist?", "How do I debug missing procedure errors?"], "level": 3, "tree_path": ["Running UnifyWeaver", "Error Handling"], "answer": "This means a module wasn't loaded. First, verify the module file exists at `src/unifyweaver/...` and exports the procedure. Then ensure you're loading the module with `:- use_module('src/unifyweaver/...')` or `:- use_module(library(unifyweaver/...))` if using init.pl. Finally, confirm you're running from the project root directory where the relative paths resolve correctly.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["src/unifyweaver/", "init.pl"], "tags": ["error-handling", "module-loading", "debugging"]}
{"id": "skill_extract_records_001", "question": "How do I extract structured examples from UnifyWeaver markdown files?", "question_variants": ["How can I parse data records from markdown files?", "What's the best way to extract examples from UnifyWeaver documentation?", "How do I get structured data out of markdown example files?"], "level": 2, "tree_path": ["Compilation", "Extract Records"], "answer": "Use the `extract_records.pl` script for parsing UnifyWeaver Example Record Format files:\n\n```bash\nperl scripts/utils/extract_records.pl [OPTIONS] [PATH...]\n```\n\nCommon options:\n- `-f content`: Extract just the code/content\n- `-f json`: Get structured JSON output\n- `-q <pattern>`: Filter records by name\n- `--file-filter all`: Process all files (default filters by file_type)\n\nThis is more robust than `grep` because it handles metadata, multi-line blocks, and produces structured output. See `skill_extract_records.md` for details.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md", "scripts/utils/extract_records.pl"], "tags": ["parsing", "markdown", "extraction", "records", "examples"]}
{"id": "skill_extract_records_002", "question": "I need to run an example from the UnifyWeaver examples library - how do I extract and execute it?", "question_variants": ["How do I run bash scripts from UnifyWeaver markdown examples?", "What's the correct way to execute extracted example code?", "How do I know whether to use bash or swipl for an extracted example?"], "level": 3, "tree_path": ["Compilation", "Extract Records", "Execution"], "answer": "**CRITICAL**: Check the code fence type (```bash or ```prolog) to use the right interpreter.\n\nFor **bash scripts**:\n```bash\nperl scripts/utils/extract_records.pl \\\n  -f content \\\n  -q \"record.name.pattern\" \\\n  path/to/file.md > tmp/script.sh\n\nbash tmp/script.sh  # Use bash, NOT swipl!\n```\n\nFor **Prolog code**:\n```bash\nperl scripts/utils/extract_records.pl \\\n  -f content \\\n  -q \"prolog.record\" \\\n  path/to/file.md > tmp/code.pl\n\nswipl -f init.pl -g \"consult('tmp/code.pl'), goal, halt\"\n```\n\nSee `skill_extract_records.md` section 4 for details.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["execution", "bash", "prolog", "examples", "interpreter"]}
{"id": "skill_extract_records_003", "question": "How can I filter and get only specific records from a markdown file?", "question_variants": ["How do I search for particular examples by name?", "Can I extract only certain records matching a pattern?", "How do I query records by their metadata?"], "level": 3, "tree_path": ["Compilation", "Extract Records", "Filtering"], "answer": "Use the `-q` (query) flag to filter records by their `name` metadata using regex:\n\n```bash\nperl scripts/utils/extract_records.pl \\\n  -q \"unifyweaver.execution.xml_data_source\" \\\n  playbooks/examples_library/xml_examples.md\n```\n\nYou can also filter by file frontmatter:\n```bash\n# Process only specific file types\nperl scripts/utils/extract_records.pl \\\n  --file-filter \"file_type=My Custom Type\" \\\n  path/to/files/\n\n# Process all files regardless of type\nperl scripts/utils/extract_records.pl \\\n  --file-filter all \\\n  path/to/files/\n```\n\nSee `skill_extract_records.md` section 3.1 for all filtering options.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["filtering", "query", "regex", "metadata", "search"]}
{"id": "skill_extract_records_004", "question": "What output formats are available when extracting records?", "question_variants": ["Can I get JSON output from extracted records?", "How do I get just the code content without the markdown formatting?", "What's the difference between full, content, and json formats?"], "level": 3, "tree_path": ["Compilation", "Extract Records", "Output Formats"], "answer": "The `-f` flag controls output format:\n\n**`-f full`** (default): Complete markdown block including metadata\n**`-f content`**: Raw code/content only (use this to save to .sh or .pl files)\n**`-f json`**: Structured JSON objects for programmatic processing\n\nExamples:\n```bash\n# Get full markdown blocks\nperl scripts/utils/extract_records.pl -f full file.md\n\n# Extract just code to run\nperl scripts/utils/extract_records.pl -f content file.md > script.sh\n\n# Get structured data for processing\nperl scripts/utils/extract_records.pl -f json file.md | jq '.'\n```\n\nChange the separator with `-s` (default is null byte \\0). See `skill_extract_records.md` section 3.1.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["output", "format", "json", "content", "parsing"]}
{"id": "skill_find_executable_001", "question": "How do I fix 'command not found' errors when running Perl or SWI-Prolog?", "question_variants": ["My agent can't find perl even though it's installed", "Getting command not found for swipl, how to locate it?", "How to find executables that aren't in PATH?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "Use the Find Executable skill to locate executables that aren't in your system's PATH. This skill searches common installation directories on Windows, Linux, and macOS to find tools like `perl` or `swipl`. Once found, it returns the full path so your agent can execute the command directly (e.g., `& \"C:\\Strawberry\\perl\\bin\\perl.exe\" my_script.pl`).", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["executable", "PATH", "command-not-found", "perl", "swipl"]}
{"id": "skill_find_executable_002", "question": "What should my agent do when a command fails because it's not in PATH?", "question_variants": ["How to handle executables not in system PATH?", "Agent can't execute installed programs", "Command exists but agent can't find it"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "When a command fails with 'command not found' but you know it's installed, use the Find Executable skill. It searches OS-specific directories (like `C:\\Strawberry\\perl\\bin` on Windows or `/opt/homebrew/bin` on macOS) to locate the executable and returns its absolute path for execution.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["executable", "PATH", "system-path", "troubleshooting"]}
{"id": "skill_find_executable_003", "question": "How can I run Perl scripts when perl isn't in my PATH?", "question_variants": ["Perl installed but command not found", "How to locate perl executable on Windows?", "Find perl binary on macOS"], "level": 3, "tree_path": ["Compilation", "Find Executable", "Perl"], "answer": "Use the Find Executable skill to locate the `perl` executable. It searches common installation paths like `C:\\Strawberry\\perl\\bin` (Windows), `/usr/local/bin` (Linux/macOS), and returns the full path. Your agent can then execute scripts using the absolute path.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["perl", "executable", "strawberry-perl", "PATH"]}
{"id": "skill_find_executable_004", "question": "Where does the agent look for executables on different operating systems?", "question_variants": ["What directories are searched for missing executables?", "Common installation paths checked by Find Executable", "OS-specific executable search paths"], "level": 3, "tree_path": ["Compilation", "Find Executable", "Search Paths"], "answer": "The Find Executable skill searches OS-specific directories: Windows checks `C:\\Strawberry\\perl\\bin`, `C:\\Program Files\\swipl\\bin`; Linux searches `/usr/bin`, `/usr/local/bin`, `/snap/bin`; macOS looks in `/usr/local/bin`, `/opt/homebrew/bin`, `/Applications/SWI-Prolog.app/Contents/MacOS`, and more. If found, it returns the absolute path; otherwise an empty string.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["search-paths", "installation-directories", "cross-platform", "windows", "linux", "macos"]}
{"id": "skill_json_sources_001", "question": "How do I read JSON data into my Prolog program?", "question_variants": ["How do I load JSON files in UnifyWeaver?", "What's the syntax for reading JSON data sources?", "How do I declare a JSON source in Prolog?"], "level": 2, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use the `source/3` directive to declare JSON data sources. For basic column projection, specify `columns/1` with field paths using dot notation: `:- source(json, order_totals, [json_file('data/orders.json'), columns(['order.customer.name', 'items[0].product'])])`. For JSONPath selectors, use `jsonpath('$.orders[*].total')`. For full JSON objects, use `return_object(true)` with `type_hint/1`. See skill_json_sources.md for all options including schema-generated records and JSON Lines support.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "data-sources", "source-directive", "columns"]}
{"id": "skill_json_sources_002", "question": "How do I handle complex JSON paths with wildcards and nested arrays?", "question_variants": ["Can I use JSONPath selectors in my JSON sources?", "How do I select data from nested JSON structures?", "What's the syntax for wildcards in JSON column paths?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources", "JSONPath Selectors"], "answer": "Use `jsonpath/1` option with JSONPath selectors for complex queries. Supported features include root `$`, dotted properties, bracket notation `['foo']`, array indices `[0]`, wildcards `[*]`, and recursive descent `..name`. Example: `jsonpath('$.orders[*].total')`. Strings starting with `$` are automatically treated as JSONPath, so `columns(['$.orders[0].id'])` works too. Use in both `columns/1` and `schema/1` declarations. See skill_json_sources.md for complete JSONPath syntax.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "jsonpath", "selectors", "wildcards", "nested-data"]}
{"id": "skill_json_sources_003", "question": "How do I create typed records from JSON data instead of just tuples?", "question_variants": ["Can I map JSON to strongly-typed objects in UnifyWeaver?", "How do I generate POCOs from JSON sources?", "What's the schema option for JSON sources?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources", "Schema-Generated Records"], "answer": "Use `schema/1` to declare typed records that generate C# POCOs. Specify fields with `field(Name, Path, Type)` and optionally name the record with `record_type/1`. Example: `:- source(json, product_rows, [json_file('data.json'), schema([field(id, 'id', string), field(price, 'price', double)]), record_type('ProductRecord')])`. Arity must be 1; `return_object(true)` is implied. For nested structures, use `record(TypeName, Fields)`. See skill_json_sources.md for nested schema examples.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "schema", "typed-records", "poco", "code-generation"]}
{"id": "skill_json_sources_004", "question": "How do I handle missing or null values in JSON data?", "question_variants": ["What happens when JSON fields are null or missing?", "How do I set default values for missing JSON fields?", "Can I skip rows with null values in JSON sources?"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources", "Null Policies"], "answer": "Use `null_policy/1` to control missing/null field behavior. Options: `null_policy(fail)` throws immediately on null, `null_policy(skip)` skips rows with nulls, `null_policy(default(Value))` substitutes a placeholder (e.g., `default('N/A')` or `default('0')`). Example: `:- source(json, items, [json_file('data.jsonl'), columns([jsonpath('$.items[1].product')]), null_policy(default('N/A'))])`. Also useful with `record_format(jsonl)` for newline-delimited JSON. See skill_json_sources.md for validation rules.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "null-handling", "default-values", "error-handling", "jsonl"]}
{"id": "skill_unifyweaver_compile_001", "question": "How do I convert Prolog rules into an executable bash script?", "question_variants": ["How can I transpile Prolog predicates to bash?", "What's the process for compiling Prolog to bash in UnifyWeaver?"], "level": 2, "tree_path": ["Compilation", "Prolog-to-Bash Transpiler"], "answer": "Use the UnifyWeaver compiler to transpile Prolog to bash. Run: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<your_file.pl>'), compile(<predicate>/<arity>, [output_dir('.')])\" -t halt`. For example, to compile `choose_strategy/3` from `temp_strategy.pl`: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('temp_strategy.pl'), compile(choose_strategy/3, [output_dir('.')])\", -t halt`. This creates an executable `.sh` file. Note: arithmetic operators like `>`, `<` are not yet supported.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md", "education/book-02-bash-target/01_introduction.md", "education/book-02-bash-target/02_simple_predicates.md", "education/book-02-bash-target/03_recursion_patterns.md", "education/book-02-bash-target/04_data_structures.md", "src/unifyweaver/core/compiler_driver.pl", "src/unifyweaver/targets/bash/"], "tags": ["compilation", "transpiler", "prolog", "bash", "compiler_driver"]}
{"id": "skill_unifyweaver_compile_002", "question": "I have Prolog predicates in a file - how do I make them executable?", "question_variants": ["How do I run Prolog rules as a script?", "What's the next step after writing Prolog predicates?"], "level": 2, "tree_path": ["Compilation", "Making Predicates Executable"], "answer": "Compile your Prolog file to an executable bash script using UnifyWeaver's compiler. The command is: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<prolog_file>'), compile(<predicate>/<arity>, [output_dir('.')])\" -t halt`. Replace `<prolog_file>` with your `.pl` file path, and `<predicate>/<arity>` with your main predicate (e.g., `choose_strategy/3`). The compiler handles dependencies automatically and outputs a `.sh` file you can execute directly.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "education/book-02-bash-target/01_introduction.md", "education/book-02-bash-target/02_simple_predicates.md", "src/unifyweaver/core/compiler_driver.pl", "src/unifyweaver/targets/bash/"], "tags": ["compilation", "executable", "prolog", "workflow"]}
{"id": "skill_unifyweaver_compile_003", "question": "Where does the compiled bash script get saved?", "question_variants": ["How do I specify the output location for compiled scripts?", "Can I control where the .sh file is created?"], "level": 3, "tree_path": ["Compilation", "Output Configuration"], "answer": "Use the `output_dir('<directory>')` option when compiling. For example: `compile(my_predicate/2, [output_dir('.')])` saves to the current directory. If you don't specify `output_dir`, the file may be saved to an unexpected default location. The output filename is automatically derived from the predicate name (e.g., `my_predicate.sh`).", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["compilation", "output", "configuration", "compiler_driver"]}
{"id": "skill_unifyweaver_compile_004", "question": "Why does my Prolog compilation fail with arithmetic operators?", "question_variants": ["Can I use > or < in predicates I want to compile?", "What arithmetic operations are supported in compilation?"], "level": 3, "tree_path": ["Compilation", "Limitations"], "answer": "The current UnifyWeaver compiler has a known limitation: it cannot transpile predicates that directly use arithmetic comparison operators like `>`, `<`, or `=<`. This will cause compilation to fail. As a workaround, restructure your logic to avoid direct arithmetic comparisons in predicates you need to compile. Dependencies are handled automatically, but any predicate using these operators will block the compilation process.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md", "education/book-02-bash-target/02_simple_predicates.md", "src/unifyweaver/core/compiler_driver.pl"], "tags": ["compilation", "limitations", "arithmetic", "troubleshooting", "operators"]}
{"id": "skill_unifyweaver_environment_001", "question": "I'm getting an error 'source_sink library(unifyweaver/...) does not exist' when running my script", "question_variants": ["How do I fix 'source_sink library does not exist' errors?", "Why can't Prolog find the UnifyWeaver modules?", "Getting module not found errors in UnifyWeaver"], "level": 3, "tree_path": ["Compilation", "Environment Setup", "Troubleshooting"], "answer": "This error means the UnifyWeaver module path isn't in your search path. Run your script using `swipl -f init.pl` from the project root directory, which sets up all module paths automatically. Alternatively, use relative paths like `'src/unifyweaver/sources'` instead of `library(unifyweaver/sources)` and ensure you're running from the project root.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "scripts/testing/init_testing.sh"], "tags": ["environment", "modules", "errors", "troubleshooting"]}
{"id": "skill_unifyweaver_environment_002", "question": "How do I run UnifyWeaver playbooks correctly?", "question_variants": ["What's the proper way to execute UnifyWeaver scripts?", "How do I set up the environment for running UnifyWeaver?", "What directory should I run UnifyWeaver commands from?"], "level": 2, "tree_path": ["Compilation", "Environment Setup"], "answer": "Always run UnifyWeaver commands from the project root directory (which contains `src/unifyweaver/`, `playbooks/`, and `init.pl`). Use `swipl -f init.pl -g \"your_goal, halt\"` for scripts, or use inline initialization in playbooks: `swipl -q -g \"asserta(file_search_path(unifyweaver, 'src/unifyweaver')), [your_script], halt\"` for reproducibility.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "playbooks/examples_library/", "templates/init_template.pl"], "tags": ["environment", "playbooks", "execution", "setup"]}
{"id": "skill_unifyweaver_environment_003", "question": "What's the difference between using init.pl and inline initialization?", "question_variants": ["Should I use init.pl or inline setup for my script?", "When should I use swipl -f init.pl?", "What's the best way to initialize the UnifyWeaver environment?"], "level": 3, "tree_path": ["Compilation", "Environment Setup", "Initialization Methods"], "answer": "Use `swipl -f init.pl` for interactive sessions and regular scripts - it automatically sets up all paths. Use inline initialization (`asserta(file_search_path(unifyweaver, 'src/unifyweaver'))`) for playbooks where you want the setup embedded in the command for reproducibility. Both require running from the project root directory.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["init.pl", "templates/init_template.pl"], "tags": ["environment", "initialization", "init.pl", "best-practices"]}
{"id": "skill_unifyweaver_environment_004", "question": "How do I set up a test environment for UnifyWeaver?", "question_variants": ["Can I create an isolated UnifyWeaver environment for testing?", "How do I test UnifyWeaver without affecting my main project?", "What's the test environment initialization process?"], "level": 3, "tree_path": ["Compilation", "Environment Setup", "Testing"], "answer": "Use the test environment initialization script: `cd /path/to/UnifyWeaver && bash scripts/testing/init_testing.sh && cd scripts/testing/test_env && ./unifyweaver.sh`. This creates a self-contained environment with all modules copied, allowing isolated testing without affecting your main project.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["scripts/testing/init_testing.sh"], "tags": ["testing", "environment", "isolation", "test-setup"]}
{"id": "skill_extract_records_001", "question": "How do I extract code examples or data records from markdown files?", "question_variants": ["Is there a tool to parse structured data from the documentation?", "How can I get JSON output from markdown records instead of just using grep?"], "level": 2, "tree_path": ["Compilation", "Extract Records"], "answer": "Use the `scripts/utils/extract_records.pl` tool. It is designed to parse UnifyWeaver Example Record Format files, handling metadata and multi-line blocks more reliably than `grep`, and can output in JSON format.", "related_skills": ["skill_extract_records.md"], "related_docs": ["docs/playbooks/parsing/README.md", "scripts/utils/extract_records.pl"], "tags": ["extraction", "parsing", "tools"]}
{"id": "skill_extract_records_002", "question": "How do I run a bash script found in a markdown record?", "question_variants": ["I want to execute a shell script record from the playbooks.", "What is the correct way to extract and run a bash code block?"], "level": 3, "tree_path": ["Compilation", "Extract Records"], "answer": "Extract the content using `perl scripts/utils/extract_records.pl -f content ... > script.sh`, then run it using `bash script.sh`. Do not attempt to run bash records using `swipl`.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["bash", "execution", "cli"]}
{"id": "skill_extract_records_003", "question": "How can I filter extracted records by their name?", "question_variants": ["Can I search for a specific metadata ID within the markdown files?", "How do I query records using a regex pattern?"], "level": 3, "tree_path": ["Compilation", "Extract Records"], "answer": "Use the `-q` or `--query` flag with the `extract_records.pl` script. This accepts a regex pattern to filter records based on their `name` metadata field.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["filtering", "querying", "metadata"]}
{"id": "skill_extract_records_004", "question": "How do I extract and load Prolog code from documentation examples?", "question_variants": ["How can I test the prolog snippets found in the guide?", "What is the workflow for consulting a prolog record?"], "level": 3, "tree_path": ["Compilation", "Extract Records"], "answer": "Use `scripts/utils/extract_records.pl` with the `-f content` flag to save the code to a `.pl` file. You can then load it into the runtime using `swipl -f init.pl -g \"consult('file.pl')...\"`.", "related_skills": ["skill_extract_records.md"], "related_docs": ["scripts/utils/extract_records.pl"], "tags": ["prolog", "execution", "workflow"]}
{"id": "skill_find_executable_001", "question": "What should I do if a command like 'perl' is not found in my system path?", "question_variants": ["How do I locate an executable that is missing from my PATH?", "What happens if a tool like SWI-Prolog isn't recognized by the terminal?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "Use the 'Find Executable' skill to search common installation directories across Windows, Linux, and macOS. It returns the absolute path to the binary, allowing you to execute it directly even if it's missing from your PATH.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["path", "troubleshooting", "executable"]}
{"id": "skill_find_executable_002", "question": "How can I find the installation path for a specific tool on my computer?", "question_variants": ["Can the agent help me locate where a program is installed?", "How do I find the full path to an executable file?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "By providing the executable name (e.g., 'swipl' or 'perl'), the 'Find Executable' skill searches standard OS-specific locations like /usr/local/bin or Program Files and returns the full path for execution.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["installation", "search", "tools"]}
{"id": "skill_find_executable_003", "question": "Where does the agent look for software that isn't in the PATH?", "question_variants": ["What directories are searched when trying to find a missing tool?", "Which standard locations are checked for installed executables?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "The 'Find Executable' skill searches predefined directories based on your OS, such as C:\\Program Files on Windows, /usr/bin and /snap/bin on Linux, and /opt/homebrew/bin or Applications on macOS.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["directories", "os-specific", "environment"]}
{"id": "skill_find_executable_004", "question": "My terminal says 'command not found'. Is there a way to fix this automatically?", "question_variants": ["How do I resolve a 'command not found' error for a required tool?", "Can the system automatically find a program if the shell can't?"], "level": 2, "tree_path": ["Compilation", "Find Executable"], "answer": "When a 'command not found' error occurs, trigger the 'Find Executable' skill. It attempts to locate the binary in common installation paths and returns the absolute path needed to run the command successfully.", "related_skills": ["skill_find_executable.md"], "related_docs": [], "tags": ["errors", "automation", "fix"]}
{"id": "skill_json_sources_001", "question": "How do I read specific fields from a JSON file into a Prolog predicate?", "question_variants": ["How to project JSON fields to Prolog arguments?", "Reading a JSON file with specific columns"], "level": 2, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use the `:- source(json, ...)` directive with the `columns/1` option. Provide a list of field names (dot notation) or `jsonpath(...)` selectors that match the arity of your predicate.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "source", "columns", "projection"]}
{"id": "skill_json_sources_002", "question": "How can I select nested data or arrays from a JSON source?", "question_variants": ["Using JSONPath in UnifyWeaver sources", "Extracting values from JSON arrays using wildcards"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use `jsonpath('$.selector')` within your `columns` or `schema` definition. You can use standard JSONPath features like `[*]` for wildcards, `[0]` for indices, and `..` for recursive descent.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "jsonpath", "nested-data"]}
{"id": "skill_json_sources_003", "question": "How do I map JSON data to strongly typed C# records?", "question_variants": ["Generating POCOs from JSON sources", "Using schema definitions for JSON files"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Use the `schema/1` option in your source declaration instead of `columns/1`. Define a list of `field(Name, Path, Type)` terms and set `record_type('TypeName')`. The predicate must have an arity of 1.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "schema", "csharp", "types"]}
{"id": "skill_json_sources_004", "question": "How do I process newline-delimited JSON (JSONL) files?", "question_variants": ["Reading .jsonl files in UnifyWeaver", "Handling null values in JSON sources"], "level": 3, "tree_path": ["Compilation", "Declaring JSON Dynamic Sources"], "answer": "Add `record_format(jsonl)` to your source options. You can also configure `null_policy/1` (set to `skip`, `fail`, or `default(Value)`) to manage how missing data impacts the stream.", "related_skills": ["skill_json_sources.md"], "related_docs": [], "tags": ["json", "jsonl", "null-handling", "streaming"]}
{"id": "skill_unifyweaver_compile_001", "question": "How do I turn my Prolog file into an executable bash script?", "question_variants": ["Convert prolog logic to shell script", "How to compile prolog rules to bash", "Make prolog file executable in bash"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "You can transpile Prolog logic to Bash using the UnifyWeaver compiler driver. Invoke it via `swipl` by loading the driver module and your source file, then calling the `compile/2` predicate. For example: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('my_rules.pl'), compile(my_pred/2, [output_dir('.')])\" -t halt`.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "docs/ADVANCED_RECURSION.md", "book-02-bash-target/01_introduction.md", "src/unifyweaver/core/compiler_driver.pl", "src/unifyweaver/targets/bash/"], "tags": ["compilation", "bash", "prolog", "transpiler"]}
{"id": "skill_unifyweaver_compile_002", "question": "What is the command syntax to compile a specific predicate?", "question_variants": ["Command to transpile a prolog predicate", "How to run the unifyweaver compiler", "Syntax for compiling functor/arity to bash"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "The standard command follows this template: `swipl -g \"use_module('src/unifyweaver/core/compiler_driver'), consult('<prolog_file>'), compile(<predicate_indicator>, [<options>])\" -t halt`. Ensure you specify the `output_dir` option, usually `output_dir('.')`, to control where the resulting script is saved.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl", "book-02-bash-target/02_simple_predicates.md"], "tags": ["command", "syntax", "compiler_driver", "swipl"]}
{"id": "skill_unifyweaver_compile_003", "question": "Does the compiler handle dependencies if my rule uses other rules?", "question_variants": ["Do I need to compile dependent predicates manually?", "How does the compiler handle sub-goals?", "Automatic dependency resolution in compilation"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "Yes, the compiler automatically handles dependencies. When you target a specific predicate (e.g., `main/0`), the `compiler_driver` analyzes the call graph and compiles all user-defined predicates that your main predicate depends on into the final Bash script.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl", "book-02-bash-target/03_recursion_patterns.md"], "tags": ["dependencies", "compilation", "automation"]}
{"id": "skill_unifyweaver_compile_004", "question": "Why is my compilation failing when using arithmetic operators?", "question_variants": ["Can I use greater than or less than signs in rules to be compiled?", "Compilation error with arithmetic comparisons", "Limitations of the bash transpiler"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Prolog-to-Bash Transpiler"], "answer": "The current version of the UnifyWeaver `compiler_driver` has a limitation regarding arithmetic comparison operators. It cannot transpile predicates that directly use operators like `>`, `<`, or `=<`. You must restructure your logic to avoid direct arithmetic comparisons in the Prolog source intended for Bash compilation.", "related_skills": ["skill_unifyweaver_compile.md"], "related_docs": ["docs/EXTENDED_README.md", "src/unifyweaver/core/compiler_driver.pl", "book-02-bash-target/01_introduction.md"], "tags": ["limitations", "arithmetic", "troubleshooting", "bash"]}
{"id": "skill_unifyweaver_environment_001", "question": "How do I run a UnifyWeaver Prolog script correctly?", "question_variants": ["What is the standard command to execute a script using UnifyWeaver modules?", "How do I use init.pl to run my script?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "Run `swipl` from the project root using the `-f init.pl` flag to automatically set up paths. For example:\n```bash\ncd /path/to/UnifyWeaver\nswipl -f init.pl -g \"consult('your_script.pl'), run_goal, halt\"\n```", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["templates/init_template.pl"], "tags": ["environment", "init.pl", "execution"]}
{"id": "skill_unifyweaver_environment_002", "question": "How do I fix 'source_sink library(unifyweaver/...) does not exist' errors?", "question_variants": ["Why can't Prolog find the unifyweaver library modules?", "I'm getting an error about missing source_sink library files when running a script."], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "This error occurs when the module search path isn't configured. To fix it:\n1. Ensure you are running from the **project root directory**.\n2. Use the `init.pl` file: `swipl -f init.pl ...`\n3. Or use relative paths in your code (e.g., `'src/unifyweaver/sources'` instead of `library(...)`).", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": [], "tags": ["troubleshooting", "modules", "paths"]}
{"id": "skill_unifyweaver_environment_003", "question": "Where should I run UnifyWeaver commands from?", "question_variants": ["What is the required working directory for UnifyWeaver?", "Do I need to be in a specific folder to run playbooks?"], "level": 2, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "CRITICAL: All UnifyWeaver commands and scripts must be run from the **project root directory**. This is the directory containing `src/`, `playbooks/`, and `init.pl`.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": [], "tags": ["environment", "directory", "setup"]}
{"id": "skill_unifyweaver_environment_004", "question": "How do I configure the UnifyWeaver environment in a standalone playbook?", "question_variants": ["What is the best way to load paths in a bash playbook?", "How do I use inline initialization for non-interactive scripts?"], "level": 3, "tree_path": ["Compilation", "UnifyWeaver Environment Setup"], "answer": "For reproducible playbooks, you can use inline initialization to set the search path before loading modules:\n```bash\nswipl -g \"asserta(file_search_path(unifyweaver, 'src/unifyweaver')), [script], halt\"\n```\nAlternatively, simply invoke with `swipl -f init.pl ...`.", "related_skills": ["skill_unifyweaver_environment.md"], "related_docs": ["playbooks/examples_library/"], "tags": ["playbooks", "automation", "inline-init"]}
