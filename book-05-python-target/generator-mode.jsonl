{"cluster_id": "b5-c3-generator-mode", "seed_level": 2, "source_files": ["education/book-05-python-target/03_generator_mode.md"], "topics": ["generator-mode", "semi-naive", "fixpoint-evaluation"], "questions": ["What is generator mode in the Python target?", "How does semi-naive fixpoint evaluation work?", "When should I use generator mode vs procedural mode?"], "answer": {"text": "## Generator Mode\n\nGenerator mode implements semi-naive fixpoint evaluation for recursive queries.\n\n### When to Use Generator Mode\n\n- Transitive closure (all paths in a graph)\n- Reachability queries\n- Recursive joins\n- Deep recursion (avoiding Python's limit)\n\n### Semi-Naive Algorithm\n\nMaintains two sets:\n- **total** - All facts discovered so far\n- **delta** - Facts discovered in current iteration\n\n### Algorithm Steps\n\n1. Initialize total and delta with input facts\n2. Apply rules to facts in delta\n3. Add newly derived facts to new_delta\n4. If new_delta empty â†’ fixpoint reached\n5. Otherwise delta = new_delta, repeat\n\n### Compilation\n\n```prolog\ncompile_predicate_to_python(path/2, [mode(generator)], Code).\n```", "anchor_question_hash": "b5c3001a"}}
{"cluster_id": "b5-c3-frozendict", "seed_level": 3, "source_files": ["education/book-05-python-target/03_generator_mode.md"], "topics": ["frozendict", "hashable", "immutable", "data-structure"], "questions": ["What is FrozenDict in the Python target?", "Why can't Python dicts be used in sets?", "How does FrozenDict enable fixpoint evaluation?"], "answer": {"text": "## FrozenDict Data Structure\n\nPython's `dict` is mutable and unhashable, so it can't be stored in a `set`. FrozenDict provides:\n\n- **Immutability** - Cannot be modified after creation\n- **Hashability** - Can be used as set elements\n- **Dictionary interface** - `get()` method for accessing values\n\n### Usage\n\n```python\n# Creating a FrozenDict\nfd = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\n\n# Using in a set (O(1) average lookup)\nfacts = set()\nfacts.add(fd)\n\n# Checking membership\nfd2 = FrozenDict.from_dict({'name': 'Alice', 'age': 30})\nprint(fd2 in facts)  # True\n\n# Converting back to dict\nd = fd.to_dict()\n```\n\nThis enables efficient duplicate detection in fixpoint iteration.", "anchor_question_hash": "b5c3002a"}}
{"cluster_id": "b5-c3-negation", "seed_level": 3, "source_files": ["education/book-05-python-target/03_generator_mode.md"], "topics": ["negation", "stratification", "negation-as-failure"], "questions": ["How does generator mode handle negation?", "What is stratified negation?", "Can I use negation in recursive predicates?"], "answer": {"text": "## Negation in Generator Mode\n\nGenerator mode supports negation-as-failure with stratification.\n\n### Example\n\n```prolog\nblocked(b, c).\n\nsafe_path(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\nsafe_path(X, Z) :- edge(X, Y), \\+ blocked(X, Y), safe_path(Y, Z).\n```\n\n### Generated Python\n\n```python\ndef _apply_rule(fact, total):\n    x, y = fact.get('arg0'), fact.get('arg1')\n    \n    # Check negation\n    blocked_fact = FrozenDict.from_dict(\n        {'relation': 'blocked', 'arg0': x, 'arg1': y}\n    )\n    if blocked_fact in total:\n        return  # Negation fails\n    \n    yield FrozenDict.from_dict({'arg0': x, 'arg1': y})\n```\n\n### Stratification Requirement\n\nNegated predicates must not depend (directly or indirectly) on the predicate being defined. The compiler validates this at compile time.", "anchor_question_hash": "b5c3003a"}}
