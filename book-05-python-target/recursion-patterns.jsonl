{"cluster_id": "b5-c4-recursion-overview", "seed_level": 2, "source_files": ["education/book-05-python-target/04_recursion_patterns.md"], "topics": ["recursion", "optimization", "tail-recursion", "memoization"], "questions": ["What recursion patterns does the Python target support?", "How does UnifyWeaver optimize different recursion types?", "What is the difference between tail and linear recursion?"], "answer": {"text": "## Recursion Patterns\n\nThe Python target recognizes and optimizes three recursion patterns:\n\n| Pattern | Optimization | Space | Use Case |\n|---------|-------------|-------|----------|\n| Tail | While loops | O(1) | Accumulators, iterative |\n| Linear | Memoization | O(n) | Single recursive call |\n| Mutual | Shared dispatcher | O(n) | Predicates calling each other |\n\n### Pattern Detection\n\nThe compiler automatically detects patterns:\n\n```\nIs the predicate recursive?\n├── No → Simple streaming\n└── Yes → What kind?\n    ├── Tail recursive? → while loop\n    ├── Linear recursive? → @functools.cache\n    ├── Mutual recursive? → shared dispatcher\n    └── Deep/unbounded? → Generator mode\n```", "anchor_question_hash": "b5c4001a"}}
{"cluster_id": "b5-c4-tail-recursion", "seed_level": 3, "source_files": ["education/book-05-python-target/04_recursion_patterns.md"], "topics": ["tail-recursion", "while-loop", "accumulator"], "questions": ["How is tail recursion compiled to Python?", "What is the accumulator pattern?", "Why do while loops have O(1) space?"], "answer": {"text": "## Tail Recursion\n\nTail recursion is converted to `while` loops for O(1) space.\n\n### Pattern Recognition\n\n- Recursive call is in tail position (last goal)\n- Base case that doesn't recurse\n- Accumulator variables pass results downward\n\n### Example\n\n```prolog\nfactorial_acc(0, Acc, Acc).\nfactorial_acc(N, Acc, F) :-\n    N > 0, N1 is N - 1, Acc1 is Acc * N,\n    factorial_acc(N1, Acc1, F).\n```\n\n```python\ndef _factorial_acc_worker(n, acc):\n    while True:\n        if n == 0:\n            return acc\n        if n > 0:\n            n, acc = n - 1, acc * n\n            continue\n        return None\n```\n\n### Benefits\n\n- O(1) space - no stack growth\n- No recursion limit\n- Fast - no function call overhead", "anchor_question_hash": "b5c4002a"}}
{"cluster_id": "b5-c4-memoization", "seed_level": 3, "source_files": ["education/book-05-python-target/04_recursion_patterns.md"], "topics": ["memoization", "functools-cache", "linear-recursion"], "questions": ["How does memoization work in the Python target?", "When is memoization most effective?", "How is Fibonacci compiled with memoization?"], "answer": {"text": "## Memoization for Linear Recursion\n\nLinear recursion uses `@functools.cache` for memoization.\n\n### Example: Fibonacci\n\n```prolog\nfib(0, 0).\nfib(1, 1).\nfib(N, F) :-\n    N > 1, N1 is N - 1, N2 is N - 2,\n    fib(N1, F1), fib(N2, F2), F is F1 + F2.\n```\n\n```python\n@functools.cache\ndef _fib_worker(n):\n    if n == 0: return 0\n    if n == 1: return 1\n    if n > 1:\n        f1 = _fib_worker(n - 1)\n        f2 = _fib_worker(n - 2)\n        if f1 is not None and f2 is not None:\n            return f1 + f2\n    return None\n```\n\n### Complexity\n\n- Without memoization: O(2^n)\n- With memoization: O(n) time, O(n) space\n\n### When Memoization Helps\n\n- Multiple recursive calls (fib(N-1) + fib(N-2))\n- Overlapping subproblems\n- Same inputs called multiple times", "anchor_question_hash": "b5c4003a"}}
{"cluster_id": "b5-c4-mutual-recursion", "seed_level": 3, "source_files": ["education/book-05-python-target/04_recursion_patterns.md"], "topics": ["mutual-recursion", "shared-dispatcher", "even-odd"], "questions": ["How is mutual recursion compiled to Python?", "What is the shared dispatcher pattern?", "What are the limitations of mutual recursion support?"], "answer": {"text": "## Mutual Recursion\n\nMutual recursion compiles to a shared dispatcher with memoization.\n\n### Example: Even/Odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(N) :- N > 0, N1 is N - 1, is_even(N1).\n```\n\n```python\n@functools.cache\ndef _mutual_dispatch(pred_name, arg):\n    if pred_name == 'is_even':\n        return _is_even_impl(arg)\n    elif pred_name == 'is_odd':\n        return _is_odd_impl(arg)\n    return None\n\ndef _is_even_impl(n):\n    if n == 0: return True\n    if n > 0:\n        return _mutual_dispatch('is_odd', n - 1)\n    return None\n```\n\n### Limitation\n\nCurrently supports **arity 1 predicates only**. For multi-argument mutual recursion, encode arguments as a tuple.", "anchor_question_hash": "b5c4004a"}}
