{"cluster_id": "cpp-target-001", "question": "How do I compile Prolog predicates to C++?", "answer": "Use the C++ target module:\n\n```prolog\n?- use_module('src/unifyweaver/targets/cpp_target').\n\n% Pipeline mode\n?- compile_predicate_to_cpp(filter/2, [pipeline_input(true)], Code).\n\n% Recursive query (transitive closure)\n?- compile_recursive(ancestor/2, [target(cpp)], Code).\n\n% Export facts\n?- compile_facts_to_cpp(parent, 2, Code).\n```\n\n**Key features:**\n- nlohmann/json for JSON (header-only, MIT license)\n- std::optional for filtering semantics\n- Iterator classes for generator mode\n- Modern C++17 features (auto, constexpr)\n- CMake FetchContent for automatic dependency download\n- 45 bindings (STL, iostream, algorithms, nlohmann/json)", "source_file": "other-books/book-cpp-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "cpp-target-001", "question": "What does the C++ pipeline mode code look like?", "answer": "Pipeline mode generates modern C++ code using `std::optional` and nlohmann/json:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <optional>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstd::optional<json> process(const json& record) {\n    // Return result or std::nullopt to filter\n    return record;\n}\n\nvoid runPipeline() {\n    std::string line;\n    \n    while (std::getline(std::cin, line)) {\n        if (line.empty()) continue;\n        \n        try {\n            json record = json::parse(line);\n            auto result = process(record);\n            if (result) {\n                std::cout << result->dump() << std::endl;\n            }\n        } catch (const json::exception& e) {\n            std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n        }\n    }\n}\n\nint main() {\n    runPipeline();\n    return 0;\n}\n```\n\n**std::optional for filtering:**\n| Prolog | C++ |\n|--------|-----|\n| Success | `return record;` (implicitly Some) |\n| Failure | `return std::nullopt;` |", "source_file": "other-books/book-cpp-target/02_pipeline_mode.md", "prerequisites": ["cpp-target-001"]}
{"cluster_id": "cpp-target-001", "question": "How does C++ generator mode work?", "answer": "Generator mode uses an **iterator class pattern** returning `std::vector<json>`:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass TESTGenerator {\npublic:\n    std::vector<json> process(const json& record) {\n        std::vector<json> results;\n        results.push_back(record);\n        return results;\n    }\n    \n    template<typename Callback>\n    void processAll(std::istream& input, Callback callback) {\n        std::string line;\n        while (std::getline(input, line)) {\n            if (line.empty()) continue;\n            try {\n                json record = json::parse(line);\n                for (const auto& result : process(record)) {\n                    callback(result);\n                }\n            } catch (const json::exception& e) {\n                std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n            }\n        }\n    }\n};\n\nint main() {\n    TESTGenerator generator;\n    generator.processAll(std::cin, [](const json& result) {\n        std::cout << result.dump() << std::endl;\n    });\n    return 0;\n}\n```", "source_file": "other-books/book-cpp-target/03_generator_mode.md", "prerequisites": ["cpp-target-001"]}
{"cluster_id": "cpp-target-001", "question": "How do I set up CMake for C++ targets with nlohmann/json?", "answer": "UnifyWeaver generates CMake with FetchContent for automatic dependency management:\n\n```prolog\n?- generate_cmake_cpp([project_name('MyPipeline')], CMake).\n```\n\nGenerates:\n```cmake\ncmake_minimum_required(VERSION 3.14)\nproject(MyPipeline CXX)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Fetch nlohmann/json automatically\ninclude(FetchContent)\nFetchContent_Declare(\n    json\n    URL https://github.com/nlohmann/json/releases/download/v3.11.3/json.tar.xz\n)\nFetchContent_MakeAvailable(json)\n\nadd_executable(pipeline pipeline.cpp)\ntarget_link_libraries(pipeline PRIVATE nlohmann_json::nlohmann_json)\n```\n\n**Build:**\n```bash\nmkdir build && cd build\ncmake ..\ncmake --build .\n./pipeline < input.jsonl\n```", "source_file": "other-books/book-cpp-target/04_cmake_integration.md", "prerequisites": ["cpp-target-001"]}
{"cluster_id": "cpp-target-001", "question": "How are recursive queries compiled to C++?", "answer": "Recursive predicates compile to a class with STL containers:\n\n```prolog\n?- compile_recursive(ancestor/2, [target(cpp)], Code).\n```\n\nGenerated C++ code:\n```cpp\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <queue>\n\nclass ANCESTORQuery {\nprivate:\n    std::unordered_map<std::string, std::vector<std::string>> baseRelation;\n\npublic:\n    void addFact(const std::string& from, const std::string& to) {\n        baseRelation[from].push_back(to);\n    }\n\n    std::vector<std::string> findAll(const std::string& start) {\n        std::vector<std::string> results;\n        std::unordered_set<std::string> visited;\n        std::queue<std::string> queue;\n\n        queue.push(start);\n        visited.insert(start);\n\n        while (!queue.empty()) {\n            std::string current = queue.front();\n            queue.pop();\n\n            auto it = baseRelation.find(current);\n            if (it != baseRelation.end()) {\n                for (const auto& next : it->second) {\n                    if (visited.find(next) == visited.end()) {\n                        visited.insert(next);\n                        queue.push(next);\n                        results.push_back(next);\n                    }\n                }\n            }\n        }\n        return results;\n    }\n};\n```\n\n**C++-specific features:**\n- `unordered_map` for O(1) adjacency lookup\n- `unordered_set` for O(1) visited check\n- `std::queue` for BFS\n- Class encapsulation for clean API", "source_file": "other-books/book-cpp-target/04_recursive_queries.md", "prerequisites": ["cpp-target-001"]}
