{"cluster_id": "scala-target-001", "question": "How do I compile Prolog predicates to Scala?", "answer": "Use the Scala target module:\n\n```prolog\n?- use_module('src/unifyweaver/targets/scala_target').\n\n% Pipeline mode (Option filtering)\n?- compile_predicate_to_scala(filter/2, [pipeline_input(true)], Code).\n\n% Generator mode (LazyList)\n?- compile_predicate_to_scala(expand/2, [generator_mode(true)], Code).\n\n% Recursive query (transitive closure)\n?- compile_recursive(ancestor/2, [target(scala)], Code).\n\n% Export facts\n?- compile_facts_to_scala(parent, 2, Code).\n```\n\n**Scala advantages:**\n- Option[T] for null-safe filtering (Some/None)\n- LazyList for memory-efficient streams\n- Pattern matching for type-safe processing\n- @tailrec for stack optimization\n- Full JVM library access", "source_file": "other-books/book-scala-target/01_introduction.md", "prerequisites": []}
{"cluster_id": "scala-target-001", "question": "How does Scala pipeline mode work?", "answer": "Pipeline mode uses `Option[T]` and pattern matching for filtering:\n\n```scala\nimport scala.io.Source\n\nobject FilterPipeline {\n  type Record = Map[String, Any]\n\n  def process(record: Record): Option[Record] = {\n    record.get(\"value\") match {\n      case Some(v: Double) if v > 50 => Some(record)\n      case Some(v: Int) if v > 50 => Some(record)\n      case _ => None\n    }\n  }\n\n  def runPipeline(): Unit = {\n    Source.stdin.getLines()\n      .filter(_.nonEmpty)\n      .flatMap(line => parseJson(line).flatMap(process))\n      .foreach(result => println(toJson(result)))\n  }\n\n  def main(args: Array[String]): Unit = runPipeline()\n}\n```\n\n**Prolog to Scala mapping:**\n| Prolog | Scala |\n|--------|-------|\n| Success | `Some(record)` |\n| Failure | `None` |\n| Type check | Pattern matching with guards |", "source_file": "other-books/book-scala-target/02_pipeline_mode.md", "prerequisites": ["scala-target-001"]}
{"cluster_id": "scala-target-001", "question": "How does Scala generator mode work with LazyList?", "answer": "Generator mode uses `LazyList` with the `#::` cons operator:\n\n```scala\nobject ExpandGenerator {\n  type Record = Map[String, Any]\n\n  def process(record: Record): LazyList[Record] = {\n    record.get(\"items\") match {\n      case Some(items: List[_]) =>\n        items.to(LazyList).map { item =>\n          record - \"items\" + (\"item\" -> item)\n        }\n      case _ => LazyList.empty\n    }\n  }\n\n  def processAll(records: Iterator[Record]): LazyList[Record] = {\n    records.to(LazyList).flatMap(process)\n  }\n}\n```\n\n**With @tailrec for recursion:**\n```scala\nimport scala.annotation.tailrec\n\ndef process(record: Record): LazyList[Record] = {\n  @tailrec\n  def loop(current: Record, acc: LazyList[Record]): LazyList[Record] = {\n    val n = current.getOrElse(\"n\", 0).asInstanceOf[Int]\n    if (n <= 0) current #:: acc\n    else loop(current + (\"n\" -> (n - 1)), current #:: acc)\n  }\n  loop(record, LazyList.empty)\n}\n```", "source_file": "other-books/book-scala-target/03_generator_mode.md", "prerequisites": ["scala-target-001"]}
{"cluster_id": "scala-target-001", "question": "How are recursive queries compiled to Scala?", "answer": "Recursive predicates compile to BFS with mutable Scala collections:\n\n```scala\npackage generated\n\nimport scala.collection.mutable\n\nobject ANCESTORQuery {\n  private val baseRelation = mutable.Map[String, mutable.Set[String]]()\n\n  def addFact(from: String, to: String): Unit = {\n    baseRelation.getOrElseUpdate(from, mutable.Set()) += to\n  }\n\n  def findAll(start: String): Set[String] = {\n    val visited = mutable.Set[String]()\n    val queue = mutable.Queue[String]()\n    val results = mutable.LinkedHashSet[String]()\n\n    queue.enqueue(start)\n    visited += start\n\n    while (queue.nonEmpty) {\n      val current = queue.dequeue()\n      baseRelation.getOrElse(current, mutable.Set.empty[String]).foreach { next =>\n        if (!visited.contains(next)) {\n          visited += next\n          queue.enqueue(next)\n          results += next\n        }\n      }\n    }\n    results.toSet\n  }\n}\n```\n\n**Scala-specific features:**\n- `mutable.Map` with `getOrElseUpdate`\n- `mutable.Queue` for BFS\n- `mutable.LinkedHashSet` for ordered results\n- `+=` operator for collection mutation", "source_file": "other-books/book-scala-target/04_recursive_queries.md", "prerequisites": ["scala-target-001"]}
