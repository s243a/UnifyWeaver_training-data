{"cluster_id": "b6-c6-generator-mode", "seed_level": 2, "source_files": ["education/book-06-go-target/06_generator_mode.md"], "topics": ["generator-mode", "fixpoint", "datalog"], "questions": ["What is generator mode in Go target?", "How does fixpoint evaluation work in Go?", "What features does Go generator mode support?"], "answer": {"text": "## Generator Mode (Fixpoint Datalog)\n\nGenerator mode creates a complete Datalog engine in Go.\n\n### Features\n\n| Feature | Description |\n|---------|-------------|\n| Core fixpoint | Iterative until no new facts |\n| Indexed joins | O(1) hash-based lookups |\n| Stratified negation | `\\+ goal` with validation |\n| Aggregation | count, sum, min, max, avg |\n| HAVING clause | Post-aggregation filtering |\n| Parallel execution | Multi-goroutine processing |\n| Database persistence | BoltDB incremental |\n\n### Basic Usage\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [mode(generator)], Code).\n```\n\n### Options\n\n| Option | Description |\n|--------|-------------|\n| `workers(N)` | N parallel goroutines |\n| `db_backend(bbolt)` | BoltDB persistence |\n| `json_input(true)` | Load facts from stdin |", "anchor_question_hash": "b6c6001a"}}
{"cluster_id": "b6-c6-aggregation-negation", "seed_level": 3, "source_files": ["education/book-06-go-target/06_generator_mode.md"], "topics": ["aggregation", "negation", "stratification"], "questions": ["How do I use aggregation in Go generator mode?", "How does stratified negation work?", "What is the HAVING clause?"], "answer": {"text": "## Aggregation and Negation\n\n### Stratified Negation\n\n```prolog\n% Find paths that aren't blocked\npath(X, Y) :- edge(X, Y), \\+ blocked(X, Y).\npath(X, Z) :- edge(X, Y), \\+ blocked(X, Y), path(Y, Z).\n```\n\nCompiler validates no cycles in negation (stratification check).\n\n### Grouped Aggregation\n\n```prolog\n% Sum salaries by department\ndept_total(Dept, Total) :-\n    aggregate_all(sum(S), salary(Dept, S), Dept, Total).\n```\n\n### HAVING Clause\n\n```prolog\n% Only departments with total > 1000\ndept_high(Dept, Total) :-\n    aggregate_all(sum(S), salary(Dept, S), Dept, Total),\n    Total > 1000.\n```\n\n### Supported Aggregations\n\n`count`, `sum`, `min`, `max`, `avg`", "anchor_question_hash": "b6c6002a"}}
{"cluster_id": "b6-c6-parallel-persistence", "seed_level": 3, "source_files": ["education/book-06-go-target/06_generator_mode.md"], "topics": ["parallel", "goroutines", "boltdb", "persistence"], "questions": ["How do I run Go generator mode in parallel?", "How does database persistence work?", "What is BoltDB persistence?"], "answer": {"text": "## Parallel Execution and Persistence\n\n### Parallel Execution\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    workers(4)\n], Code).\n```\n\nDistributes facts across goroutines, collects via channels.\n\n**Tip:** Use `workers(N)` where N = CPU cores.\n\n### Database Persistence\n\n```prolog\ncompile_predicate_to_go(ancestor/2, [\n    mode(generator),\n    db_backend(bbolt),\n    db_file('ancestry.db')\n], Code).\n```\n\n### Workflow\n\n```bash\n# First run - computes and saves\n./ancestor\n\n# Later runs - continue from saved state\necho '{\"relation\":\"parent\",...}' | ./ancestor\n```\n\nSubsequent runs start from existing database state (incremental computation).", "anchor_question_hash": "b6c6003a"}}
