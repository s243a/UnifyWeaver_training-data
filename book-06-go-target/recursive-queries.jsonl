{"cluster_id": "b6-c7-recursive-compilation", "seed_level": 2, "source_files": ["education/book-06-go-target/07_recursive_queries.md"], "topics": ["recursive-queries", "transitive-closure", "bfs"], "questions": ["How do I compile recursive predicates to Go?", "What is compile_recursive/3?", "How does BFS-based transitive closure work?"], "answer": {"text": "## Recursive Queries\n\n### Compiling Transitive Closure\n\n```prolog\n?- use_module('src/unifyweaver/core/recursive_compiler').\n?- compile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### Generated Go (BFS)\n\n```go\ntype ANCESTORQuery struct {\n    baseRelation map[string][]string\n}\n\nfunc (q *ANCESTORQuery) FindAll(start string) []string {\n    visited := make(map[string]bool)\n    queue := []string{start}\n    var results []string\n\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n\n        for _, next := range q.baseRelation[current] {\n            if !visited[next] {\n                visited[next] = true\n                queue = append(queue, next)\n                results = append(results, next)\n            }\n        }\n    }\n    return results\n}\n```\n\n### Go Constructs Used\n\n| Feature | Go Construct |\n|---------|-------------|\n| Adjacency List | `map[string][]string` |\n| BFS Queue | `[]string` slice |\n| Visited Set | `map[string]bool` |", "anchor_question_hash": "b6c7001a"}}
{"cluster_id": "b6-c7-recursion-patterns", "seed_level": 3, "source_files": ["education/book-06-go-target/07_recursive_queries.md"], "topics": ["tail-recursion", "linear-recursion", "mutual-recursion", "memoization"], "questions": ["How is tail recursion compiled to Go?", "How does memoization work in Go target?", "How are mutually recursive predicates compiled?"], "answer": {"text": "## Recursion Patterns in Go\n\n### Tail Recursion (O(1) space)\n\n```prolog\n?- go_target:compile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n```go\nfunc sum_list(items []int, acc int) int {\n    for _, item := range items {\n        acc += item\n    }\n    return acc\n}\n```\n\n### Linear Recursion (Memoization)\n\n```prolog\n?- go_target:compile_linear_recursion_go(triangular/2, [], Code).\n```\n\n```go\nvar triangularMemo = make(map[int]int)\n\nfunc triangular(n int) int {\n    if result, ok := triangularMemo[n]; ok {\n        return result\n    }\n    result := triangular(n-1) + n\n    triangularMemo[n] = result\n    return result\n}\n```\n\n### Mutual Recursion (Shared Memo)\n\n```prolog\n?- go_target:compile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```\n\nGenerates shared `map[string]bool` for both predicates.", "anchor_question_hash": "b6c7002a"}}
