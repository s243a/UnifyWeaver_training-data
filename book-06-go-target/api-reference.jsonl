{"cluster_id": "b6-a1-core-apis", "seed_level": 2, "source_files": ["education/book-06-go-target/A1_api_reference.md"], "topics": ["compile-predicate-to-go", "compile-facts-to-go", "api-reference"], "questions": ["What APIs does the Go target provide?", "What is compile_predicate_to_go/3?", "What options does compile_predicate_to_go accept?"], "answer": {"text": "## Go Target Core APIs\n\n### compile_predicate_to_go/3\n\nMain compilation predicate for streaming and generator modes.\n\n```prolog\ncompile_predicate_to_go(+Predicate/Arity, +Options, -Code)\n```\n\n**Options:**\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `mode(streaming)` | ✓ | stdin→stdout processor |\n| `mode(generator)` | - | Fixpoint Datalog engine |\n| `json_input(true)` | false | Read JSONL from stdin |\n| `workers(N)` | 1 | Parallel goroutines |\n| `db_backend(bbolt)` | - | BoltDB persistence |\n\n### compile_facts_to_go/3\n\nExports facts as Go struct slices.\n\n```prolog\ncompile_facts_to_go(+Functor, +Arity, -Code)\n```\n\nGenerates: `GetAll<NAME>()`, `Stream<NAME>()`, `Contains<NAME>()`", "anchor_question_hash": "b6a1001a"}}
{"cluster_id": "b6-a1-recursion-apis", "seed_level": 3, "source_files": ["education/book-06-go-target/A1_api_reference.md"], "topics": ["compile-recursive", "tail-recursion", "memoization", "mutual-recursion"], "questions": ["What recursion APIs does Go target have?", "How do I compile tail recursion to Go?", "What is compile_mutual_recursion_go/3?"], "answer": {"text": "## Go Target Recursion APIs\n\n### compile_recursive/3\n\nBFS-based transitive closure. O(V + E) complexity.\n\n```prolog\ncompile_recursive(ancestor/2, [target(go)], Code).\n```\n\n### compile_tail_recursion_go/3\n\nConverts tail recursion to iterative loops. O(1) stack space.\n\n```prolog\ncompile_tail_recursion_go(sum_list/3, [], Code).\n```\n\n### compile_linear_recursion_go/3\n\nAdds memoization with `map[int]int`. O(n) time via caching.\n\n```prolog\ncompile_linear_recursion_go(triangular/2, [], Code).\n```\n\n### compile_mutual_recursion_go/3\n\nShared memo map for mutually recursive predicates.\n\n```prolog\ncompile_mutual_recursion_go([is_even/1, is_odd/1], [], Code).\n```", "anchor_question_hash": "b6a1002a"}}
{"cluster_id": "b6-a1-api-selection", "seed_level": 2, "source_files": ["education/book-06-go-target/A1_api_reference.md"], "topics": ["api-selection", "streaming-vs-generator", "when-to-use"], "questions": ["Which Go target API should I use?", "When do I use generator mode vs streaming?", "How do I choose between recursion APIs?"], "answer": {"text": "## API Selection Guide\n\n| Use Case | API | Mode |\n|----------|-----|------|\n| Export facts to structs | `compile_facts_to_go/3` | - |\n| Simple stream transform | `compile_predicate_to_go/3` | streaming |\n| Full Datalog with joins | `compile_predicate_to_go/3` | generator |\n| Transitive closure (BFS) | `compile_recursive/3` | - |\n| Accumulator loops | `compile_tail_recursion_go/3` | - |\n| Memoized recursion | `compile_linear_recursion_go/3` | - |\n| Mutual recursion | `compile_mutual_recursion_go/3` | - |\n\n### Mode Selection\n\n- **Streaming**: O(n) single-pass, O(1) memory. For ETL pipelines.\n- **Generator**: Fixpoint iteration, O(n) memory. For recursion, joins, negation.", "anchor_question_hash": "b6a1003a"}}
