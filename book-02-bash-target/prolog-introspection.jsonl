{"cluster_id": "prolog-introspection", "seed_level": 2, "source_files": ["education/book-02-bash-target/07_prolog_introspection.md"], "topics": ["introspection", "clause/2", "functor/3", "metaprogramming"], "questions": ["How does UnifyWeaver analyze Prolog code?", "What is Prolog introspection?", "How do I inspect predicate clauses in Prolog?", "What is clause/2 used for?"], "answer": {"text": "## Prolog Introspection\n\n**Introspection** is the ability of Prolog programs to examine and analyze other Prolog code. UnifyWeaver uses this to detect recursion patterns automatically.\n\n### The clause/2 Predicate\n\nThe foundation of code analysis:\n\n```prolog\nclause(Head, Body)\n```\n\n- `Head` - the clause head (before `:-`)\n- `Body` - the clause body (after `:-`), or `true` for facts\n\n**Example:**\n\n```prolog\n% Define predicates\nparent(abraham, isaac).\nparent(isaac, jacob).\n\n% Query clauses\n?- clause(parent(X, Y), Body).\nX = abraham, Y = isaac, Body = true ;\nX = isaac, Y = jacob, Body = true.\n```\n\n### The functor/3 Predicate\n\nExtract or construct terms:\n\n```prolog\n?- functor(parent(a, b), F, A).\nF = parent, A = 2.\n\n?- functor(Head, ancestor, 2).\nHead = ancestor(_A, _B).\n```\n\n### Analyzing Predicates\n\n```prolog\n% Find what predicates are called\nfind_calls(Pred/Arity, Called) :-\n    functor(Head, Pred, Arity),\n    user:clause(Head, Body),\n    extract_calls(Body, Called).\n\n% Check if self-recursive\n?- is_self_recursive(ancestor/2).\ntrue.\n```\n\nUnifyWeaver uses these techniques to build call graphs and detect recursion patterns.", "anchor_question_hash": "07a1b2c3d4e50001"}}
{"cluster_id": "call-graph-construction", "seed_level": 2, "source_files": ["education/book-02-bash-target/07_prolog_introspection.md"], "topics": ["call-graph", "dependency-analysis", "code-analysis"], "questions": ["What is a call graph in UnifyWeaver?", "How does UnifyWeaver build dependency graphs?", "How are predicate dependencies detected?", "What does call graph analysis reveal?"], "answer": {"text": "## Call Graph Construction\n\nA **call graph** is a directed graph showing predicate dependencies:\n- **Nodes**: Predicates (`Pred/Arity`)\n- **Edges**: Calls (`A -> B` means A calls B)\n\n### What Call Graphs Reveal\n\n- **Self-recursion**: Predicate calls itself\n- **Mutual recursion**: Cycle between predicates\n- **Dependencies**: Compilation order\n- **Reachability**: All predicates used\n\n### Building a Call Graph\n\n```prolog\n?- use_module(unifyweaver(core/advanced/call_graph)).\n\n% Define predicates\n?- assertz(ancestor(X, Y) :- parent(X, Y)).\n?- assertz((ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z))).\n\n% Get dependencies\n?- get_dependencies(ancestor/2, Deps).\nDeps = [ancestor/2, parent/2].\n\n% Build full graph\n?- build_call_graph([ancestor/2, parent/2], Graph).\nGraph = [ancestor/2 -> parent/2, ancestor/2 -> ancestor/2].\n```\n\n### Extracting Calls from Bodies\n\nThe system handles:\n- Conjunctions: `(A, B)`\n- Disjunctions: `(A; B)`\n- Conditionals: `(A -> B)`\n- Negations: `\\+ A`\n\n```prolog\n% Recursively walks clause body\nextract_calls((A, B), Pred/Arity) :-\n    ( extract_calls(A, Pred/Arity)\n    ; extract_calls(B, Pred/Arity)\n    ).\n```", "anchor_question_hash": "07b2c3d4e5f60002"}}
{"cluster_id": "scc-detection", "seed_level": 3, "source_files": ["education/book-02-bash-target/07_prolog_introspection.md"], "topics": ["scc", "tarjan", "mutual-recursion", "graph-algorithms"], "questions": ["What is SCC detection in UnifyWeaver?", "How does UnifyWeaver detect mutual recursion?", "What is Tarjan's algorithm?", "How are strongly connected components found?"], "answer": {"text": "## Strongly Connected Components (SCC)\n\nAn **SCC** is a maximal set of nodes where every node is reachable from every other.\n\n### Why SCCs Matter\n\nMutual recursion forms cycles:\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\nCall graph:\n```\nis_even/1 -> is_odd/1\nis_odd/1  -> is_even/1\n```\n\nBoth predicates are in the **same SCC** = mutual recursion!\n\n### Tarjan's Algorithm\n\nUnifyWeaver uses Tarjan's algorithm (O(V+E)):\n\n1. Perform depth-first search\n2. Track `index` (visit order) and `lowlink` (smallest reachable index)\n3. When `index == lowlink`, node is SCC root\n\n### Usage\n\n```prolog\n?- use_module(unifyweaver(core/advanced/scc_detection)).\n\n% Build call graph\n?- build_call_graph([is_even/1, is_odd/1], Graph).\n\n% Find SCCs\n?- find_sccs(Graph, SCCs).\nSCCs = [[is_even/1, is_odd/1]].  % One SCC!\n\n% Check if non-trivial (mutual recursion)\n?- is_trivial_scc([is_even/1, is_odd/1]).\nfalse.  % More than one predicate = mutual recursion\n\n?- is_trivial_scc([ancestor/2]).\ntrue.   % Single predicate = self-recursion only\n```", "anchor_question_hash": "07c3d4e5f6a70003"}}
{"cluster_id": "pattern-matching-detection", "seed_level": 2, "source_files": ["education/book-02-bash-target/07_prolog_introspection.md"], "topics": ["pattern-detection", "tail-recursion", "linear-recursion", "classification"], "questions": ["How does UnifyWeaver classify recursion patterns?", "What patterns does UnifyWeaver detect?", "How is tail recursion detected?", "What is the pattern selection priority?"], "answer": {"text": "## Pattern Detection\n\nUnifyWeaver uses pattern matchers to classify predicates:\n\n### Pattern 1: Tail Recursion\n\n**Characteristics:**\n- Recursive call is LAST (tail position)\n- Uses accumulator\n- Typically arity 3: `pred(Input, Acc, Result)`\n\n```prolog\n% Tail position - recursive call is last\ncount([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count(T, Acc1, N).  % <- TAIL\n\n% NOT tail - work after recursive call\nlength([_|T], N) :-\n    length(T, N1),      % <- NOT tail\n    N is N1 + 1.        % work happens after!\n```\n\n### Pattern 2: Linear Recursion\n\n- Exactly ONE recursive call per clause\n- Arguments pre-computed (not pattern matching)\n\n### Pattern 3: Tree Recursion\n\n- Structural decomposition `[V, L, R]`\n- Multiple recursive calls\n\n### Pattern Selection Priority\n\n1. **Tail recursion** (most efficient)\n2. **Linear recursion** (unless forbidden)\n3. **Tree recursion** (structural)\n4. **Mutual recursion** (via SCC)\n5. **Basic recursion** (fallback BFS)\n\n```prolog\n?- is_tail_recursive_accumulator(count/3, AccInfo).\ntrue.\n\n?- is_linear_recursive_streamable(factorial/2).\ntrue.\n```", "anchor_question_hash": "07d4e5f6a7b80004"}}
