{"cluster_id": "tail-recursion", "seed_level": 2, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md", "src/unifyweaver/core/advanced/tail_recursion.pl"], "topics": ["tail-recursion", "accumulator", "optimization", "iterative-loop"], "questions": ["What is tail recursion optimization in UnifyWeaver?", "How does UnifyWeaver compile tail-recursive predicates?", "What is an accumulator pattern?", "How is tail recursion converted to a loop?"], "answer": {"text": "## Tail Recursion Optimization\n\nTail recursion is when the recursive call is the last action in a function.\n\n### Why It Matters\n\nTail recursion can be converted to an iterative loop:\n- No stack overhead\n- No stack overflow risk\n- Much faster execution\n\n### The Accumulator Pattern\n\n```prolog\n% count_items(List, Accumulator, FinalCount)\n\n% Base case: empty list, return accumulator\ncount_items([], Acc, Acc).\n\n% Recursive step: increment and recurse (tail call)\ncount_items([_|T], Acc, N) :-\n    Acc1 is Acc + 1,\n    count_items(T, Acc1, N).  % This is the tail call\n```\n\n### Generated Bash: Iterative Loop\n\n```bash\ncount_items() {\n    local current_list=\"$1\"\n    local acc=\"$2\"\n    \n    # Base case check\n    if [[ \"$current_list\" == \"[]\" || -z \"$current_list\" ]]; then\n        echo \"$1:$2:$acc\"\n        return 0\n    fi\n    \n    # Iterative loop (replaces recursion)\n    while [[ \"$current_list\" != \"[]\" && -n \"$current_list\" ]]; do\n        # Extract tail of list\n        current_list=\"${current_list#[}\"\n        current_list=\"${current_list%]}\"\n        \n        if [[ \"$current_list\" =~ ^[^,]+,(.+)$ ]]; then\n            current_list=\"[${BASH_REMATCH[1]}]\"\n        else\n            current_list=\"[]\"\n        fi\n        \n        # Step: Acc1 is Acc + 1\n        acc=$((acc + 1))\n    done\n    \n    echo \"$1:$2:$acc\"\n}\n```\n\n### Usage\n\n```bash\nsource count_items.sh\ncount_items \"[a,b,c,d,e]\" 0 \"\"\n# Output: [a,b,c,d,e]:0:5\n```", "anchor_question_hash": "b4c5d6e7f8a90123"}}
{"cluster_id": "linear-recursion", "seed_level": 2, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md", "src/unifyweaver/core/advanced/linear_recursion.pl"], "topics": ["linear-recursion", "fold", "memoization", "factorial"], "questions": ["How does UnifyWeaver compile linear recursion?", "What is fold-based compilation?", "How is factorial compiled to Bash?", "What is memoization in generated code?"], "answer": {"text": "## Linear Recursion with Fold-Based Compilation\n\nLinear recursion: exactly one recursive call per clause.\n\n### Example: Factorial\n\n```prolog\nfactorial(0, 1).\nfactorial(N, F) :-\n    N > 0,\n    N1 is N - 1,\n    factorial(N1, F1),\n    F is N * F1.\n```\n\n### Fold-Based Approach\n\nUnifyWeaver generates:\n1. **Range builder** - generates N, N-1, ..., 1\n2. **Fold operation** - multiplies accumulator\n3. **Memoization** - caches results\n\n### Generated Bash\n\n```bash\n# Fold helper\nfold_left() {\n    local acc=\"$1\"\n    local op_func=\"$2\"\n    shift 2\n    for item in \"$@\"; do\n        acc=$(\"$op_func\" \"$item\" \"$acc\")\n    done\n    echo \"$acc\"\n}\n\n# Range builder\nbuild_range_down() {\n    local n=\"$1\"\n    seq \"$n\" -1 1\n}\n\n# Fold operation\nfactorial_op() {\n    local current=\"$1\"\n    local acc=\"$2\"\n    echo $((current * acc))\n}\n\n# Main with memoization\ndeclare -gA factorial_memo\n\nfactorial() {\n    local n=\"$1\"\n    \n    # Check memo\n    if [[ -n \"${factorial_memo[$n]}\" ]]; then\n        echo \"$n:${factorial_memo[$n]}\"\n        return 0\n    fi\n    \n    # Base case\n    if [[ \"$n\" -eq 0 ]]; then\n        factorial_memo[\"$n\"]=\"1\"\n        echo \"$n:1\"\n        return 0\n    fi\n    \n    # Fold computation\n    local range=$(build_range_down \"$n\")\n    local result=$(fold_left 1 \"factorial_op\" $range)\n    \n    factorial_memo[\"$n\"]=\"$result\"\n    echo \"$n:$result\"\n}\n```\n\n### Usage\n\n```bash\nfactorial 5 \"\"\n# Output: 5:120\n\nfactorial 10 \"\"\n# Output: 10:3628800\n```", "anchor_question_hash": "c5d6e7f8a9b01234"}}
{"cluster_id": "tree-recursion", "seed_level": 3, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md", "src/unifyweaver/core/advanced/tree_recursion.pl"], "topics": ["tree-recursion", "binary-tree", "structural-decomposition"], "questions": ["How does UnifyWeaver handle tree recursion?", "How is tree_sum compiled to Bash?", "What is structural decomposition in recursion?", "How are nested structures parsed in Bash?"], "answer": {"text": "## Tree Recursion\n\nTree recursion: multiple recursive calls per clause on structural parts.\n\n### Example: tree_sum\n\n```prolog\n% Tree as [Value, LeftSubtree, RightSubtree]\ntree_sum([], 0).\ntree_sum([V, L, R], Sum) :-\n    tree_sum(L, LS),\n    tree_sum(R, RS),\n    Sum is V + LS + RS.\n```\n\n### Generated Bash\n\n```bash\ntree_sum() {\n    local tree=\"$1\"\n    \n    # Base case: empty tree\n    if [[ \"$tree\" == \"[]\" || -z \"$tree\" ]]; then\n        echo 0\n        return 0\n    fi\n    \n    # Parse tree structure\n    local value left right\n    parse_tree \"$tree\" value left right\n    \n    # Recursive calls on subtrees\n    local left_result=$(tree_sum \"$left\")\n    local right_result=$(tree_sum \"$right\")\n    \n    # Combine results\n    echo $(( $value + $left_result + $right_result ))\n}\n\n# Parser tracks bracket depth for nested structures\nparse_tree() {\n    local tree_str=\"$1\"\n    local -n val=\"$2\" lft=\"$3\" rgt=\"$4\"\n    \n    # Remove outer brackets, parse by depth\n    tree_str=\"${tree_str#[}\"\n    tree_str=\"${tree_str%]}\"\n    \n    local depth=0 part=0 current=\"\"\n    for (( i=0; i<${#tree_str}; i++ )); do\n        char=\"${tree_str:$i:1}\"\n        case \"$char\" in\n            '[') ((depth++)); current+=\"$char\" ;;\n            ']') ((depth--)); current+=\"$char\" ;;\n            ',')\n                if [[ $depth -eq 0 ]]; then\n                    case $part in\n                        0) val=\"$current\" ;;\n                        1) lft=\"$current\" ;;\n                    esac\n                    current=\"\"; ((part++))\n                else\n                    current+=\"$char\"\n                fi ;;\n            *) current+=\"$char\" ;;\n        esac\n    done\n    rgt=\"$current\"\n}\n```\n\n### Usage\n\n```bash\n#       5\n#      / \\\n#     3   2\n#    /\n#   1\ntree_sum \"[5,[3,[1,[],[]]],[2,[],[]]]\"\n# Output: 11\n```", "anchor_question_hash": "d6e7f8a9b0c12345"}}
{"cluster_id": "mutual-recursion", "seed_level": 3, "source_files": ["education/book-02-bash-target/06_advanced_recursion.md", "src/unifyweaver/core/advanced/mutual_recursion.pl"], "topics": ["mutual-recursion", "scc", "even-odd", "shared-memoization"], "questions": ["How does UnifyWeaver handle mutual recursion?", "What is SCC detection for mutual recursion?", "How are is_even and is_odd compiled together?", "What is shared memoization?"], "answer": {"text": "## Mutual Recursion\n\nMutual recursion: two or more functions call each other in a cycle.\n\n### Example: is_even / is_odd\n\n```prolog\nis_even(0).\nis_even(N) :- N > 0, N1 is N - 1, is_odd(N1).\n\nis_odd(1).\nis_odd(N) :- N > 1, N1 is N - 1, is_even(N1).\n```\n\n### SCC Detection\n\nUnifyWeaver uses Tarjan's algorithm to find Strongly Connected Components:\n1. Build call graph (predicates as nodes, calls as edges)\n2. Find SCCs (groups where every node reaches every other)\n3. Compile SCC members together with shared state\n\n### Generated Bash: Shared Memoization\n\n```bash\n# Shared memo for all predicates in group\ndeclare -gA is_even_is_odd_memo\n\nis_even() {\n    local arg1=\"$1\"\n    local key=\"is_even:$*\"\n    \n    # Check shared memo\n    if [[ -n \"${is_even_is_odd_memo[$key]}\" ]]; then\n        echo \"${is_even_is_odd_memo[$key]}\"\n        return 0\n    fi\n    \n    # Base case: is_even(0)\n    if [[ \"$arg1\" == \"0\" ]]; then\n        is_even_is_odd_memo[\"$key\"]=\"true\"\n        echo \"true\"\n        return 0\n    fi\n    \n    # Recursive: call is_odd\n    if [[ \"$arg1\" -gt 0 ]]; then\n        local n1=$(( $arg1 - 1 ))\n        local rec_result=$(is_odd \"$n1\")\n        if [[ $? -eq 0 && \"$rec_result\" == \"true\" ]]; then\n            is_even_is_odd_memo[\"$key\"]=\"true\"\n            echo \"true\"\n            return 0\n        fi\n    fi\n    return 1\n}\n\nis_odd() {\n    # Similar structure, calls is_even\n    # Uses same is_even_is_odd_memo table\n    ...\n}\n```\n\n### Why Shared Memoization?\n\n- Prevents redundant computation across mutual calls\n- Consistent caching for the entire SCC\n- Correct handling of complex call patterns\n\n### Usage\n\n```bash\nis_even 0 && echo \"true\"  # true\nis_even 4 && echo \"true\"  # true (via is_odd(3)->is_even(2)->...)\nis_odd 3 && echo \"true\"   # true\nis_even 5 || echo \"false\" # false\n```", "anchor_question_hash": "e7f8a9b0c1d23456"}}
