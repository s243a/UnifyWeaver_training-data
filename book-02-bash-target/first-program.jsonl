{"cluster_id": "first-bash-program", "seed_level": 1, "source_files": ["education/book-02-bash-target/01_your_first_program.md", "src/unifyweaver/core/recursive_compiler.pl"], "topics": ["tutorial", "compilation", "bash", "ancestor", "family-tree"], "questions": ["How do I compile my first Prolog program to Bash?", "What is the step-by-step process to use UnifyWeaver?", "How do I compile ancestor/2 to Bash?", "How do I run generated Bash scripts?"], "answer": {"text": "## Your First UnifyWeaver Program\n\nHere's the complete step-by-step workflow:\n\n### Step 1: Start SWI-Prolog\n\n```bash\ncd UnifyWeaver\nswipl\n```\n\n### Step 2: Initialize Environment\n\n```prolog\n?- ['education/init'].\n[UnifyWeaver] Educational environment initialized.\n```\n\n### Step 3: Load the Compiler\n\n```prolog\n?- use_module(unifyweaver(core/recursive_compiler)).\ntrue.\n```\n\n### Step 4: Load Your Program\n\n```prolog\n?- ['education/family_tree'].\ntrue.\n```\n\n### Step 5: Compile Facts First\n\n```prolog\n?- use_module(unifyweaver(core/stream_compiler)).\n?- stream_compiler:compile_facts(parent, 2, [], BashCode),\n   open('education/output/parent.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 6: Compile Recursive Rule\n\n```prolog\n?- compile_recursive(ancestor/2, [], BashCode),\n   open('education/output/ancestor.sh', write, S),\n   write(S, BashCode), close(S).\n```\n\n### Step 7: Run the Scripts\n\n```bash\nsource education/output/parent.sh\nsource education/output/ancestor.sh\n\n# Find all descendants of abraham\nancestor abraham\n# Output: abraham:isaac, abraham:jacob, ...\n\n# Check specific relationship\nancestor isaac judah && echo \"Yes\" || echo \"No\"\n# Output: Yes\n```\n\n### Key Points\n\n- Facts and rules compile separately\n- Dependencies must be sourced first (`parent.sh` before `ancestor.sh`)\n- Generated functions support both streaming and lookup modes", "anchor_question_hash": "a3f8d2c1b4e79650"}}
{"cluster_id": "compile-workflow", "seed_level": 2, "source_files": ["education/book-02-bash-target/01_your_first_program.md", "src/unifyweaver/core/compiler_driver.pl"], "topics": ["compile_recursive", "compile_stream", "compile_predicate", "workflow"], "questions": ["What's the difference between compile_recursive and compile_stream?", "When should I use compile_predicate vs compile_recursive?", "How does UnifyWeaver decide which compiler to use?", "What are the main compilation predicates?"], "answer": {"text": "## UnifyWeaver Compilation Predicates\n\n### Three Main Entry Points\n\n| Predicate | Purpose | When to Use |\n|-----------|---------|-------------|\n| `compile_predicate/3` | Auto-selects compiler | Recommended default |\n| `compile_recursive/3` | Recursive predicates | Transitive closures, accumulators |\n| `compile_stream/3` | Non-recursive predicates | Simple joins, filters |\n\n### How Auto-Selection Works\n\n```prolog\n% compile_predicate analyzes your predicate and routes accordingly\n?- compile_predicate(grandparent/2, [], Code).  % Uses stream_compiler\n?- compile_predicate(ancestor/2, [], Code).     % Uses recursive_compiler\n```\n\n### Manual Selection\n\n```prolog\n% For non-recursive rules (joins, filters)\n?- compile_stream(grandparent/2, [], BashCode).\n\n% For recursive rules (transitive closures)\n?- compile_recursive(ancestor/2, [], BashCode).\n\n% For facts only\n?- stream_compiler:compile_facts(parent, 2, [], BashCode).\n```\n\n### Example: grandparent/2 (Non-Recursive)\n\n```prolog\ngrandparent(GP, GC) :-\n    parent(GP, P),\n    parent(P, GC).\n```\n\nCompiles to a stream join pipeline.\n\n### Example: ancestor/2 (Recursive)\n\n```prolog\nancestor(A, D) :- parent(A, D).\nancestor(A, D) :- parent(A, P), ancestor(P, D).\n```\n\nCompiles to BFS with visited tracking.", "anchor_question_hash": "b5e7c9a2f1d38460"}}
