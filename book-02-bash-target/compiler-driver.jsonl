{"cluster_id": "compiler-driver", "seed_level": 1, "source_files": ["education/book-02-bash-target/09_recursive_compilation.md", "src/unifyweaver/core/compiler_driver.pl"], "topics": ["compiler-driver", "one-click-compilation", "dependency-resolution"], "questions": ["What is the UnifyWeaver compiler driver?", "How do I compile with automatic dependency resolution?", "What does compile/3 do?", "How is one-click compilation achieved?"], "answer": {"text": "## The Compiler Driver\n\nThe `compiler_driver.pl` module provides **one-click compilation** with automatic dependency resolution.\n\n### The Problem\n\nManual compilation requires:\n1. Compile `parent/2` facts → `parent.sh`\n2. Compile `ancestor/2` rule → `ancestor.sh`\n\nThis is tedious and error-prone for complex projects.\n\n### The Solution: compile/3\n\n```prolog\n?- use_module(unifyweaver(core/compiler_driver)).\n\n?- ['education/family_tree'].\n\n?- compile(ancestor/2, [output_dir('output')], Scripts).\nScripts = ['output/parent.sh', 'output/ancestor.sh'].\n```\n\n**One call compiles everything!**\n\n### How It Works\n\n1. **Dependency Analysis**: Scans predicate to find dependencies\n2. **Recursive Compilation**: Compiles each dependency first\n3. **Tracks Compiled**: Avoids redundant work and infinite loops\n4. **Compiles Target**: Finally compiles requested predicate\n5. **Returns List**: All generated script paths\n\n### Generating Test Runners\n\n```prolog\ngenerate_test_runner(Pred, Path) :-\n    compile(Pred, [output_dir('output')], Scripts),\n    open(Path, write, S),\n    write(S, '#!/bin/bash\\n'),\n    forall(member(Script, Scripts),\n           format(S, 'source ~w\\n', [Script])),\n    close(S).\n\n?- generate_test_runner(ancestor/2, 'test.sh').\n```\n\nThe `Scripts` variable gives the exact files to source.", "anchor_question_hash": "09a1b2c3d4e50001"}}
{"cluster_id": "compile-api-reference", "seed_level": 2, "source_files": ["education/book-02-bash-target/09_recursive_compilation.md", "src/unifyweaver/core/compiler_driver.pl"], "topics": ["compile/3", "compile_recursive/3", "api", "options"], "questions": ["What is the difference between compile/3 and compile_recursive/3?", "What options does compile/3 accept?", "How do I specify the output directory?", "Which compile function should I use?"], "answer": {"text": "## Compile API Reference\n\n### compile/3 (Recommended)\n\nThe high-level interface with automatic dependency resolution:\n\n```prolog\ncompile(Predicate, Options, GeneratedScripts)\n```\n\n**Parameters:**\n- `Predicate`: `name/arity` (e.g., `ancestor/2`)\n- `Options`: List of options\n- `GeneratedScripts`: Output - list of generated file paths\n\n**Common Options:**\n\n| Option | Description |\n|--------|-------------|\n| `output_dir(Dir)` | Where to save generated scripts |\n| `target(bash)` | Target language (default: bash) |\n| `unique(true/false)` | Constraint for deduplication |\n\n### compile_recursive/3 (Low-level)\n\nCompiles a single predicate without dependency resolution:\n\n```prolog\n% Compiles ONLY ancestor/2, not its dependencies\n?- compile_recursive(ancestor/2, [], BashCode).\n```\n\n**When to use each:**\n\n| Function | Use When |\n|----------|----------|\n| `compile/3` | Normal compilation - handles everything |\n| `compile_recursive/3` | Manual control, dependencies already compiled |\n\n### Example\n\n```prolog\n% Automatic (recommended)\n?- compile(ancestor/2, [output_dir('out')], Scripts).\nScripts = ['out/parent.sh', 'out/ancestor.sh'].\n\n% Manual (advanced)\n?- compile_recursive(parent/2, [], ParentCode),\n   compile_recursive(ancestor/2, [], AncestorCode).\n```", "anchor_question_hash": "09b2c3d4e5f60002"}}
